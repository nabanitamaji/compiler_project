; ModuleID = 'lua_inlined.bc'
target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct._IO_FILE = type { i32, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, %struct._IO_marker*, %struct._IO_FILE*, i32, i32, i64, i16, i8, [1 x i8], i8*, i64, i8*, i8*, i8*, i8*, i64, i32, [20 x i8] }
%struct._IO_marker = type { %struct._IO_marker*, %struct._IO_FILE*, i32 }
%struct.luaL_Reg = type { i8*, i32 (%struct.lua_State*)* }
%struct.lua_State = type { %union.GCObject*, i8, i8, i8, %struct.lua_TValue*, %struct.global_State*, %struct.CallInfo*, i32*, %struct.lua_TValue*, %struct.lua_TValue*, i32, i16, i16, i8, i8, i32, i32, void (%struct.lua_State*, %struct.lua_Debug*)*, %union.GCObject*, %union.GCObject*, %struct.lua_longjmp*, i64, %struct.CallInfo }
%struct.global_State = type { i8* (i8*, i8*, i64, i64)*, i8*, i64, i64, i64, i64, %struct.stringtable, %struct.lua_TValue, i32, i8, i8, i8, i8, i32, %union.GCObject*, %union.GCObject*, %union.GCObject**, %union.GCObject**, %union.GCObject*, %union.GCObject*, %union.GCObject*, %union.GCObject*, %union.GCObject*, %union.GCObject*, %struct.UpVal, %struct.Mbuffer, i32, i32, i32, i32 (%struct.lua_State*)*, %struct.lua_State*, double*, %union.TString*, [17 x %union.TString*], [9 x %struct.Table*] }
%struct.stringtable = type { %union.GCObject**, i32, i32 }
%struct.lua_TValue = type { %union.Value, i32 }
%union.Value = type { %union.GCObject* }
%struct.UpVal = type { %union.GCObject*, i8, i8, %struct.lua_TValue*, %union.anon }
%union.anon = type { %struct.lua_TValue }
%struct.Mbuffer = type { i8*, i64, i64 }
%union.TString = type { %struct.anon.0 }
%struct.anon.0 = type { %union.GCObject*, i8, i8, i8, i32, i64 }
%struct.Table = type { %union.GCObject*, i8, i8, i8, i8, %struct.Table*, %struct.lua_TValue*, %struct.Node*, %struct.Node*, %union.GCObject*, i32 }
%struct.Node = type { %struct.lua_TValue, %union.TKey }
%union.TKey = type { %struct.anon.1 }
%struct.anon.1 = type { %union.Value, i32, %struct.Node* }
%struct.lua_Debug = type { i32, i8*, i8*, i8*, i8*, i32, i32, i32, i8, i8, i8, i8, [60 x i8], %struct.CallInfo* }
%union.GCObject = type { %struct.lua_State }
%struct.lua_longjmp = type { %struct.lua_longjmp*, [1 x %struct.__jmp_buf_tag], i32 }
%struct.__jmp_buf_tag = type { [8 x i64], i32, %struct.__sigset_t }
%struct.__sigset_t = type { [16 x i64] }
%struct.CallInfo = type { %struct.lua_TValue*, %struct.lua_TValue*, %struct.CallInfo*, %struct.CallInfo*, i16, i8, i64, %union.anon.2 }
%union.anon.2 = type { %struct.anon.4 }
%struct.anon.4 = type { i32, i32 (%struct.lua_State*)*, i64, i8, i8 }
%union.Value.281 = type { %union.GCObject.280* }
%union.GCObject.280 = type { %struct.lua_State.279 }
%struct.lua_State.279 = type { %union.GCObject.280*, i8, i8, i8, %struct.lua_TValue.263*, %struct.global_State.274*, %struct.CallInfo.276*, i32*, %struct.lua_TValue.263*, %struct.lua_TValue.263*, i32, i16, i16, i8, i8, i32, i32, void (%struct.lua_State.279*, %struct.lua_Debug.277*)*, %union.GCObject.280*, %union.GCObject.280*, %struct.lua_longjmp*, i64, %struct.CallInfo.276 }
%struct.global_State.274 = type { i8* (i8*, i8*, i64, i64)*, i8*, i64, i64, i64, i64, %struct.stringtable.264, %struct.lua_TValue.263, i32, i8, i8, i8, i8, i32, %union.GCObject.280*, %union.GCObject.280*, %union.GCObject.280**, %union.GCObject.280**, %union.GCObject.280*, %union.GCObject.280*, %union.GCObject.280*, %union.GCObject.280*, %union.GCObject.280*, %union.GCObject.280*, %struct.UpVal.266, %struct.Mbuffer, i32, i32, i32, i32 (%struct.lua_State.279*)*, %struct.lua_State.279*, double*, %union.TString.269*, [17 x %union.TString.269*], [9 x %struct.Table.273*] }
%struct.stringtable.264 = type { %union.GCObject.280**, i32, i32 }
%struct.lua_TValue.263 = type { %union.Value.281, i32 }
%struct.UpVal.266 = type { %union.GCObject.280*, i8, i8, %struct.lua_TValue.263*, %union.anon.4.265 }
%union.anon.4.265 = type { %struct.lua_TValue.263 }
%union.TString.269 = type { %struct.anon.268 }
%struct.anon.268 = type { %union.GCObject.280*, i8, i8, i8, i32, i64 }
%struct.Table.273 = type { %union.GCObject.280*, i8, i8, i8, i8, %struct.Table.273*, %struct.lua_TValue.263*, %struct.Node.272*, %struct.Node.272*, %union.GCObject.280*, i32 }
%struct.Node.272 = type { %struct.lua_TValue.263, %union.TKey.271 }
%union.TKey.271 = type { %struct.anon.3.270 }
%struct.anon.3.270 = type { %union.Value.281, i32, %struct.Node.272* }
%struct.lua_Debug.277 = type { i32, i8*, i8*, i8*, i8*, i32, i32, i32, i8, i8, i8, i8, [60 x i8], %struct.CallInfo.276* }
%struct.CallInfo.276 = type { %struct.lua_TValue.263*, %struct.lua_TValue.263*, %struct.CallInfo.276*, %struct.CallInfo.276*, i16, i8, i64, %union.anon.275 }
%union.anon.275 = type { %struct.anon.2 }
%struct.anon.2 = type { i32, {}*, i64, i8, i8 }
%struct.anon.9 = type { i8, i8 }
%struct.CClosure = type { %union.GCObject*, i8, i8, i8, %union.GCObject*, i32 (%struct.lua_State*)*, [1 x %struct.lua_TValue] }
%union.Closure = type { %struct.CClosure }
%struct.GCheader = type { %union.GCObject*, i8, i8 }
%union.luai_Cast = type { double }
%union.Udata = type { %struct.anon.5 }
%struct.anon.5 = type { %union.GCObject*, i8, i8, %struct.Table*, %struct.Table*, i64 }
%struct.LClosure = type { %union.GCObject*, i8, i8, i8, %union.GCObject*, %struct.Proto*, [1 x %struct.UpVal*] }
%struct.Proto = type { %union.GCObject*, i8, i8, %struct.lua_TValue*, i32*, %struct.Proto**, i32*, %struct.LocVar*, %struct.Upvaldesc*, %union.Closure*, %union.TString*, i32, i32, i32, i32, i32, i32, i32, i32, %union.GCObject*, i8, i8, i8 }
%struct.LocVar = type { %union.TString*, i32, i32 }
%struct.Upvaldesc = type { %union.TString*, i8, i8 }
%struct.__va_list_tag = type { i32, i32, i8*, i8* }
%struct.CallS = type { %struct.lua_TValue*, i32 }
%struct.Zio = type { i64, i8*, i8* (%struct.lua_State*, i8*, i64*)*, i8*, %struct.lua_State* }
%union.anon.4 = type { i32 }
%union.anon.0 = type { i32 }
%union.anon.1 = type { i32 }
%union.anon.2.5 = type { i32 }
%struct.luaL_Buffer = type { i8*, i64, i64, %struct.lua_State*, [8192 x i8] }
%struct.LoadF = type { i32, %struct._IO_FILE*, [8192 x i8] }
%struct.LoadS = type { i8*, i64 }
%struct.FuncState = type { %struct.Proto.36*, %struct.Table.23*, %struct.FuncState*, %struct.LexState*, %struct.BlockCnt*, i32, i32, i32, i32, i32, i32, i16, i8, i8, i8 }
%struct.Proto.36 = type { %union.GCObject.31*, i8, i8, %struct.lua_TValue.13*, i32*, %struct.Proto.36**, i32*, %struct.LocVar.32*, %struct.Upvaldesc.33*, %union.Closure.35*, %union.TString.19*, i32, i32, i32, i32, i32, i32, i32, i32, %union.GCObject.31*, i8, i8, i8 }
%struct.lua_TValue.13 = type { %union.Value.12, i32 }
%union.Value.12 = type { %union.GCObject.31* }
%struct.LocVar.32 = type { %union.TString.19*, i32, i32 }
%struct.Upvaldesc.33 = type { %union.TString.19*, i8, i8 }
%union.Closure.35 = type { %struct.CClosure.34 }
%struct.CClosure.34 = type { %union.GCObject.31*, i8, i8, i8, %union.GCObject.31*, i32 (%struct.lua_State.30*)*, [1 x %struct.lua_TValue.13] }
%struct.lua_State.30 = type { %union.GCObject.31*, i8, i8, i8, %struct.lua_TValue.13*, %struct.global_State.24*, %struct.CallInfo.27*, i32*, %struct.lua_TValue.13*, %struct.lua_TValue.13*, i32, i16, i16, i8, i8, i32, i32, void (%struct.lua_State.30*, %struct.lua_Debug.28*)*, %union.GCObject.31*, %union.GCObject.31*, %struct.lua_longjmp*, i64, %struct.CallInfo.27 }
%struct.global_State.24 = type { i8* (i8*, i8*, i64, i64)*, i8*, i64, i64, i64, i64, %struct.stringtable.14, %struct.lua_TValue.13, i32, i8, i8, i8, i8, i32, %union.GCObject.31*, %union.GCObject.31*, %union.GCObject.31**, %union.GCObject.31**, %union.GCObject.31*, %union.GCObject.31*, %union.GCObject.31*, %union.GCObject.31*, %union.GCObject.31*, %union.GCObject.31*, %struct.UpVal.16, %struct.Mbuffer, i32, i32, i32, i32 (%struct.lua_State.30*)*, %struct.lua_State.30*, double*, %union.TString.19*, [17 x %union.TString.19*], [9 x %struct.Table.23*] }
%struct.stringtable.14 = type { %union.GCObject.31**, i32, i32 }
%struct.UpVal.16 = type { %union.GCObject.31*, i8, i8, %struct.lua_TValue.13*, %union.anon.2.15 }
%union.anon.2.15 = type { %struct.lua_TValue.13 }
%struct.lua_Debug.28 = type { i32, i8*, i8*, i8*, i8*, i32, i32, i32, i8, i8, i8, i8, [60 x i8], %struct.CallInfo.27* }
%struct.CallInfo.27 = type { %struct.lua_TValue.13*, %struct.lua_TValue.13*, %struct.CallInfo.27*, %struct.CallInfo.27*, i16, i8, i64, %union.anon.26 }
%union.anon.26 = type { %struct.anon.0.25 }
%struct.anon.0.25 = type { i32, {}*, i64, i8, i8 }
%union.TString.19 = type { %struct.anon.1.18 }
%struct.anon.1.18 = type { %union.GCObject.31*, i8, i8, i8, i32, i64 }
%union.GCObject.31 = type { %struct.lua_State.30 }
%struct.Table.23 = type { %union.GCObject.31*, i8, i8, i8, i8, %struct.Table.23*, %struct.lua_TValue.13*, %struct.Node.22*, %struct.Node.22*, %union.GCObject.31*, i32 }
%struct.Node.22 = type { %struct.lua_TValue.13, %union.TKey.21 }
%union.TKey.21 = type { %struct.anon.4.20 }
%struct.anon.4.20 = type { %union.Value.12, i32, %struct.Node.22* }
%struct.LexState = type { i32, i32, i32, %struct.Token, %struct.Token, %struct.FuncState*, %struct.lua_State.30*, %struct.Zio.37*, %struct.Mbuffer*, %struct.Dyndata*, %union.TString.19*, %union.TString.19*, i8 }
%struct.Token = type { i32, %union.SemInfo }
%union.SemInfo = type { double }
%struct.Zio.37 = type { i64, i8*, i8* (%struct.lua_State.30*, i8*, i64*)*, i8*, %struct.lua_State.30* }
%struct.Dyndata = type { %struct.anon.5.38, %struct.Labellist, %struct.Labellist }
%struct.anon.5.38 = type { %struct.Vardesc*, i32, i32 }
%struct.Vardesc = type { i16 }
%struct.Labellist = type { %struct.Labeldesc*, i32, i32 }
%struct.Labeldesc = type { %union.TString.19*, i32, i32, i8 }
%struct.BlockCnt = type { %struct.BlockCnt*, i16, i16, i8, i8, i8 }
%struct.expdesc = type { i32, %union.anon.7, i32, i32 }
%union.anon.7 = type { double }
%struct.anon.8 = type { i16, i8, i8 }
%struct.GCheader.40 = type { %union.GCObject.31*, i8, i8 }
%struct.anon.3 = type { %struct.lua_TValue*, i32* }
%struct.SParser = type { %struct.Zio*, %struct.Mbuffer, %struct.Dyndata.107, i8*, i8* }
%struct.Dyndata.107 = type { %struct.anon.6, %struct.Labellist.106, %struct.Labellist.106 }
%struct.anon.6 = type { %struct.Vardesc*, i32, i32 }
%struct.Labellist.106 = type { %struct.Labeldesc.105*, i32, i32 }
%struct.Labeldesc.105 = type { %union.TString*, i32, i32, i8 }
%struct.DumpState = type { %struct.lua_State*, i32 (%struct.lua_State*, i8*, i64, i8*)*, i8*, i32, i32 }
%union.Closure.157 = type { %struct.CClosure.156 }
%struct.CClosure.156 = type { %union.GCObject.155*, i8, i8, i8, %union.GCObject.155*, i32 (%struct.lua_State.154*)*, [1 x %struct.lua_TValue.137] }
%union.GCObject.155 = type { %struct.lua_State.154 }
%struct.lua_State.154 = type { %union.GCObject.155*, i8, i8, i8, %struct.lua_TValue.137*, %struct.global_State.148*, %struct.CallInfo.151*, i32*, %struct.lua_TValue.137*, %struct.lua_TValue.137*, i32, i16, i16, i8, i8, i32, i32, void (%struct.lua_State.154*, %struct.lua_Debug.152*)*, %union.GCObject.155*, %union.GCObject.155*, %struct.lua_longjmp*, i64, %struct.CallInfo.151 }
%struct.global_State.148 = type { i8* (i8*, i8*, i64, i64)*, i8*, i64, i64, i64, i64, %struct.stringtable.138, %struct.lua_TValue.137, i32, i8, i8, i8, i8, i32, %union.GCObject.155*, %union.GCObject.155*, %union.GCObject.155**, %union.GCObject.155**, %union.GCObject.155*, %union.GCObject.155*, %union.GCObject.155*, %union.GCObject.155*, %union.GCObject.155*, %union.GCObject.155*, %struct.UpVal.140, %struct.Mbuffer, i32, i32, i32, {}*, %struct.lua_State.154*, double*, %union.TString.143*, [17 x %union.TString.143*], [9 x %struct.Table.147*] }
%struct.stringtable.138 = type { %union.GCObject.155**, i32, i32 }
%struct.lua_TValue.137 = type { %union.Value.136, i32 }
%union.Value.136 = type { %union.GCObject.155* }
%struct.UpVal.140 = type { %union.GCObject.155*, i8, i8, %struct.lua_TValue.137*, %union.anon.139 }
%union.anon.139 = type { %struct.lua_TValue.137 }
%union.TString.143 = type { %struct.anon.0.142 }
%struct.anon.0.142 = type { %union.GCObject.155*, i8, i8, i8, i32, i64 }
%struct.Table.147 = type { %union.GCObject.155*, i8, i8, i8, i8, %struct.Table.147*, %struct.lua_TValue.137*, %struct.Node.146*, %struct.Node.146*, %union.GCObject.155*, i32 }
%struct.Node.146 = type { %struct.lua_TValue.137, %union.TKey.145 }
%union.TKey.145 = type { %struct.anon.1.144 }
%struct.anon.1.144 = type { %union.Value.136, i32, %struct.Node.146* }
%struct.lua_Debug.152 = type { i32, i8*, i8*, i8*, i8*, i32, i32, i32, i8, i8, i8, i8, [60 x i8], %struct.CallInfo.151* }
%struct.CallInfo.151 = type { %struct.lua_TValue.137*, %struct.lua_TValue.137*, %struct.CallInfo.151*, %struct.CallInfo.151*, i16, i8, i64, %union.anon.2.150 }
%union.anon.2.150 = type { %struct.anon.4.149 }
%struct.anon.4.149 = type { i32, {}*, i64, i8, i8 }
%struct.LClosure.161 = type { %union.GCObject.155*, i8, i8, i8, %union.GCObject.155*, %struct.Proto.160*, [1 x %struct.UpVal.140*] }
%struct.Proto.160 = type { %union.GCObject.155*, i8, i8, %struct.lua_TValue.137*, i32*, %struct.Proto.160**, i32*, %struct.LocVar.158*, %struct.Upvaldesc.159*, %union.Closure.157*, %union.TString.143*, i32, i32, i32, i32, i32, i32, i32, i32, %union.GCObject.155*, i8, i8, i8 }
%struct.LocVar.158 = type { %union.TString.143*, i32, i32 }
%struct.Upvaldesc.159 = type { %union.TString.143*, i8, i8 }
%struct.GCheader.162 = type { %union.GCObject.155*, i8, i8 }
%struct.anon = type { %struct.UpVal.140*, %struct.UpVal.140* }
%struct.anon.192 = type { %struct.UpVal*, %struct.UpVal* }
%struct.luaL_Stream = type { %struct._IO_FILE*, i32 (%struct.lua_State*)* }
%struct.LexState.235 = type { i32, i32, i32, %struct.Token, %struct.Token, %struct.FuncState.228*, %struct.lua_State*, %struct.Zio*, %struct.Mbuffer*, %struct.Dyndata.234*, %union.TString*, %union.TString*, i8 }
%struct.FuncState.228 = type { %struct.Proto*, %struct.Table*, %struct.FuncState.228*, %struct.LexState.235*, %struct.BlockCnt*, i32, i32, i32, i32, i32, i32, i16, i8, i8, i8 }
%struct.Dyndata.234 = type { %struct.anon.6, %struct.Labellist.233, %struct.Labellist.233 }
%struct.Labellist.233 = type { %struct.Labeldesc.232*, i32, i32 }
%struct.Labeldesc.232 = type { %union.TString*, i32, i32, i8 }
%struct.lconv = type { i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8 }
%struct.tm = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i64, i8* }
%struct.Zio.308 = type { i64, i8*, i8* (%struct.lua_State.154*, i8*, i64*)*, i8*, %struct.lua_State.154* }
%struct.Dyndata.313 = type { %struct.anon.6, %struct.Labellist.312, %struct.Labellist.312 }
%struct.Labellist.312 = type { %struct.Labeldesc.311*, i32, i32 }
%struct.Labeldesc.311 = type { %union.TString.143*, i32, i32, i8 }
%struct.LexState.321 = type { i32, i32, i32, %struct.Token, %struct.Token, %struct.FuncState.320*, %struct.lua_State.154*, %struct.Zio.308*, %struct.Mbuffer*, %struct.Dyndata.313*, %union.TString.143*, %union.TString.143*, i8 }
%struct.FuncState.320 = type { %struct.Proto.160*, %struct.Table.147*, %struct.FuncState.320*, %struct.LexState.321*, %struct.BlockCnt*, i32, i32, i32, i32, i32, i32, i16, i8, i8, i8 }
%struct.LClosure.324 = type { %union.GCObject.155*, i8, i8, i8, %union.GCObject.155*, %struct.Proto.160*, [1 x %struct.UpVal.140*] }
%struct.GCheader.325 = type { %union.GCObject.155*, i8, i8 }
%struct.LHS_assign = type { %struct.LHS_assign*, %struct.expdesc }
%struct.ConsControl = type { %struct.expdesc, %struct.expdesc*, i32, i32, i32 }
%struct.global_State.337 = type { i8* (i8*, i8*, i64, i64)*, i8*, i64, i64, i64, i64, %struct.stringtable.327, %struct.lua_TValue.346, i32, i8, i8, i8, i8, i32, %union.GCObject.344*, %union.GCObject.344*, %union.GCObject.344**, %union.GCObject.344**, %union.GCObject.344*, %union.GCObject.344*, %union.GCObject.344*, %union.GCObject.344*, %union.GCObject.344*, %union.GCObject.344*, %struct.UpVal.329, %struct.Mbuffer, i32, i32, i32, i32 (%struct.lua_State.343*)*, %struct.lua_State.343*, double*, %union.TString.332*, [17 x %union.TString.332*], [9 x %struct.Table.336*] }
%struct.stringtable.327 = type { %union.GCObject.344**, i32, i32 }
%struct.lua_TValue.346 = type { %union.Value.345, i32 }
%union.Value.345 = type { %union.GCObject.344* }
%union.GCObject.344 = type { %struct.lua_State.343 }
%struct.lua_State.343 = type { %union.GCObject.344*, i8, i8, i8, %struct.lua_TValue.346*, %struct.global_State.337*, %struct.CallInfo.340*, i32*, %struct.lua_TValue.346*, %struct.lua_TValue.346*, i32, i16, i16, i8, i8, i32, i32, void (%struct.lua_State.343*, %struct.lua_Debug.341*)*, %union.GCObject.344*, %union.GCObject.344*, %struct.lua_longjmp*, i64, %struct.CallInfo.340 }
%struct.lua_Debug.341 = type { i32, i8*, i8*, i8*, i8*, i32, i32, i32, i8, i8, i8, i8, [60 x i8], %struct.CallInfo.340* }
%struct.CallInfo.340 = type { %struct.lua_TValue.346*, %struct.lua_TValue.346*, %struct.CallInfo.340*, %struct.CallInfo.340*, i16, i8, i64, %union.anon.339 }
%union.anon.339 = type { %struct.anon.2 }
%struct.UpVal.329 = type { %union.GCObject.344*, i8, i8, %struct.lua_TValue.346*, %union.anon.4.328 }
%union.anon.4.328 = type { %struct.lua_TValue.346 }
%union.TString.332 = type { %struct.anon.331 }
%struct.anon.331 = type { %union.GCObject.344*, i8, i8, i8, i32, i64 }
%struct.Table.336 = type { %union.GCObject.344*, i8, i8, i8, i8, %struct.Table.336*, %struct.lua_TValue.346*, %struct.Node.335*, %struct.Node.335*, %union.GCObject.344*, i32 }
%struct.Node.335 = type { %struct.lua_TValue.346, %union.TKey.334 }
%union.TKey.334 = type { %struct.anon.3.333 }
%struct.anon.3.333 = type { %union.Value.345, i32, %struct.Node.335* }
%struct.LX = type { %struct.lua_State.343 }
%struct.LG = type { %struct.LX, %struct.global_State.337 }
%struct.anon.5.347 = type { %struct.UpVal.329*, %struct.UpVal.329* }
%union.TString.367 = type { %struct.anon.366 }
%struct.anon.366 = type { %union.GCObject.365*, i8, i8, i8, i32, i64 }
%union.GCObject.365 = type { %struct.lua_State.364 }
%struct.lua_State.364 = type { %union.GCObject.365*, i8, i8, i8, %struct.lua_TValue.349*, %struct.global_State.358*, %struct.CallInfo.361*, i32*, %struct.lua_TValue.349*, %struct.lua_TValue.349*, i32, i16, i16, i8, i8, i32, i32, void (%struct.lua_State.364*, %struct.lua_Debug.362*)*, %union.GCObject.365*, %union.GCObject.365*, %struct.lua_longjmp*, i64, %struct.CallInfo.361 }
%struct.global_State.358 = type { i8* (i8*, i8*, i64, i64)*, i8*, i64, i64, i64, i64, %struct.stringtable.350, %struct.lua_TValue.349, i32, i8, i8, i8, i8, i32, %union.GCObject.365*, %union.GCObject.365*, %union.GCObject.365**, %union.GCObject.365**, %union.GCObject.365*, %union.GCObject.365*, %union.GCObject.365*, %union.GCObject.365*, %union.GCObject.365*, %union.GCObject.365*, %struct.UpVal.352, %struct.Mbuffer, i32, i32, i32, i32 (%struct.lua_State.364*)*, %struct.lua_State.364*, double*, %union.TString.367*, [17 x %union.TString.367*], [9 x %struct.Table.357*] }
%struct.stringtable.350 = type { %union.GCObject.365**, i32, i32 }
%struct.lua_TValue.349 = type { %union.Value.348, i32 }
%union.Value.348 = type { %union.GCObject.365* }
%struct.UpVal.352 = type { %union.GCObject.365*, i8, i8, %struct.lua_TValue.349*, %union.anon.4.351 }
%union.anon.4.351 = type { %struct.lua_TValue.349 }
%struct.Table.357 = type { %union.GCObject.365*, i8, i8, i8, i8, %struct.Table.357*, %struct.lua_TValue.349*, %struct.Node.356*, %struct.Node.356*, %union.GCObject.365*, i32 }
%struct.Node.356 = type { %struct.lua_TValue.349, %union.TKey.355 }
%union.TKey.355 = type { %struct.anon.3.354 }
%struct.anon.3.354 = type { %union.Value.348, i32, %struct.Node.356* }
%struct.lua_Debug.362 = type { i32, i8*, i8*, i8*, i8*, i32, i32, i32, i8, i8, i8, i8, [60 x i8], %struct.CallInfo.361* }
%struct.CallInfo.361 = type { %struct.lua_TValue.349*, %struct.lua_TValue.349*, %struct.CallInfo.361*, %struct.CallInfo.361*, i16, i8, i64, %union.anon.360 }
%union.anon.360 = type { %struct.anon.2 }
%struct.GCheader.370 = type { %union.GCObject.365*, i8, i8 }
%union.Udata.369 = type { %struct.anon.0.368 }
%struct.anon.0.368 = type { %union.GCObject.365*, i8, i8, %struct.Table.357*, %struct.Table.357*, i64 }
%struct.MatchState = type { i32, i8*, i8*, i8*, %struct.lua_State*, i32, [32 x %struct.anon.374] }
%struct.anon.374 = type { i8*, i64 }
%struct.Zio.449 = type { i64, i8*, i8* (%struct.lua_State.154*, i8*, i64*)*, i8*, %struct.lua_State.154* }
%struct.LoadState = type { %struct.lua_State.154*, %struct.Zio.449*, %struct.Mbuffer*, i8* }
%struct.LClosure.453 = type { %union.GCObject.155*, i8, i8, i8, %union.GCObject.155*, %struct.Proto.160*, [1 x %struct.UpVal.140*] }
%struct.GCheader.479 = type { %union.GCObject.365*, i8, i8 }
%union.Udata.481 = type { %struct.anon.2.480 }
%struct.anon.2.480 = type { %union.GCObject.365*, i8, i8, %struct.Table.357*, %struct.Table.357*, i64 }
%struct.anon.482 = type { %struct.lua_TValue.349*, i32* }
%struct.LClosure.483 = type { %union.GCObject.365*, i8, i8, i8, %union.GCObject.365*, %struct.Proto.478*, [1 x %struct.UpVal.352*] }
%struct.Proto.478 = type { %union.GCObject.365*, i8, i8, %struct.lua_TValue.349*, i32*, %struct.Proto.478**, i32*, %struct.LocVar.476*, %struct.Upvaldesc.477*, %union.Closure.475*, %union.TString.367*, i32, i32, i32, i32, i32, i32, i32, i32, %union.GCObject.365*, i8, i8, i8 }
%struct.LocVar.476 = type { %union.TString.367*, i32, i32 }
%struct.Upvaldesc.477 = type { %union.TString.367*, i8, i8 }
%union.Closure.475 = type { %struct.CClosure.474 }
%struct.CClosure.474 = type { %union.GCObject.365*, i8, i8, i8, %union.GCObject.365*, i32 (%struct.lua_State.364*)*, [1 x %struct.lua_TValue.349] }

@lua_ident = constant [129 x i8] c"$LuaVersion: Lua 5.2.2  Copyright (C) 1994-2013 Lua.org, PUC-Rio $$LuaAuthors: R. Ierusalimschy, L. H. de Figueiredo, W. Celes $\00", align 16
@lua_version.version = internal constant double 5.020000e+02, align 8
@.str = private unnamed_addr constant [2 x i8] c"?\00", align 1
@.str1 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str2 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
@.str13 = private unnamed_addr constant [17 x i8] c"stack traceback:\00", align 1
@.str24 = private unnamed_addr constant [6 x i8] c"\0A\09...\00", align 1
@.str3 = private unnamed_addr constant [5 x i8] c"Slnt\00", align 1
@.str4 = private unnamed_addr constant [6 x i8] c"\0A\09%s:\00", align 1
@.str5 = private unnamed_addr constant [4 x i8] c"%d:\00", align 1
@.str6 = private unnamed_addr constant [5 x i8] c" in \00", align 1
@.str7 = private unnamed_addr constant [21 x i8] c"\0A\09(...tail calls...)\00", align 1
@.str8 = private unnamed_addr constant [22 x i8] c"bad argument #%d (%s)\00", align 1
@.str9 = private unnamed_addr constant [2 x i8] c"n\00", align 1
@.str10 = private unnamed_addr constant [7 x i8] c"method\00", align 1
@.str11 = private unnamed_addr constant [30 x i8] c"calling '%s' on bad self (%s)\00", align 1
@.str12 = private unnamed_addr constant [2 x i8] c"?\00", align 1
@.str135 = private unnamed_addr constant [30 x i8] c"bad argument #%d to '%s' (%s)\00", align 1
@.str14 = private unnamed_addr constant [3 x i8] c"Sl\00", align 1
@.str15 = private unnamed_addr constant [8 x i8] c"%s:%d: \00", align 1
@.str16 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str17 = private unnamed_addr constant [7 x i8] c"%s: %s\00", align 1
@.str18 = private unnamed_addr constant [5 x i8] c"exit\00", align 1
@.str19 = private unnamed_addr constant [7 x i8] c"signal\00", align 1
@.str20 = private unnamed_addr constant [20 x i8] c"invalid option '%s'\00", align 1
@.str21 = private unnamed_addr constant [20 x i8] c"stack overflow (%s)\00", align 1
@.str22 = private unnamed_addr constant [15 x i8] c"stack overflow\00", align 1
@.str23 = private unnamed_addr constant [15 x i8] c"value expected\00", align 1
@.str246 = private unnamed_addr constant [17 x i8] c"buffer too large\00", align 1
@.str25 = private unnamed_addr constant [7 x i8] c"=stdin\00", align 1
@stdin = external global %struct._IO_FILE*
@.str26 = private unnamed_addr constant [4 x i8] c"@%s\00", align 1
@.str27 = private unnamed_addr constant [2 x i8] c"r\00", align 1
@.str28 = private unnamed_addr constant [5 x i8] c"open\00", align 1
@.str29 = private unnamed_addr constant [5 x i8] c"\1BLua\00", align 1
@.str30 = private unnamed_addr constant [3 x i8] c"rb\00", align 1
@.str31 = private unnamed_addr constant [7 x i8] c"reopen\00", align 1
@.str32 = private unnamed_addr constant [5 x i8] c"read\00", align 1
@.str33 = private unnamed_addr constant [30 x i8] c"object length is not a number\00", align 1
@.str34 = private unnamed_addr constant [11 x i8] c"__tostring\00", align 1
@.str35 = private unnamed_addr constant [5 x i8] c"true\00", align 1
@.str36 = private unnamed_addr constant [6 x i8] c"false\00", align 1
@.str37 = private unnamed_addr constant [4 x i8] c"nil\00", align 1
@.str38 = private unnamed_addr constant [7 x i8] c"%s: %p\00", align 1
@.str39 = private unnamed_addr constant [18 x i8] c"too many upvalues\00", align 1
@.str40 = private unnamed_addr constant [8 x i8] c"_LOADED\00", align 1
@.str41 = private unnamed_addr constant [26 x i8] c"multiple Lua VMs detected\00", align 1
@.str42 = private unnamed_addr constant [54 x i8] c"version mismatch: app. needs %f, Lua core provides %f\00", align 1
@.str43 = private unnamed_addr constant [68 x i8] c"bad conversion number->int; must recompile Lua with proper settings\00", align 1
@stderr = external global %struct._IO_FILE*
@.str44 = private unnamed_addr constant [50 x i8] c"PANIC: unprotected error in call to Lua API (%s)\0A\00", align 1
@.str45 = private unnamed_addr constant [4 x i8] c"\EF\BB\BF\00", align 1
@.str46 = private unnamed_addr constant [17 x i8] c"cannot %s %s: %s\00", align 1
@.str47 = private unnamed_addr constant [20 x i8] c"%s expected, got %s\00", align 1
@.str48 = private unnamed_addr constant [2 x i8] c"f\00", align 1
@.str49 = private unnamed_addr constant [2 x i8] c".\00", align 1
@.str50 = private unnamed_addr constant [14 x i8] c"function '%s'\00", align 1
@.str51 = private unnamed_addr constant [11 x i8] c"main chunk\00", align 1
@.str52 = private unnamed_addr constant [17 x i8] c"function <%s:%d>\00", align 1
@.str53 = private unnamed_addr constant [3 x i8] c"_G\00", align 1
@base_funcs = internal constant [23 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8]* @.str356, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_assert }, %struct.luaL_Reg { i8* getelementptr inbounds ([15 x i8]* @.str457, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_collectgarbage }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8]* @.str558, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_dofile }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8]* @.str659, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_error }, %struct.luaL_Reg { i8* getelementptr inbounds ([13 x i8]* @.str760, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_getmetatable }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8]* @.str861, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_ipairs }, %struct.luaL_Reg { i8* getelementptr inbounds ([9 x i8]* @.str962, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_loadfile }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8]* @.str1063, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_load }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8]* @.str1164, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_next }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8]* @.str1265, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_pairs }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8]* @.str1366, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_pcall }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8]* @.str1467, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_print }, %struct.luaL_Reg { i8* getelementptr inbounds ([9 x i8]* @.str1568, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_rawequal }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8]* @.str1669, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_rawlen }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8]* @.str1770, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_rawget }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8]* @.str1871, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_rawset }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8]* @.str1972, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_select }, %struct.luaL_Reg { i8* getelementptr inbounds ([13 x i8]* @.str2073, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_setmetatable }, %struct.luaL_Reg { i8* getelementptr inbounds ([9 x i8]* @.str2174, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_tonumber }, %struct.luaL_Reg { i8* getelementptr inbounds ([9 x i8]* @.str2275, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_tostring }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8]* @.str2376, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_type }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8]* @.str2477, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_xpcall }, %struct.luaL_Reg zeroinitializer], align 16
@.str154 = private unnamed_addr constant [8 x i8] c"Lua 5.2\00", align 1
@.str255 = private unnamed_addr constant [9 x i8] c"_VERSION\00", align 1
@.str356 = private unnamed_addr constant [7 x i8] c"assert\00", align 1
@.str457 = private unnamed_addr constant [15 x i8] c"collectgarbage\00", align 1
@.str558 = private unnamed_addr constant [7 x i8] c"dofile\00", align 1
@.str659 = private unnamed_addr constant [6 x i8] c"error\00", align 1
@.str760 = private unnamed_addr constant [13 x i8] c"getmetatable\00", align 1
@.str861 = private unnamed_addr constant [7 x i8] c"ipairs\00", align 1
@.str962 = private unnamed_addr constant [9 x i8] c"loadfile\00", align 1
@.str1063 = private unnamed_addr constant [5 x i8] c"load\00", align 1
@.str1164 = private unnamed_addr constant [5 x i8] c"next\00", align 1
@.str1265 = private unnamed_addr constant [6 x i8] c"pairs\00", align 1
@.str1366 = private unnamed_addr constant [6 x i8] c"pcall\00", align 1
@.str1467 = private unnamed_addr constant [6 x i8] c"print\00", align 1
@.str1568 = private unnamed_addr constant [9 x i8] c"rawequal\00", align 1
@.str1669 = private unnamed_addr constant [7 x i8] c"rawlen\00", align 1
@.str1770 = private unnamed_addr constant [7 x i8] c"rawget\00", align 1
@.str1871 = private unnamed_addr constant [7 x i8] c"rawset\00", align 1
@.str1972 = private unnamed_addr constant [7 x i8] c"select\00", align 1
@.str2073 = private unnamed_addr constant [13 x i8] c"setmetatable\00", align 1
@.str2174 = private unnamed_addr constant [9 x i8] c"tonumber\00", align 1
@.str2275 = private unnamed_addr constant [9 x i8] c"tostring\00", align 1
@.str2376 = private unnamed_addr constant [5 x i8] c"type\00", align 1
@.str2477 = private unnamed_addr constant [7 x i8] c"xpcall\00", align 1
@.str2578 = private unnamed_addr constant [15 x i8] c"value expected\00", align 1
@.str2679 = private unnamed_addr constant [15 x i8] c"stack overflow\00", align 1
@.str2780 = private unnamed_addr constant [18 x i8] c"base out of range\00", align 1
@.str2881 = private unnamed_addr constant [7 x i8] c" \0C\0A\0D\09\0B\00", align 1
@.str2982 = private unnamed_addr constant [22 x i8] c"nil or table expected\00", align 1
@.str3083 = private unnamed_addr constant [12 x i8] c"__metatable\00", align 1
@.str3184 = private unnamed_addr constant [36 x i8] c"cannot change a protected metatable\00", align 1
@.str3285 = private unnamed_addr constant [19 x i8] c"index out of range\00", align 1
@.str3386 = private unnamed_addr constant [25 x i8] c"table or string expected\00", align 1
@.str3487 = private unnamed_addr constant [43 x i8] c"'tostring' must return a string to 'print'\00", align 1
@.str3588 = private unnamed_addr constant [2 x i8] c"\09\00", align 1
@stdout = external global %struct._IO_FILE*
@.str3689 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str3790 = private unnamed_addr constant [8 x i8] c"__pairs\00", align 1
@.str3891 = private unnamed_addr constant [3 x i8] c"bt\00", align 1
@.str3992 = private unnamed_addr constant [8 x i8] c"=(load)\00", align 1
@.str4093 = private unnamed_addr constant [26 x i8] c"too many nested functions\00", align 1
@.str4194 = private unnamed_addr constant [37 x i8] c"reader function must return a string\00", align 1
@.str4295 = private unnamed_addr constant [9 x i8] c"__ipairs\00", align 1
@luaB_collectgarbage.opts = internal constant [12 x i8*] [i8* getelementptr inbounds ([5 x i8]* @.str4396, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8]* @.str4497, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8]* @.str4598, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8]* @.str4699, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8]* @.str47100, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8]* @.str48101, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8]* @.str49102, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8]* @.str50103, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8]* @.str51104, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8]* @.str52105, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8]* @.str53106, i32 0, i32 0), i8* null], align 16
@.str4396 = private unnamed_addr constant [5 x i8] c"stop\00", align 1
@.str4497 = private unnamed_addr constant [8 x i8] c"restart\00", align 1
@.str4598 = private unnamed_addr constant [8 x i8] c"collect\00", align 1
@.str4699 = private unnamed_addr constant [6 x i8] c"count\00", align 1
@.str47100 = private unnamed_addr constant [5 x i8] c"step\00", align 1
@.str48101 = private unnamed_addr constant [9 x i8] c"setpause\00", align 1
@.str49102 = private unnamed_addr constant [11 x i8] c"setstepmul\00", align 1
@.str50103 = private unnamed_addr constant [12 x i8] c"setmajorinc\00", align 1
@.str51104 = private unnamed_addr constant [10 x i8] c"isrunning\00", align 1
@.str52105 = private unnamed_addr constant [13 x i8] c"generational\00", align 1
@.str53106 = private unnamed_addr constant [12 x i8] c"incremental\00", align 1
@luaB_collectgarbage.optsnum = internal constant [11 x i32] [i32 0, i32 1, i32 2, i32 3, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11], align 16
@.str54 = private unnamed_addr constant [3 x i8] c"%s\00", align 1
@.str55 = private unnamed_addr constant [18 x i8] c"assertion failed!\00", align 1
@bitlib = internal constant [13 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8]* @.str107, i32 0, i32 0), i32 (%struct.lua_State*)* @b_arshift }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8]* @.str1108, i32 0, i32 0), i32 (%struct.lua_State*)* @b_and }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8]* @.str2109, i32 0, i32 0), i32 (%struct.lua_State*)* @b_not }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8]* @.str3110, i32 0, i32 0), i32 (%struct.lua_State*)* @b_or }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8]* @.str4111, i32 0, i32 0), i32 (%struct.lua_State*)* @b_xor }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8]* @.str5112, i32 0, i32 0), i32 (%struct.lua_State*)* @b_test }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8]* @.str6113, i32 0, i32 0), i32 (%struct.lua_State*)* @b_extract }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8]* @.str7114, i32 0, i32 0), i32 (%struct.lua_State*)* @b_lrot }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8]* @.str8115, i32 0, i32 0), i32 (%struct.lua_State*)* @b_lshift }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8]* @.str9116, i32 0, i32 0), i32 (%struct.lua_State*)* @b_replace }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8]* @.str10117, i32 0, i32 0), i32 (%struct.lua_State*)* @b_rrot }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8]* @.str11118, i32 0, i32 0), i32 (%struct.lua_State*)* @b_rshift }, %struct.luaL_Reg zeroinitializer], align 16
@.str107 = private unnamed_addr constant [8 x i8] c"arshift\00", align 1
@.str1108 = private unnamed_addr constant [5 x i8] c"band\00", align 1
@.str2109 = private unnamed_addr constant [5 x i8] c"bnot\00", align 1
@.str3110 = private unnamed_addr constant [4 x i8] c"bor\00", align 1
@.str4111 = private unnamed_addr constant [5 x i8] c"bxor\00", align 1
@.str5112 = private unnamed_addr constant [6 x i8] c"btest\00", align 1
@.str6113 = private unnamed_addr constant [8 x i8] c"extract\00", align 1
@.str7114 = private unnamed_addr constant [8 x i8] c"lrotate\00", align 1
@.str8115 = private unnamed_addr constant [7 x i8] c"lshift\00", align 1
@.str9116 = private unnamed_addr constant [8 x i8] c"replace\00", align 1
@.str10117 = private unnamed_addr constant [8 x i8] c"rrotate\00", align 1
@.str11118 = private unnamed_addr constant [7 x i8] c"rshift\00", align 1
@.str12119 = private unnamed_addr constant [25 x i8] c"field cannot be negative\00", align 1
@.str13120 = private unnamed_addr constant [23 x i8] c"width must be positive\00", align 1
@.str14121 = private unnamed_addr constant [35 x i8] c"trying to access non-existent bits\00", align 1
@.str122 = private unnamed_addr constant [35 x i8] c"function or expression too complex\00", align 1
@.str1123 = private unnamed_addr constant [21 x i8] c"constructor too long\00", align 1
@.str2124 = private unnamed_addr constant [10 x i8] c"constants\00", align 1
@.str3125 = private unnamed_addr constant [8 x i8] c"opcodes\00", align 1
@.str4126 = private unnamed_addr constant [27 x i8] c"control structure too long\00", align 1
@co_funcs = internal constant [7 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8]* @.str127, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_cocreate }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8]* @.str1128, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_coresume }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8]* @.str2129, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_corunning }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8]* @.str3130, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_costatus }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8]* @.str4131, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_cowrap }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8]* @.str5132, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_yield }, %struct.luaL_Reg zeroinitializer], align 16
@.str127 = private unnamed_addr constant [7 x i8] c"create\00", align 1
@.str1128 = private unnamed_addr constant [7 x i8] c"resume\00", align 1
@.str2129 = private unnamed_addr constant [8 x i8] c"running\00", align 1
@.str3130 = private unnamed_addr constant [7 x i8] c"status\00", align 1
@.str4131 = private unnamed_addr constant [5 x i8] c"wrap\00", align 1
@.str5132 = private unnamed_addr constant [6 x i8] c"yield\00", align 1
@.str6133 = private unnamed_addr constant [29 x i8] c"too many arguments to resume\00", align 1
@.str7134 = private unnamed_addr constant [29 x i8] c"cannot resume dead coroutine\00", align 1
@.str8135 = private unnamed_addr constant [27 x i8] c"too many results to resume\00", align 1
@.str9136 = private unnamed_addr constant [19 x i8] c"coroutine expected\00", align 1
@.str10137 = private unnamed_addr constant [10 x i8] c"suspended\00", align 1
@.str11138 = private unnamed_addr constant [7 x i8] c"normal\00", align 1
@.str12139 = private unnamed_addr constant [5 x i8] c"dead\00", align 1
@luai_ctype_ = hidden constant [257 x i8] c"\00\00\00\00\00\00\00\00\00\00\08\08\08\08\08\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\0C\04\04\04\04\04\04\04\04\04\04\04\04\04\04\04\16\16\16\16\16\16\16\16\16\16\04\04\04\04\04\04\04\15\15\15\15\15\15\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\04\04\04\04\05\04\15\15\15\15\15\15\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\04\04\04\04\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", align 16
@dblib = internal constant [17 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8]* @.str140, i32 0, i32 0), i32 (%struct.lua_State*)* @db_debug }, %struct.luaL_Reg { i8* getelementptr inbounds ([13 x i8]* @.str1141, i32 0, i32 0), i32 (%struct.lua_State*)* @db_getuservalue }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8]* @.str2142, i32 0, i32 0), i32 (%struct.lua_State*)* @db_gethook }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8]* @.str3143, i32 0, i32 0), i32 (%struct.lua_State*)* @db_getinfo }, %struct.luaL_Reg { i8* getelementptr inbounds ([9 x i8]* @.str4144, i32 0, i32 0), i32 (%struct.lua_State*)* @db_getlocal }, %struct.luaL_Reg { i8* getelementptr inbounds ([12 x i8]* @.str5145, i32 0, i32 0), i32 (%struct.lua_State*)* @db_getregistry }, %struct.luaL_Reg { i8* getelementptr inbounds ([13 x i8]* @.str6146, i32 0, i32 0), i32 (%struct.lua_State*)* @db_getmetatable }, %struct.luaL_Reg { i8* getelementptr inbounds ([11 x i8]* @.str7147, i32 0, i32 0), i32 (%struct.lua_State*)* @db_getupvalue }, %struct.luaL_Reg { i8* getelementptr inbounds ([12 x i8]* @.str8148, i32 0, i32 0), i32 (%struct.lua_State*)* @db_upvaluejoin }, %struct.luaL_Reg { i8* getelementptr inbounds ([10 x i8]* @.str9149, i32 0, i32 0), i32 (%struct.lua_State*)* @db_upvalueid }, %struct.luaL_Reg { i8* getelementptr inbounds ([13 x i8]* @.str10150, i32 0, i32 0), i32 (%struct.lua_State*)* @db_setuservalue }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8]* @.str11151, i32 0, i32 0), i32 (%struct.lua_State*)* @db_sethook }, %struct.luaL_Reg { i8* getelementptr inbounds ([9 x i8]* @.str12152, i32 0, i32 0), i32 (%struct.lua_State*)* @db_setlocal }, %struct.luaL_Reg { i8* getelementptr inbounds ([13 x i8]* @.str13153, i32 0, i32 0), i32 (%struct.lua_State*)* @db_setmetatable }, %struct.luaL_Reg { i8* getelementptr inbounds ([11 x i8]* @.str14154, i32 0, i32 0), i32 (%struct.lua_State*)* @db_setupvalue }, %struct.luaL_Reg { i8* getelementptr inbounds ([10 x i8]* @.str15155, i32 0, i32 0), i32 (%struct.lua_State*)* @db_traceback }, %struct.luaL_Reg zeroinitializer], align 16
@.str140 = private unnamed_addr constant [6 x i8] c"debug\00", align 1
@.str1141 = private unnamed_addr constant [13 x i8] c"getuservalue\00", align 1
@.str2142 = private unnamed_addr constant [8 x i8] c"gethook\00", align 1
@.str3143 = private unnamed_addr constant [8 x i8] c"getinfo\00", align 1
@.str4144 = private unnamed_addr constant [9 x i8] c"getlocal\00", align 1
@.str5145 = private unnamed_addr constant [12 x i8] c"getregistry\00", align 1
@.str6146 = private unnamed_addr constant [13 x i8] c"getmetatable\00", align 1
@.str7147 = private unnamed_addr constant [11 x i8] c"getupvalue\00", align 1
@.str8148 = private unnamed_addr constant [12 x i8] c"upvaluejoin\00", align 1
@.str9149 = private unnamed_addr constant [10 x i8] c"upvalueid\00", align 1
@.str10150 = private unnamed_addr constant [13 x i8] c"setuservalue\00", align 1
@.str11151 = private unnamed_addr constant [8 x i8] c"sethook\00", align 1
@.str12152 = private unnamed_addr constant [9 x i8] c"setlocal\00", align 1
@.str13153 = private unnamed_addr constant [13 x i8] c"setmetatable\00", align 1
@.str14154 = private unnamed_addr constant [11 x i8] c"setupvalue\00", align 1
@.str15155 = private unnamed_addr constant [10 x i8] c"traceback\00", align 1
@.str16156 = private unnamed_addr constant [22 x i8] c"nil or table expected\00", align 1
@.str17157 = private unnamed_addr constant [19 x i8] c"level out of range\00", align 1
@.str18158 = private unnamed_addr constant [6 x i8] c"_HKEY\00", align 1
@.str19159 = private unnamed_addr constant [2 x i8] c"k\00", align 1
@.str20160 = private unnamed_addr constant [7 x i8] c"__mode\00", align 1
@hookf.hooknames = internal constant [5 x i8*] [i8* getelementptr inbounds ([5 x i8]* @.str21161, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8]* @.str22162, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8]* @.str23163, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8]* @.str24164, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8]* @.str25165, i32 0, i32 0)], align 16
@.str21161 = private unnamed_addr constant [5 x i8] c"call\00", align 1
@.str22162 = private unnamed_addr constant [7 x i8] c"return\00", align 1
@.str23163 = private unnamed_addr constant [5 x i8] c"line\00", align 1
@.str24164 = private unnamed_addr constant [6 x i8] c"count\00", align 1
@.str25165 = private unnamed_addr constant [10 x i8] c"tail call\00", align 1
@.str26166 = private unnamed_addr constant [43 x i8] c"full userdata expected, got light userdata\00", align 1
@.str27167 = private unnamed_addr constant [3 x i8] c">u\00", align 1
@.str28168 = private unnamed_addr constant [22 x i8] c"invalid upvalue index\00", align 1
@.str29169 = private unnamed_addr constant [22 x i8] c"Lua function expected\00", align 1
@.str30170 = private unnamed_addr constant [7 x i8] c"flnStu\00", align 1
@.str31171 = private unnamed_addr constant [4 x i8] c">%s\00", align 1
@.str32172 = private unnamed_addr constant [27 x i8] c"function or level expected\00", align 1
@.str33173 = private unnamed_addr constant [15 x i8] c"invalid option\00", align 1
@.str34174 = private unnamed_addr constant [7 x i8] c"source\00", align 1
@.str35175 = private unnamed_addr constant [10 x i8] c"short_src\00", align 1
@.str36176 = private unnamed_addr constant [12 x i8] c"linedefined\00", align 1
@.str37177 = private unnamed_addr constant [16 x i8] c"lastlinedefined\00", align 1
@.str38178 = private unnamed_addr constant [5 x i8] c"what\00", align 1
@.str39179 = private unnamed_addr constant [12 x i8] c"currentline\00", align 1
@.str40180 = private unnamed_addr constant [5 x i8] c"nups\00", align 1
@.str41181 = private unnamed_addr constant [8 x i8] c"nparams\00", align 1
@.str42182 = private unnamed_addr constant [9 x i8] c"isvararg\00", align 1
@.str43183 = private unnamed_addr constant [5 x i8] c"name\00", align 1
@.str44184 = private unnamed_addr constant [9 x i8] c"namewhat\00", align 1
@.str45185 = private unnamed_addr constant [11 x i8] c"istailcall\00", align 1
@.str46186 = private unnamed_addr constant [12 x i8] c"activelines\00", align 1
@.str47187 = private unnamed_addr constant [5 x i8] c"func\00", align 1
@.str48188 = private unnamed_addr constant [14 x i8] c"external hook\00", align 1
@.str49189 = private unnamed_addr constant [3 x i8] c"%s\00", align 1
@.str50190 = private unnamed_addr constant [12 x i8] c"lua_debug> \00", align 1
@.str51191 = private unnamed_addr constant [6 x i8] c"cont\0A\00", align 1
@.str52192 = private unnamed_addr constant [17 x i8] c"=(debug command)\00", align 1
@.str53193 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
@.str194 = private unnamed_addr constant [35 x i8] c"attempt to %s %s '%s' (a %s value)\00", align 1
@.str1195 = private unnamed_addr constant [25 x i8] c"attempt to %s a %s value\00", align 1
@.str2196 = private unnamed_addr constant [12 x i8] c"concatenate\00", align 1
@.str3197 = private unnamed_addr constant [22 x i8] c"perform arithmetic on\00", align 1
@.str4198 = private unnamed_addr constant [33 x i8] c"attempt to compare two %s values\00", align 1
@.str5199 = private unnamed_addr constant [30 x i8] c"attempt to compare %s with %s\00", align 1
@.str6200 = private unnamed_addr constant [10 x i8] c"%s:%d: %s\00", align 1
@.str7201 = private unnamed_addr constant [6 x i8] c"local\00", align 1
@.str8202 = private unnamed_addr constant [5 x i8] c"_ENV\00", align 1
@.str9203 = private unnamed_addr constant [7 x i8] c"global\00", align 1
@.str10204 = private unnamed_addr constant [6 x i8] c"field\00", align 1
@.str11205 = private unnamed_addr constant [8 x i8] c"upvalue\00", align 1
@.str12206 = private unnamed_addr constant [9 x i8] c"constant\00", align 1
@.str13207 = private unnamed_addr constant [7 x i8] c"method\00", align 1
@.str14208 = private unnamed_addr constant [2 x i8] c"?\00", align 1
@.str15209 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str16210 = private unnamed_addr constant [13 x i8] c"for iterator\00", align 1
@.str17211 = private unnamed_addr constant [11 x i8] c"metamethod\00", align 1
@.str18212 = private unnamed_addr constant [5 x i8] c"=[C]\00", align 1
@.str19213 = private unnamed_addr constant [2 x i8] c"C\00", align 1
@.str20214 = private unnamed_addr constant [3 x i8] c"=?\00", align 1
@.str21215 = private unnamed_addr constant [5 x i8] c"main\00", align 1
@.str22216 = private unnamed_addr constant [4 x i8] c"Lua\00", align 1
@.str23217 = private unnamed_addr constant [13 x i8] c"(*temporary)\00", align 1
@.str24218 = private unnamed_addr constant [10 x i8] c"(*vararg)\00", align 1
@.str237 = private unnamed_addr constant [15 x i8] c"stack overflow\00", align 1
@.str1238 = private unnamed_addr constant [17 x i8] c"C stack overflow\00", align 1
@.str2239 = private unnamed_addr constant [42 x i8] c"attempt to yield across a C-call boundary\00", align 1
@.str3240 = private unnamed_addr constant [42 x i8] c"attempt to yield from outside a coroutine\00", align 1
@.str4241 = private unnamed_addr constant [5 x i8] c"\1BLua\00", align 1
@.str5242 = private unnamed_addr constant [7 x i8] c"binary\00", align 1
@.str6243 = private unnamed_addr constant [5 x i8] c"text\00", align 1
@.str7244 = private unnamed_addr constant [42 x i8] c"attempt to load a %s chunk (mode is '%s')\00", align 1
@.str8245 = private unnamed_addr constant [24 x i8] c"error in error handling\00", align 1
@.str9246 = private unnamed_addr constant [38 x i8] c"cannot resume non-suspended coroutine\00", align 1
@.str10247 = private unnamed_addr constant [29 x i8] c"cannot resume dead coroutine\00", align 1
@.str11248 = private unnamed_addr constant [5 x i8] c"call\00", align 1
@.str275 = private unnamed_addr constant [11 x i8] c"no message\00", align 1
@.str1276 = private unnamed_addr constant [30 x i8] c"error in __gc metamethod (%s)\00", align 1
@loadedlibs = internal constant [11 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([3 x i8]* @.str1296, i32 0, i32 0), i32 (%struct.lua_State*)* @luaopen_base }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8]* @.str2297, i32 0, i32 0), i32 (%struct.lua_State*)* @luaopen_package }, %struct.luaL_Reg { i8* getelementptr inbounds ([10 x i8]* @.str3298, i32 0, i32 0), i32 (%struct.lua_State*)* @luaopen_coroutine }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8]* @.str4299, i32 0, i32 0), i32 (%struct.lua_State*)* @luaopen_table }, %struct.luaL_Reg { i8* getelementptr inbounds ([3 x i8]* @.str5300, i32 0, i32 0), i32 (%struct.lua_State*)* @luaopen_io }, %struct.luaL_Reg { i8* getelementptr inbounds ([3 x i8]* @.str6301, i32 0, i32 0), i32 (%struct.lua_State*)* @luaopen_os }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8]* @.str7302, i32 0, i32 0), i32 (%struct.lua_State*)* @luaopen_string }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8]* @.str8303, i32 0, i32 0), i32 (%struct.lua_State*)* @luaopen_bit32 }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8]* @.str9304, i32 0, i32 0), i32 (%struct.lua_State*)* @luaopen_math }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8]* @.str10305, i32 0, i32 0), i32 (%struct.lua_State*)* @luaopen_debug }, %struct.luaL_Reg zeroinitializer], align 16
@.str295 = private unnamed_addr constant [9 x i8] c"_PRELOAD\00", align 1
@preloadedlibs = internal constant [1 x %struct.luaL_Reg] zeroinitializer, align 16
@.str1296 = private unnamed_addr constant [3 x i8] c"_G\00", align 1
@.str2297 = private unnamed_addr constant [8 x i8] c"package\00", align 1
@.str3298 = private unnamed_addr constant [10 x i8] c"coroutine\00", align 1
@.str4299 = private unnamed_addr constant [6 x i8] c"table\00", align 1
@.str5300 = private unnamed_addr constant [3 x i8] c"io\00", align 1
@.str6301 = private unnamed_addr constant [3 x i8] c"os\00", align 1
@.str7302 = private unnamed_addr constant [7 x i8] c"string\00", align 1
@.str8303 = private unnamed_addr constant [6 x i8] c"bit32\00", align 1
@.str9304 = private unnamed_addr constant [5 x i8] c"math\00", align 1
@.str10305 = private unnamed_addr constant [6 x i8] c"debug\00", align 1
@iolib = internal constant [12 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8]* @.str8314, i32 0, i32 0), i32 (%struct.lua_State*)* @io_close }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8]* @.str9315, i32 0, i32 0), i32 (%struct.lua_State*)* @io_flush }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8]* @.str35341, i32 0, i32 0), i32 (%struct.lua_State*)* @io_input }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8]* @.str10316, i32 0, i32 0), i32 (%struct.lua_State*)* @io_lines }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8]* @.str36342, i32 0, i32 0), i32 (%struct.lua_State*)* @io_open }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8]* @.str37343, i32 0, i32 0), i32 (%struct.lua_State*)* @io_output }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8]* @.str38344, i32 0, i32 0), i32 (%struct.lua_State*)* @io_popen }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8]* @.str11317, i32 0, i32 0), i32 (%struct.lua_State*)* @io_read }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8]* @.str39345, i32 0, i32 0), i32 (%struct.lua_State*)* @io_tmpfile }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8]* @.str40346, i32 0, i32 0), i32 (%struct.lua_State*)* @io_type }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8]* @.str14320, i32 0, i32 0), i32 (%struct.lua_State*)* @io_write }, %struct.luaL_Reg zeroinitializer], align 16
@.str306 = private unnamed_addr constant [10 x i8] c"_IO_input\00", align 1
@.str1307 = private unnamed_addr constant [6 x i8] c"stdin\00", align 1
@.str2308 = private unnamed_addr constant [11 x i8] c"_IO_output\00", align 1
@.str3309 = private unnamed_addr constant [7 x i8] c"stdout\00", align 1
@.str4310 = private unnamed_addr constant [7 x i8] c"stderr\00", align 1
@.str5311 = private unnamed_addr constant [6 x i8] c"FILE*\00", align 1
@.str6312 = private unnamed_addr constant [27 x i8] c"cannot close standard file\00", align 1
@.str7313 = private unnamed_addr constant [8 x i8] c"__index\00", align 1
@flib = internal constant [10 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8]* @.str8314, i32 0, i32 0), i32 (%struct.lua_State*)* @io_close }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8]* @.str9315, i32 0, i32 0), i32 (%struct.lua_State*)* @f_flush }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8]* @.str10316, i32 0, i32 0), i32 (%struct.lua_State*)* @f_lines }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8]* @.str11317, i32 0, i32 0), i32 (%struct.lua_State*)* @f_read }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8]* @.str12318, i32 0, i32 0), i32 (%struct.lua_State*)* @f_seek }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8]* @.str13319, i32 0, i32 0), i32 (%struct.lua_State*)* @f_setvbuf }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8]* @.str14320, i32 0, i32 0), i32 (%struct.lua_State*)* @f_write }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8]* @.str15321, i32 0, i32 0), i32 (%struct.lua_State*)* @f_gc }, %struct.luaL_Reg { i8* getelementptr inbounds ([11 x i8]* @.str16322, i32 0, i32 0), i32 (%struct.lua_State*)* @f_tostring }, %struct.luaL_Reg zeroinitializer], align 16
@.str8314 = private unnamed_addr constant [6 x i8] c"close\00", align 1
@.str9315 = private unnamed_addr constant [6 x i8] c"flush\00", align 1
@.str10316 = private unnamed_addr constant [6 x i8] c"lines\00", align 1
@.str11317 = private unnamed_addr constant [5 x i8] c"read\00", align 1
@.str12318 = private unnamed_addr constant [5 x i8] c"seek\00", align 1
@.str13319 = private unnamed_addr constant [8 x i8] c"setvbuf\00", align 1
@.str14320 = private unnamed_addr constant [6 x i8] c"write\00", align 1
@.str15321 = private unnamed_addr constant [5 x i8] c"__gc\00", align 1
@.str16322 = private unnamed_addr constant [11 x i8] c"__tostring\00", align 1
@.str17323 = private unnamed_addr constant [14 x i8] c"file (closed)\00", align 1
@.str18324 = private unnamed_addr constant [10 x i8] c"file (%p)\00", align 1
@.str19325 = private unnamed_addr constant [6 x i8] c"%.14g\00", align 1
@.str20326 = private unnamed_addr constant [29 x i8] c"attempt to use a closed file\00", align 1
@f_setvbuf.mode = internal constant [3 x i32] [i32 2, i32 0, i32 1], align 4
@f_setvbuf.modenames = internal constant [4 x i8*] [i8* getelementptr inbounds ([3 x i8]* @.str21327, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8]* @.str22328, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8]* @.str23329, i32 0, i32 0), i8* null], align 16
@.str21327 = private unnamed_addr constant [3 x i8] c"no\00", align 1
@.str22328 = private unnamed_addr constant [5 x i8] c"full\00", align 1
@.str23329 = private unnamed_addr constant [5 x i8] c"line\00", align 1
@f_seek.mode = internal constant [3 x i32] [i32 0, i32 1, i32 2], align 4
@f_seek.modenames = internal constant [4 x i8*] [i8* getelementptr inbounds ([4 x i8]* @.str24330, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8]* @.str25331, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8]* @.str26332, i32 0, i32 0), i8* null], align 16
@.str24330 = private unnamed_addr constant [4 x i8] c"set\00", align 1
@.str25331 = private unnamed_addr constant [4 x i8] c"cur\00", align 1
@.str26332 = private unnamed_addr constant [4 x i8] c"end\00", align 1
@.str27333 = private unnamed_addr constant [31 x i8] c"not an integer in proper range\00", align 1
@.str28334 = private unnamed_addr constant [19 x i8] c"too many arguments\00", align 1
@.str29335 = private unnamed_addr constant [15 x i8] c"invalid option\00", align 1
@.str30336 = private unnamed_addr constant [15 x i8] c"invalid format\00", align 1
@.str31337 = private unnamed_addr constant [4 x i8] c"%lf\00", align 1
@.str32338 = private unnamed_addr constant [17 x i8] c"too many options\00", align 1
@.str33339 = private unnamed_addr constant [23 x i8] c"file is already closed\00", align 1
@.str34340 = private unnamed_addr constant [3 x i8] c"%s\00", align 1
@.str35341 = private unnamed_addr constant [6 x i8] c"input\00", align 1
@.str36342 = private unnamed_addr constant [5 x i8] c"open\00", align 1
@.str37343 = private unnamed_addr constant [7 x i8] c"output\00", align 1
@.str38344 = private unnamed_addr constant [6 x i8] c"popen\00", align 1
@.str39345 = private unnamed_addr constant [8 x i8] c"tmpfile\00", align 1
@.str40346 = private unnamed_addr constant [5 x i8] c"type\00", align 1
@.str41347 = private unnamed_addr constant [27 x i8] c"standard %s file is closed\00", align 1
@.str42348 = private unnamed_addr constant [12 x i8] c"closed file\00", align 1
@.str43349 = private unnamed_addr constant [5 x i8] c"file\00", align 1
@.str44350 = private unnamed_addr constant [2 x i8] c"r\00", align 1
@.str45351 = private unnamed_addr constant [2 x i8] c"w\00", align 1
@.str46352 = private unnamed_addr constant [27 x i8] c"cannot open file '%s' (%s)\00", align 1
@.str47353 = private unnamed_addr constant [4 x i8] c"rwa\00", align 1
@.str48354 = private unnamed_addr constant [13 x i8] c"invalid mode\00", align 1
@luaX_tokens = internal constant [33 x i8*] [i8* getelementptr inbounds ([4 x i8]* @.str21378, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8]* @.str22379, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8]* @.str23380, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8]* @.str24381, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8]* @.str25382, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8]* @.str26383, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8]* @.str27384, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8]* @.str28385, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8]* @.str29386, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8]* @.str30387, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8]* @.str31388, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8]* @.str32389, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8]* @.str33390, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8]* @.str34391, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8]* @.str35392, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8]* @.str36393, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8]* @.str37394, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8]* @.str38395, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8]* @.str39396, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8]* @.str40397, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8]* @.str41398, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8]* @.str42399, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8]* @.str43400, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8]* @.str44401, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8]* @.str45402, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8]* @.str46403, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8]* @.str47404, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8]* @.str48405, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8]* @.str49406, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8]* @.str50407, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8]* @.str51408, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8]* @.str52409, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8]* @.str53410, i32 0, i32 0)], align 16
@.str357 = private unnamed_addr constant [5 x i8] c"'%c'\00", align 1
@.str1358 = private unnamed_addr constant [9 x i8] c"char(%d)\00", align 1
@.str2359 = private unnamed_addr constant [5 x i8] c"'%s'\00", align 1
@.str3360 = private unnamed_addr constant [5 x i8] c"_ENV\00", align 1
@.str4361 = private unnamed_addr constant [30 x i8] c"invalid long string delimiter\00", align 1
@.str5362 = private unnamed_addr constant [2 x i8] c".\00", align 1
@.str6363 = private unnamed_addr constant [3 x i8] c"Ee\00", align 1
@.str7364 = private unnamed_addr constant [3 x i8] c"Xx\00", align 1
@.str8365 = private unnamed_addr constant [3 x i8] c"Pp\00", align 1
@.str9366 = private unnamed_addr constant [3 x i8] c"+-\00", align 1
@.str10367 = private unnamed_addr constant [17 x i8] c"malformed number\00", align 1
@.str11368 = private unnamed_addr constant [25 x i8] c"lexical element too long\00", align 1
@.str12369 = private unnamed_addr constant [18 x i8] c"unfinished string\00", align 1
@.str13370 = private unnamed_addr constant [24 x i8] c"invalid escape sequence\00", align 1
@.str14371 = private unnamed_addr constant [25 x i8] c"decimal escape too large\00", align 1
@.str15372 = private unnamed_addr constant [27 x i8] c"hexadecimal digit expected\00", align 1
@.str16373 = private unnamed_addr constant [23 x i8] c"unfinished long string\00", align 1
@.str17374 = private unnamed_addr constant [24 x i8] c"unfinished long comment\00", align 1
@.str18375 = private unnamed_addr constant [25 x i8] c"chunk has too many lines\00", align 1
@.str19376 = private unnamed_addr constant [10 x i8] c"%s:%d: %s\00", align 1
@.str20377 = private unnamed_addr constant [11 x i8] c"%s near %s\00", align 1
@.str21378 = private unnamed_addr constant [4 x i8] c"and\00", align 1
@.str22379 = private unnamed_addr constant [6 x i8] c"break\00", align 1
@.str23380 = private unnamed_addr constant [3 x i8] c"do\00", align 1
@.str24381 = private unnamed_addr constant [5 x i8] c"else\00", align 1
@.str25382 = private unnamed_addr constant [7 x i8] c"elseif\00", align 1
@.str26383 = private unnamed_addr constant [4 x i8] c"end\00", align 1
@.str27384 = private unnamed_addr constant [6 x i8] c"false\00", align 1
@.str28385 = private unnamed_addr constant [4 x i8] c"for\00", align 1
@.str29386 = private unnamed_addr constant [9 x i8] c"function\00", align 1
@.str30387 = private unnamed_addr constant [5 x i8] c"goto\00", align 1
@.str31388 = private unnamed_addr constant [3 x i8] c"if\00", align 1
@.str32389 = private unnamed_addr constant [3 x i8] c"in\00", align 1
@.str33390 = private unnamed_addr constant [6 x i8] c"local\00", align 1
@.str34391 = private unnamed_addr constant [4 x i8] c"nil\00", align 1
@.str35392 = private unnamed_addr constant [4 x i8] c"not\00", align 1
@.str36393 = private unnamed_addr constant [3 x i8] c"or\00", align 1
@.str37394 = private unnamed_addr constant [7 x i8] c"repeat\00", align 1
@.str38395 = private unnamed_addr constant [7 x i8] c"return\00", align 1
@.str39396 = private unnamed_addr constant [5 x i8] c"then\00", align 1
@.str40397 = private unnamed_addr constant [5 x i8] c"true\00", align 1
@.str41398 = private unnamed_addr constant [6 x i8] c"until\00", align 1
@.str42399 = private unnamed_addr constant [6 x i8] c"while\00", align 1
@.str43400 = private unnamed_addr constant [3 x i8] c"..\00", align 1
@.str44401 = private unnamed_addr constant [4 x i8] c"...\00", align 1
@.str45402 = private unnamed_addr constant [3 x i8] c"==\00", align 1
@.str46403 = private unnamed_addr constant [3 x i8] c">=\00", align 1
@.str47404 = private unnamed_addr constant [3 x i8] c"<=\00", align 1
@.str48405 = private unnamed_addr constant [3 x i8] c"~=\00", align 1
@.str49406 = private unnamed_addr constant [3 x i8] c"::\00", align 1
@.str50407 = private unnamed_addr constant [6 x i8] c"<eof>\00", align 1
@.str51408 = private unnamed_addr constant [9 x i8] c"<number>\00", align 1
@.str52409 = private unnamed_addr constant [7 x i8] c"<name>\00", align 1
@.str53410 = private unnamed_addr constant [9 x i8] c"<string>\00", align 1
@mathlib = internal constant [28 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8]* @.str2415, i32 0, i32 0), i32 (%struct.lua_State*)* @math_abs }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8]* @.str3416, i32 0, i32 0), i32 (%struct.lua_State*)* @math_acos }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8]* @.str4417, i32 0, i32 0), i32 (%struct.lua_State*)* @math_asin }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8]* @.str5418, i32 0, i32 0), i32 (%struct.lua_State*)* @math_atan2 }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8]* @.str6419, i32 0, i32 0), i32 (%struct.lua_State*)* @math_atan }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8]* @.str7420, i32 0, i32 0), i32 (%struct.lua_State*)* @math_ceil }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8]* @.str8421, i32 0, i32 0), i32 (%struct.lua_State*)* @math_cosh }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8]* @.str9422, i32 0, i32 0), i32 (%struct.lua_State*)* @math_cos }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8]* @.str10423, i32 0, i32 0), i32 (%struct.lua_State*)* @math_deg }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8]* @.str11424, i32 0, i32 0), i32 (%struct.lua_State*)* @math_exp }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8]* @.str12425, i32 0, i32 0), i32 (%struct.lua_State*)* @math_floor }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8]* @.str13426, i32 0, i32 0), i32 (%struct.lua_State*)* @math_fmod }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8]* @.str14427, i32 0, i32 0), i32 (%struct.lua_State*)* @math_frexp }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8]* @.str15428, i32 0, i32 0), i32 (%struct.lua_State*)* @math_ldexp }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8]* @.str16429, i32 0, i32 0), i32 (%struct.lua_State*)* @math_log }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8]* @.str17430, i32 0, i32 0), i32 (%struct.lua_State*)* @math_max }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8]* @.str18431, i32 0, i32 0), i32 (%struct.lua_State*)* @math_min }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8]* @.str19432, i32 0, i32 0), i32 (%struct.lua_State*)* @math_modf }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8]* @.str20433, i32 0, i32 0), i32 (%struct.lua_State*)* @math_pow }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8]* @.str21434, i32 0, i32 0), i32 (%struct.lua_State*)* @math_rad }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8]* @.str22435, i32 0, i32 0), i32 (%struct.lua_State*)* @math_random }, %struct.luaL_Reg { i8* getelementptr inbounds ([11 x i8]* @.str23436, i32 0, i32 0), i32 (%struct.lua_State*)* @math_randomseed }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8]* @.str24437, i32 0, i32 0), i32 (%struct.lua_State*)* @math_sinh }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8]* @.str25438, i32 0, i32 0), i32 (%struct.lua_State*)* @math_sin }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8]* @.str26439, i32 0, i32 0), i32 (%struct.lua_State*)* @math_sqrt }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8]* @.str27440, i32 0, i32 0), i32 (%struct.lua_State*)* @math_tanh }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8]* @.str28441, i32 0, i32 0), i32 (%struct.lua_State*)* @math_tan }, %struct.luaL_Reg zeroinitializer], align 16
@.str413 = private unnamed_addr constant [3 x i8] c"pi\00", align 1
@.str1414 = private unnamed_addr constant [5 x i8] c"huge\00", align 1
@.str2415 = private unnamed_addr constant [4 x i8] c"abs\00", align 1
@.str3416 = private unnamed_addr constant [5 x i8] c"acos\00", align 1
@.str4417 = private unnamed_addr constant [5 x i8] c"asin\00", align 1
@.str5418 = private unnamed_addr constant [6 x i8] c"atan2\00", align 1
@.str6419 = private unnamed_addr constant [5 x i8] c"atan\00", align 1
@.str7420 = private unnamed_addr constant [5 x i8] c"ceil\00", align 1
@.str8421 = private unnamed_addr constant [5 x i8] c"cosh\00", align 1
@.str9422 = private unnamed_addr constant [4 x i8] c"cos\00", align 1
@.str10423 = private unnamed_addr constant [4 x i8] c"deg\00", align 1
@.str11424 = private unnamed_addr constant [4 x i8] c"exp\00", align 1
@.str12425 = private unnamed_addr constant [6 x i8] c"floor\00", align 1
@.str13426 = private unnamed_addr constant [5 x i8] c"fmod\00", align 1
@.str14427 = private unnamed_addr constant [6 x i8] c"frexp\00", align 1
@.str15428 = private unnamed_addr constant [6 x i8] c"ldexp\00", align 1
@.str16429 = private unnamed_addr constant [4 x i8] c"log\00", align 1
@.str17430 = private unnamed_addr constant [4 x i8] c"max\00", align 1
@.str18431 = private unnamed_addr constant [4 x i8] c"min\00", align 1
@.str19432 = private unnamed_addr constant [5 x i8] c"modf\00", align 1
@.str20433 = private unnamed_addr constant [4 x i8] c"pow\00", align 1
@.str21434 = private unnamed_addr constant [4 x i8] c"rad\00", align 1
@.str22435 = private unnamed_addr constant [7 x i8] c"random\00", align 1
@.str23436 = private unnamed_addr constant [11 x i8] c"randomseed\00", align 1
@.str24437 = private unnamed_addr constant [5 x i8] c"sinh\00", align 1
@.str25438 = private unnamed_addr constant [4 x i8] c"sin\00", align 1
@.str26439 = private unnamed_addr constant [5 x i8] c"sqrt\00", align 1
@.str27440 = private unnamed_addr constant [5 x i8] c"tanh\00", align 1
@.str28441 = private unnamed_addr constant [4 x i8] c"tan\00", align 1
@.str29442 = private unnamed_addr constant [18 x i8] c"interval is empty\00", align 1
@.str30443 = private unnamed_addr constant [26 x i8] c"wrong number of arguments\00", align 1
@.str446 = private unnamed_addr constant [26 x i8] c"too many %s (limit is %d)\00", align 1
@.str1447 = private unnamed_addr constant [39 x i8] c"memory allocation error: block too big\00", align 1
@.str454 = private unnamed_addr constant [7 x i8] c"_CLIBS\00", align 1
@.str1455 = private unnamed_addr constant [5 x i8] c"__gc\00", align 1
@pk_funcs = internal constant [3 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8]* @.str37491, i32 0, i32 0), i32 (%struct.lua_State*)* @ll_loadlib }, %struct.luaL_Reg { i8* getelementptr inbounds ([11 x i8]* @.str38492, i32 0, i32 0), i32 (%struct.lua_State*)* @ll_searchpath }, %struct.luaL_Reg zeroinitializer], align 16
@.str2456 = private unnamed_addr constant [10 x i8] c"searchers\00", align 1
@.str3457 = private unnamed_addr constant [5 x i8] c"path\00", align 1
@.str4458 = private unnamed_addr constant [13 x i8] c"LUA_PATH_5_2\00", align 1
@.str5459 = private unnamed_addr constant [9 x i8] c"LUA_PATH\00", align 1
@.str6460 = private unnamed_addr constant [138 x i8] c"/usr/local/share/lua/5.2/?.lua;/usr/local/share/lua/5.2/?/init.lua;/usr/local/lib/lua/5.2/?.lua;/usr/local/lib/lua/5.2/?/init.lua;./?.lua\00", align 1
@.str7461 = private unnamed_addr constant [6 x i8] c"cpath\00", align 1
@.str8462 = private unnamed_addr constant [14 x i8] c"LUA_CPATH_5_2\00", align 1
@.str9463 = private unnamed_addr constant [10 x i8] c"LUA_CPATH\00", align 1
@.str10464 = private unnamed_addr constant [69 x i8] c"/usr/local/lib/lua/5.2/?.so;/usr/local/lib/lua/5.2/loadall.so;./?.so\00", align 1
@.str11465 = private unnamed_addr constant [11 x i8] c"/\0A;\0A?\0A!\0A-\0A\00", align 1
@.str12466 = private unnamed_addr constant [7 x i8] c"config\00", align 1
@.str13467 = private unnamed_addr constant [8 x i8] c"_LOADED\00", align 1
@.str14468 = private unnamed_addr constant [7 x i8] c"loaded\00", align 1
@.str15469 = private unnamed_addr constant [9 x i8] c"_PRELOAD\00", align 1
@.str16470 = private unnamed_addr constant [8 x i8] c"preload\00", align 1
@ll_funcs = internal constant [2 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8]* @.str17471, i32 0, i32 0), i32 (%struct.lua_State*)* @ll_require }, %struct.luaL_Reg zeroinitializer], align 16
@.str17471 = private unnamed_addr constant [8 x i8] c"require\00", align 1
@.str18472 = private unnamed_addr constant [36 x i8] c"'package.searchers' must be a table\00", align 1
@.str19473 = private unnamed_addr constant [25 x i8] c"module '%s' not found:%s\00", align 1
@.str20474 = private unnamed_addr constant [3 x i8] c";;\00", align 1
@.str21475 = private unnamed_addr constant [4 x i8] c";\01;\00", align 1
@.str22476 = private unnamed_addr constant [2 x i8] c"\01\00", align 1
@.str23477 = private unnamed_addr constant [10 x i8] c"LUA_NOENV\00", align 1
@createsearcherstable.searchers = internal constant [5 x i32 (%struct.lua_State*)*] [i32 (%struct.lua_State*)* @searcher_preload, i32 (%struct.lua_State*)* @searcher_Lua, i32 (%struct.lua_State*)* @searcher_C, i32 (%struct.lua_State*)* @searcher_Croot, i32 (%struct.lua_State*)* null], align 16
@.str24478 = private unnamed_addr constant [2 x i8] c"/\00", align 1
@.str25479 = private unnamed_addr constant [30 x i8] c"\0A\09no module '%s' in file '%s'\00", align 1
@.str26480 = private unnamed_addr constant [46 x i8] c"error loading module '%s' from file '%s':\0A\09%s\00", align 1
@.str27481 = private unnamed_addr constant [2 x i8] c".\00", align 1
@.str28482 = private unnamed_addr constant [2 x i8] c"_\00", align 1
@.str29483 = private unnamed_addr constant [2 x i8] c"-\00", align 1
@.str30484 = private unnamed_addr constant [11 x i8] c"luaopen_%s\00", align 1
@.str31485 = private unnamed_addr constant [30 x i8] c"'package.%s' must be a string\00", align 1
@.str32486 = private unnamed_addr constant [2 x i8] c"?\00", align 1
@.str33487 = private unnamed_addr constant [15 x i8] c"\0A\09no file '%s'\00", align 1
@.str34488 = private unnamed_addr constant [2 x i8] c"r\00", align 1
@.str35489 = private unnamed_addr constant [2 x i8] c";\00", align 1
@.str36490 = private unnamed_addr constant [33 x i8] c"\0A\09no field package.preload['%s']\00", align 1
@.str37491 = private unnamed_addr constant [8 x i8] c"loadlib\00", align 1
@.str38492 = private unnamed_addr constant [11 x i8] c"searchpath\00", align 1
@.str39493 = private unnamed_addr constant [5 x i8] c"open\00", align 1
@.str40494 = private unnamed_addr constant [5 x i8] c"init\00", align 1
@luaO_nilobject_ = hidden constant { %union.Value.281, i32, [4 x i8] } { %union.Value.281 zeroinitializer, i32 0, [4 x i8] undef }, align 8
@luaO_ceillog2.log_2 = internal constant [256 x i8] c"\00\01\02\02\03\03\03\03\04\04\04\04\04\04\04\04\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08", align 16
@.str499 = private unnamed_addr constant [3 x i8] c"nN\00", align 1
@.str1500 = private unnamed_addr constant [3 x i8] c"xX\00", align 1
@.str2501 = private unnamed_addr constant [7 x i8] c"(null)\00", align 1
@.str3502 = private unnamed_addr constant [3 x i8] c"%p\00", align 1
@.str4503 = private unnamed_addr constant [2 x i8] c"%\00", align 1
@.str5504 = private unnamed_addr constant [43 x i8] c"invalid option '%%%c' to 'lua_pushfstring'\00", align 1
@.str6505 = private unnamed_addr constant [4 x i8] c"...\00", align 1
@.str7506 = private unnamed_addr constant [10 x i8] c"[string \22\00", align 1
@.str8507 = private unnamed_addr constant [3 x i8] c"\22]\00", align 1
@.str520 = private unnamed_addr constant [5 x i8] c"MOVE\00", align 1
@.str1521 = private unnamed_addr constant [6 x i8] c"LOADK\00", align 1
@.str2522 = private unnamed_addr constant [7 x i8] c"LOADKX\00", align 1
@.str3523 = private unnamed_addr constant [9 x i8] c"LOADBOOL\00", align 1
@.str4524 = private unnamed_addr constant [8 x i8] c"LOADNIL\00", align 1
@.str5525 = private unnamed_addr constant [9 x i8] c"GETUPVAL\00", align 1
@.str6526 = private unnamed_addr constant [9 x i8] c"GETTABUP\00", align 1
@.str7527 = private unnamed_addr constant [9 x i8] c"GETTABLE\00", align 1
@.str8528 = private unnamed_addr constant [9 x i8] c"SETTABUP\00", align 1
@.str9529 = private unnamed_addr constant [9 x i8] c"SETUPVAL\00", align 1
@.str10530 = private unnamed_addr constant [9 x i8] c"SETTABLE\00", align 1
@.str11531 = private unnamed_addr constant [9 x i8] c"NEWTABLE\00", align 1
@.str12532 = private unnamed_addr constant [5 x i8] c"SELF\00", align 1
@.str13533 = private unnamed_addr constant [4 x i8] c"ADD\00", align 1
@.str14534 = private unnamed_addr constant [4 x i8] c"SUB\00", align 1
@.str15535 = private unnamed_addr constant [4 x i8] c"MUL\00", align 1
@.str16536 = private unnamed_addr constant [4 x i8] c"DIV\00", align 1
@.str17537 = private unnamed_addr constant [4 x i8] c"MOD\00", align 1
@.str18538 = private unnamed_addr constant [4 x i8] c"POW\00", align 1
@.str19539 = private unnamed_addr constant [4 x i8] c"UNM\00", align 1
@.str20540 = private unnamed_addr constant [4 x i8] c"NOT\00", align 1
@.str21541 = private unnamed_addr constant [4 x i8] c"LEN\00", align 1
@.str22542 = private unnamed_addr constant [7 x i8] c"CONCAT\00", align 1
@.str23543 = private unnamed_addr constant [4 x i8] c"JMP\00", align 1
@.str24544 = private unnamed_addr constant [3 x i8] c"EQ\00", align 1
@.str25545 = private unnamed_addr constant [3 x i8] c"LT\00", align 1
@.str26546 = private unnamed_addr constant [3 x i8] c"LE\00", align 1
@.str27547 = private unnamed_addr constant [5 x i8] c"TEST\00", align 1
@.str28548 = private unnamed_addr constant [8 x i8] c"TESTSET\00", align 1
@.str29549 = private unnamed_addr constant [5 x i8] c"CALL\00", align 1
@.str30550 = private unnamed_addr constant [9 x i8] c"TAILCALL\00", align 1
@.str31551 = private unnamed_addr constant [7 x i8] c"RETURN\00", align 1
@.str32552 = private unnamed_addr constant [8 x i8] c"FORLOOP\00", align 1
@.str33553 = private unnamed_addr constant [8 x i8] c"FORPREP\00", align 1
@.str34554 = private unnamed_addr constant [9 x i8] c"TFORCALL\00", align 1
@.str35555 = private unnamed_addr constant [9 x i8] c"TFORLOOP\00", align 1
@.str36556 = private unnamed_addr constant [8 x i8] c"SETLIST\00", align 1
@.str37557 = private unnamed_addr constant [8 x i8] c"CLOSURE\00", align 1
@.str38558 = private unnamed_addr constant [7 x i8] c"VARARG\00", align 1
@.str39559 = private unnamed_addr constant [9 x i8] c"EXTRAARG\00", align 1
@luaP_opnames = hidden constant [41 x i8*] [i8* getelementptr inbounds ([5 x i8]* @.str520, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8]* @.str1521, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8]* @.str2522, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8]* @.str3523, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8]* @.str4524, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8]* @.str5525, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8]* @.str6526, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8]* @.str7527, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8]* @.str8528, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8]* @.str9529, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8]* @.str10530, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8]* @.str11531, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8]* @.str12532, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8]* @.str13533, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8]* @.str14534, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8]* @.str15535, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8]* @.str16536, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8]* @.str17537, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8]* @.str18538, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8]* @.str19539, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8]* @.str20540, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8]* @.str21541, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8]* @.str22542, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8]* @.str23543, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8]* @.str24544, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8]* @.str25545, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8]* @.str26546, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8]* @.str27547, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8]* @.str28548, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8]* @.str29549, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8]* @.str30550, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8]* @.str31551, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8]* @.str32552, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8]* @.str33553, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8]* @.str34554, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8]* @.str35555, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8]* @.str36556, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8]* @.str37557, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8]* @.str38558, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8]* @.str39559, i32 0, i32 0), i8* null], align 16
@luaP_opmodes = hidden constant [40 x i8] c"`qATPP\5Cl<\10<Tl||||||```h\22\BC\BC\BC\84\E4TT\10bb\04b\14QP\17", align 16
@syslib = internal constant [12 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8]* @.str562, i32 0, i32 0), i32 (%struct.lua_State*)* @os_clock }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8]* @.str1563, i32 0, i32 0), i32 (%struct.lua_State*)* @os_date }, %struct.luaL_Reg { i8* getelementptr inbounds ([9 x i8]* @.str2564, i32 0, i32 0), i32 (%struct.lua_State*)* @os_difftime }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8]* @.str3565, i32 0, i32 0), i32 (%struct.lua_State*)* @os_execute }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8]* @.str4566, i32 0, i32 0), i32 (%struct.lua_State*)* @os_exit }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8]* @.str5567, i32 0, i32 0), i32 (%struct.lua_State*)* @os_getenv }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8]* @.str6568, i32 0, i32 0), i32 (%struct.lua_State*)* @os_remove }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8]* @.str7569, i32 0, i32 0), i32 (%struct.lua_State*)* @os_rename }, %struct.luaL_Reg { i8* getelementptr inbounds ([10 x i8]* @.str8570, i32 0, i32 0), i32 (%struct.lua_State*)* @os_setlocale }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8]* @.str9571, i32 0, i32 0), i32 (%struct.lua_State*)* @os_time }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8]* @.str10572, i32 0, i32 0), i32 (%struct.lua_State*)* @os_tmpname }, %struct.luaL_Reg zeroinitializer], align 16
@.str562 = private unnamed_addr constant [6 x i8] c"clock\00", align 1
@.str1563 = private unnamed_addr constant [5 x i8] c"date\00", align 1
@.str2564 = private unnamed_addr constant [9 x i8] c"difftime\00", align 1
@.str3565 = private unnamed_addr constant [8 x i8] c"execute\00", align 1
@.str4566 = private unnamed_addr constant [5 x i8] c"exit\00", align 1
@.str5567 = private unnamed_addr constant [7 x i8] c"getenv\00", align 1
@.str6568 = private unnamed_addr constant [7 x i8] c"remove\00", align 1
@.str7569 = private unnamed_addr constant [7 x i8] c"rename\00", align 1
@.str8570 = private unnamed_addr constant [10 x i8] c"setlocale\00", align 1
@.str9571 = private unnamed_addr constant [5 x i8] c"time\00", align 1
@.str10572 = private unnamed_addr constant [8 x i8] c"tmpname\00", align 1
@.str11573 = private unnamed_addr constant [16 x i8] c"/tmp/lua_XXXXXX\00", align 1
@.str12574 = private unnamed_addr constant [37 x i8] c"unable to generate a unique filename\00", align 1
@.str13575 = private unnamed_addr constant [4 x i8] c"sec\00", align 1
@.str14576 = private unnamed_addr constant [4 x i8] c"min\00", align 1
@.str15577 = private unnamed_addr constant [5 x i8] c"hour\00", align 1
@.str16578 = private unnamed_addr constant [4 x i8] c"day\00", align 1
@.str17579 = private unnamed_addr constant [6 x i8] c"month\00", align 1
@.str18580 = private unnamed_addr constant [5 x i8] c"year\00", align 1
@.str19581 = private unnamed_addr constant [6 x i8] c"isdst\00", align 1
@.str20582 = private unnamed_addr constant [33 x i8] c"field '%s' missing in date table\00", align 1
@os_setlocale.cat = internal constant [6 x i32] [i32 6, i32 3, i32 0, i32 4, i32 1, i32 2], align 16
@os_setlocale.catnames = internal constant [7 x i8*] [i8* getelementptr inbounds ([4 x i8]* @.str21583, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8]* @.str22584, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8]* @.str23585, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8]* @.str24586, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8]* @.str25587, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8]* @.str9571, i32 0, i32 0), i8* null], align 16
@.str21583 = private unnamed_addr constant [4 x i8] c"all\00", align 1
@.str22584 = private unnamed_addr constant [8 x i8] c"collate\00", align 1
@.str23585 = private unnamed_addr constant [6 x i8] c"ctype\00", align 1
@.str24586 = private unnamed_addr constant [9 x i8] c"monetary\00", align 1
@.str25587 = private unnamed_addr constant [8 x i8] c"numeric\00", align 1
@.str26588 = private unnamed_addr constant [3 x i8] c"%c\00", align 1
@.str27589 = private unnamed_addr constant [3 x i8] c"*t\00", align 1
@.str28590 = private unnamed_addr constant [5 x i8] c"wday\00", align 1
@.str29591 = private unnamed_addr constant [5 x i8] c"yday\00", align 1
@checkoption.options = internal constant [6 x i8*] [i8* getelementptr inbounds ([38 x i8]* @.str30592, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8]* @.str31593, i32 0, i32 0), i8* getelementptr inbounds ([2 x i8]* @.str32594, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8]* @.str33595, i32 0, i32 0), i8* getelementptr inbounds ([2 x i8]* @.str34596, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8]* @.str35597, i32 0, i32 0)], align 16
@.str30592 = private unnamed_addr constant [38 x i8] c"aAbBcCdDeFgGhHIjmMnprRStTuUVwWxXyYzZ%\00", align 1
@.str31593 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str32594 = private unnamed_addr constant [2 x i8] c"E\00", align 1
@.str33595 = private unnamed_addr constant [7 x i8] c"cCxXyY\00", align 1
@.str34596 = private unnamed_addr constant [2 x i8] c"O\00", align 1
@.str35597 = private unnamed_addr constant [14 x i8] c"deHImMSuUVwWy\00", align 1
@.str36598 = private unnamed_addr constant [36 x i8] c"invalid conversion specifier '%%%s'\00", align 1
@.str601 = private unnamed_addr constant [34 x i8] c"<%s> at line %d not inside a loop\00", align 1
@.str1602 = private unnamed_addr constant [44 x i8] c"no visible label '%s' for <goto> at line %d\00", align 1
@.str2603 = private unnamed_addr constant [56 x i8] c"<goto %s> at line %d jumps into the scope of local '%s'\00", align 1
@.str3604 = private unnamed_addr constant [6 x i8] c"break\00", align 1
@.str4605 = private unnamed_addr constant [13 x i8] c"labels/gotos\00", align 1
@.str5606 = private unnamed_addr constant [12 x i8] c"%s expected\00", align 1
@.str6607 = private unnamed_addr constant [13 x i8] c"syntax error\00", align 1
@.str7608 = private unnamed_addr constant [9 x i8] c"C levels\00", align 1
@priority = internal constant [15 x %struct.anon.9] [%struct.anon.9 { i8 6, i8 6 }, %struct.anon.9 { i8 6, i8 6 }, %struct.anon.9 { i8 7, i8 7 }, %struct.anon.9 { i8 7, i8 7 }, %struct.anon.9 { i8 7, i8 7 }, %struct.anon.9 { i8 10, i8 9 }, %struct.anon.9 { i8 5, i8 4 }, %struct.anon.9 { i8 3, i8 3 }, %struct.anon.9 { i8 3, i8 3 }, %struct.anon.9 { i8 3, i8 3 }, %struct.anon.9 { i8 3, i8 3 }, %struct.anon.9 { i8 3, i8 3 }, %struct.anon.9 { i8 3, i8 3 }, %struct.anon.9 { i8 2, i8 2 }, %struct.anon.9 { i8 1, i8 1 }], align 16
@.str8609 = private unnamed_addr constant [43 x i8] c"cannot use '...' outside a vararg function\00", align 1
@.str9610 = private unnamed_addr constant [5 x i8] c"self\00", align 1
@.str10611 = private unnamed_addr constant [25 x i8] c"<name> or '...' expected\00", align 1
@.str11612 = private unnamed_addr constant [16 x i8] c"local variables\00", align 1
@.str12613 = private unnamed_addr constant [10 x i8] c"functions\00", align 1
@.str13614 = private unnamed_addr constant [23 x i8] c"items in a constructor\00", align 1
@.str14615 = private unnamed_addr constant [14 x i8] c"main function\00", align 1
@.str15616 = private unnamed_addr constant [20 x i8] c"function at line %d\00", align 1
@.str16617 = private unnamed_addr constant [32 x i8] c"too many %s (limit is %d) in %s\00", align 1
@.str17618 = private unnamed_addr constant [28 x i8] c"function arguments expected\00", align 1
@.str18619 = private unnamed_addr constant [18 x i8] c"unexpected symbol\00", align 1
@.str19620 = private unnamed_addr constant [38 x i8] c"label '%s' already defined on line %d\00", align 1
@.str20621 = private unnamed_addr constant [21 x i8] c"'=' or 'in' expected\00", align 1
@.str21622 = private unnamed_addr constant [16 x i8] c"(for generator)\00", align 1
@.str22623 = private unnamed_addr constant [12 x i8] c"(for state)\00", align 1
@.str23624 = private unnamed_addr constant [14 x i8] c"(for control)\00", align 1
@.str24625 = private unnamed_addr constant [12 x i8] c"(for index)\00", align 1
@.str25626 = private unnamed_addr constant [12 x i8] c"(for limit)\00", align 1
@.str26627 = private unnamed_addr constant [11 x i8] c"(for step)\00", align 1
@.str27628 = private unnamed_addr constant [37 x i8] c"%s expected (to close %s at line %d)\00", align 1
@.str28629 = private unnamed_addr constant [9 x i8] c"upvalues\00", align 1
@.str632 = private unnamed_addr constant [18 x i8] c"not enough memory\00", align 1
@strlib = internal constant [15 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8]* @.str2662, i32 0, i32 0), i32 (%struct.lua_State*)* @str_byte }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8]* @.str3663, i32 0, i32 0), i32 (%struct.lua_State*)* @str_char }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8]* @.str4664, i32 0, i32 0), i32 (%struct.lua_State*)* @str_dump }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8]* @.str5665, i32 0, i32 0), i32 (%struct.lua_State*)* @str_find }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8]* @.str6666, i32 0, i32 0), i32 (%struct.lua_State*)* @str_format }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8]* @.str7667, i32 0, i32 0), i32 (%struct.lua_State*)* @gmatch }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8]* @.str8668, i32 0, i32 0), i32 (%struct.lua_State*)* @str_gsub }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8]* @.str9669, i32 0, i32 0), i32 (%struct.lua_State*)* @str_len }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8]* @.str10670, i32 0, i32 0), i32 (%struct.lua_State*)* @str_lower }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8]* @.str11671, i32 0, i32 0), i32 (%struct.lua_State*)* @str_match }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8]* @.str12672, i32 0, i32 0), i32 (%struct.lua_State*)* @str_rep }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8]* @.str13673, i32 0, i32 0), i32 (%struct.lua_State*)* @str_reverse }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8]* @.str14674, i32 0, i32 0), i32 (%struct.lua_State*)* @str_sub }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8]* @.str15675, i32 0, i32 0), i32 (%struct.lua_State*)* @str_upper }, %struct.luaL_Reg zeroinitializer], align 16
@.str660 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str1661 = private unnamed_addr constant [8 x i8] c"__index\00", align 1
@.str2662 = private unnamed_addr constant [5 x i8] c"byte\00", align 1
@.str3663 = private unnamed_addr constant [5 x i8] c"char\00", align 1
@.str4664 = private unnamed_addr constant [5 x i8] c"dump\00", align 1
@.str5665 = private unnamed_addr constant [5 x i8] c"find\00", align 1
@.str6666 = private unnamed_addr constant [7 x i8] c"format\00", align 1
@.str7667 = private unnamed_addr constant [7 x i8] c"gmatch\00", align 1
@.str8668 = private unnamed_addr constant [5 x i8] c"gsub\00", align 1
@.str9669 = private unnamed_addr constant [4 x i8] c"len\00", align 1
@.str10670 = private unnamed_addr constant [6 x i8] c"lower\00", align 1
@.str11671 = private unnamed_addr constant [6 x i8] c"match\00", align 1
@.str12672 = private unnamed_addr constant [4 x i8] c"rep\00", align 1
@.str13673 = private unnamed_addr constant [8 x i8] c"reverse\00", align 1
@.str14674 = private unnamed_addr constant [4 x i8] c"sub\00", align 1
@.str15675 = private unnamed_addr constant [6 x i8] c"upper\00", align 1
@.str16676 = private unnamed_addr constant [27 x i8] c"resulting string too large\00", align 1
@.str17677 = private unnamed_addr constant [18 x i8] c"too many captures\00", align 1
@.str18678 = private unnamed_addr constant [22 x i8] c"invalid capture index\00", align 1
@.str19679 = private unnamed_addr constant [19 x i8] c"unfinished capture\00", align 1
@.str20680 = private unnamed_addr constant [20 x i8] c"pattern too complex\00", align 1
@.str21681 = private unnamed_addr constant [35 x i8] c"missing '[' after '%%f' in pattern\00", align 1
@.str22682 = private unnamed_addr constant [27 x i8] c"invalid capture index %%%d\00", align 1
@.str23683 = private unnamed_addr constant [35 x i8] c"malformed pattern (ends with '%%')\00", align 1
@.str24684 = private unnamed_addr constant [32 x i8] c"malformed pattern (missing ']')\00", align 1
@.str25685 = private unnamed_addr constant [47 x i8] c"malformed pattern (missing arguments to '%%b')\00", align 1
@.str26686 = private unnamed_addr constant [24 x i8] c"invalid pattern capture\00", align 1
@.str27687 = private unnamed_addr constant [11 x i8] c"^$*+?.([%-\00", align 1
@.str28688 = private unnamed_addr constant [31 x i8] c"string/function/table expected\00", align 1
@.str29689 = private unnamed_addr constant [33 x i8] c"invalid replacement value (a %s)\00", align 1
@.str30690 = private unnamed_addr constant [42 x i8] c"invalid use of '%c' in replacement string\00", align 1
@.str31691 = private unnamed_addr constant [9 x i8] c"no value\00", align 1
@.str32692 = private unnamed_addr constant [29 x i8] c"not a number in proper range\00", align 1
@.str33693 = private unnamed_addr constant [3 x i8] c"ll\00", align 1
@.str34694 = private unnamed_addr constant [42 x i8] c"not a non-negative number in proper range\00", align 1
@.str35695 = private unnamed_addr constant [34 x i8] c"invalid option '%%%c' to 'format'\00", align 1
@.str36696 = private unnamed_addr constant [4 x i8] c"\5C%d\00", align 1
@.str37697 = private unnamed_addr constant [6 x i8] c"\5C%03d\00", align 1
@.str38698 = private unnamed_addr constant [6 x i8] c"-+ #0\00", align 1
@.str39699 = private unnamed_addr constant [32 x i8] c"invalid format (repeated flags)\00", align 1
@.str40700 = private unnamed_addr constant [45 x i8] c"invalid format (width or precision too long)\00", align 1
@.str41701 = private unnamed_addr constant [30 x i8] c"unable to dump given function\00", align 1
@.str42702 = private unnamed_addr constant [19 x i8] c"value out of range\00", align 1
@.str43703 = private unnamed_addr constant [22 x i8] c"string slice too long\00", align 1
@.str706 = private unnamed_addr constant [19 x i8] c"table index is nil\00", align 1
@.str1707 = private unnamed_addr constant [19 x i8] c"table index is NaN\00", align 1
@dummynode_ = internal constant { { %union.Value, i32, [4 x i8] }, %union.TKey } { { %union.Value, i32, [4 x i8] } { %union.Value zeroinitializer, i32 0, [4 x i8] undef }, %union.TKey zeroinitializer }, align 8
@.str2708 = private unnamed_addr constant [15 x i8] c"table overflow\00", align 1
@.str3709 = private unnamed_addr constant [22 x i8] c"invalid key to 'next'\00", align 1
@tab_funcs = internal constant [7 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8]* @.str728, i32 0, i32 0), i32 (%struct.lua_State*)* @tconcat }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8]* @.str1729, i32 0, i32 0), i32 (%struct.lua_State*)* @tinsert }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8]* @.str2730, i32 0, i32 0), i32 (%struct.lua_State*)* @pack }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8]* @.str3731, i32 0, i32 0), i32 (%struct.lua_State*)* @unpack }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8]* @.str4732, i32 0, i32 0), i32 (%struct.lua_State*)* @tremove }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8]* @.str5733, i32 0, i32 0), i32 (%struct.lua_State*)* @sort }, %struct.luaL_Reg zeroinitializer], align 16
@.str728 = private unnamed_addr constant [7 x i8] c"concat\00", align 1
@.str1729 = private unnamed_addr constant [7 x i8] c"insert\00", align 1
@.str2730 = private unnamed_addr constant [5 x i8] c"pack\00", align 1
@.str3731 = private unnamed_addr constant [7 x i8] c"unpack\00", align 1
@.str4732 = private unnamed_addr constant [7 x i8] c"remove\00", align 1
@.str5733 = private unnamed_addr constant [5 x i8] c"sort\00", align 1
@.str6734 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str7735 = private unnamed_addr constant [35 x i8] c"invalid order function for sorting\00", align 1
@.str8736 = private unnamed_addr constant [23 x i8] c"position out of bounds\00", align 1
@.str9737 = private unnamed_addr constant [27 x i8] c"too many results to unpack\00", align 1
@.str10738 = private unnamed_addr constant [2 x i8] c"n\00", align 1
@.str11739 = private unnamed_addr constant [38 x i8] c"wrong number of arguments to 'insert'\00", align 1
@.str12740 = private unnamed_addr constant [53 x i8] c"invalid value (%s) at index %d in table for 'concat'\00", align 1
@.str743 = private unnamed_addr constant [9 x i8] c"no value\00", align 1
@.str1744 = private unnamed_addr constant [4 x i8] c"nil\00", align 1
@.str2745 = private unnamed_addr constant [8 x i8] c"boolean\00", align 1
@udatatypename = internal constant [9 x i8] c"userdata\00", align 1
@.str3746 = private unnamed_addr constant [7 x i8] c"number\00", align 1
@.str4747 = private unnamed_addr constant [7 x i8] c"string\00", align 1
@.str5748 = private unnamed_addr constant [6 x i8] c"table\00", align 1
@.str6749 = private unnamed_addr constant [9 x i8] c"function\00", align 1
@.str7750 = private unnamed_addr constant [7 x i8] c"thread\00", align 1
@.str8751 = private unnamed_addr constant [6 x i8] c"proto\00", align 1
@.str9752 = private unnamed_addr constant [6 x i8] c"upval\00", align 1
@luaT_typenames_ = hidden constant [12 x i8*] [i8* getelementptr inbounds ([9 x i8]* @.str743, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8]* @.str1744, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8]* @.str2745, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8]* @udatatypename, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8]* @.str3746, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8]* @.str4747, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8]* @.str5748, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8]* @.str6749, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8]* @udatatypename, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8]* @.str7750, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8]* @.str8751, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8]* @.str9752, i32 0, i32 0)], align 16
@luaT_init.luaT_eventname = internal constant [17 x i8*] [i8* getelementptr inbounds ([8 x i8]* @.str10755, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8]* @.str11756, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8]* @.str12757, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8]* @.str13758, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8]* @.str14759, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8]* @.str15760, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8]* @.str16761, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8]* @.str17762, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8]* @.str18763, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8]* @.str19764, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8]* @.str20765, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8]* @.str21766, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8]* @.str22767, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8]* @.str23768, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8]* @.str24769, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8]* @.str25770, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8]* @.str26771, i32 0, i32 0)], align 16
@.str10755 = private unnamed_addr constant [8 x i8] c"__index\00", align 1
@.str11756 = private unnamed_addr constant [11 x i8] c"__newindex\00", align 1
@.str12757 = private unnamed_addr constant [5 x i8] c"__gc\00", align 1
@.str13758 = private unnamed_addr constant [7 x i8] c"__mode\00", align 1
@.str14759 = private unnamed_addr constant [6 x i8] c"__len\00", align 1
@.str15760 = private unnamed_addr constant [5 x i8] c"__eq\00", align 1
@.str16761 = private unnamed_addr constant [6 x i8] c"__add\00", align 1
@.str17762 = private unnamed_addr constant [6 x i8] c"__sub\00", align 1
@.str18763 = private unnamed_addr constant [6 x i8] c"__mul\00", align 1
@.str19764 = private unnamed_addr constant [6 x i8] c"__div\00", align 1
@.str20765 = private unnamed_addr constant [6 x i8] c"__mod\00", align 1
@.str21766 = private unnamed_addr constant [6 x i8] c"__pow\00", align 1
@.str22767 = private unnamed_addr constant [6 x i8] c"__unm\00", align 1
@.str23768 = private unnamed_addr constant [5 x i8] c"__lt\00", align 1
@.str24769 = private unnamed_addr constant [5 x i8] c"__le\00", align 1
@.str25770 = private unnamed_addr constant [9 x i8] c"__concat\00", align 1
@.str26771 = private unnamed_addr constant [7 x i8] c"__call\00", align 1
@.str778 = private unnamed_addr constant [39 x i8] c"cannot create state: not enough memory\00", align 1
@.str1779 = private unnamed_addr constant [31 x i8] c"(error object is not a string)\00", align 1
@progname = internal global i8* getelementptr inbounds ([4 x i8]* @.str2781, i32 0, i32 0), align 8
@.str2781 = private unnamed_addr constant [4 x i8] c"lua\00", align 1
@.str3782 = private unnamed_addr constant [10 x i8] c"LUA_NOENV\00", align 1
@globalL = internal global %struct.lua_State* null, align 8
@.str4783 = private unnamed_addr constant [13 x i8] c"interrupted!\00", align 1
@.str5784 = private unnamed_addr constant [11 x i8] c"__tostring\00", align 1
@.str6785 = private unnamed_addr constant [19 x i8] c"(no error message)\00", align 1
@.str7786 = private unnamed_addr constant [26 x i8] c"too many results to print\00", align 1
@.str8787 = private unnamed_addr constant [6 x i8] c"print\00", align 1
@.str9788 = private unnamed_addr constant [27 x i8] c"error calling 'print' (%s)\00", align 1
@.str10789 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str11790 = private unnamed_addr constant [7 x i8] c"=stdin\00", align 1
@.str12791 = private unnamed_addr constant [6 x i8] c"<eof>\00", align 1
@.str13792 = private unnamed_addr constant [10 x i8] c"return %s\00", align 1
@.str14793 = private unnamed_addr constant [8 x i8] c"_PROMPT\00", align 1
@.str15794 = private unnamed_addr constant [9 x i8] c"_PROMPT2\00", align 1
@.str16795 = private unnamed_addr constant [3 x i8] c"> \00", align 1
@.str17796 = private unnamed_addr constant [4 x i8] c">> \00", align 1
@.str18797 = private unnamed_addr constant [4 x i8] c"arg\00", align 1
@.str19798 = private unnamed_addr constant [2 x i8] c"-\00", align 1
@.str20799 = private unnamed_addr constant [3 x i8] c"--\00", align 1
@.str21800 = private unnamed_addr constant [29 x i8] c"too many arguments to script\00", align 1
@.str22801 = private unnamed_addr constant [16 x i8] c"=(command line)\00", align 1
@.str23802 = private unnamed_addr constant [8 x i8] c"require\00", align 1
@.str24803 = private unnamed_addr constant [14 x i8] c"=LUA_INIT_5_2\00", align 1
@.str25804 = private unnamed_addr constant [10 x i8] c"=LUA_INIT\00", align 1
@.str26805 = private unnamed_addr constant [52 x i8] c"Lua 5.2.2  Copyright (C) 1994-2013 Lua.org, PUC-Rio\00", align 1
@.str27806 = private unnamed_addr constant [5 x i8] c"%s: \00", align 1
@.str28807 = private unnamed_addr constant [21 x i8] c"'%s' needs argument\0A\00", align 1
@.str29808 = private unnamed_addr constant [26 x i8] c"unrecognized option '%s'\0A\00", align 1
@.str30809 = private unnamed_addr constant [346 x i8] c"usage: %s [options] [script [args]]\0AAvailable options are:\0A  -e stat  execute string 'stat'\0A  -i       enter interactive mode after executing 'script'\0A  -l name  require library 'name'\0A  -v       show version information\0A  -E       ignore environment variables\0A  --       stop handling options\0A  -        stop handling options and execute stdin\0A\00", align 1
@.str31810 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
@.str811 = private unnamed_addr constant [5 x i8] c"\1BLua\00", align 1
@.str1812 = private unnamed_addr constant [14 x i8] c"binary string\00", align 1
@.str2813 = private unnamed_addr constant [2 x i8] c"5\00", align 1
@.str3814 = private unnamed_addr constant [2 x i8] c"2\00", align 1
@.str4815 = private unnamed_addr constant [7 x i8] c"\19\93\0D\0A\1A\0A\00", align 1
@.str5816 = private unnamed_addr constant [10 x i8] c"truncated\00", align 1
@.str6817 = private unnamed_addr constant [25 x i8] c"%s: %s precompiled chunk\00", align 1
@.str7818 = private unnamed_addr constant [10 x i8] c"corrupted\00", align 1
@.str8819 = private unnamed_addr constant [6 x i8] c"not a\00", align 1
@.str9820 = private unnamed_addr constant [20 x i8] c"version mismatch in\00", align 1
@.str10821 = private unnamed_addr constant [13 x i8] c"incompatible\00", align 1
@.str826 = private unnamed_addr constant [6 x i8] c"%.14g\00", align 1
@.str1827 = private unnamed_addr constant [6 x i8] c"index\00", align 1
@.str2828 = private unnamed_addr constant [17 x i8] c"loop in gettable\00", align 1
@.str3829 = private unnamed_addr constant [17 x i8] c"loop in settable\00", align 1
@.str4830 = private unnamed_addr constant [23 x i8] c"string length overflow\00", align 1
@.str5831 = private unnamed_addr constant [14 x i8] c"get length of\00", align 1
@.str6832 = private unnamed_addr constant [37 x i8] c"'for' initial value must be a number\00", align 1
@.str7833 = private unnamed_addr constant [29 x i8] c"'for' limit must be a number\00", align 1
@.str8834 = private unnamed_addr constant [28 x i8] c"'for' step must be a number\00", align 1

; Function Attrs: nounwind uwtable
define i32 @lua_checkstack(%struct.lua_State* %L, i32 %size) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %size.addr = alloca i32, align 4
  %res = alloca i32, align 4
  %ci = alloca %struct.CallInfo*, align 8
  %inuse = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %size, i32* %size.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %ci1 = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 6
  %1 = load %struct.CallInfo** %ci1, align 8
  store %struct.CallInfo* %1, %struct.CallInfo** %ci, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %stack_last = getelementptr inbounds %struct.lua_State* %2, i32 0, i32 8
  %3 = load %struct.lua_TValue** %stack_last, align 8
  %4 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %4, i32 0, i32 4
  %5 = load %struct.lua_TValue** %top, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.lua_TValue* %3 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.lua_TValue* %5 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 16
  %6 = load i32* %size.addr, align 4
  %conv = sext i32 %6 to i64
  %cmp = icmp sgt i64 %sub.ptr.div, %conv
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 1, i32* %res, align 4
  br label %if.end15

if.else:                                          ; preds = %entry
  %7 = load %struct.lua_State** %L.addr, align 8
  %top3 = getelementptr inbounds %struct.lua_State* %7, i32 0, i32 4
  %8 = load %struct.lua_TValue** %top3, align 8
  %9 = load %struct.lua_State** %L.addr, align 8
  %stack = getelementptr inbounds %struct.lua_State* %9, i32 0, i32 9
  %10 = load %struct.lua_TValue** %stack, align 8
  %sub.ptr.lhs.cast4 = ptrtoint %struct.lua_TValue* %8 to i64
  %sub.ptr.rhs.cast5 = ptrtoint %struct.lua_TValue* %10 to i64
  %sub.ptr.sub6 = sub i64 %sub.ptr.lhs.cast4, %sub.ptr.rhs.cast5
  %sub.ptr.div7 = sdiv exact i64 %sub.ptr.sub6, 16
  %conv8 = trunc i64 %sub.ptr.div7 to i32
  %add = add nsw i32 %conv8, 5
  store i32 %add, i32* %inuse, align 4
  %11 = load i32* %inuse, align 4
  %12 = load i32* %size.addr, align 4
  %sub = sub nsw i32 1000000, %12
  %cmp9 = icmp sgt i32 %11, %sub
  br i1 %cmp9, label %if.then11, label %if.else12

if.then11:                                        ; preds = %if.else
  store i32 0, i32* %res, align 4
  br label %if.end

if.else12:                                        ; preds = %if.else
  %13 = load %struct.lua_State** %L.addr, align 8
  %14 = bitcast i32* %size.addr to i8*
  %call = call i32 @luaD_rawrunprotected(%struct.lua_State* %13, void (%struct.lua_State*, i8*)* @growstack, i8* %14)
  %cmp13 = icmp eq i32 %call, 0
  %conv14 = zext i1 %cmp13 to i32
  store i32 %conv14, i32* %res, align 4
  br label %if.end

if.end:                                           ; preds = %if.else12, %if.then11
  br label %if.end15

if.end15:                                         ; preds = %if.end, %if.then
  %15 = load i32* %res, align 4
  %tobool = icmp ne i32 %15, 0
  br i1 %tobool, label %land.lhs.true, label %if.end25

land.lhs.true:                                    ; preds = %if.end15
  %16 = load %struct.CallInfo** %ci, align 8
  %top16 = getelementptr inbounds %struct.CallInfo* %16, i32 0, i32 1
  %17 = load %struct.lua_TValue** %top16, align 8
  %18 = load %struct.lua_State** %L.addr, align 8
  %top17 = getelementptr inbounds %struct.lua_State* %18, i32 0, i32 4
  %19 = load %struct.lua_TValue** %top17, align 8
  %20 = load i32* %size.addr, align 4
  %idx.ext = sext i32 %20 to i64
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %19, i64 %idx.ext
  %cmp18 = icmp ult %struct.lua_TValue* %17, %add.ptr
  br i1 %cmp18, label %if.then20, label %if.end25

if.then20:                                        ; preds = %land.lhs.true
  %21 = load %struct.lua_State** %L.addr, align 8
  %top21 = getelementptr inbounds %struct.lua_State* %21, i32 0, i32 4
  %22 = load %struct.lua_TValue** %top21, align 8
  %23 = load i32* %size.addr, align 4
  %idx.ext22 = sext i32 %23 to i64
  %add.ptr23 = getelementptr inbounds %struct.lua_TValue* %22, i64 %idx.ext22
  %24 = load %struct.CallInfo** %ci, align 8
  %top24 = getelementptr inbounds %struct.CallInfo* %24, i32 0, i32 1
  store %struct.lua_TValue* %add.ptr23, %struct.lua_TValue** %top24, align 8
  br label %if.end25

if.end25:                                         ; preds = %if.then20, %land.lhs.true, %if.end15
  %25 = load i32* %res, align 4
  ret i32 %25
}

; Function Attrs: nounwind uwtable
define internal void @growstack(%struct.lua_State* %L, i8* %ud) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %ud.addr = alloca i8*, align 8
  %size = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %ud, i8** %ud.addr, align 8
  %0 = load i8** %ud.addr, align 8
  %1 = bitcast i8* %0 to i32*
  %2 = load i32* %1, align 4
  store i32 %2, i32* %size, align 4
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load i32* %size, align 4
  call void @luaD_growstack(%struct.lua_State* %3, i32 %4)
  ret void
}

; Function Attrs: nounwind uwtable
define void @lua_xmove(%struct.lua_State* %from, %struct.lua_State* %to, i32 %n) #0 {
entry:
  %from.addr = alloca %struct.lua_State*, align 8
  %to.addr = alloca %struct.lua_State*, align 8
  %n.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %io2 = alloca %struct.lua_TValue*, align 8
  %io1 = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %from, %struct.lua_State** %from.addr, align 8
  store %struct.lua_State* %to, %struct.lua_State** %to.addr, align 8
  store i32 %n, i32* %n.addr, align 4
  %0 = load %struct.lua_State** %from.addr, align 8
  %1 = load %struct.lua_State** %to.addr, align 8
  %cmp = icmp eq %struct.lua_State* %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %for.end

if.end:                                           ; preds = %entry
  %2 = load i32* %n.addr, align 4
  %3 = load %struct.lua_State** %from.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %3, i32 0, i32 4
  %4 = load %struct.lua_TValue** %top, align 8
  %idx.ext = sext i32 %2 to i64
  %idx.neg = sub i64 0, %idx.ext
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %4, i64 %idx.neg
  store %struct.lua_TValue* %add.ptr, %struct.lua_TValue** %top, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %5 = load i32* %i, align 4
  %6 = load i32* %n.addr, align 4
  %cmp1 = icmp slt i32 %5, %6
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load %struct.lua_State** %from.addr, align 8
  %top2 = getelementptr inbounds %struct.lua_State* %7, i32 0, i32 4
  %8 = load %struct.lua_TValue** %top2, align 8
  %9 = load i32* %i, align 4
  %idx.ext3 = sext i32 %9 to i64
  %add.ptr4 = getelementptr inbounds %struct.lua_TValue* %8, i64 %idx.ext3
  store %struct.lua_TValue* %add.ptr4, %struct.lua_TValue** %io2, align 8
  %10 = load %struct.lua_State** %to.addr, align 8
  %top5 = getelementptr inbounds %struct.lua_State* %10, i32 0, i32 4
  %11 = load %struct.lua_TValue** %top5, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %11, i32 1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %top5, align 8
  store %struct.lua_TValue* %11, %struct.lua_TValue** %io1, align 8
  %12 = load %struct.lua_TValue** %io1, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %12, i32 0, i32 0
  %13 = load %struct.lua_TValue** %io2, align 8
  %value_6 = getelementptr inbounds %struct.lua_TValue* %13, i32 0, i32 0
  %14 = bitcast %union.Value* %value_ to i8*
  %15 = bitcast %union.Value* %value_6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %14, i8* %15, i64 8, i32 8, i1 false)
  %16 = load %struct.lua_TValue** %io2, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %16, i32 0, i32 1
  %17 = load i32* %tt_, align 4
  %18 = load %struct.lua_TValue** %io1, align 8
  %tt_7 = getelementptr inbounds %struct.lua_TValue* %18, i32 0, i32 1
  store i32 %17, i32* %tt_7, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %19 = load i32* %i, align 4
  %inc = add nsw i32 %19, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond, %if.then
  ret void
}

; Function Attrs: nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture, i8* nocapture readonly, i64, i32, i1) #1

; Function Attrs: nounwind uwtable
define i32 (%struct.lua_State*)* @lua_atpanic(%struct.lua_State* %L, i32 (%struct.lua_State*)* %panicf) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %panicf.addr = alloca i32 (%struct.lua_State*)*, align 8
  %old = alloca i32 (%struct.lua_State*)*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 (%struct.lua_State*)* %panicf, i32 (%struct.lua_State*)** %panicf.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 5
  %1 = load %struct.global_State** %l_G, align 8
  %panic = getelementptr inbounds %struct.global_State* %1, i32 0, i32 29
  %2 = load i32 (%struct.lua_State*)** %panic, align 8
  store i32 (%struct.lua_State*)* %2, i32 (%struct.lua_State*)** %old, align 8
  %3 = load i32 (%struct.lua_State*)** %panicf.addr, align 8
  %4 = load %struct.lua_State** %L.addr, align 8
  %l_G1 = getelementptr inbounds %struct.lua_State* %4, i32 0, i32 5
  %5 = load %struct.global_State** %l_G1, align 8
  %panic2 = getelementptr inbounds %struct.global_State* %5, i32 0, i32 29
  store i32 (%struct.lua_State*)* %3, i32 (%struct.lua_State*)** %panic2, align 8
  %6 = load i32 (%struct.lua_State*)** %old, align 8
  ret i32 (%struct.lua_State*)* %6
}

; Function Attrs: nounwind uwtable
define double* @lua_version(%struct.lua_State* %L) #0 {
entry:
  %retval = alloca double*, align 8
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %cmp = icmp eq %struct.lua_State* %0, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store double* @lua_version.version, double** %retval
  br label %return

if.else:                                          ; preds = %entry
  %1 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %1, i32 0, i32 5
  %2 = load %struct.global_State** %l_G, align 8
  %version = getelementptr inbounds %struct.global_State* %2, i32 0, i32 31
  %3 = load double** %version, align 8
  store double* %3, double** %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %4 = load double** %retval
  ret double* %4
}

; Function Attrs: nounwind uwtable
define i32 @lua_absindex(%struct.lua_State* %L, i32 %idx) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %idx.addr = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  %0 = load i32* %idx.addr, align 4
  %cmp = icmp sgt i32 %0, 0
  br i1 %cmp, label %cond.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32* %idx.addr, align 4
  %cmp1 = icmp sle i32 %1, -1001000
  br i1 %cmp1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %lor.lhs.false, %entry
  %2 = load i32* %idx.addr, align 4
  br label %cond.end

cond.false:                                       ; preds = %lor.lhs.false
  %3 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %3, i32 0, i32 4
  %4 = load %struct.lua_TValue** %top, align 8
  %5 = load %struct.lua_State** %L.addr, align 8
  %ci = getelementptr inbounds %struct.lua_State* %5, i32 0, i32 6
  %6 = load %struct.CallInfo** %ci, align 8
  %func = getelementptr inbounds %struct.CallInfo* %6, i32 0, i32 0
  %7 = load %struct.lua_TValue** %func, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.lua_TValue* %4 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.lua_TValue* %7 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 16
  %8 = load i32* %idx.addr, align 4
  %conv = sext i32 %8 to i64
  %add = add nsw i64 %sub.ptr.div, %conv
  %conv2 = trunc i64 %add to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %2, %cond.true ], [ %conv2, %cond.false ]
  ret i32 %cond
}

; Function Attrs: nounwind uwtable
define i32 @lua_gettop(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 4
  %1 = load %struct.lua_TValue** %top, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %ci = getelementptr inbounds %struct.lua_State* %2, i32 0, i32 6
  %3 = load %struct.CallInfo** %ci, align 8
  %func = getelementptr inbounds %struct.CallInfo* %3, i32 0, i32 0
  %4 = load %struct.lua_TValue** %func, align 8
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %4, i64 1
  %sub.ptr.lhs.cast = ptrtoint %struct.lua_TValue* %1 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.lua_TValue* %add.ptr to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 16
  %conv = trunc i64 %sub.ptr.div to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define void @lua_settop(%struct.lua_State* %L, i32 %idx) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %idx.addr = alloca i32, align 4
  %func = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %ci = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 6
  %1 = load %struct.CallInfo** %ci, align 8
  %func1 = getelementptr inbounds %struct.CallInfo* %1, i32 0, i32 0
  %2 = load %struct.lua_TValue** %func1, align 8
  store %struct.lua_TValue* %2, %struct.lua_TValue** %func, align 8
  %3 = load i32* %idx.addr, align 4
  %cmp = icmp sge i32 %3, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then
  %4 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %4, i32 0, i32 4
  %5 = load %struct.lua_TValue** %top, align 8
  %6 = load %struct.lua_TValue** %func, align 8
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %6, i64 1
  %7 = load i32* %idx.addr, align 4
  %idx.ext = sext i32 %7 to i64
  %add.ptr2 = getelementptr inbounds %struct.lua_TValue* %add.ptr, i64 %idx.ext
  %cmp3 = icmp ult %struct.lua_TValue* %5, %add.ptr2
  br i1 %cmp3, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %8 = load %struct.lua_State** %L.addr, align 8
  %top4 = getelementptr inbounds %struct.lua_State* %8, i32 0, i32 4
  %9 = load %struct.lua_TValue** %top4, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %9, i32 1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %top4, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %9, i32 0, i32 1
  store i32 0, i32* %tt_, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %10 = load %struct.lua_TValue** %func, align 8
  %add.ptr5 = getelementptr inbounds %struct.lua_TValue* %10, i64 1
  %11 = load i32* %idx.addr, align 4
  %idx.ext6 = sext i32 %11 to i64
  %add.ptr7 = getelementptr inbounds %struct.lua_TValue* %add.ptr5, i64 %idx.ext6
  %12 = load %struct.lua_State** %L.addr, align 8
  %top8 = getelementptr inbounds %struct.lua_State* %12, i32 0, i32 4
  store %struct.lua_TValue* %add.ptr7, %struct.lua_TValue** %top8, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %13 = load i32* %idx.addr, align 4
  %add = add nsw i32 %13, 1
  %14 = load %struct.lua_State** %L.addr, align 8
  %top9 = getelementptr inbounds %struct.lua_State* %14, i32 0, i32 4
  %15 = load %struct.lua_TValue** %top9, align 8
  %idx.ext10 = sext i32 %add to i64
  %add.ptr11 = getelementptr inbounds %struct.lua_TValue* %15, i64 %idx.ext10
  store %struct.lua_TValue* %add.ptr11, %struct.lua_TValue** %top9, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %while.end
  ret void
}

; Function Attrs: nounwind uwtable
define void @lua_remove(%struct.lua_State* %L, i32 %idx) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %idx.addr = alloca i32, align 4
  %p = alloca %struct.lua_TValue*, align 8
  %io2 = alloca %struct.lua_TValue*, align 8
  %io1 = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %idx.addr, align 4
  %call = call %struct.lua_TValue* @index2addr(%struct.lua_State* %0, i32 %1)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %p, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %2 = load %struct.lua_TValue** %p, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %2, i32 1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %p, align 8
  %3 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %3, i32 0, i32 4
  %4 = load %struct.lua_TValue** %top, align 8
  %cmp = icmp ult %struct.lua_TValue* %incdec.ptr, %4
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %5 = load %struct.lua_TValue** %p, align 8
  store %struct.lua_TValue* %5, %struct.lua_TValue** %io2, align 8
  %6 = load %struct.lua_TValue** %p, align 8
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %6, i64 -1
  store %struct.lua_TValue* %add.ptr, %struct.lua_TValue** %io1, align 8
  %7 = load %struct.lua_TValue** %io1, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %7, i32 0, i32 0
  %8 = load %struct.lua_TValue** %io2, align 8
  %value_1 = getelementptr inbounds %struct.lua_TValue* %8, i32 0, i32 0
  %9 = bitcast %union.Value* %value_ to i8*
  %10 = bitcast %union.Value* %value_1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %9, i8* %10, i64 8, i32 8, i1 false)
  %11 = load %struct.lua_TValue** %io2, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %11, i32 0, i32 1
  %12 = load i32* %tt_, align 4
  %13 = load %struct.lua_TValue** %io1, align 8
  %tt_2 = getelementptr inbounds %struct.lua_TValue* %13, i32 0, i32 1
  store i32 %12, i32* %tt_2, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %14 = load %struct.lua_State** %L.addr, align 8
  %top3 = getelementptr inbounds %struct.lua_State* %14, i32 0, i32 4
  %15 = load %struct.lua_TValue** %top3, align 8
  %incdec.ptr4 = getelementptr inbounds %struct.lua_TValue* %15, i32 -1
  store %struct.lua_TValue* %incdec.ptr4, %struct.lua_TValue** %top3, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal %struct.lua_TValue* @index2addr(%struct.lua_State* %L, i32 %idx) #0 {
entry:
  %retval = alloca %struct.lua_TValue*, align 8
  %L.addr = alloca %struct.lua_State*, align 8
  %idx.addr = alloca i32, align 4
  %ci = alloca %struct.CallInfo*, align 8
  %o = alloca %struct.lua_TValue*, align 8
  %func18 = alloca %struct.CClosure*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %ci1 = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 6
  %1 = load %struct.CallInfo** %ci1, align 8
  store %struct.CallInfo* %1, %struct.CallInfo** %ci, align 8
  %2 = load i32* %idx.addr, align 4
  %cmp = icmp sgt i32 %2, 0
  br i1 %cmp, label %if.then, label %if.else4

if.then:                                          ; preds = %entry
  %3 = load %struct.CallInfo** %ci, align 8
  %func = getelementptr inbounds %struct.CallInfo* %3, i32 0, i32 0
  %4 = load %struct.lua_TValue** %func, align 8
  %5 = load i32* %idx.addr, align 4
  %idx.ext = sext i32 %5 to i64
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %4, i64 %idx.ext
  store %struct.lua_TValue* %add.ptr, %struct.lua_TValue** %o, align 8
  %6 = load %struct.lua_TValue** %o, align 8
  %7 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %7, i32 0, i32 4
  %8 = load %struct.lua_TValue** %top, align 8
  %cmp2 = icmp uge %struct.lua_TValue* %6, %8
  br i1 %cmp2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.then
  store %struct.lua_TValue* bitcast ({ %union.Value.281, i32, [4 x i8] }* @luaO_nilobject_ to %struct.lua_TValue*), %struct.lua_TValue** %retval
  br label %return

if.else:                                          ; preds = %if.then
  %9 = load %struct.lua_TValue** %o, align 8
  store %struct.lua_TValue* %9, %struct.lua_TValue** %retval
  br label %return

if.else4:                                         ; preds = %entry
  %10 = load i32* %idx.addr, align 4
  %cmp5 = icmp sle i32 %10, -1001000
  br i1 %cmp5, label %if.else10, label %if.then6

if.then6:                                         ; preds = %if.else4
  %11 = load %struct.lua_State** %L.addr, align 8
  %top7 = getelementptr inbounds %struct.lua_State* %11, i32 0, i32 4
  %12 = load %struct.lua_TValue** %top7, align 8
  %13 = load i32* %idx.addr, align 4
  %idx.ext8 = sext i32 %13 to i64
  %add.ptr9 = getelementptr inbounds %struct.lua_TValue* %12, i64 %idx.ext8
  store %struct.lua_TValue* %add.ptr9, %struct.lua_TValue** %retval
  br label %return

if.else10:                                        ; preds = %if.else4
  %14 = load i32* %idx.addr, align 4
  %cmp11 = icmp eq i32 %14, -1001000
  br i1 %cmp11, label %if.then12, label %if.else13

if.then12:                                        ; preds = %if.else10
  %15 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %15, i32 0, i32 5
  %16 = load %struct.global_State** %l_G, align 8
  %l_registry = getelementptr inbounds %struct.global_State* %16, i32 0, i32 7
  store %struct.lua_TValue* %l_registry, %struct.lua_TValue** %retval
  br label %return

if.else13:                                        ; preds = %if.else10
  %17 = load i32* %idx.addr, align 4
  %sub = sub nsw i32 -1001000, %17
  store i32 %sub, i32* %idx.addr, align 4
  %18 = load %struct.CallInfo** %ci, align 8
  %func14 = getelementptr inbounds %struct.CallInfo* %18, i32 0, i32 0
  %19 = load %struct.lua_TValue** %func14, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %19, i32 0, i32 1
  %20 = load i32* %tt_, align 4
  %cmp15 = icmp eq i32 %20, 22
  br i1 %cmp15, label %if.then16, label %if.else17

if.then16:                                        ; preds = %if.else13
  store %struct.lua_TValue* bitcast ({ %union.Value.281, i32, [4 x i8] }* @luaO_nilobject_ to %struct.lua_TValue*), %struct.lua_TValue** %retval
  br label %return

if.else17:                                        ; preds = %if.else13
  %21 = load %struct.CallInfo** %ci, align 8
  %func19 = getelementptr inbounds %struct.CallInfo* %21, i32 0, i32 0
  %22 = load %struct.lua_TValue** %func19, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %22, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %23 = load %union.GCObject** %gc, align 8
  %cl = bitcast %union.GCObject* %23 to %union.Closure*
  %c = bitcast %union.Closure* %cl to %struct.CClosure*
  store %struct.CClosure* %c, %struct.CClosure** %func18, align 8
  %24 = load i32* %idx.addr, align 4
  %25 = load %struct.CClosure** %func18, align 8
  %nupvalues = getelementptr inbounds %struct.CClosure* %25, i32 0, i32 3
  %26 = load i8* %nupvalues, align 1
  %conv = zext i8 %26 to i32
  %cmp20 = icmp sle i32 %24, %conv
  br i1 %cmp20, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.else17
  %27 = load i32* %idx.addr, align 4
  %sub22 = sub nsw i32 %27, 1
  %idxprom = sext i32 %sub22 to i64
  %28 = load %struct.CClosure** %func18, align 8
  %upvalue = getelementptr inbounds %struct.CClosure* %28, i32 0, i32 6
  %arrayidx = getelementptr inbounds [1 x %struct.lua_TValue]* %upvalue, i32 0, i64 %idxprom
  br label %cond.end

cond.false:                                       ; preds = %if.else17
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.lua_TValue* [ %arrayidx, %cond.true ], [ bitcast ({ %union.Value.281, i32, [4 x i8] }* @luaO_nilobject_ to %struct.lua_TValue*), %cond.false ]
  store %struct.lua_TValue* %cond, %struct.lua_TValue** %retval
  br label %return

return:                                           ; preds = %cond.end, %if.then16, %if.then12, %if.then6, %if.else, %if.then3
  %29 = load %struct.lua_TValue** %retval
  ret %struct.lua_TValue* %29
}

; Function Attrs: nounwind uwtable
define void @lua_insert(%struct.lua_State* %L, i32 %idx) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %idx.addr = alloca i32, align 4
  %p = alloca %struct.lua_TValue*, align 8
  %q = alloca %struct.lua_TValue*, align 8
  %io2 = alloca %struct.lua_TValue*, align 8
  %io1 = alloca %struct.lua_TValue*, align 8
  %io23 = alloca %struct.lua_TValue*, align 8
  %io15 = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %idx.addr, align 4
  %call = call %struct.lua_TValue* @index2addr(%struct.lua_State* %0, i32 %1)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %p, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %2, i32 0, i32 4
  %3 = load %struct.lua_TValue** %top, align 8
  store %struct.lua_TValue* %3, %struct.lua_TValue** %q, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %4 = load %struct.lua_TValue** %q, align 8
  %5 = load %struct.lua_TValue** %p, align 8
  %cmp = icmp ugt %struct.lua_TValue* %4, %5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load %struct.lua_TValue** %q, align 8
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %6, i64 -1
  store %struct.lua_TValue* %add.ptr, %struct.lua_TValue** %io2, align 8
  %7 = load %struct.lua_TValue** %q, align 8
  store %struct.lua_TValue* %7, %struct.lua_TValue** %io1, align 8
  %8 = load %struct.lua_TValue** %io1, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %8, i32 0, i32 0
  %9 = load %struct.lua_TValue** %io2, align 8
  %value_1 = getelementptr inbounds %struct.lua_TValue* %9, i32 0, i32 0
  %10 = bitcast %union.Value* %value_ to i8*
  %11 = bitcast %union.Value* %value_1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %10, i8* %11, i64 8, i32 8, i1 false)
  %12 = load %struct.lua_TValue** %io2, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %12, i32 0, i32 1
  %13 = load i32* %tt_, align 4
  %14 = load %struct.lua_TValue** %io1, align 8
  %tt_2 = getelementptr inbounds %struct.lua_TValue* %14, i32 0, i32 1
  store i32 %13, i32* %tt_2, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %15 = load %struct.lua_TValue** %q, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %15, i32 -1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %q, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %16 = load %struct.lua_State** %L.addr, align 8
  %top4 = getelementptr inbounds %struct.lua_State* %16, i32 0, i32 4
  %17 = load %struct.lua_TValue** %top4, align 8
  store %struct.lua_TValue* %17, %struct.lua_TValue** %io23, align 8
  %18 = load %struct.lua_TValue** %p, align 8
  store %struct.lua_TValue* %18, %struct.lua_TValue** %io15, align 8
  %19 = load %struct.lua_TValue** %io15, align 8
  %value_6 = getelementptr inbounds %struct.lua_TValue* %19, i32 0, i32 0
  %20 = load %struct.lua_TValue** %io23, align 8
  %value_7 = getelementptr inbounds %struct.lua_TValue* %20, i32 0, i32 0
  %21 = bitcast %union.Value* %value_6 to i8*
  %22 = bitcast %union.Value* %value_7 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %21, i8* %22, i64 8, i32 8, i1 false)
  %23 = load %struct.lua_TValue** %io23, align 8
  %tt_8 = getelementptr inbounds %struct.lua_TValue* %23, i32 0, i32 1
  %24 = load i32* %tt_8, align 4
  %25 = load %struct.lua_TValue** %io15, align 8
  %tt_9 = getelementptr inbounds %struct.lua_TValue* %25, i32 0, i32 1
  store i32 %24, i32* %tt_9, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define void @lua_replace(%struct.lua_State* %L, i32 %idx) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %idx.addr = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %1, i32 0, i32 4
  %2 = load %struct.lua_TValue** %top, align 8
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %2, i64 -1
  %3 = load i32* %idx.addr, align 4
  call void @moveto(%struct.lua_State* %0, %struct.lua_TValue* %add.ptr, i32 %3)
  %4 = load %struct.lua_State** %L.addr, align 8
  %top1 = getelementptr inbounds %struct.lua_State* %4, i32 0, i32 4
  %5 = load %struct.lua_TValue** %top1, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %5, i32 -1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %top1, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @moveto(%struct.lua_State* %L, %struct.lua_TValue* %fr, i32 %idx) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %fr.addr = alloca %struct.lua_TValue*, align 8
  %idx.addr = alloca i32, align 4
  %to = alloca %struct.lua_TValue*, align 8
  %io2 = alloca %struct.lua_TValue*, align 8
  %io1 = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.lua_TValue* %fr, %struct.lua_TValue** %fr.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %idx.addr, align 4
  %call = call %struct.lua_TValue* @index2addr(%struct.lua_State* %0, i32 %1)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %to, align 8
  %2 = load %struct.lua_TValue** %fr.addr, align 8
  store %struct.lua_TValue* %2, %struct.lua_TValue** %io2, align 8
  %3 = load %struct.lua_TValue** %to, align 8
  store %struct.lua_TValue* %3, %struct.lua_TValue** %io1, align 8
  %4 = load %struct.lua_TValue** %io1, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %4, i32 0, i32 0
  %5 = load %struct.lua_TValue** %io2, align 8
  %value_1 = getelementptr inbounds %struct.lua_TValue* %5, i32 0, i32 0
  %6 = bitcast %union.Value* %value_ to i8*
  %7 = bitcast %union.Value* %value_1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %6, i8* %7, i64 8, i32 8, i1 false)
  %8 = load %struct.lua_TValue** %io2, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %8, i32 0, i32 1
  %9 = load i32* %tt_, align 4
  %10 = load %struct.lua_TValue** %io1, align 8
  %tt_2 = getelementptr inbounds %struct.lua_TValue* %10, i32 0, i32 1
  store i32 %9, i32* %tt_2, align 4
  %11 = load i32* %idx.addr, align 4
  %cmp = icmp slt i32 %11, -1001000
  br i1 %cmp, label %if.then, label %if.end24

if.then:                                          ; preds = %entry
  %12 = load %struct.lua_TValue** %fr.addr, align 8
  %tt_3 = getelementptr inbounds %struct.lua_TValue* %12, i32 0, i32 1
  %13 = load i32* %tt_3, align 4
  %and = and i32 %13, 64
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then
  %14 = load %struct.lua_TValue** %fr.addr, align 8
  %value_4 = getelementptr inbounds %struct.lua_TValue* %14, i32 0, i32 0
  %gc = bitcast %union.Value* %value_4 to %union.GCObject**
  %15 = load %union.GCObject** %gc, align 8
  %gch = bitcast %union.GCObject* %15 to %struct.GCheader*
  %marked = getelementptr inbounds %struct.GCheader* %gch, i32 0, i32 2
  %16 = load i8* %marked, align 1
  %conv = zext i8 %16 to i32
  %and5 = and i32 %conv, 3
  %tobool6 = icmp ne i32 %and5, 0
  br i1 %tobool6, label %land.lhs.true7, label %if.end

land.lhs.true7:                                   ; preds = %land.lhs.true
  %17 = load %struct.lua_State** %L.addr, align 8
  %ci = getelementptr inbounds %struct.lua_State* %17, i32 0, i32 6
  %18 = load %struct.CallInfo** %ci, align 8
  %func = getelementptr inbounds %struct.CallInfo* %18, i32 0, i32 0
  %19 = load %struct.lua_TValue** %func, align 8
  %value_8 = getelementptr inbounds %struct.lua_TValue* %19, i32 0, i32 0
  %gc9 = bitcast %union.Value* %value_8 to %union.GCObject**
  %20 = load %union.GCObject** %gc9, align 8
  %cl = bitcast %union.GCObject* %20 to %union.Closure*
  %c = bitcast %union.Closure* %cl to %struct.CClosure*
  %21 = bitcast %struct.CClosure* %c to %union.GCObject*
  %gch10 = bitcast %union.GCObject* %21 to %struct.GCheader*
  %marked11 = getelementptr inbounds %struct.GCheader* %gch10, i32 0, i32 2
  %22 = load i8* %marked11, align 1
  %conv12 = zext i8 %22 to i32
  %and13 = and i32 %conv12, 4
  %tobool14 = icmp ne i32 %and13, 0
  br i1 %tobool14, label %if.then15, label %if.end

if.then15:                                        ; preds = %land.lhs.true7
  %23 = load %struct.lua_State** %L.addr, align 8
  %24 = load %struct.lua_State** %L.addr, align 8
  %ci16 = getelementptr inbounds %struct.lua_State* %24, i32 0, i32 6
  %25 = load %struct.CallInfo** %ci16, align 8
  %func17 = getelementptr inbounds %struct.CallInfo* %25, i32 0, i32 0
  %26 = load %struct.lua_TValue** %func17, align 8
  %value_18 = getelementptr inbounds %struct.lua_TValue* %26, i32 0, i32 0
  %gc19 = bitcast %union.Value* %value_18 to %union.GCObject**
  %27 = load %union.GCObject** %gc19, align 8
  %cl20 = bitcast %union.GCObject* %27 to %union.Closure*
  %c21 = bitcast %union.Closure* %cl20 to %struct.CClosure*
  %28 = bitcast %struct.CClosure* %c21 to %union.GCObject*
  %29 = load %struct.lua_TValue** %fr.addr, align 8
  %value_22 = getelementptr inbounds %struct.lua_TValue* %29, i32 0, i32 0
  %gc23 = bitcast %union.Value* %value_22 to %union.GCObject**
  %30 = load %union.GCObject** %gc23, align 8
  call void @luaC_barrier_(%struct.lua_State* %23, %union.GCObject* %28, %union.GCObject* %30)
  br label %if.end

if.end:                                           ; preds = %if.then15, %land.lhs.true7, %land.lhs.true, %if.then
  br label %if.end24

if.end24:                                         ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @lua_copy(%struct.lua_State* %L, i32 %fromidx, i32 %toidx) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %fromidx.addr = alloca i32, align 4
  %toidx.addr = alloca i32, align 4
  %fr = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %fromidx, i32* %fromidx.addr, align 4
  store i32 %toidx, i32* %toidx.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %fromidx.addr, align 4
  %call = call %struct.lua_TValue* @index2addr(%struct.lua_State* %0, i32 %1)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %fr, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load %struct.lua_TValue** %fr, align 8
  %4 = load i32* %toidx.addr, align 4
  call void @moveto(%struct.lua_State* %2, %struct.lua_TValue* %3, i32 %4)
  ret void
}

; Function Attrs: nounwind uwtable
define void @lua_pushvalue(%struct.lua_State* %L, i32 %idx) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %idx.addr = alloca i32, align 4
  %io2 = alloca %struct.lua_TValue*, align 8
  %io1 = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %idx.addr, align 4
  %call = call %struct.lua_TValue* @index2addr(%struct.lua_State* %0, i32 %1)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %io2, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %2, i32 0, i32 4
  %3 = load %struct.lua_TValue** %top, align 8
  store %struct.lua_TValue* %3, %struct.lua_TValue** %io1, align 8
  %4 = load %struct.lua_TValue** %io1, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %4, i32 0, i32 0
  %5 = load %struct.lua_TValue** %io2, align 8
  %value_1 = getelementptr inbounds %struct.lua_TValue* %5, i32 0, i32 0
  %6 = bitcast %union.Value* %value_ to i8*
  %7 = bitcast %union.Value* %value_1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %6, i8* %7, i64 8, i32 8, i1 false)
  %8 = load %struct.lua_TValue** %io2, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %8, i32 0, i32 1
  %9 = load i32* %tt_, align 4
  %10 = load %struct.lua_TValue** %io1, align 8
  %tt_2 = getelementptr inbounds %struct.lua_TValue* %10, i32 0, i32 1
  store i32 %9, i32* %tt_2, align 4
  %11 = load %struct.lua_State** %L.addr, align 8
  %top3 = getelementptr inbounds %struct.lua_State* %11, i32 0, i32 4
  %12 = load %struct.lua_TValue** %top3, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %12, i32 1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %top3, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @lua_type(%struct.lua_State* %L, i32 %idx) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %idx.addr = alloca i32, align 4
  %o = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %idx.addr, align 4
  %call = call %struct.lua_TValue* @index2addr(%struct.lua_State* %0, i32 %1)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %o, align 8
  %2 = load %struct.lua_TValue** %o, align 8
  %cmp = icmp ne %struct.lua_TValue* %2, bitcast ({ %union.Value.281, i32, [4 x i8] }* @luaO_nilobject_ to %struct.lua_TValue*)
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load %struct.lua_TValue** %o, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %3, i32 0, i32 1
  %4 = load i32* %tt_, align 4
  %and = and i32 %4, 15
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %and, %cond.true ], [ -1, %cond.false ]
  ret i32 %cond
}

; Function Attrs: nounwind uwtable
define i8* @lua_typename(%struct.lua_State* %L, i32 %t) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %t.addr = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %t, i32* %t.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %t.addr, align 4
  %add = add nsw i32 %1, 1
  %idxprom = sext i32 %add to i64
  %arrayidx = getelementptr inbounds [12 x i8*]* @luaT_typenames_, i32 0, i64 %idxprom
  %2 = load i8** %arrayidx, align 8
  ret i8* %2
}

; Function Attrs: nounwind uwtable
define i32 @lua_iscfunction(%struct.lua_State* %L, i32 %idx) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %idx.addr = alloca i32, align 4
  %o = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %idx.addr, align 4
  %call = call %struct.lua_TValue* @index2addr(%struct.lua_State* %0, i32 %1)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %o, align 8
  %2 = load %struct.lua_TValue** %o, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %2, i32 0, i32 1
  %3 = load i32* %tt_, align 4
  %cmp = icmp eq i32 %3, 22
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %4 = load %struct.lua_TValue** %o, align 8
  %tt_1 = getelementptr inbounds %struct.lua_TValue* %4, i32 0, i32 1
  %5 = load i32* %tt_1, align 4
  %cmp2 = icmp eq i32 %5, 102
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %6 = phi i1 [ true, %entry ], [ %cmp2, %lor.rhs ]
  %lor.ext = zext i1 %6 to i32
  ret i32 %lor.ext
}

; Function Attrs: nounwind uwtable
define i32 @lua_isnumber(%struct.lua_State* %L, i32 %idx) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %idx.addr = alloca i32, align 4
  %n = alloca %struct.lua_TValue, align 8
  %o = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %idx.addr, align 4
  %call = call %struct.lua_TValue* @index2addr(%struct.lua_State* %0, i32 %1)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %o, align 8
  %2 = load %struct.lua_TValue** %o, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %2, i32 0, i32 1
  %3 = load i32* %tt_, align 4
  %cmp = icmp eq i32 %3, 3
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %4 = load %struct.lua_TValue** %o, align 8
  %call1 = call %struct.lua_TValue* bitcast (%struct.lua_TValue.349* (%struct.lua_TValue.349*, %struct.lua_TValue.349*)* @luaV_tonumber to %struct.lua_TValue* (%struct.lua_TValue*, %struct.lua_TValue*)*)(%struct.lua_TValue* %4, %struct.lua_TValue* %n)
  store %struct.lua_TValue* %call1, %struct.lua_TValue** %o, align 8
  %cmp2 = icmp ne %struct.lua_TValue* %call1, null
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %5 = phi i1 [ true, %entry ], [ %cmp2, %lor.rhs ]
  %lor.ext = zext i1 %5 to i32
  ret i32 %lor.ext
}

; Function Attrs: nounwind uwtable
define i32 @lua_isstring(%struct.lua_State* %L, i32 %idx) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %idx.addr = alloca i32, align 4
  %t = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %idx.addr, align 4
  %call = call i32 @lua_type(%struct.lua_State* %0, i32 %1)
  store i32 %call, i32* %t, align 4
  %2 = load i32* %t, align 4
  %cmp = icmp eq i32 %2, 4
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %3 = load i32* %t, align 4
  %cmp1 = icmp eq i32 %3, 3
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %4 = phi i1 [ true, %entry ], [ %cmp1, %lor.rhs ]
  %lor.ext = zext i1 %4 to i32
  ret i32 %lor.ext
}

; Function Attrs: nounwind uwtable
define i32 @lua_isuserdata(%struct.lua_State* %L, i32 %idx) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %idx.addr = alloca i32, align 4
  %o = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %idx.addr, align 4
  %call = call %struct.lua_TValue* @index2addr(%struct.lua_State* %0, i32 %1)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %o, align 8
  %2 = load %struct.lua_TValue** %o, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %2, i32 0, i32 1
  %3 = load i32* %tt_, align 4
  %cmp = icmp eq i32 %3, 71
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %4 = load %struct.lua_TValue** %o, align 8
  %tt_1 = getelementptr inbounds %struct.lua_TValue* %4, i32 0, i32 1
  %5 = load i32* %tt_1, align 4
  %cmp2 = icmp eq i32 %5, 2
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %6 = phi i1 [ true, %entry ], [ %cmp2, %lor.rhs ]
  %lor.ext = zext i1 %6 to i32
  ret i32 %lor.ext
}

; Function Attrs: nounwind uwtable
define i32 @lua_rawequal(%struct.lua_State* %L, i32 %index1, i32 %index2) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %index1.addr = alloca i32, align 4
  %index2.addr = alloca i32, align 4
  %o1 = alloca %struct.lua_TValue*, align 8
  %o2 = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %index1, i32* %index1.addr, align 4
  store i32 %index2, i32* %index2.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %index1.addr, align 4
  %call = call %struct.lua_TValue* @index2addr(%struct.lua_State* %0, i32 %1)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %o1, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load i32* %index2.addr, align 4
  %call1 = call %struct.lua_TValue* @index2addr(%struct.lua_State* %2, i32 %3)
  store %struct.lua_TValue* %call1, %struct.lua_TValue** %o2, align 8
  %4 = load %struct.lua_TValue** %o1, align 8
  %cmp = icmp ne %struct.lua_TValue* %4, bitcast ({ %union.Value.281, i32, [4 x i8] }* @luaO_nilobject_ to %struct.lua_TValue*)
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %5 = load %struct.lua_TValue** %o2, align 8
  %cmp2 = icmp ne %struct.lua_TValue* %5, bitcast ({ %union.Value.281, i32, [4 x i8] }* @luaO_nilobject_ to %struct.lua_TValue*)
  br i1 %cmp2, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  %6 = load %struct.lua_TValue** %o1, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %6, i32 0, i32 1
  %7 = load i32* %tt_, align 4
  %8 = load %struct.lua_TValue** %o2, align 8
  %tt_3 = getelementptr inbounds %struct.lua_TValue* %8, i32 0, i32 1
  %9 = load i32* %tt_3, align 4
  %cmp4 = icmp eq i32 %7, %9
  br i1 %cmp4, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %cond.true
  %10 = load %struct.lua_TValue** %o1, align 8
  %11 = load %struct.lua_TValue** %o2, align 8
  %call5 = call i32 bitcast (i32 (%struct.lua_State.364*, %struct.lua_TValue.349*, %struct.lua_TValue.349*)* @luaV_equalobj_ to i32 (%struct.lua_State*, %struct.lua_TValue*, %struct.lua_TValue*)*)(%struct.lua_State* null, %struct.lua_TValue* %10, %struct.lua_TValue* %11)
  %tobool = icmp ne i32 %call5, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %cond.true
  %12 = phi i1 [ false, %cond.true ], [ %tobool, %land.rhs ]
  %land.ext = zext i1 %12 to i32
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %land.end
  %cond = phi i32 [ %land.ext, %land.end ], [ 0, %cond.false ]
  ret i32 %cond
}

; Function Attrs: nounwind uwtable
define void @lua_arith(%struct.lua_State* %L, i32 %op) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %op.addr = alloca i32, align 4
  %o1 = alloca %struct.lua_TValue*, align 8
  %o2 = alloca %struct.lua_TValue*, align 8
  %io2 = alloca %struct.lua_TValue*, align 8
  %io1 = alloca %struct.lua_TValue*, align 8
  %io = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %op, i32* %op.addr, align 4
  %0 = load i32* %op.addr, align 4
  %cmp = icmp ne i32 %0, 6
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end

if.else:                                          ; preds = %entry
  %1 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %1, i32 0, i32 4
  %2 = load %struct.lua_TValue** %top, align 8
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %2, i64 -1
  store %struct.lua_TValue* %add.ptr, %struct.lua_TValue** %io2, align 8
  %3 = load %struct.lua_State** %L.addr, align 8
  %top1 = getelementptr inbounds %struct.lua_State* %3, i32 0, i32 4
  %4 = load %struct.lua_TValue** %top1, align 8
  store %struct.lua_TValue* %4, %struct.lua_TValue** %io1, align 8
  %5 = load %struct.lua_TValue** %io1, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %5, i32 0, i32 0
  %6 = load %struct.lua_TValue** %io2, align 8
  %value_2 = getelementptr inbounds %struct.lua_TValue* %6, i32 0, i32 0
  %7 = bitcast %union.Value* %value_ to i8*
  %8 = bitcast %union.Value* %value_2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %7, i8* %8, i64 8, i32 8, i1 false)
  %9 = load %struct.lua_TValue** %io2, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %9, i32 0, i32 1
  %10 = load i32* %tt_, align 4
  %11 = load %struct.lua_TValue** %io1, align 8
  %tt_3 = getelementptr inbounds %struct.lua_TValue* %11, i32 0, i32 1
  store i32 %10, i32* %tt_3, align 4
  %12 = load %struct.lua_State** %L.addr, align 8
  %top4 = getelementptr inbounds %struct.lua_State* %12, i32 0, i32 4
  %13 = load %struct.lua_TValue** %top4, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %13, i32 1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %top4, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %14 = load %struct.lua_State** %L.addr, align 8
  %top5 = getelementptr inbounds %struct.lua_State* %14, i32 0, i32 4
  %15 = load %struct.lua_TValue** %top5, align 8
  %add.ptr6 = getelementptr inbounds %struct.lua_TValue* %15, i64 -2
  store %struct.lua_TValue* %add.ptr6, %struct.lua_TValue** %o1, align 8
  %16 = load %struct.lua_State** %L.addr, align 8
  %top7 = getelementptr inbounds %struct.lua_State* %16, i32 0, i32 4
  %17 = load %struct.lua_TValue** %top7, align 8
  %add.ptr8 = getelementptr inbounds %struct.lua_TValue* %17, i64 -1
  store %struct.lua_TValue* %add.ptr8, %struct.lua_TValue** %o2, align 8
  %18 = load %struct.lua_TValue** %o1, align 8
  %tt_9 = getelementptr inbounds %struct.lua_TValue* %18, i32 0, i32 1
  %19 = load i32* %tt_9, align 4
  %cmp10 = icmp eq i32 %19, 3
  br i1 %cmp10, label %land.lhs.true, label %if.else20

land.lhs.true:                                    ; preds = %if.end
  %20 = load %struct.lua_TValue** %o2, align 8
  %tt_11 = getelementptr inbounds %struct.lua_TValue* %20, i32 0, i32 1
  %21 = load i32* %tt_11, align 4
  %cmp12 = icmp eq i32 %21, 3
  br i1 %cmp12, label %if.then13, label %if.else20

if.then13:                                        ; preds = %land.lhs.true
  %22 = load %struct.lua_TValue** %o1, align 8
  store %struct.lua_TValue* %22, %struct.lua_TValue** %io, align 8
  %23 = load i32* %op.addr, align 4
  %24 = load %struct.lua_TValue** %o1, align 8
  %value_14 = getelementptr inbounds %struct.lua_TValue* %24, i32 0, i32 0
  %n = bitcast %union.Value* %value_14 to double*
  %25 = load double* %n, align 8
  %26 = load %struct.lua_TValue** %o2, align 8
  %value_15 = getelementptr inbounds %struct.lua_TValue* %26, i32 0, i32 0
  %n16 = bitcast %union.Value* %value_15 to double*
  %27 = load double* %n16, align 8
  %call = call double @luaO_arith(i32 %23, double %25, double %27)
  %28 = load %struct.lua_TValue** %io, align 8
  %value_17 = getelementptr inbounds %struct.lua_TValue* %28, i32 0, i32 0
  %n18 = bitcast %union.Value* %value_17 to double*
  store double %call, double* %n18, align 8
  %29 = load %struct.lua_TValue** %io, align 8
  %tt_19 = getelementptr inbounds %struct.lua_TValue* %29, i32 0, i32 1
  store i32 3, i32* %tt_19, align 4
  br label %if.end21

if.else20:                                        ; preds = %land.lhs.true, %if.end
  %30 = load %struct.lua_State** %L.addr, align 8
  %31 = load %struct.lua_TValue** %o1, align 8
  %32 = load %struct.lua_TValue** %o1, align 8
  %33 = load %struct.lua_TValue** %o2, align 8
  %34 = load i32* %op.addr, align 4
  %sub = sub nsw i32 %34, 0
  %add = add nsw i32 %sub, 6
  call void bitcast (void (%struct.lua_State.364*, %struct.lua_TValue.349*, %struct.lua_TValue.349*, %struct.lua_TValue.349*, i32)* @luaV_arith to void (%struct.lua_State*, %struct.lua_TValue*, %struct.lua_TValue*, %struct.lua_TValue*, i32)*)(%struct.lua_State* %30, %struct.lua_TValue* %31, %struct.lua_TValue* %32, %struct.lua_TValue* %33, i32 %add)
  br label %if.end21

if.end21:                                         ; preds = %if.else20, %if.then13
  %35 = load %struct.lua_State** %L.addr, align 8
  %top22 = getelementptr inbounds %struct.lua_State* %35, i32 0, i32 4
  %36 = load %struct.lua_TValue** %top22, align 8
  %incdec.ptr23 = getelementptr inbounds %struct.lua_TValue* %36, i32 -1
  store %struct.lua_TValue* %incdec.ptr23, %struct.lua_TValue** %top22, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @lua_compare(%struct.lua_State* %L, i32 %index1, i32 %index2, i32 %op) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %index1.addr = alloca i32, align 4
  %index2.addr = alloca i32, align 4
  %op.addr = alloca i32, align 4
  %o1 = alloca %struct.lua_TValue*, align 8
  %o2 = alloca %struct.lua_TValue*, align 8
  %i = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %index1, i32* %index1.addr, align 4
  store i32 %index2, i32* %index2.addr, align 4
  store i32 %op, i32* %op.addr, align 4
  store i32 0, i32* %i, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %index1.addr, align 4
  %call = call %struct.lua_TValue* @index2addr(%struct.lua_State* %0, i32 %1)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %o1, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load i32* %index2.addr, align 4
  %call1 = call %struct.lua_TValue* @index2addr(%struct.lua_State* %2, i32 %3)
  store %struct.lua_TValue* %call1, %struct.lua_TValue** %o2, align 8
  %4 = load %struct.lua_TValue** %o1, align 8
  %cmp = icmp ne %struct.lua_TValue* %4, bitcast ({ %union.Value.281, i32, [4 x i8] }* @luaO_nilobject_ to %struct.lua_TValue*)
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %5 = load %struct.lua_TValue** %o2, align 8
  %cmp2 = icmp ne %struct.lua_TValue* %5, bitcast ({ %union.Value.281, i32, [4 x i8] }* @luaO_nilobject_ to %struct.lua_TValue*)
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %6 = load i32* %op.addr, align 4
  switch i32 %6, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb6
    i32 2, label %sw.bb8
  ]

sw.bb:                                            ; preds = %if.then
  %7 = load %struct.lua_TValue** %o1, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %7, i32 0, i32 1
  %8 = load i32* %tt_, align 4
  %9 = load %struct.lua_TValue** %o2, align 8
  %tt_3 = getelementptr inbounds %struct.lua_TValue* %9, i32 0, i32 1
  %10 = load i32* %tt_3, align 4
  %cmp4 = icmp eq i32 %8, %10
  br i1 %cmp4, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %sw.bb
  %11 = load %struct.lua_State** %L.addr, align 8
  %12 = load %struct.lua_TValue** %o1, align 8
  %13 = load %struct.lua_TValue** %o2, align 8
  %call5 = call i32 bitcast (i32 (%struct.lua_State.364*, %struct.lua_TValue.349*, %struct.lua_TValue.349*)* @luaV_equalobj_ to i32 (%struct.lua_State*, %struct.lua_TValue*, %struct.lua_TValue*)*)(%struct.lua_State* %11, %struct.lua_TValue* %12, %struct.lua_TValue* %13)
  %tobool = icmp ne i32 %call5, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %sw.bb
  %14 = phi i1 [ false, %sw.bb ], [ %tobool, %land.rhs ]
  %land.ext = zext i1 %14 to i32
  store i32 %land.ext, i32* %i, align 4
  br label %sw.epilog

sw.bb6:                                           ; preds = %if.then
  %15 = load %struct.lua_State** %L.addr, align 8
  %16 = load %struct.lua_TValue** %o1, align 8
  %17 = load %struct.lua_TValue** %o2, align 8
  %call7 = call i32 bitcast (i32 (%struct.lua_State.364*, %struct.lua_TValue.349*, %struct.lua_TValue.349*)* @luaV_lessthan to i32 (%struct.lua_State*, %struct.lua_TValue*, %struct.lua_TValue*)*)(%struct.lua_State* %15, %struct.lua_TValue* %16, %struct.lua_TValue* %17)
  store i32 %call7, i32* %i, align 4
  br label %sw.epilog

sw.bb8:                                           ; preds = %if.then
  %18 = load %struct.lua_State** %L.addr, align 8
  %19 = load %struct.lua_TValue** %o1, align 8
  %20 = load %struct.lua_TValue** %o2, align 8
  %call9 = call i32 bitcast (i32 (%struct.lua_State.364*, %struct.lua_TValue.349*, %struct.lua_TValue.349*)* @luaV_lessequal to i32 (%struct.lua_State*, %struct.lua_TValue*, %struct.lua_TValue*)*)(%struct.lua_State* %18, %struct.lua_TValue* %19, %struct.lua_TValue* %20)
  store i32 %call9, i32* %i, align 4
  br label %sw.epilog

sw.default:                                       ; preds = %if.then
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb8, %sw.bb6, %land.end
  br label %if.end

if.end:                                           ; preds = %sw.epilog, %land.lhs.true, %entry
  %21 = load i32* %i, align 4
  ret i32 %21
}

; Function Attrs: nounwind uwtable
define double @lua_tonumberx(%struct.lua_State* %L, i32 %idx, i32* %isnum) #0 {
entry:
  %retval = alloca double, align 8
  %L.addr = alloca %struct.lua_State*, align 8
  %idx.addr = alloca i32, align 4
  %isnum.addr = alloca i32*, align 8
  %n = alloca %struct.lua_TValue, align 8
  %o = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  store i32* %isnum, i32** %isnum.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %idx.addr, align 4
  %call = call %struct.lua_TValue* @index2addr(%struct.lua_State* %0, i32 %1)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %o, align 8
  %2 = load %struct.lua_TValue** %o, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %2, i32 0, i32 1
  %3 = load i32* %tt_, align 4
  %cmp = icmp eq i32 %3, 3
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %4 = load %struct.lua_TValue** %o, align 8
  %call1 = call %struct.lua_TValue* bitcast (%struct.lua_TValue.349* (%struct.lua_TValue.349*, %struct.lua_TValue.349*)* @luaV_tonumber to %struct.lua_TValue* (%struct.lua_TValue*, %struct.lua_TValue*)*)(%struct.lua_TValue* %4, %struct.lua_TValue* %n)
  store %struct.lua_TValue* %call1, %struct.lua_TValue** %o, align 8
  %cmp2 = icmp ne %struct.lua_TValue* %call1, null
  br i1 %cmp2, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  %5 = load i32** %isnum.addr, align 8
  %tobool = icmp ne i32* %5, null
  br i1 %tobool, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %6 = load i32** %isnum.addr, align 8
  store i32 1, i32* %6, align 4
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.then
  %7 = load %struct.lua_TValue** %o, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %7, i32 0, i32 0
  %n4 = bitcast %union.Value* %value_ to double*
  %8 = load double* %n4, align 8
  store double %8, double* %retval
  br label %return

if.else:                                          ; preds = %lor.lhs.false
  %9 = load i32** %isnum.addr, align 8
  %tobool5 = icmp ne i32* %9, null
  br i1 %tobool5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.else
  %10 = load i32** %isnum.addr, align 8
  store i32 0, i32* %10, align 4
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %if.else
  store double 0.000000e+00, double* %retval
  br label %return

return:                                           ; preds = %if.end7, %if.end
  %11 = load double* %retval
  ret double %11
}

; Function Attrs: nounwind uwtable
define i64 @lua_tointegerx(%struct.lua_State* %L, i32 %idx, i32* %isnum) #0 {
entry:
  %retval = alloca i64, align 8
  %L.addr = alloca %struct.lua_State*, align 8
  %idx.addr = alloca i32, align 4
  %isnum.addr = alloca i32*, align 8
  %n = alloca %struct.lua_TValue, align 8
  %o = alloca %struct.lua_TValue*, align 8
  %res = alloca i64, align 8
  %num = alloca double, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  store i32* %isnum, i32** %isnum.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %idx.addr, align 4
  %call = call %struct.lua_TValue* @index2addr(%struct.lua_State* %0, i32 %1)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %o, align 8
  %2 = load %struct.lua_TValue** %o, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %2, i32 0, i32 1
  %3 = load i32* %tt_, align 4
  %cmp = icmp eq i32 %3, 3
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %4 = load %struct.lua_TValue** %o, align 8
  %call1 = call %struct.lua_TValue* bitcast (%struct.lua_TValue.349* (%struct.lua_TValue.349*, %struct.lua_TValue.349*)* @luaV_tonumber to %struct.lua_TValue* (%struct.lua_TValue*, %struct.lua_TValue*)*)(%struct.lua_TValue* %4, %struct.lua_TValue* %n)
  store %struct.lua_TValue* %call1, %struct.lua_TValue** %o, align 8
  %cmp2 = icmp ne %struct.lua_TValue* %call1, null
  br i1 %cmp2, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  %5 = load %struct.lua_TValue** %o, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %5, i32 0, i32 0
  %n3 = bitcast %union.Value* %value_ to double*
  %6 = load double* %n3, align 8
  store double %6, double* %num, align 8
  %7 = load double* %num, align 8
  %conv = fptosi double %7 to i64
  store i64 %conv, i64* %res, align 8
  %8 = load i32** %isnum.addr, align 8
  %tobool = icmp ne i32* %8, null
  br i1 %tobool, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  %9 = load i32** %isnum.addr, align 8
  store i32 1, i32* %9, align 4
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then
  %10 = load i64* %res, align 8
  store i64 %10, i64* %retval
  br label %return

if.else:                                          ; preds = %lor.lhs.false
  %11 = load i32** %isnum.addr, align 8
  %tobool5 = icmp ne i32* %11, null
  br i1 %tobool5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.else
  %12 = load i32** %isnum.addr, align 8
  store i32 0, i32* %12, align 4
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %if.else
  store i64 0, i64* %retval
  br label %return

return:                                           ; preds = %if.end7, %if.end
  %13 = load i64* %retval
  ret i64 %13
}

; Function Attrs: nounwind uwtable
define i32 @lua_tounsignedx(%struct.lua_State* %L, i32 %idx, i32* %isnum) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %idx.addr = alloca i32, align 4
  %isnum.addr = alloca i32*, align 8
  %n = alloca %struct.lua_TValue, align 8
  %o = alloca %struct.lua_TValue*, align 8
  %res = alloca i32, align 4
  %num = alloca double, align 8
  %u = alloca %union.luai_Cast, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  store i32* %isnum, i32** %isnum.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %idx.addr, align 4
  %call = call %struct.lua_TValue* @index2addr(%struct.lua_State* %0, i32 %1)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %o, align 8
  %2 = load %struct.lua_TValue** %o, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %2, i32 0, i32 1
  %3 = load i32* %tt_, align 4
  %cmp = icmp eq i32 %3, 3
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %4 = load %struct.lua_TValue** %o, align 8
  %call1 = call %struct.lua_TValue* bitcast (%struct.lua_TValue.349* (%struct.lua_TValue.349*, %struct.lua_TValue.349*)* @luaV_tonumber to %struct.lua_TValue* (%struct.lua_TValue*, %struct.lua_TValue*)*)(%struct.lua_TValue* %4, %struct.lua_TValue* %n)
  store %struct.lua_TValue* %call1, %struct.lua_TValue** %o, align 8
  %cmp2 = icmp ne %struct.lua_TValue* %call1, null
  br i1 %cmp2, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  %5 = load %struct.lua_TValue** %o, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %5, i32 0, i32 0
  %n3 = bitcast %union.Value* %value_ to double*
  %6 = load double* %n3, align 8
  store double %6, double* %num, align 8
  %7 = load double* %num, align 8
  %add = fadd double %7, 0x4338000000000000
  %l_d = bitcast %union.luai_Cast* %u to double*
  store volatile double %add, double* %l_d, align 8
  %l_p = bitcast %union.luai_Cast* %u to [2 x i32]*
  %arrayidx = getelementptr inbounds [2 x i32]* %l_p, i32 0, i64 0
  %8 = load volatile i32* %arrayidx, align 4
  store i32 %8, i32* %res, align 4
  %9 = load i32** %isnum.addr, align 8
  %tobool = icmp ne i32* %9, null
  br i1 %tobool, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  %10 = load i32** %isnum.addr, align 8
  store i32 1, i32* %10, align 4
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then
  %11 = load i32* %res, align 4
  store i32 %11, i32* %retval
  br label %return

if.else:                                          ; preds = %lor.lhs.false
  %12 = load i32** %isnum.addr, align 8
  %tobool5 = icmp ne i32* %12, null
  br i1 %tobool5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.else
  %13 = load i32** %isnum.addr, align 8
  store i32 0, i32* %13, align 4
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %if.else
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.end7, %if.end
  %14 = load i32* %retval
  ret i32 %14
}

; Function Attrs: nounwind uwtable
define i32 @lua_toboolean(%struct.lua_State* %L, i32 %idx) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %idx.addr = alloca i32, align 4
  %o = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %idx.addr, align 4
  %call = call %struct.lua_TValue* @index2addr(%struct.lua_State* %0, i32 %1)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %o, align 8
  %2 = load %struct.lua_TValue** %o, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %2, i32 0, i32 1
  %3 = load i32* %tt_, align 4
  %cmp = icmp eq i32 %3, 0
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %4 = load %struct.lua_TValue** %o, align 8
  %tt_1 = getelementptr inbounds %struct.lua_TValue* %4, i32 0, i32 1
  %5 = load i32* %tt_1, align 4
  %cmp2 = icmp eq i32 %5, 1
  br i1 %cmp2, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %lor.rhs
  %6 = load %struct.lua_TValue** %o, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %6, i32 0, i32 0
  %b = bitcast %union.Value* %value_ to i32*
  %7 = load i32* %b, align 4
  %cmp3 = icmp eq i32 %7, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %lor.rhs
  %8 = phi i1 [ false, %lor.rhs ], [ %cmp3, %land.rhs ]
  br label %lor.end

lor.end:                                          ; preds = %land.end, %entry
  %9 = phi i1 [ true, %entry ], [ %8, %land.end ]
  %lnot = xor i1 %9, true
  %lnot.ext = zext i1 %lnot to i32
  ret i32 %lnot.ext
}

; Function Attrs: nounwind uwtable
define i8* @lua_tolstring(%struct.lua_State* %L, i32 %idx, i64* %len) #0 {
entry:
  %retval = alloca i8*, align 8
  %L.addr = alloca %struct.lua_State*, align 8
  %idx.addr = alloca i32, align 4
  %len.addr = alloca i64*, align 8
  %o = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  store i64* %len, i64** %len.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %idx.addr, align 4
  %call = call %struct.lua_TValue* @index2addr(%struct.lua_State* %0, i32 %1)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %o, align 8
  %2 = load %struct.lua_TValue** %o, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %2, i32 0, i32 1
  %3 = load i32* %tt_, align 4
  %and = and i32 %3, 15
  %cmp = icmp eq i32 %and, 4
  br i1 %cmp, label %if.end10, label %if.then

if.then:                                          ; preds = %entry
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load %struct.lua_TValue** %o, align 8
  %call1 = call i32 bitcast (i32 (%struct.lua_State.364*, %struct.lua_TValue.349*)* @luaV_tostring to i32 (%struct.lua_State*, %struct.lua_TValue*)*)(%struct.lua_State* %4, %struct.lua_TValue* %5)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.end5, label %if.then2

if.then2:                                         ; preds = %if.then
  %6 = load i64** %len.addr, align 8
  %cmp3 = icmp ne i64* %6, null
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then2
  %7 = load i64** %len.addr, align 8
  store i64 0, i64* %7, align 8
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then2
  store i8* null, i8** %retval
  br label %return

if.end5:                                          ; preds = %if.then
  %8 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %8, i32 0, i32 5
  %9 = load %struct.global_State** %l_G, align 8
  %GCdebt = getelementptr inbounds %struct.global_State* %9, i32 0, i32 3
  %10 = load i64* %GCdebt, align 8
  %cmp6 = icmp sgt i64 %10, 0
  br i1 %cmp6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end5
  %11 = load %struct.lua_State** %L.addr, align 8
  call void @luaC_step(%struct.lua_State* %11)
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %if.end5
  %12 = load %struct.lua_State** %L.addr, align 8
  %13 = load i32* %idx.addr, align 4
  %call9 = call %struct.lua_TValue* @index2addr(%struct.lua_State* %12, i32 %13)
  store %struct.lua_TValue* %call9, %struct.lua_TValue** %o, align 8
  br label %if.end10

if.end10:                                         ; preds = %if.end8, %entry
  %14 = load i64** %len.addr, align 8
  %cmp11 = icmp ne i64* %14, null
  br i1 %cmp11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.end10
  %15 = load %struct.lua_TValue** %o, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %15, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %16 = load %union.GCObject** %gc, align 8
  %ts = bitcast %union.GCObject* %16 to %union.TString*
  %tsv = bitcast %union.TString* %ts to %struct.anon.0*
  %len13 = getelementptr inbounds %struct.anon.0* %tsv, i32 0, i32 5
  %17 = load i64* %len13, align 8
  %18 = load i64** %len.addr, align 8
  store i64 %17, i64* %18, align 8
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %if.end10
  %19 = load %struct.lua_TValue** %o, align 8
  %value_15 = getelementptr inbounds %struct.lua_TValue* %19, i32 0, i32 0
  %gc16 = bitcast %union.Value* %value_15 to %union.GCObject**
  %20 = load %union.GCObject** %gc16, align 8
  %ts17 = bitcast %union.GCObject* %20 to %union.TString*
  %add.ptr = getelementptr inbounds %union.TString* %ts17, i64 1
  %21 = bitcast %union.TString* %add.ptr to i8*
  store i8* %21, i8** %retval
  br label %return

return:                                           ; preds = %if.end14, %if.end
  %22 = load i8** %retval
  ret i8* %22
}

; Function Attrs: nounwind uwtable
define i64 @lua_rawlen(%struct.lua_State* %L, i32 %idx) #0 {
entry:
  %retval = alloca i64, align 8
  %L.addr = alloca %struct.lua_State*, align 8
  %idx.addr = alloca i32, align 4
  %o = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %idx.addr, align 4
  %call = call %struct.lua_TValue* @index2addr(%struct.lua_State* %0, i32 %1)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %o, align 8
  %2 = load %struct.lua_TValue** %o, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %2, i32 0, i32 1
  %3 = load i32* %tt_, align 4
  %and = and i32 %3, 15
  switch i32 %and, label %sw.default [
    i32 4, label %sw.bb
    i32 7, label %sw.bb1
    i32 5, label %sw.bb5
  ]

sw.bb:                                            ; preds = %entry
  %4 = load %struct.lua_TValue** %o, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %4, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %5 = load %union.GCObject** %gc, align 8
  %ts = bitcast %union.GCObject* %5 to %union.TString*
  %tsv = bitcast %union.TString* %ts to %struct.anon.0*
  %len = getelementptr inbounds %struct.anon.0* %tsv, i32 0, i32 5
  %6 = load i64* %len, align 8
  store i64 %6, i64* %retval
  br label %return

sw.bb1:                                           ; preds = %entry
  %7 = load %struct.lua_TValue** %o, align 8
  %value_2 = getelementptr inbounds %struct.lua_TValue* %7, i32 0, i32 0
  %gc3 = bitcast %union.Value* %value_2 to %union.GCObject**
  %8 = load %union.GCObject** %gc3, align 8
  %u = bitcast %union.GCObject* %8 to %union.Udata*
  %uv = bitcast %union.Udata* %u to %struct.anon.5*
  %len4 = getelementptr inbounds %struct.anon.5* %uv, i32 0, i32 5
  %9 = load i64* %len4, align 8
  store i64 %9, i64* %retval
  br label %return

sw.bb5:                                           ; preds = %entry
  %10 = load %struct.lua_TValue** %o, align 8
  %value_6 = getelementptr inbounds %struct.lua_TValue* %10, i32 0, i32 0
  %gc7 = bitcast %union.Value* %value_6 to %union.GCObject**
  %11 = load %union.GCObject** %gc7, align 8
  %h = bitcast %union.GCObject* %11 to %struct.Table*
  %call8 = call i32 @luaH_getn(%struct.Table* %h)
  %conv = sext i32 %call8 to i64
  store i64 %conv, i64* %retval
  br label %return

sw.default:                                       ; preds = %entry
  store i64 0, i64* %retval
  br label %return

return:                                           ; preds = %sw.default, %sw.bb5, %sw.bb1, %sw.bb
  %12 = load i64* %retval
  ret i64 %12
}

; Function Attrs: nounwind uwtable
define i32 (%struct.lua_State*)* @lua_tocfunction(%struct.lua_State* %L, i32 %idx) #0 {
entry:
  %retval = alloca i32 (%struct.lua_State*)*, align 8
  %L.addr = alloca %struct.lua_State*, align 8
  %idx.addr = alloca i32, align 4
  %o = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %idx.addr, align 4
  %call = call %struct.lua_TValue* @index2addr(%struct.lua_State* %0, i32 %1)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %o, align 8
  %2 = load %struct.lua_TValue** %o, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %2, i32 0, i32 1
  %3 = load i32* %tt_, align 4
  %cmp = icmp eq i32 %3, 22
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %4 = load %struct.lua_TValue** %o, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %4, i32 0, i32 0
  %f = bitcast %union.Value* %value_ to i32 (%struct.lua_State*)**
  %5 = load i32 (%struct.lua_State*)** %f, align 8
  store i32 (%struct.lua_State*)* %5, i32 (%struct.lua_State*)** %retval
  br label %return

if.else:                                          ; preds = %entry
  %6 = load %struct.lua_TValue** %o, align 8
  %tt_1 = getelementptr inbounds %struct.lua_TValue* %6, i32 0, i32 1
  %7 = load i32* %tt_1, align 4
  %cmp2 = icmp eq i32 %7, 102
  br i1 %cmp2, label %if.then3, label %if.else6

if.then3:                                         ; preds = %if.else
  %8 = load %struct.lua_TValue** %o, align 8
  %value_4 = getelementptr inbounds %struct.lua_TValue* %8, i32 0, i32 0
  %gc = bitcast %union.Value* %value_4 to %union.GCObject**
  %9 = load %union.GCObject** %gc, align 8
  %cl = bitcast %union.GCObject* %9 to %union.Closure*
  %c = bitcast %union.Closure* %cl to %struct.CClosure*
  %f5 = getelementptr inbounds %struct.CClosure* %c, i32 0, i32 5
  %10 = load i32 (%struct.lua_State*)** %f5, align 8
  store i32 (%struct.lua_State*)* %10, i32 (%struct.lua_State*)** %retval
  br label %return

if.else6:                                         ; preds = %if.else
  store i32 (%struct.lua_State*)* null, i32 (%struct.lua_State*)** %retval
  br label %return

return:                                           ; preds = %if.else6, %if.then3, %if.then
  %11 = load i32 (%struct.lua_State*)** %retval
  ret i32 (%struct.lua_State*)* %11
}

; Function Attrs: nounwind uwtable
define i8* @lua_touserdata(%struct.lua_State* %L, i32 %idx) #0 {
entry:
  %retval = alloca i8*, align 8
  %L.addr = alloca %struct.lua_State*, align 8
  %idx.addr = alloca i32, align 4
  %o = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %idx.addr, align 4
  %call = call %struct.lua_TValue* @index2addr(%struct.lua_State* %0, i32 %1)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %o, align 8
  %2 = load %struct.lua_TValue** %o, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %2, i32 0, i32 1
  %3 = load i32* %tt_, align 4
  %and = and i32 %3, 15
  switch i32 %and, label %sw.default [
    i32 7, label %sw.bb
    i32 2, label %sw.bb1
  ]

sw.bb:                                            ; preds = %entry
  %4 = load %struct.lua_TValue** %o, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %4, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %5 = load %union.GCObject** %gc, align 8
  %u = bitcast %union.GCObject* %5 to %union.Udata*
  %add.ptr = getelementptr inbounds %union.Udata* %u, i64 1
  %6 = bitcast %union.Udata* %add.ptr to i8*
  store i8* %6, i8** %retval
  br label %return

sw.bb1:                                           ; preds = %entry
  %7 = load %struct.lua_TValue** %o, align 8
  %value_2 = getelementptr inbounds %struct.lua_TValue* %7, i32 0, i32 0
  %p = bitcast %union.Value* %value_2 to i8**
  %8 = load i8** %p, align 8
  store i8* %8, i8** %retval
  br label %return

sw.default:                                       ; preds = %entry
  store i8* null, i8** %retval
  br label %return

return:                                           ; preds = %sw.default, %sw.bb1, %sw.bb
  %9 = load i8** %retval
  ret i8* %9
}

; Function Attrs: nounwind uwtable
define %struct.lua_State* @lua_tothread(%struct.lua_State* %L, i32 %idx) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %idx.addr = alloca i32, align 4
  %o = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %idx.addr, align 4
  %call = call %struct.lua_TValue* @index2addr(%struct.lua_State* %0, i32 %1)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %o, align 8
  %2 = load %struct.lua_TValue** %o, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %2, i32 0, i32 1
  %3 = load i32* %tt_, align 4
  %cmp = icmp eq i32 %3, 72
  br i1 %cmp, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %4 = load %struct.lua_TValue** %o, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %4, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %5 = load %union.GCObject** %gc, align 8
  %th = bitcast %union.GCObject* %5 to %struct.lua_State*
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.lua_State* [ null, %cond.true ], [ %th, %cond.false ]
  ret %struct.lua_State* %cond
}

; Function Attrs: nounwind uwtable
define i8* @lua_topointer(%struct.lua_State* %L, i32 %idx) #0 {
entry:
  %retval = alloca i8*, align 8
  %L.addr = alloca %struct.lua_State*, align 8
  %idx.addr = alloca i32, align 4
  %o = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %idx.addr, align 4
  %call = call %struct.lua_TValue* @index2addr(%struct.lua_State* %0, i32 %1)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %o, align 8
  %2 = load %struct.lua_TValue** %o, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %2, i32 0, i32 1
  %3 = load i32* %tt_, align 4
  %and = and i32 %3, 63
  switch i32 %and, label %sw.default [
    i32 5, label %sw.bb
    i32 6, label %sw.bb1
    i32 38, label %sw.bb4
    i32 22, label %sw.bb8
    i32 8, label %sw.bb10
    i32 7, label %sw.bb13
    i32 2, label %sw.bb13
  ]

sw.bb:                                            ; preds = %entry
  %4 = load %struct.lua_TValue** %o, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %4, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %5 = load %union.GCObject** %gc, align 8
  %h = bitcast %union.GCObject* %5 to %struct.Table*
  %6 = bitcast %struct.Table* %h to i8*
  store i8* %6, i8** %retval
  br label %return

sw.bb1:                                           ; preds = %entry
  %7 = load %struct.lua_TValue** %o, align 8
  %value_2 = getelementptr inbounds %struct.lua_TValue* %7, i32 0, i32 0
  %gc3 = bitcast %union.Value* %value_2 to %union.GCObject**
  %8 = load %union.GCObject** %gc3, align 8
  %cl = bitcast %union.GCObject* %8 to %union.Closure*
  %l = bitcast %union.Closure* %cl to %struct.LClosure*
  %9 = bitcast %struct.LClosure* %l to i8*
  store i8* %9, i8** %retval
  br label %return

sw.bb4:                                           ; preds = %entry
  %10 = load %struct.lua_TValue** %o, align 8
  %value_5 = getelementptr inbounds %struct.lua_TValue* %10, i32 0, i32 0
  %gc6 = bitcast %union.Value* %value_5 to %union.GCObject**
  %11 = load %union.GCObject** %gc6, align 8
  %cl7 = bitcast %union.GCObject* %11 to %union.Closure*
  %c = bitcast %union.Closure* %cl7 to %struct.CClosure*
  %12 = bitcast %struct.CClosure* %c to i8*
  store i8* %12, i8** %retval
  br label %return

sw.bb8:                                           ; preds = %entry
  %13 = load %struct.lua_TValue** %o, align 8
  %value_9 = getelementptr inbounds %struct.lua_TValue* %13, i32 0, i32 0
  %f = bitcast %union.Value* %value_9 to i32 (%struct.lua_State*)**
  %14 = load i32 (%struct.lua_State*)** %f, align 8
  %15 = ptrtoint i32 (%struct.lua_State*)* %14 to i64
  %16 = inttoptr i64 %15 to i8*
  store i8* %16, i8** %retval
  br label %return

sw.bb10:                                          ; preds = %entry
  %17 = load %struct.lua_TValue** %o, align 8
  %value_11 = getelementptr inbounds %struct.lua_TValue* %17, i32 0, i32 0
  %gc12 = bitcast %union.Value* %value_11 to %union.GCObject**
  %18 = load %union.GCObject** %gc12, align 8
  %th = bitcast %union.GCObject* %18 to %struct.lua_State*
  %19 = bitcast %struct.lua_State* %th to i8*
  store i8* %19, i8** %retval
  br label %return

sw.bb13:                                          ; preds = %entry, %entry
  %20 = load %struct.lua_State** %L.addr, align 8
  %21 = load i32* %idx.addr, align 4
  %call14 = call i8* @lua_touserdata(%struct.lua_State* %20, i32 %21)
  store i8* %call14, i8** %retval
  br label %return

sw.default:                                       ; preds = %entry
  store i8* null, i8** %retval
  br label %return

return:                                           ; preds = %sw.default, %sw.bb13, %sw.bb10, %sw.bb8, %sw.bb4, %sw.bb1, %sw.bb
  %22 = load i8** %retval
  ret i8* %22
}

; Function Attrs: nounwind uwtable
define void @lua_pushnil(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 4
  %1 = load %struct.lua_TValue** %top, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %1, i32 0, i32 1
  store i32 0, i32* %tt_, align 4
  %2 = load %struct.lua_State** %L.addr, align 8
  %top1 = getelementptr inbounds %struct.lua_State* %2, i32 0, i32 4
  %3 = load %struct.lua_TValue** %top1, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %3, i32 1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %top1, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define void @lua_pushnumber(%struct.lua_State* %L, double %n) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %n.addr = alloca double, align 8
  %io = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store double %n, double* %n.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 4
  %1 = load %struct.lua_TValue** %top, align 8
  store %struct.lua_TValue* %1, %struct.lua_TValue** %io, align 8
  %2 = load double* %n.addr, align 8
  %3 = load %struct.lua_TValue** %io, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %3, i32 0, i32 0
  %n1 = bitcast %union.Value* %value_ to double*
  store double %2, double* %n1, align 8
  %4 = load %struct.lua_TValue** %io, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %4, i32 0, i32 1
  store i32 3, i32* %tt_, align 4
  %5 = load %struct.lua_State** %L.addr, align 8
  %top2 = getelementptr inbounds %struct.lua_State* %5, i32 0, i32 4
  %6 = load %struct.lua_TValue** %top2, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %6, i32 1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %top2, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define void @lua_pushinteger(%struct.lua_State* %L, i64 %n) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %n.addr = alloca i64, align 8
  %io = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i64 %n, i64* %n.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 4
  %1 = load %struct.lua_TValue** %top, align 8
  store %struct.lua_TValue* %1, %struct.lua_TValue** %io, align 8
  %2 = load i64* %n.addr, align 8
  %conv = sitofp i64 %2 to double
  %3 = load %struct.lua_TValue** %io, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %3, i32 0, i32 0
  %n1 = bitcast %union.Value* %value_ to double*
  store double %conv, double* %n1, align 8
  %4 = load %struct.lua_TValue** %io, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %4, i32 0, i32 1
  store i32 3, i32* %tt_, align 4
  %5 = load %struct.lua_State** %L.addr, align 8
  %top2 = getelementptr inbounds %struct.lua_State* %5, i32 0, i32 4
  %6 = load %struct.lua_TValue** %top2, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %6, i32 1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %top2, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define void @lua_pushunsigned(%struct.lua_State* %L, i32 %u) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %u.addr = alloca i32, align 4
  %n = alloca double, align 8
  %io = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %u, i32* %u.addr, align 4
  %0 = load i32* %u.addr, align 4
  %cmp = icmp ule i32 %0, 2147483647
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load i32* %u.addr, align 4
  %conv = sitofp i32 %1 to double
  br label %cond.end

cond.false:                                       ; preds = %entry
  %2 = load i32* %u.addr, align 4
  %conv1 = uitofp i32 %2 to double
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi double [ %conv, %cond.true ], [ %conv1, %cond.false ]
  store double %cond, double* %n, align 8
  %3 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %3, i32 0, i32 4
  %4 = load %struct.lua_TValue** %top, align 8
  store %struct.lua_TValue* %4, %struct.lua_TValue** %io, align 8
  %5 = load double* %n, align 8
  %6 = load %struct.lua_TValue** %io, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %6, i32 0, i32 0
  %n2 = bitcast %union.Value* %value_ to double*
  store double %5, double* %n2, align 8
  %7 = load %struct.lua_TValue** %io, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %7, i32 0, i32 1
  store i32 3, i32* %tt_, align 4
  %8 = load %struct.lua_State** %L.addr, align 8
  %top3 = getelementptr inbounds %struct.lua_State* %8, i32 0, i32 4
  %9 = load %struct.lua_TValue** %top3, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %9, i32 1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %top3, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define i8* @lua_pushlstring(%struct.lua_State* %L, i8* %s, i64 %len) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %s.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %ts = alloca %union.TString*, align 8
  %io = alloca %struct.lua_TValue*, align 8
  %x_ = alloca %union.TString*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %s, i8** %s.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 5
  %1 = load %struct.global_State** %l_G, align 8
  %GCdebt = getelementptr inbounds %struct.global_State* %1, i32 0, i32 3
  %2 = load i64* %GCdebt, align 8
  %cmp = icmp sgt i64 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load %struct.lua_State** %L.addr, align 8
  call void @luaC_step(%struct.lua_State* %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load i8** %s.addr, align 8
  %6 = load i64* %len.addr, align 8
  %call = call %union.TString* bitcast (%union.TString.367* (%struct.lua_State.364*, i8*, i64)* @luaS_newlstr to %union.TString* (%struct.lua_State*, i8*, i64)*)(%struct.lua_State* %4, i8* %5, i64 %6)
  store %union.TString* %call, %union.TString** %ts, align 8
  %7 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %7, i32 0, i32 4
  %8 = load %struct.lua_TValue** %top, align 8
  store %struct.lua_TValue* %8, %struct.lua_TValue** %io, align 8
  %9 = load %union.TString** %ts, align 8
  store %union.TString* %9, %union.TString** %x_, align 8
  %10 = load %union.TString** %x_, align 8
  %11 = bitcast %union.TString* %10 to %union.GCObject*
  %12 = load %struct.lua_TValue** %io, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %12, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  store %union.GCObject* %11, %union.GCObject** %gc, align 8
  %13 = load %union.TString** %x_, align 8
  %tsv = bitcast %union.TString* %13 to %struct.anon.0*
  %tt = getelementptr inbounds %struct.anon.0* %tsv, i32 0, i32 1
  %14 = load i8* %tt, align 1
  %conv = zext i8 %14 to i32
  %or = or i32 %conv, 64
  %15 = load %struct.lua_TValue** %io, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %15, i32 0, i32 1
  store i32 %or, i32* %tt_, align 4
  %16 = load %struct.lua_State** %L.addr, align 8
  %top1 = getelementptr inbounds %struct.lua_State* %16, i32 0, i32 4
  %17 = load %struct.lua_TValue** %top1, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %17, i32 1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %top1, align 8
  %18 = load %union.TString** %ts, align 8
  %add.ptr = getelementptr inbounds %union.TString* %18, i64 1
  %19 = bitcast %union.TString* %add.ptr to i8*
  ret i8* %19
}

; Function Attrs: nounwind uwtable
define i8* @lua_pushstring(%struct.lua_State* %L, i8* %s) #0 {
entry:
  %retval = alloca i8*, align 8
  %L.addr = alloca %struct.lua_State*, align 8
  %s.addr = alloca i8*, align 8
  %ts = alloca %union.TString*, align 8
  %io = alloca %struct.lua_TValue*, align 8
  %x_ = alloca %union.TString*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %s, i8** %s.addr, align 8
  %0 = load i8** %s.addr, align 8
  %cmp = icmp eq i8* %0, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushnil(%struct.lua_State* %1)
  store i8* null, i8** %retval
  br label %return

if.else:                                          ; preds = %entry
  %2 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %2, i32 0, i32 5
  %3 = load %struct.global_State** %l_G, align 8
  %GCdebt = getelementptr inbounds %struct.global_State* %3, i32 0, i32 3
  %4 = load i64* %GCdebt, align 8
  %cmp1 = icmp sgt i64 %4, 0
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.else
  %5 = load %struct.lua_State** %L.addr, align 8
  call void @luaC_step(%struct.lua_State* %5)
  br label %if.end

if.end:                                           ; preds = %if.then2, %if.else
  %6 = load %struct.lua_State** %L.addr, align 8
  %7 = load i8** %s.addr, align 8
  %call = call %union.TString* bitcast (%union.TString.367* (%struct.lua_State.364*, i8*)* @luaS_new to %union.TString* (%struct.lua_State*, i8*)*)(%struct.lua_State* %6, i8* %7)
  store %union.TString* %call, %union.TString** %ts, align 8
  %8 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %8, i32 0, i32 4
  %9 = load %struct.lua_TValue** %top, align 8
  store %struct.lua_TValue* %9, %struct.lua_TValue** %io, align 8
  %10 = load %union.TString** %ts, align 8
  store %union.TString* %10, %union.TString** %x_, align 8
  %11 = load %union.TString** %x_, align 8
  %12 = bitcast %union.TString* %11 to %union.GCObject*
  %13 = load %struct.lua_TValue** %io, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %13, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  store %union.GCObject* %12, %union.GCObject** %gc, align 8
  %14 = load %union.TString** %x_, align 8
  %tsv = bitcast %union.TString* %14 to %struct.anon.0*
  %tt = getelementptr inbounds %struct.anon.0* %tsv, i32 0, i32 1
  %15 = load i8* %tt, align 1
  %conv = zext i8 %15 to i32
  %or = or i32 %conv, 64
  %16 = load %struct.lua_TValue** %io, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %16, i32 0, i32 1
  store i32 %or, i32* %tt_, align 4
  %17 = load %struct.lua_State** %L.addr, align 8
  %top3 = getelementptr inbounds %struct.lua_State* %17, i32 0, i32 4
  %18 = load %struct.lua_TValue** %top3, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %18, i32 1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %top3, align 8
  %19 = load %union.TString** %ts, align 8
  %add.ptr = getelementptr inbounds %union.TString* %19, i64 1
  %20 = bitcast %union.TString* %add.ptr to i8*
  store i8* %20, i8** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %21 = load i8** %retval
  ret i8* %21
}

; Function Attrs: nounwind uwtable
define i8* @lua_pushvfstring(%struct.lua_State* %L, i8* %fmt, %struct.__va_list_tag* %argp) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %fmt.addr = alloca i8*, align 8
  %argp.addr = alloca %struct.__va_list_tag*, align 8
  %ret = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %fmt, i8** %fmt.addr, align 8
  store %struct.__va_list_tag* %argp, %struct.__va_list_tag** %argp.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 5
  %1 = load %struct.global_State** %l_G, align 8
  %GCdebt = getelementptr inbounds %struct.global_State* %1, i32 0, i32 3
  %2 = load i64* %GCdebt, align 8
  %cmp = icmp sgt i64 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load %struct.lua_State** %L.addr, align 8
  call void @luaC_step(%struct.lua_State* %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load i8** %fmt.addr, align 8
  %6 = load %struct.__va_list_tag** %argp.addr, align 8
  %call = call i8* bitcast (i8* (%struct.lua_State.279*, i8*, %struct.__va_list_tag*)* @luaO_pushvfstring to i8* (%struct.lua_State*, i8*, %struct.__va_list_tag*)*)(%struct.lua_State* %4, i8* %5, %struct.__va_list_tag* %6)
  store i8* %call, i8** %ret, align 8
  %7 = load i8** %ret, align 8
  ret i8* %7
}

; Function Attrs: nounwind uwtable
define i8* @lua_pushfstring(%struct.lua_State* %L, i8* %fmt, ...) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %fmt.addr = alloca i8*, align 8
  %ret = alloca i8*, align 8
  %argp = alloca [1 x %struct.__va_list_tag], align 16
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %fmt, i8** %fmt.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 5
  %1 = load %struct.global_State** %l_G, align 8
  %GCdebt = getelementptr inbounds %struct.global_State* %1, i32 0, i32 3
  %2 = load i64* %GCdebt, align 8
  %cmp = icmp sgt i64 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load %struct.lua_State** %L.addr, align 8
  call void @luaC_step(%struct.lua_State* %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag]* %argp, i32 0, i32 0
  %arraydecay1 = bitcast %struct.__va_list_tag* %arraydecay to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load i8** %fmt.addr, align 8
  %arraydecay2 = getelementptr inbounds [1 x %struct.__va_list_tag]* %argp, i32 0, i32 0
  %call = call i8* bitcast (i8* (%struct.lua_State.279*, i8*, %struct.__va_list_tag*)* @luaO_pushvfstring to i8* (%struct.lua_State*, i8*, %struct.__va_list_tag*)*)(%struct.lua_State* %4, i8* %5, %struct.__va_list_tag* %arraydecay2)
  store i8* %call, i8** %ret, align 8
  %arraydecay3 = getelementptr inbounds [1 x %struct.__va_list_tag]* %argp, i32 0, i32 0
  %arraydecay34 = bitcast %struct.__va_list_tag* %arraydecay3 to i8*
  call void @llvm.va_end(i8* %arraydecay34)
  %6 = load i8** %ret, align 8
  ret i8* %6
}

; Function Attrs: nounwind
declare void @llvm.va_start(i8*) #1

; Function Attrs: nounwind
declare void @llvm.va_end(i8*) #1

; Function Attrs: nounwind uwtable
define void @lua_pushcclosure(%struct.lua_State* %L, i32 (%struct.lua_State*)* %fn, i32 %n) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %fn.addr = alloca i32 (%struct.lua_State*)*, align 8
  %n.addr = alloca i32, align 4
  %io = alloca %struct.lua_TValue*, align 8
  %cl = alloca %union.Closure*, align 8
  %io2 = alloca %struct.lua_TValue*, align 8
  %io1 = alloca %struct.lua_TValue*, align 8
  %io13 = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 (%struct.lua_State*)* %fn, i32 (%struct.lua_State*)** %fn.addr, align 8
  store i32 %n, i32* %n.addr, align 4
  %0 = load i32* %n.addr, align 4
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %1, i32 0, i32 4
  %2 = load %struct.lua_TValue** %top, align 8
  store %struct.lua_TValue* %2, %struct.lua_TValue** %io, align 8
  %3 = load i32 (%struct.lua_State*)** %fn.addr, align 8
  %4 = load %struct.lua_TValue** %io, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %4, i32 0, i32 0
  %f = bitcast %union.Value* %value_ to i32 (%struct.lua_State*)**
  store i32 (%struct.lua_State*)* %3, i32 (%struct.lua_State*)** %f, align 8
  %5 = load %struct.lua_TValue** %io, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %5, i32 0, i32 1
  store i32 22, i32* %tt_, align 4
  br label %if.end17

if.else:                                          ; preds = %entry
  %6 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %6, i32 0, i32 5
  %7 = load %struct.global_State** %l_G, align 8
  %GCdebt = getelementptr inbounds %struct.global_State* %7, i32 0, i32 3
  %8 = load i64* %GCdebt, align 8
  %cmp1 = icmp sgt i64 %8, 0
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.else
  %9 = load %struct.lua_State** %L.addr, align 8
  call void @luaC_step(%struct.lua_State* %9)
  br label %if.end

if.end:                                           ; preds = %if.then2, %if.else
  %10 = load %struct.lua_State** %L.addr, align 8
  %11 = load i32* %n.addr, align 4
  %call = call %union.Closure* bitcast (%union.Closure.157* (%struct.lua_State.154*, i32)* @luaF_newCclosure to %union.Closure* (%struct.lua_State*, i32)*)(%struct.lua_State* %10, i32 %11)
  store %union.Closure* %call, %union.Closure** %cl, align 8
  %12 = load i32 (%struct.lua_State*)** %fn.addr, align 8
  %13 = load %union.Closure** %cl, align 8
  %c = bitcast %union.Closure* %13 to %struct.CClosure*
  %f3 = getelementptr inbounds %struct.CClosure* %c, i32 0, i32 5
  store i32 (%struct.lua_State*)* %12, i32 (%struct.lua_State*)** %f3, align 8
  %14 = load i32* %n.addr, align 4
  %15 = load %struct.lua_State** %L.addr, align 8
  %top4 = getelementptr inbounds %struct.lua_State* %15, i32 0, i32 4
  %16 = load %struct.lua_TValue** %top4, align 8
  %idx.ext = sext i32 %14 to i64
  %idx.neg = sub i64 0, %idx.ext
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %16, i64 %idx.neg
  store %struct.lua_TValue* %add.ptr, %struct.lua_TValue** %top4, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %17 = load i32* %n.addr, align 4
  %dec = add nsw i32 %17, -1
  store i32 %dec, i32* %n.addr, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %18 = load %struct.lua_State** %L.addr, align 8
  %top5 = getelementptr inbounds %struct.lua_State* %18, i32 0, i32 4
  %19 = load %struct.lua_TValue** %top5, align 8
  %20 = load i32* %n.addr, align 4
  %idx.ext6 = sext i32 %20 to i64
  %add.ptr7 = getelementptr inbounds %struct.lua_TValue* %19, i64 %idx.ext6
  store %struct.lua_TValue* %add.ptr7, %struct.lua_TValue** %io2, align 8
  %21 = load i32* %n.addr, align 4
  %idxprom = sext i32 %21 to i64
  %22 = load %union.Closure** %cl, align 8
  %c8 = bitcast %union.Closure* %22 to %struct.CClosure*
  %upvalue = getelementptr inbounds %struct.CClosure* %c8, i32 0, i32 6
  %arrayidx = getelementptr inbounds [1 x %struct.lua_TValue]* %upvalue, i32 0, i64 %idxprom
  store %struct.lua_TValue* %arrayidx, %struct.lua_TValue** %io1, align 8
  %23 = load %struct.lua_TValue** %io1, align 8
  %value_9 = getelementptr inbounds %struct.lua_TValue* %23, i32 0, i32 0
  %24 = load %struct.lua_TValue** %io2, align 8
  %value_10 = getelementptr inbounds %struct.lua_TValue* %24, i32 0, i32 0
  %25 = bitcast %union.Value* %value_9 to i8*
  %26 = bitcast %union.Value* %value_10 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %25, i8* %26, i64 8, i32 8, i1 false)
  %27 = load %struct.lua_TValue** %io2, align 8
  %tt_11 = getelementptr inbounds %struct.lua_TValue* %27, i32 0, i32 1
  %28 = load i32* %tt_11, align 4
  %29 = load %struct.lua_TValue** %io1, align 8
  %tt_12 = getelementptr inbounds %struct.lua_TValue* %29, i32 0, i32 1
  store i32 %28, i32* %tt_12, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %30 = load %struct.lua_State** %L.addr, align 8
  %top14 = getelementptr inbounds %struct.lua_State* %30, i32 0, i32 4
  %31 = load %struct.lua_TValue** %top14, align 8
  store %struct.lua_TValue* %31, %struct.lua_TValue** %io13, align 8
  %32 = load %union.Closure** %cl, align 8
  %33 = bitcast %union.Closure* %32 to %union.GCObject*
  %34 = load %struct.lua_TValue** %io13, align 8
  %value_15 = getelementptr inbounds %struct.lua_TValue* %34, i32 0, i32 0
  %gc = bitcast %union.Value* %value_15 to %union.GCObject**
  store %union.GCObject* %33, %union.GCObject** %gc, align 8
  %35 = load %struct.lua_TValue** %io13, align 8
  %tt_16 = getelementptr inbounds %struct.lua_TValue* %35, i32 0, i32 1
  store i32 102, i32* %tt_16, align 4
  br label %if.end17

if.end17:                                         ; preds = %while.end, %if.then
  %36 = load %struct.lua_State** %L.addr, align 8
  %top18 = getelementptr inbounds %struct.lua_State* %36, i32 0, i32 4
  %37 = load %struct.lua_TValue** %top18, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %37, i32 1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %top18, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define void @lua_pushboolean(%struct.lua_State* %L, i32 %b) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %b.addr = alloca i32, align 4
  %io = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %b, i32* %b.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 4
  %1 = load %struct.lua_TValue** %top, align 8
  store %struct.lua_TValue* %1, %struct.lua_TValue** %io, align 8
  %2 = load i32* %b.addr, align 4
  %cmp = icmp ne i32 %2, 0
  %conv = zext i1 %cmp to i32
  %3 = load %struct.lua_TValue** %io, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %3, i32 0, i32 0
  %b1 = bitcast %union.Value* %value_ to i32*
  store i32 %conv, i32* %b1, align 4
  %4 = load %struct.lua_TValue** %io, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %4, i32 0, i32 1
  store i32 1, i32* %tt_, align 4
  %5 = load %struct.lua_State** %L.addr, align 8
  %top2 = getelementptr inbounds %struct.lua_State* %5, i32 0, i32 4
  %6 = load %struct.lua_TValue** %top2, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %6, i32 1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %top2, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define void @lua_pushlightuserdata(%struct.lua_State* %L, i8* %p) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %p.addr = alloca i8*, align 8
  %io = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %p, i8** %p.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 4
  %1 = load %struct.lua_TValue** %top, align 8
  store %struct.lua_TValue* %1, %struct.lua_TValue** %io, align 8
  %2 = load i8** %p.addr, align 8
  %3 = load %struct.lua_TValue** %io, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %3, i32 0, i32 0
  %p1 = bitcast %union.Value* %value_ to i8**
  store i8* %2, i8** %p1, align 8
  %4 = load %struct.lua_TValue** %io, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %4, i32 0, i32 1
  store i32 2, i32* %tt_, align 4
  %5 = load %struct.lua_State** %L.addr, align 8
  %top2 = getelementptr inbounds %struct.lua_State* %5, i32 0, i32 4
  %6 = load %struct.lua_TValue** %top2, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %6, i32 1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %top2, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @lua_pushthread(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %io = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 4
  %1 = load %struct.lua_TValue** %top, align 8
  store %struct.lua_TValue* %1, %struct.lua_TValue** %io, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = bitcast %struct.lua_State* %2 to %union.GCObject*
  %4 = load %struct.lua_TValue** %io, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %4, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  store %union.GCObject* %3, %union.GCObject** %gc, align 8
  %5 = load %struct.lua_TValue** %io, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %5, i32 0, i32 1
  store i32 72, i32* %tt_, align 4
  %6 = load %struct.lua_State** %L.addr, align 8
  %top1 = getelementptr inbounds %struct.lua_State* %6, i32 0, i32 4
  %7 = load %struct.lua_TValue** %top1, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %7, i32 1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %top1, align 8
  %8 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %8, i32 0, i32 5
  %9 = load %struct.global_State** %l_G, align 8
  %mainthread = getelementptr inbounds %struct.global_State* %9, i32 0, i32 30
  %10 = load %struct.lua_State** %mainthread, align 8
  %11 = load %struct.lua_State** %L.addr, align 8
  %cmp = icmp eq %struct.lua_State* %10, %11
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define void @lua_getglobal(%struct.lua_State* %L, i8* %var) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %var.addr = alloca i8*, align 8
  %reg = alloca %struct.Table*, align 8
  %gt = alloca %struct.lua_TValue*, align 8
  %io = alloca %struct.lua_TValue*, align 8
  %x_ = alloca %union.TString*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %var, i8** %var.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 5
  %1 = load %struct.global_State** %l_G, align 8
  %l_registry = getelementptr inbounds %struct.global_State* %1, i32 0, i32 7
  %value_ = getelementptr inbounds %struct.lua_TValue* %l_registry, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %2 = load %union.GCObject** %gc, align 8
  %h = bitcast %union.GCObject* %2 to %struct.Table*
  store %struct.Table* %h, %struct.Table** %reg, align 8
  %3 = load %struct.Table** %reg, align 8
  %call = call %struct.lua_TValue* @luaH_getint(%struct.Table* %3, i32 2)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %gt, align 8
  %4 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %4, i32 0, i32 4
  %5 = load %struct.lua_TValue** %top, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %5, i32 1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %top, align 8
  store %struct.lua_TValue* %5, %struct.lua_TValue** %io, align 8
  %6 = load %struct.lua_State** %L.addr, align 8
  %7 = load i8** %var.addr, align 8
  %call1 = call %union.TString* bitcast (%union.TString.367* (%struct.lua_State.364*, i8*)* @luaS_new to %union.TString* (%struct.lua_State*, i8*)*)(%struct.lua_State* %6, i8* %7)
  store %union.TString* %call1, %union.TString** %x_, align 8
  %8 = load %union.TString** %x_, align 8
  %9 = bitcast %union.TString* %8 to %union.GCObject*
  %10 = load %struct.lua_TValue** %io, align 8
  %value_2 = getelementptr inbounds %struct.lua_TValue* %10, i32 0, i32 0
  %gc3 = bitcast %union.Value* %value_2 to %union.GCObject**
  store %union.GCObject* %9, %union.GCObject** %gc3, align 8
  %11 = load %union.TString** %x_, align 8
  %tsv = bitcast %union.TString* %11 to %struct.anon.0*
  %tt = getelementptr inbounds %struct.anon.0* %tsv, i32 0, i32 1
  %12 = load i8* %tt, align 1
  %conv = zext i8 %12 to i32
  %or = or i32 %conv, 64
  %13 = load %struct.lua_TValue** %io, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %13, i32 0, i32 1
  store i32 %or, i32* %tt_, align 4
  %14 = load %struct.lua_State** %L.addr, align 8
  %15 = load %struct.lua_TValue** %gt, align 8
  %16 = load %struct.lua_State** %L.addr, align 8
  %top4 = getelementptr inbounds %struct.lua_State* %16, i32 0, i32 4
  %17 = load %struct.lua_TValue** %top4, align 8
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %17, i64 -1
  %18 = load %struct.lua_State** %L.addr, align 8
  %top5 = getelementptr inbounds %struct.lua_State* %18, i32 0, i32 4
  %19 = load %struct.lua_TValue** %top5, align 8
  %add.ptr6 = getelementptr inbounds %struct.lua_TValue* %19, i64 -1
  call void bitcast (void (%struct.lua_State.364*, %struct.lua_TValue.349*, %struct.lua_TValue.349*, %struct.lua_TValue.349*)* @luaV_gettable to void (%struct.lua_State*, %struct.lua_TValue*, %struct.lua_TValue*, %struct.lua_TValue*)*)(%struct.lua_State* %14, %struct.lua_TValue* %15, %struct.lua_TValue* %add.ptr, %struct.lua_TValue* %add.ptr6)
  ret void
}

; Function Attrs: nounwind uwtable
define void @lua_gettable(%struct.lua_State* %L, i32 %idx) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %idx.addr = alloca i32, align 4
  %t = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %idx.addr, align 4
  %call = call %struct.lua_TValue* @index2addr(%struct.lua_State* %0, i32 %1)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %t, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load %struct.lua_TValue** %t, align 8
  %4 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %4, i32 0, i32 4
  %5 = load %struct.lua_TValue** %top, align 8
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %5, i64 -1
  %6 = load %struct.lua_State** %L.addr, align 8
  %top1 = getelementptr inbounds %struct.lua_State* %6, i32 0, i32 4
  %7 = load %struct.lua_TValue** %top1, align 8
  %add.ptr2 = getelementptr inbounds %struct.lua_TValue* %7, i64 -1
  call void bitcast (void (%struct.lua_State.364*, %struct.lua_TValue.349*, %struct.lua_TValue.349*, %struct.lua_TValue.349*)* @luaV_gettable to void (%struct.lua_State*, %struct.lua_TValue*, %struct.lua_TValue*, %struct.lua_TValue*)*)(%struct.lua_State* %2, %struct.lua_TValue* %3, %struct.lua_TValue* %add.ptr, %struct.lua_TValue* %add.ptr2)
  ret void
}

; Function Attrs: nounwind uwtable
define void @lua_getfield(%struct.lua_State* %L, i32 %idx, i8* %k) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %idx.addr = alloca i32, align 4
  %k.addr = alloca i8*, align 8
  %t = alloca %struct.lua_TValue*, align 8
  %io = alloca %struct.lua_TValue*, align 8
  %x_ = alloca %union.TString*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  store i8* %k, i8** %k.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %idx.addr, align 4
  %call = call %struct.lua_TValue* @index2addr(%struct.lua_State* %0, i32 %1)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %t, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %2, i32 0, i32 4
  %3 = load %struct.lua_TValue** %top, align 8
  store %struct.lua_TValue* %3, %struct.lua_TValue** %io, align 8
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load i8** %k.addr, align 8
  %call1 = call %union.TString* bitcast (%union.TString.367* (%struct.lua_State.364*, i8*)* @luaS_new to %union.TString* (%struct.lua_State*, i8*)*)(%struct.lua_State* %4, i8* %5)
  store %union.TString* %call1, %union.TString** %x_, align 8
  %6 = load %union.TString** %x_, align 8
  %7 = bitcast %union.TString* %6 to %union.GCObject*
  %8 = load %struct.lua_TValue** %io, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %8, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  store %union.GCObject* %7, %union.GCObject** %gc, align 8
  %9 = load %union.TString** %x_, align 8
  %tsv = bitcast %union.TString* %9 to %struct.anon.0*
  %tt = getelementptr inbounds %struct.anon.0* %tsv, i32 0, i32 1
  %10 = load i8* %tt, align 1
  %conv = zext i8 %10 to i32
  %or = or i32 %conv, 64
  %11 = load %struct.lua_TValue** %io, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %11, i32 0, i32 1
  store i32 %or, i32* %tt_, align 4
  %12 = load %struct.lua_State** %L.addr, align 8
  %top2 = getelementptr inbounds %struct.lua_State* %12, i32 0, i32 4
  %13 = load %struct.lua_TValue** %top2, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %13, i32 1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %top2, align 8
  %14 = load %struct.lua_State** %L.addr, align 8
  %15 = load %struct.lua_TValue** %t, align 8
  %16 = load %struct.lua_State** %L.addr, align 8
  %top3 = getelementptr inbounds %struct.lua_State* %16, i32 0, i32 4
  %17 = load %struct.lua_TValue** %top3, align 8
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %17, i64 -1
  %18 = load %struct.lua_State** %L.addr, align 8
  %top4 = getelementptr inbounds %struct.lua_State* %18, i32 0, i32 4
  %19 = load %struct.lua_TValue** %top4, align 8
  %add.ptr5 = getelementptr inbounds %struct.lua_TValue* %19, i64 -1
  call void bitcast (void (%struct.lua_State.364*, %struct.lua_TValue.349*, %struct.lua_TValue.349*, %struct.lua_TValue.349*)* @luaV_gettable to void (%struct.lua_State*, %struct.lua_TValue*, %struct.lua_TValue*, %struct.lua_TValue*)*)(%struct.lua_State* %14, %struct.lua_TValue* %15, %struct.lua_TValue* %add.ptr, %struct.lua_TValue* %add.ptr5)
  ret void
}

; Function Attrs: nounwind uwtable
define void @lua_rawget(%struct.lua_State* %L, i32 %idx) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %idx.addr = alloca i32, align 4
  %t = alloca %struct.lua_TValue*, align 8
  %io2 = alloca %struct.lua_TValue*, align 8
  %io1 = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %idx.addr, align 4
  %call = call %struct.lua_TValue* @index2addr(%struct.lua_State* %0, i32 %1)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %t, align 8
  %2 = load %struct.lua_TValue** %t, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %2, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %3 = load %union.GCObject** %gc, align 8
  %h = bitcast %union.GCObject* %3 to %struct.Table*
  %4 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %4, i32 0, i32 4
  %5 = load %struct.lua_TValue** %top, align 8
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %5, i64 -1
  %call1 = call %struct.lua_TValue* @luaH_get(%struct.Table* %h, %struct.lua_TValue* %add.ptr)
  store %struct.lua_TValue* %call1, %struct.lua_TValue** %io2, align 8
  %6 = load %struct.lua_State** %L.addr, align 8
  %top2 = getelementptr inbounds %struct.lua_State* %6, i32 0, i32 4
  %7 = load %struct.lua_TValue** %top2, align 8
  %add.ptr3 = getelementptr inbounds %struct.lua_TValue* %7, i64 -1
  store %struct.lua_TValue* %add.ptr3, %struct.lua_TValue** %io1, align 8
  %8 = load %struct.lua_TValue** %io1, align 8
  %value_4 = getelementptr inbounds %struct.lua_TValue* %8, i32 0, i32 0
  %9 = load %struct.lua_TValue** %io2, align 8
  %value_5 = getelementptr inbounds %struct.lua_TValue* %9, i32 0, i32 0
  %10 = bitcast %union.Value* %value_4 to i8*
  %11 = bitcast %union.Value* %value_5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %10, i8* %11, i64 8, i32 8, i1 false)
  %12 = load %struct.lua_TValue** %io2, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %12, i32 0, i32 1
  %13 = load i32* %tt_, align 4
  %14 = load %struct.lua_TValue** %io1, align 8
  %tt_6 = getelementptr inbounds %struct.lua_TValue* %14, i32 0, i32 1
  store i32 %13, i32* %tt_6, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define void @lua_rawgeti(%struct.lua_State* %L, i32 %idx, i32 %n) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %idx.addr = alloca i32, align 4
  %n.addr = alloca i32, align 4
  %t = alloca %struct.lua_TValue*, align 8
  %io2 = alloca %struct.lua_TValue*, align 8
  %io1 = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  store i32 %n, i32* %n.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %idx.addr, align 4
  %call = call %struct.lua_TValue* @index2addr(%struct.lua_State* %0, i32 %1)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %t, align 8
  %2 = load %struct.lua_TValue** %t, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %2, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %3 = load %union.GCObject** %gc, align 8
  %h = bitcast %union.GCObject* %3 to %struct.Table*
  %4 = load i32* %n.addr, align 4
  %call1 = call %struct.lua_TValue* @luaH_getint(%struct.Table* %h, i32 %4)
  store %struct.lua_TValue* %call1, %struct.lua_TValue** %io2, align 8
  %5 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %5, i32 0, i32 4
  %6 = load %struct.lua_TValue** %top, align 8
  store %struct.lua_TValue* %6, %struct.lua_TValue** %io1, align 8
  %7 = load %struct.lua_TValue** %io1, align 8
  %value_2 = getelementptr inbounds %struct.lua_TValue* %7, i32 0, i32 0
  %8 = load %struct.lua_TValue** %io2, align 8
  %value_3 = getelementptr inbounds %struct.lua_TValue* %8, i32 0, i32 0
  %9 = bitcast %union.Value* %value_2 to i8*
  %10 = bitcast %union.Value* %value_3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %9, i8* %10, i64 8, i32 8, i1 false)
  %11 = load %struct.lua_TValue** %io2, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %11, i32 0, i32 1
  %12 = load i32* %tt_, align 4
  %13 = load %struct.lua_TValue** %io1, align 8
  %tt_4 = getelementptr inbounds %struct.lua_TValue* %13, i32 0, i32 1
  store i32 %12, i32* %tt_4, align 4
  %14 = load %struct.lua_State** %L.addr, align 8
  %top5 = getelementptr inbounds %struct.lua_State* %14, i32 0, i32 4
  %15 = load %struct.lua_TValue** %top5, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %15, i32 1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %top5, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define void @lua_rawgetp(%struct.lua_State* %L, i32 %idx, i8* %p) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %idx.addr = alloca i32, align 4
  %p.addr = alloca i8*, align 8
  %t = alloca %struct.lua_TValue*, align 8
  %k = alloca %struct.lua_TValue, align 8
  %io = alloca %struct.lua_TValue*, align 8
  %io2 = alloca %struct.lua_TValue*, align 8
  %io1 = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  store i8* %p, i8** %p.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %idx.addr, align 4
  %call = call %struct.lua_TValue* @index2addr(%struct.lua_State* %0, i32 %1)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %t, align 8
  store %struct.lua_TValue* %k, %struct.lua_TValue** %io, align 8
  %2 = load i8** %p.addr, align 8
  %3 = load %struct.lua_TValue** %io, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %3, i32 0, i32 0
  %p1 = bitcast %union.Value* %value_ to i8**
  store i8* %2, i8** %p1, align 8
  %4 = load %struct.lua_TValue** %io, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %4, i32 0, i32 1
  store i32 2, i32* %tt_, align 4
  %5 = load %struct.lua_TValue** %t, align 8
  %value_2 = getelementptr inbounds %struct.lua_TValue* %5, i32 0, i32 0
  %gc = bitcast %union.Value* %value_2 to %union.GCObject**
  %6 = load %union.GCObject** %gc, align 8
  %h = bitcast %union.GCObject* %6 to %struct.Table*
  %call3 = call %struct.lua_TValue* @luaH_get(%struct.Table* %h, %struct.lua_TValue* %k)
  store %struct.lua_TValue* %call3, %struct.lua_TValue** %io2, align 8
  %7 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %7, i32 0, i32 4
  %8 = load %struct.lua_TValue** %top, align 8
  store %struct.lua_TValue* %8, %struct.lua_TValue** %io1, align 8
  %9 = load %struct.lua_TValue** %io1, align 8
  %value_4 = getelementptr inbounds %struct.lua_TValue* %9, i32 0, i32 0
  %10 = load %struct.lua_TValue** %io2, align 8
  %value_5 = getelementptr inbounds %struct.lua_TValue* %10, i32 0, i32 0
  %11 = bitcast %union.Value* %value_4 to i8*
  %12 = bitcast %union.Value* %value_5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %11, i8* %12, i64 8, i32 8, i1 false)
  %13 = load %struct.lua_TValue** %io2, align 8
  %tt_6 = getelementptr inbounds %struct.lua_TValue* %13, i32 0, i32 1
  %14 = load i32* %tt_6, align 4
  %15 = load %struct.lua_TValue** %io1, align 8
  %tt_7 = getelementptr inbounds %struct.lua_TValue* %15, i32 0, i32 1
  store i32 %14, i32* %tt_7, align 4
  %16 = load %struct.lua_State** %L.addr, align 8
  %top8 = getelementptr inbounds %struct.lua_State* %16, i32 0, i32 4
  %17 = load %struct.lua_TValue** %top8, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %17, i32 1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %top8, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define void @lua_createtable(%struct.lua_State* %L, i32 %narray, i32 %nrec) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %narray.addr = alloca i32, align 4
  %nrec.addr = alloca i32, align 4
  %t = alloca %struct.Table*, align 8
  %io = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %narray, i32* %narray.addr, align 4
  store i32 %nrec, i32* %nrec.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 5
  %1 = load %struct.global_State** %l_G, align 8
  %GCdebt = getelementptr inbounds %struct.global_State* %1, i32 0, i32 3
  %2 = load i64* %GCdebt, align 8
  %cmp = icmp sgt i64 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load %struct.lua_State** %L.addr, align 8
  call void @luaC_step(%struct.lua_State* %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load %struct.lua_State** %L.addr, align 8
  %call = call %struct.Table* @luaH_new(%struct.lua_State* %4)
  store %struct.Table* %call, %struct.Table** %t, align 8
  %5 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %5, i32 0, i32 4
  %6 = load %struct.lua_TValue** %top, align 8
  store %struct.lua_TValue* %6, %struct.lua_TValue** %io, align 8
  %7 = load %struct.Table** %t, align 8
  %8 = bitcast %struct.Table* %7 to %union.GCObject*
  %9 = load %struct.lua_TValue** %io, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %9, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  store %union.GCObject* %8, %union.GCObject** %gc, align 8
  %10 = load %struct.lua_TValue** %io, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %10, i32 0, i32 1
  store i32 69, i32* %tt_, align 4
  %11 = load %struct.lua_State** %L.addr, align 8
  %top1 = getelementptr inbounds %struct.lua_State* %11, i32 0, i32 4
  %12 = load %struct.lua_TValue** %top1, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %12, i32 1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %top1, align 8
  %13 = load i32* %narray.addr, align 4
  %cmp2 = icmp sgt i32 %13, 0
  br i1 %cmp2, label %if.then4, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %14 = load i32* %nrec.addr, align 4
  %cmp3 = icmp sgt i32 %14, 0
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %lor.lhs.false, %if.end
  %15 = load %struct.lua_State** %L.addr, align 8
  %16 = load %struct.Table** %t, align 8
  %17 = load i32* %narray.addr, align 4
  %18 = load i32* %nrec.addr, align 4
  call void @luaH_resize(%struct.lua_State* %15, %struct.Table* %16, i32 %17, i32 %18)
  br label %if.end5

if.end5:                                          ; preds = %if.then4, %lor.lhs.false
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @lua_getmetatable(%struct.lua_State* %L, i32 %objindex) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %objindex.addr = alloca i32, align 4
  %obj = alloca %struct.lua_TValue*, align 8
  %mt = alloca %struct.Table*, align 8
  %res = alloca i32, align 4
  %io = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %objindex, i32* %objindex.addr, align 4
  store %struct.Table* null, %struct.Table** %mt, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %objindex.addr, align 4
  %call = call %struct.lua_TValue* @index2addr(%struct.lua_State* %0, i32 %1)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %obj, align 8
  %2 = load %struct.lua_TValue** %obj, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %2, i32 0, i32 1
  %3 = load i32* %tt_, align 4
  %and = and i32 %3, 15
  switch i32 %and, label %sw.default [
    i32 5, label %sw.bb
    i32 7, label %sw.bb1
  ]

sw.bb:                                            ; preds = %entry
  %4 = load %struct.lua_TValue** %obj, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %4, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %5 = load %union.GCObject** %gc, align 8
  %h = bitcast %union.GCObject* %5 to %struct.Table*
  %metatable = getelementptr inbounds %struct.Table* %h, i32 0, i32 5
  %6 = load %struct.Table** %metatable, align 8
  store %struct.Table* %6, %struct.Table** %mt, align 8
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  %7 = load %struct.lua_TValue** %obj, align 8
  %value_2 = getelementptr inbounds %struct.lua_TValue* %7, i32 0, i32 0
  %gc3 = bitcast %union.Value* %value_2 to %union.GCObject**
  %8 = load %union.GCObject** %gc3, align 8
  %u = bitcast %union.GCObject* %8 to %union.Udata*
  %uv = bitcast %union.Udata* %u to %struct.anon.5*
  %metatable4 = getelementptr inbounds %struct.anon.5* %uv, i32 0, i32 3
  %9 = load %struct.Table** %metatable4, align 8
  store %struct.Table* %9, %struct.Table** %mt, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %10 = load %struct.lua_TValue** %obj, align 8
  %tt_5 = getelementptr inbounds %struct.lua_TValue* %10, i32 0, i32 1
  %11 = load i32* %tt_5, align 4
  %and6 = and i32 %11, 15
  %idxprom = sext i32 %and6 to i64
  %12 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %12, i32 0, i32 5
  %13 = load %struct.global_State** %l_G, align 8
  %mt7 = getelementptr inbounds %struct.global_State* %13, i32 0, i32 34
  %arrayidx = getelementptr inbounds [9 x %struct.Table*]* %mt7, i32 0, i64 %idxprom
  %14 = load %struct.Table** %arrayidx, align 8
  store %struct.Table* %14, %struct.Table** %mt, align 8
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb1, %sw.bb
  %15 = load %struct.Table** %mt, align 8
  %cmp = icmp eq %struct.Table* %15, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %sw.epilog
  store i32 0, i32* %res, align 4
  br label %if.end

if.else:                                          ; preds = %sw.epilog
  %16 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %16, i32 0, i32 4
  %17 = load %struct.lua_TValue** %top, align 8
  store %struct.lua_TValue* %17, %struct.lua_TValue** %io, align 8
  %18 = load %struct.Table** %mt, align 8
  %19 = bitcast %struct.Table* %18 to %union.GCObject*
  %20 = load %struct.lua_TValue** %io, align 8
  %value_8 = getelementptr inbounds %struct.lua_TValue* %20, i32 0, i32 0
  %gc9 = bitcast %union.Value* %value_8 to %union.GCObject**
  store %union.GCObject* %19, %union.GCObject** %gc9, align 8
  %21 = load %struct.lua_TValue** %io, align 8
  %tt_10 = getelementptr inbounds %struct.lua_TValue* %21, i32 0, i32 1
  store i32 69, i32* %tt_10, align 4
  %22 = load %struct.lua_State** %L.addr, align 8
  %top11 = getelementptr inbounds %struct.lua_State* %22, i32 0, i32 4
  %23 = load %struct.lua_TValue** %top11, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %23, i32 1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %top11, align 8
  store i32 1, i32* %res, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %24 = load i32* %res, align 4
  ret i32 %24
}

; Function Attrs: nounwind uwtable
define void @lua_getuservalue(%struct.lua_State* %L, i32 %idx) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %idx.addr = alloca i32, align 4
  %o = alloca %struct.lua_TValue*, align 8
  %io = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %idx.addr, align 4
  %call = call %struct.lua_TValue* @index2addr(%struct.lua_State* %0, i32 %1)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %o, align 8
  %2 = load %struct.lua_TValue** %o, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %2, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %3 = load %union.GCObject** %gc, align 8
  %u = bitcast %union.GCObject* %3 to %union.Udata*
  %uv = bitcast %union.Udata* %u to %struct.anon.5*
  %env = getelementptr inbounds %struct.anon.5* %uv, i32 0, i32 4
  %4 = load %struct.Table** %env, align 8
  %tobool = icmp ne %struct.Table* %4, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %5 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %5, i32 0, i32 4
  %6 = load %struct.lua_TValue** %top, align 8
  store %struct.lua_TValue* %6, %struct.lua_TValue** %io, align 8
  %7 = load %struct.lua_TValue** %o, align 8
  %value_1 = getelementptr inbounds %struct.lua_TValue* %7, i32 0, i32 0
  %gc2 = bitcast %union.Value* %value_1 to %union.GCObject**
  %8 = load %union.GCObject** %gc2, align 8
  %u3 = bitcast %union.GCObject* %8 to %union.Udata*
  %uv4 = bitcast %union.Udata* %u3 to %struct.anon.5*
  %env5 = getelementptr inbounds %struct.anon.5* %uv4, i32 0, i32 4
  %9 = load %struct.Table** %env5, align 8
  %10 = bitcast %struct.Table* %9 to %union.GCObject*
  %11 = load %struct.lua_TValue** %io, align 8
  %value_6 = getelementptr inbounds %struct.lua_TValue* %11, i32 0, i32 0
  %gc7 = bitcast %union.Value* %value_6 to %union.GCObject**
  store %union.GCObject* %10, %union.GCObject** %gc7, align 8
  %12 = load %struct.lua_TValue** %io, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %12, i32 0, i32 1
  store i32 69, i32* %tt_, align 4
  br label %if.end

if.else:                                          ; preds = %entry
  %13 = load %struct.lua_State** %L.addr, align 8
  %top8 = getelementptr inbounds %struct.lua_State* %13, i32 0, i32 4
  %14 = load %struct.lua_TValue** %top8, align 8
  %tt_9 = getelementptr inbounds %struct.lua_TValue* %14, i32 0, i32 1
  store i32 0, i32* %tt_9, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %15 = load %struct.lua_State** %L.addr, align 8
  %top10 = getelementptr inbounds %struct.lua_State* %15, i32 0, i32 4
  %16 = load %struct.lua_TValue** %top10, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %16, i32 1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %top10, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define void @lua_setglobal(%struct.lua_State* %L, i8* %var) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %var.addr = alloca i8*, align 8
  %reg = alloca %struct.Table*, align 8
  %gt = alloca %struct.lua_TValue*, align 8
  %io = alloca %struct.lua_TValue*, align 8
  %x_ = alloca %union.TString*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %var, i8** %var.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 5
  %1 = load %struct.global_State** %l_G, align 8
  %l_registry = getelementptr inbounds %struct.global_State* %1, i32 0, i32 7
  %value_ = getelementptr inbounds %struct.lua_TValue* %l_registry, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %2 = load %union.GCObject** %gc, align 8
  %h = bitcast %union.GCObject* %2 to %struct.Table*
  store %struct.Table* %h, %struct.Table** %reg, align 8
  %3 = load %struct.Table** %reg, align 8
  %call = call %struct.lua_TValue* @luaH_getint(%struct.Table* %3, i32 2)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %gt, align 8
  %4 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %4, i32 0, i32 4
  %5 = load %struct.lua_TValue** %top, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %5, i32 1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %top, align 8
  store %struct.lua_TValue* %5, %struct.lua_TValue** %io, align 8
  %6 = load %struct.lua_State** %L.addr, align 8
  %7 = load i8** %var.addr, align 8
  %call1 = call %union.TString* bitcast (%union.TString.367* (%struct.lua_State.364*, i8*)* @luaS_new to %union.TString* (%struct.lua_State*, i8*)*)(%struct.lua_State* %6, i8* %7)
  store %union.TString* %call1, %union.TString** %x_, align 8
  %8 = load %union.TString** %x_, align 8
  %9 = bitcast %union.TString* %8 to %union.GCObject*
  %10 = load %struct.lua_TValue** %io, align 8
  %value_2 = getelementptr inbounds %struct.lua_TValue* %10, i32 0, i32 0
  %gc3 = bitcast %union.Value* %value_2 to %union.GCObject**
  store %union.GCObject* %9, %union.GCObject** %gc3, align 8
  %11 = load %union.TString** %x_, align 8
  %tsv = bitcast %union.TString* %11 to %struct.anon.0*
  %tt = getelementptr inbounds %struct.anon.0* %tsv, i32 0, i32 1
  %12 = load i8* %tt, align 1
  %conv = zext i8 %12 to i32
  %or = or i32 %conv, 64
  %13 = load %struct.lua_TValue** %io, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %13, i32 0, i32 1
  store i32 %or, i32* %tt_, align 4
  %14 = load %struct.lua_State** %L.addr, align 8
  %15 = load %struct.lua_TValue** %gt, align 8
  %16 = load %struct.lua_State** %L.addr, align 8
  %top4 = getelementptr inbounds %struct.lua_State* %16, i32 0, i32 4
  %17 = load %struct.lua_TValue** %top4, align 8
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %17, i64 -1
  %18 = load %struct.lua_State** %L.addr, align 8
  %top5 = getelementptr inbounds %struct.lua_State* %18, i32 0, i32 4
  %19 = load %struct.lua_TValue** %top5, align 8
  %add.ptr6 = getelementptr inbounds %struct.lua_TValue* %19, i64 -2
  call void bitcast (void (%struct.lua_State.364*, %struct.lua_TValue.349*, %struct.lua_TValue.349*, %struct.lua_TValue.349*)* @luaV_settable to void (%struct.lua_State*, %struct.lua_TValue*, %struct.lua_TValue*, %struct.lua_TValue*)*)(%struct.lua_State* %14, %struct.lua_TValue* %15, %struct.lua_TValue* %add.ptr, %struct.lua_TValue* %add.ptr6)
  %20 = load %struct.lua_State** %L.addr, align 8
  %top7 = getelementptr inbounds %struct.lua_State* %20, i32 0, i32 4
  %21 = load %struct.lua_TValue** %top7, align 8
  %add.ptr8 = getelementptr inbounds %struct.lua_TValue* %21, i64 -2
  store %struct.lua_TValue* %add.ptr8, %struct.lua_TValue** %top7, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define void @lua_settable(%struct.lua_State* %L, i32 %idx) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %idx.addr = alloca i32, align 4
  %t = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %idx.addr, align 4
  %call = call %struct.lua_TValue* @index2addr(%struct.lua_State* %0, i32 %1)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %t, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load %struct.lua_TValue** %t, align 8
  %4 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %4, i32 0, i32 4
  %5 = load %struct.lua_TValue** %top, align 8
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %5, i64 -2
  %6 = load %struct.lua_State** %L.addr, align 8
  %top1 = getelementptr inbounds %struct.lua_State* %6, i32 0, i32 4
  %7 = load %struct.lua_TValue** %top1, align 8
  %add.ptr2 = getelementptr inbounds %struct.lua_TValue* %7, i64 -1
  call void bitcast (void (%struct.lua_State.364*, %struct.lua_TValue.349*, %struct.lua_TValue.349*, %struct.lua_TValue.349*)* @luaV_settable to void (%struct.lua_State*, %struct.lua_TValue*, %struct.lua_TValue*, %struct.lua_TValue*)*)(%struct.lua_State* %2, %struct.lua_TValue* %3, %struct.lua_TValue* %add.ptr, %struct.lua_TValue* %add.ptr2)
  %8 = load %struct.lua_State** %L.addr, align 8
  %top3 = getelementptr inbounds %struct.lua_State* %8, i32 0, i32 4
  %9 = load %struct.lua_TValue** %top3, align 8
  %add.ptr4 = getelementptr inbounds %struct.lua_TValue* %9, i64 -2
  store %struct.lua_TValue* %add.ptr4, %struct.lua_TValue** %top3, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define void @lua_setfield(%struct.lua_State* %L, i32 %idx, i8* %k) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %idx.addr = alloca i32, align 4
  %k.addr = alloca i8*, align 8
  %t = alloca %struct.lua_TValue*, align 8
  %io = alloca %struct.lua_TValue*, align 8
  %x_ = alloca %union.TString*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  store i8* %k, i8** %k.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %idx.addr, align 4
  %call = call %struct.lua_TValue* @index2addr(%struct.lua_State* %0, i32 %1)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %t, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %2, i32 0, i32 4
  %3 = load %struct.lua_TValue** %top, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %3, i32 1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %top, align 8
  store %struct.lua_TValue* %3, %struct.lua_TValue** %io, align 8
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load i8** %k.addr, align 8
  %call1 = call %union.TString* bitcast (%union.TString.367* (%struct.lua_State.364*, i8*)* @luaS_new to %union.TString* (%struct.lua_State*, i8*)*)(%struct.lua_State* %4, i8* %5)
  store %union.TString* %call1, %union.TString** %x_, align 8
  %6 = load %union.TString** %x_, align 8
  %7 = bitcast %union.TString* %6 to %union.GCObject*
  %8 = load %struct.lua_TValue** %io, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %8, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  store %union.GCObject* %7, %union.GCObject** %gc, align 8
  %9 = load %union.TString** %x_, align 8
  %tsv = bitcast %union.TString* %9 to %struct.anon.0*
  %tt = getelementptr inbounds %struct.anon.0* %tsv, i32 0, i32 1
  %10 = load i8* %tt, align 1
  %conv = zext i8 %10 to i32
  %or = or i32 %conv, 64
  %11 = load %struct.lua_TValue** %io, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %11, i32 0, i32 1
  store i32 %or, i32* %tt_, align 4
  %12 = load %struct.lua_State** %L.addr, align 8
  %13 = load %struct.lua_TValue** %t, align 8
  %14 = load %struct.lua_State** %L.addr, align 8
  %top2 = getelementptr inbounds %struct.lua_State* %14, i32 0, i32 4
  %15 = load %struct.lua_TValue** %top2, align 8
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %15, i64 -1
  %16 = load %struct.lua_State** %L.addr, align 8
  %top3 = getelementptr inbounds %struct.lua_State* %16, i32 0, i32 4
  %17 = load %struct.lua_TValue** %top3, align 8
  %add.ptr4 = getelementptr inbounds %struct.lua_TValue* %17, i64 -2
  call void bitcast (void (%struct.lua_State.364*, %struct.lua_TValue.349*, %struct.lua_TValue.349*, %struct.lua_TValue.349*)* @luaV_settable to void (%struct.lua_State*, %struct.lua_TValue*, %struct.lua_TValue*, %struct.lua_TValue*)*)(%struct.lua_State* %12, %struct.lua_TValue* %13, %struct.lua_TValue* %add.ptr, %struct.lua_TValue* %add.ptr4)
  %18 = load %struct.lua_State** %L.addr, align 8
  %top5 = getelementptr inbounds %struct.lua_State* %18, i32 0, i32 4
  %19 = load %struct.lua_TValue** %top5, align 8
  %add.ptr6 = getelementptr inbounds %struct.lua_TValue* %19, i64 -2
  store %struct.lua_TValue* %add.ptr6, %struct.lua_TValue** %top5, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define void @lua_rawset(%struct.lua_State* %L, i32 %idx) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %idx.addr = alloca i32, align 4
  %t = alloca %struct.lua_TValue*, align 8
  %io2 = alloca %struct.lua_TValue*, align 8
  %io1 = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %idx.addr, align 4
  %call = call %struct.lua_TValue* @index2addr(%struct.lua_State* %0, i32 %1)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %t, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %2, i32 0, i32 4
  %3 = load %struct.lua_TValue** %top, align 8
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %3, i64 -1
  store %struct.lua_TValue* %add.ptr, %struct.lua_TValue** %io2, align 8
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load %struct.lua_TValue** %t, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %5, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %6 = load %union.GCObject** %gc, align 8
  %h = bitcast %union.GCObject* %6 to %struct.Table*
  %7 = load %struct.lua_State** %L.addr, align 8
  %top1 = getelementptr inbounds %struct.lua_State* %7, i32 0, i32 4
  %8 = load %struct.lua_TValue** %top1, align 8
  %add.ptr2 = getelementptr inbounds %struct.lua_TValue* %8, i64 -2
  %call3 = call %struct.lua_TValue* @luaH_set(%struct.lua_State* %4, %struct.Table* %h, %struct.lua_TValue* %add.ptr2)
  store %struct.lua_TValue* %call3, %struct.lua_TValue** %io1, align 8
  %9 = load %struct.lua_TValue** %io1, align 8
  %value_4 = getelementptr inbounds %struct.lua_TValue* %9, i32 0, i32 0
  %10 = load %struct.lua_TValue** %io2, align 8
  %value_5 = getelementptr inbounds %struct.lua_TValue* %10, i32 0, i32 0
  %11 = bitcast %union.Value* %value_4 to i8*
  %12 = bitcast %union.Value* %value_5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %11, i8* %12, i64 8, i32 8, i1 false)
  %13 = load %struct.lua_TValue** %io2, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %13, i32 0, i32 1
  %14 = load i32* %tt_, align 4
  %15 = load %struct.lua_TValue** %io1, align 8
  %tt_6 = getelementptr inbounds %struct.lua_TValue* %15, i32 0, i32 1
  store i32 %14, i32* %tt_6, align 4
  %16 = load %struct.lua_TValue** %t, align 8
  %value_7 = getelementptr inbounds %struct.lua_TValue* %16, i32 0, i32 0
  %gc8 = bitcast %union.Value* %value_7 to %union.GCObject**
  %17 = load %union.GCObject** %gc8, align 8
  %h9 = bitcast %union.GCObject* %17 to %struct.Table*
  %flags = getelementptr inbounds %struct.Table* %h9, i32 0, i32 3
  store i8 0, i8* %flags, align 1
  %18 = load %struct.lua_State** %L.addr, align 8
  %top10 = getelementptr inbounds %struct.lua_State* %18, i32 0, i32 4
  %19 = load %struct.lua_TValue** %top10, align 8
  %add.ptr11 = getelementptr inbounds %struct.lua_TValue* %19, i64 -1
  %tt_12 = getelementptr inbounds %struct.lua_TValue* %add.ptr11, i32 0, i32 1
  %20 = load i32* %tt_12, align 4
  %and = and i32 %20, 64
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %21 = load %struct.lua_State** %L.addr, align 8
  %top13 = getelementptr inbounds %struct.lua_State* %21, i32 0, i32 4
  %22 = load %struct.lua_TValue** %top13, align 8
  %add.ptr14 = getelementptr inbounds %struct.lua_TValue* %22, i64 -1
  %value_15 = getelementptr inbounds %struct.lua_TValue* %add.ptr14, i32 0, i32 0
  %gc16 = bitcast %union.Value* %value_15 to %union.GCObject**
  %23 = load %union.GCObject** %gc16, align 8
  %gch = bitcast %union.GCObject* %23 to %struct.GCheader*
  %marked = getelementptr inbounds %struct.GCheader* %gch, i32 0, i32 2
  %24 = load i8* %marked, align 1
  %conv = zext i8 %24 to i32
  %and17 = and i32 %conv, 3
  %tobool18 = icmp ne i32 %and17, 0
  br i1 %tobool18, label %land.lhs.true19, label %if.end

land.lhs.true19:                                  ; preds = %land.lhs.true
  %25 = load %struct.lua_TValue** %t, align 8
  %value_20 = getelementptr inbounds %struct.lua_TValue* %25, i32 0, i32 0
  %gc21 = bitcast %union.Value* %value_20 to %union.GCObject**
  %26 = load %union.GCObject** %gc21, align 8
  %gch22 = bitcast %union.GCObject* %26 to %struct.GCheader*
  %marked23 = getelementptr inbounds %struct.GCheader* %gch22, i32 0, i32 2
  %27 = load i8* %marked23, align 1
  %conv24 = zext i8 %27 to i32
  %and25 = and i32 %conv24, 4
  %tobool26 = icmp ne i32 %and25, 0
  br i1 %tobool26, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true19
  %28 = load %struct.lua_State** %L.addr, align 8
  %29 = load %struct.lua_TValue** %t, align 8
  %value_27 = getelementptr inbounds %struct.lua_TValue* %29, i32 0, i32 0
  %gc28 = bitcast %union.Value* %value_27 to %union.GCObject**
  %30 = load %union.GCObject** %gc28, align 8
  call void @luaC_barrierback_(%struct.lua_State* %28, %union.GCObject* %30)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true19, %land.lhs.true, %entry
  %31 = load %struct.lua_State** %L.addr, align 8
  %top29 = getelementptr inbounds %struct.lua_State* %31, i32 0, i32 4
  %32 = load %struct.lua_TValue** %top29, align 8
  %add.ptr30 = getelementptr inbounds %struct.lua_TValue* %32, i64 -2
  store %struct.lua_TValue* %add.ptr30, %struct.lua_TValue** %top29, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define void @lua_rawseti(%struct.lua_State* %L, i32 %idx, i32 %n) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %idx.addr = alloca i32, align 4
  %n.addr = alloca i32, align 4
  %t = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  store i32 %n, i32* %n.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %idx.addr, align 4
  %call = call %struct.lua_TValue* @index2addr(%struct.lua_State* %0, i32 %1)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %t, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load %struct.lua_TValue** %t, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %3, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %4 = load %union.GCObject** %gc, align 8
  %h = bitcast %union.GCObject* %4 to %struct.Table*
  %5 = load i32* %n.addr, align 4
  %6 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %6, i32 0, i32 4
  %7 = load %struct.lua_TValue** %top, align 8
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %7, i64 -1
  call void @luaH_setint(%struct.lua_State* %2, %struct.Table* %h, i32 %5, %struct.lua_TValue* %add.ptr)
  %8 = load %struct.lua_State** %L.addr, align 8
  %top1 = getelementptr inbounds %struct.lua_State* %8, i32 0, i32 4
  %9 = load %struct.lua_TValue** %top1, align 8
  %add.ptr2 = getelementptr inbounds %struct.lua_TValue* %9, i64 -1
  %tt_ = getelementptr inbounds %struct.lua_TValue* %add.ptr2, i32 0, i32 1
  %10 = load i32* %tt_, align 4
  %and = and i32 %10, 64
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %11 = load %struct.lua_State** %L.addr, align 8
  %top3 = getelementptr inbounds %struct.lua_State* %11, i32 0, i32 4
  %12 = load %struct.lua_TValue** %top3, align 8
  %add.ptr4 = getelementptr inbounds %struct.lua_TValue* %12, i64 -1
  %value_5 = getelementptr inbounds %struct.lua_TValue* %add.ptr4, i32 0, i32 0
  %gc6 = bitcast %union.Value* %value_5 to %union.GCObject**
  %13 = load %union.GCObject** %gc6, align 8
  %gch = bitcast %union.GCObject* %13 to %struct.GCheader*
  %marked = getelementptr inbounds %struct.GCheader* %gch, i32 0, i32 2
  %14 = load i8* %marked, align 1
  %conv = zext i8 %14 to i32
  %and7 = and i32 %conv, 3
  %tobool8 = icmp ne i32 %and7, 0
  br i1 %tobool8, label %land.lhs.true9, label %if.end

land.lhs.true9:                                   ; preds = %land.lhs.true
  %15 = load %struct.lua_TValue** %t, align 8
  %value_10 = getelementptr inbounds %struct.lua_TValue* %15, i32 0, i32 0
  %gc11 = bitcast %union.Value* %value_10 to %union.GCObject**
  %16 = load %union.GCObject** %gc11, align 8
  %gch12 = bitcast %union.GCObject* %16 to %struct.GCheader*
  %marked13 = getelementptr inbounds %struct.GCheader* %gch12, i32 0, i32 2
  %17 = load i8* %marked13, align 1
  %conv14 = zext i8 %17 to i32
  %and15 = and i32 %conv14, 4
  %tobool16 = icmp ne i32 %and15, 0
  br i1 %tobool16, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true9
  %18 = load %struct.lua_State** %L.addr, align 8
  %19 = load %struct.lua_TValue** %t, align 8
  %value_17 = getelementptr inbounds %struct.lua_TValue* %19, i32 0, i32 0
  %gc18 = bitcast %union.Value* %value_17 to %union.GCObject**
  %20 = load %union.GCObject** %gc18, align 8
  call void @luaC_barrierback_(%struct.lua_State* %18, %union.GCObject* %20)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true9, %land.lhs.true, %entry
  %21 = load %struct.lua_State** %L.addr, align 8
  %top19 = getelementptr inbounds %struct.lua_State* %21, i32 0, i32 4
  %22 = load %struct.lua_TValue** %top19, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %22, i32 -1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %top19, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define void @lua_rawsetp(%struct.lua_State* %L, i32 %idx, i8* %p) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %idx.addr = alloca i32, align 4
  %p.addr = alloca i8*, align 8
  %t = alloca %struct.lua_TValue*, align 8
  %k = alloca %struct.lua_TValue, align 8
  %io = alloca %struct.lua_TValue*, align 8
  %io2 = alloca %struct.lua_TValue*, align 8
  %io1 = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  store i8* %p, i8** %p.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %idx.addr, align 4
  %call = call %struct.lua_TValue* @index2addr(%struct.lua_State* %0, i32 %1)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %t, align 8
  store %struct.lua_TValue* %k, %struct.lua_TValue** %io, align 8
  %2 = load i8** %p.addr, align 8
  %3 = load %struct.lua_TValue** %io, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %3, i32 0, i32 0
  %p1 = bitcast %union.Value* %value_ to i8**
  store i8* %2, i8** %p1, align 8
  %4 = load %struct.lua_TValue** %io, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %4, i32 0, i32 1
  store i32 2, i32* %tt_, align 4
  %5 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %5, i32 0, i32 4
  %6 = load %struct.lua_TValue** %top, align 8
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %6, i64 -1
  store %struct.lua_TValue* %add.ptr, %struct.lua_TValue** %io2, align 8
  %7 = load %struct.lua_State** %L.addr, align 8
  %8 = load %struct.lua_TValue** %t, align 8
  %value_2 = getelementptr inbounds %struct.lua_TValue* %8, i32 0, i32 0
  %gc = bitcast %union.Value* %value_2 to %union.GCObject**
  %9 = load %union.GCObject** %gc, align 8
  %h = bitcast %union.GCObject* %9 to %struct.Table*
  %call3 = call %struct.lua_TValue* @luaH_set(%struct.lua_State* %7, %struct.Table* %h, %struct.lua_TValue* %k)
  store %struct.lua_TValue* %call3, %struct.lua_TValue** %io1, align 8
  %10 = load %struct.lua_TValue** %io1, align 8
  %value_4 = getelementptr inbounds %struct.lua_TValue* %10, i32 0, i32 0
  %11 = load %struct.lua_TValue** %io2, align 8
  %value_5 = getelementptr inbounds %struct.lua_TValue* %11, i32 0, i32 0
  %12 = bitcast %union.Value* %value_4 to i8*
  %13 = bitcast %union.Value* %value_5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %12, i8* %13, i64 8, i32 8, i1 false)
  %14 = load %struct.lua_TValue** %io2, align 8
  %tt_6 = getelementptr inbounds %struct.lua_TValue* %14, i32 0, i32 1
  %15 = load i32* %tt_6, align 4
  %16 = load %struct.lua_TValue** %io1, align 8
  %tt_7 = getelementptr inbounds %struct.lua_TValue* %16, i32 0, i32 1
  store i32 %15, i32* %tt_7, align 4
  %17 = load %struct.lua_State** %L.addr, align 8
  %top8 = getelementptr inbounds %struct.lua_State* %17, i32 0, i32 4
  %18 = load %struct.lua_TValue** %top8, align 8
  %add.ptr9 = getelementptr inbounds %struct.lua_TValue* %18, i64 -1
  %tt_10 = getelementptr inbounds %struct.lua_TValue* %add.ptr9, i32 0, i32 1
  %19 = load i32* %tt_10, align 4
  %and = and i32 %19, 64
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %20 = load %struct.lua_State** %L.addr, align 8
  %top11 = getelementptr inbounds %struct.lua_State* %20, i32 0, i32 4
  %21 = load %struct.lua_TValue** %top11, align 8
  %add.ptr12 = getelementptr inbounds %struct.lua_TValue* %21, i64 -1
  %value_13 = getelementptr inbounds %struct.lua_TValue* %add.ptr12, i32 0, i32 0
  %gc14 = bitcast %union.Value* %value_13 to %union.GCObject**
  %22 = load %union.GCObject** %gc14, align 8
  %gch = bitcast %union.GCObject* %22 to %struct.GCheader*
  %marked = getelementptr inbounds %struct.GCheader* %gch, i32 0, i32 2
  %23 = load i8* %marked, align 1
  %conv = zext i8 %23 to i32
  %and15 = and i32 %conv, 3
  %tobool16 = icmp ne i32 %and15, 0
  br i1 %tobool16, label %land.lhs.true17, label %if.end

land.lhs.true17:                                  ; preds = %land.lhs.true
  %24 = load %struct.lua_TValue** %t, align 8
  %value_18 = getelementptr inbounds %struct.lua_TValue* %24, i32 0, i32 0
  %gc19 = bitcast %union.Value* %value_18 to %union.GCObject**
  %25 = load %union.GCObject** %gc19, align 8
  %gch20 = bitcast %union.GCObject* %25 to %struct.GCheader*
  %marked21 = getelementptr inbounds %struct.GCheader* %gch20, i32 0, i32 2
  %26 = load i8* %marked21, align 1
  %conv22 = zext i8 %26 to i32
  %and23 = and i32 %conv22, 4
  %tobool24 = icmp ne i32 %and23, 0
  br i1 %tobool24, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true17
  %27 = load %struct.lua_State** %L.addr, align 8
  %28 = load %struct.lua_TValue** %t, align 8
  %value_25 = getelementptr inbounds %struct.lua_TValue* %28, i32 0, i32 0
  %gc26 = bitcast %union.Value* %value_25 to %union.GCObject**
  %29 = load %union.GCObject** %gc26, align 8
  call void @luaC_barrierback_(%struct.lua_State* %27, %union.GCObject* %29)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true17, %land.lhs.true, %entry
  %30 = load %struct.lua_State** %L.addr, align 8
  %top27 = getelementptr inbounds %struct.lua_State* %30, i32 0, i32 4
  %31 = load %struct.lua_TValue** %top27, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %31, i32 -1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %top27, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @lua_setmetatable(%struct.lua_State* %L, i32 %objindex) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %objindex.addr = alloca i32, align 4
  %obj = alloca %struct.lua_TValue*, align 8
  %mt = alloca %struct.Table*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %objindex, i32* %objindex.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %objindex.addr, align 4
  %call = call %struct.lua_TValue* @index2addr(%struct.lua_State* %0, i32 %1)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %obj, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %2, i32 0, i32 4
  %3 = load %struct.lua_TValue** %top, align 8
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %3, i64 -1
  %tt_ = getelementptr inbounds %struct.lua_TValue* %add.ptr, i32 0, i32 1
  %4 = load i32* %tt_, align 4
  %cmp = icmp eq i32 %4, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store %struct.Table* null, %struct.Table** %mt, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %5 = load %struct.lua_State** %L.addr, align 8
  %top1 = getelementptr inbounds %struct.lua_State* %5, i32 0, i32 4
  %6 = load %struct.lua_TValue** %top1, align 8
  %add.ptr2 = getelementptr inbounds %struct.lua_TValue* %6, i64 -1
  %value_ = getelementptr inbounds %struct.lua_TValue* %add.ptr2, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %7 = load %union.GCObject** %gc, align 8
  %h = bitcast %union.GCObject* %7 to %struct.Table*
  store %struct.Table* %h, %struct.Table** %mt, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %8 = load %struct.lua_TValue** %obj, align 8
  %tt_3 = getelementptr inbounds %struct.lua_TValue* %8, i32 0, i32 1
  %9 = load i32* %tt_3, align 4
  %and = and i32 %9, 15
  switch i32 %and, label %sw.default [
    i32 5, label %sw.bb
    i32 7, label %sw.bb24
  ]

sw.bb:                                            ; preds = %if.end
  %10 = load %struct.Table** %mt, align 8
  %11 = load %struct.lua_TValue** %obj, align 8
  %value_4 = getelementptr inbounds %struct.lua_TValue* %11, i32 0, i32 0
  %gc5 = bitcast %union.Value* %value_4 to %union.GCObject**
  %12 = load %union.GCObject** %gc5, align 8
  %h6 = bitcast %union.GCObject* %12 to %struct.Table*
  %metatable = getelementptr inbounds %struct.Table* %h6, i32 0, i32 5
  store %struct.Table* %10, %struct.Table** %metatable, align 8
  %13 = load %struct.Table** %mt, align 8
  %tobool = icmp ne %struct.Table* %13, null
  br i1 %tobool, label %if.then7, label %if.end23

if.then7:                                         ; preds = %sw.bb
  %14 = load %struct.Table** %mt, align 8
  %15 = bitcast %struct.Table* %14 to %union.GCObject*
  %gch = bitcast %union.GCObject* %15 to %struct.GCheader*
  %marked = getelementptr inbounds %struct.GCheader* %gch, i32 0, i32 2
  %16 = load i8* %marked, align 1
  %conv = zext i8 %16 to i32
  %and8 = and i32 %conv, 3
  %tobool9 = icmp ne i32 %and8, 0
  br i1 %tobool9, label %land.lhs.true, label %if.end20

land.lhs.true:                                    ; preds = %if.then7
  %17 = load %struct.lua_TValue** %obj, align 8
  %value_10 = getelementptr inbounds %struct.lua_TValue* %17, i32 0, i32 0
  %gc11 = bitcast %union.Value* %value_10 to %union.GCObject**
  %18 = load %union.GCObject** %gc11, align 8
  %gch12 = bitcast %union.GCObject* %18 to %struct.GCheader*
  %marked13 = getelementptr inbounds %struct.GCheader* %gch12, i32 0, i32 2
  %19 = load i8* %marked13, align 1
  %conv14 = zext i8 %19 to i32
  %and15 = and i32 %conv14, 4
  %tobool16 = icmp ne i32 %and15, 0
  br i1 %tobool16, label %if.then17, label %if.end20

if.then17:                                        ; preds = %land.lhs.true
  %20 = load %struct.lua_State** %L.addr, align 8
  %21 = load %struct.lua_TValue** %obj, align 8
  %value_18 = getelementptr inbounds %struct.lua_TValue* %21, i32 0, i32 0
  %gc19 = bitcast %union.Value* %value_18 to %union.GCObject**
  %22 = load %union.GCObject** %gc19, align 8
  call void @luaC_barrierback_(%struct.lua_State* %20, %union.GCObject* %22)
  br label %if.end20

if.end20:                                         ; preds = %if.then17, %land.lhs.true, %if.then7
  %23 = load %struct.lua_State** %L.addr, align 8
  %24 = load %struct.lua_TValue** %obj, align 8
  %value_21 = getelementptr inbounds %struct.lua_TValue* %24, i32 0, i32 0
  %gc22 = bitcast %union.Value* %value_21 to %union.GCObject**
  %25 = load %union.GCObject** %gc22, align 8
  %26 = load %struct.Table** %mt, align 8
  call void @luaC_checkfinalizer(%struct.lua_State* %23, %union.GCObject* %25, %struct.Table* %26)
  br label %if.end23

if.end23:                                         ; preds = %if.end20, %sw.bb
  br label %sw.epilog

sw.bb24:                                          ; preds = %if.end
  %27 = load %struct.Table** %mt, align 8
  %28 = load %struct.lua_TValue** %obj, align 8
  %value_25 = getelementptr inbounds %struct.lua_TValue* %28, i32 0, i32 0
  %gc26 = bitcast %union.Value* %value_25 to %union.GCObject**
  %29 = load %union.GCObject** %gc26, align 8
  %u = bitcast %union.GCObject* %29 to %union.Udata*
  %uv = bitcast %union.Udata* %u to %struct.anon.5*
  %metatable27 = getelementptr inbounds %struct.anon.5* %uv, i32 0, i32 3
  store %struct.Table* %27, %struct.Table** %metatable27, align 8
  %30 = load %struct.Table** %mt, align 8
  %tobool28 = icmp ne %struct.Table* %30, null
  br i1 %tobool28, label %if.then29, label %if.end51

if.then29:                                        ; preds = %sw.bb24
  %31 = load %struct.Table** %mt, align 8
  %32 = bitcast %struct.Table* %31 to %union.GCObject*
  %gch30 = bitcast %union.GCObject* %32 to %struct.GCheader*
  %marked31 = getelementptr inbounds %struct.GCheader* %gch30, i32 0, i32 2
  %33 = load i8* %marked31, align 1
  %conv32 = zext i8 %33 to i32
  %and33 = and i32 %conv32, 3
  %tobool34 = icmp ne i32 %and33, 0
  br i1 %tobool34, label %land.lhs.true35, label %if.end48

land.lhs.true35:                                  ; preds = %if.then29
  %34 = load %struct.lua_TValue** %obj, align 8
  %value_36 = getelementptr inbounds %struct.lua_TValue* %34, i32 0, i32 0
  %gc37 = bitcast %union.Value* %value_36 to %union.GCObject**
  %35 = load %union.GCObject** %gc37, align 8
  %u38 = bitcast %union.GCObject* %35 to %union.Udata*
  %36 = bitcast %union.Udata* %u38 to %union.GCObject*
  %gch39 = bitcast %union.GCObject* %36 to %struct.GCheader*
  %marked40 = getelementptr inbounds %struct.GCheader* %gch39, i32 0, i32 2
  %37 = load i8* %marked40, align 1
  %conv41 = zext i8 %37 to i32
  %and42 = and i32 %conv41, 4
  %tobool43 = icmp ne i32 %and42, 0
  br i1 %tobool43, label %if.then44, label %if.end48

if.then44:                                        ; preds = %land.lhs.true35
  %38 = load %struct.lua_State** %L.addr, align 8
  %39 = load %struct.lua_TValue** %obj, align 8
  %value_45 = getelementptr inbounds %struct.lua_TValue* %39, i32 0, i32 0
  %gc46 = bitcast %union.Value* %value_45 to %union.GCObject**
  %40 = load %union.GCObject** %gc46, align 8
  %u47 = bitcast %union.GCObject* %40 to %union.Udata*
  %41 = bitcast %union.Udata* %u47 to %union.GCObject*
  %42 = load %struct.Table** %mt, align 8
  %43 = bitcast %struct.Table* %42 to %union.GCObject*
  call void @luaC_barrier_(%struct.lua_State* %38, %union.GCObject* %41, %union.GCObject* %43)
  br label %if.end48

if.end48:                                         ; preds = %if.then44, %land.lhs.true35, %if.then29
  %44 = load %struct.lua_State** %L.addr, align 8
  %45 = load %struct.lua_TValue** %obj, align 8
  %value_49 = getelementptr inbounds %struct.lua_TValue* %45, i32 0, i32 0
  %gc50 = bitcast %union.Value* %value_49 to %union.GCObject**
  %46 = load %union.GCObject** %gc50, align 8
  %47 = load %struct.Table** %mt, align 8
  call void @luaC_checkfinalizer(%struct.lua_State* %44, %union.GCObject* %46, %struct.Table* %47)
  br label %if.end51

if.end51:                                         ; preds = %if.end48, %sw.bb24
  br label %sw.epilog

sw.default:                                       ; preds = %if.end
  %48 = load %struct.Table** %mt, align 8
  %49 = load %struct.lua_TValue** %obj, align 8
  %tt_52 = getelementptr inbounds %struct.lua_TValue* %49, i32 0, i32 1
  %50 = load i32* %tt_52, align 4
  %and53 = and i32 %50, 15
  %idxprom = sext i32 %and53 to i64
  %51 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %51, i32 0, i32 5
  %52 = load %struct.global_State** %l_G, align 8
  %mt54 = getelementptr inbounds %struct.global_State* %52, i32 0, i32 34
  %arrayidx = getelementptr inbounds [9 x %struct.Table*]* %mt54, i32 0, i64 %idxprom
  store %struct.Table* %48, %struct.Table** %arrayidx, align 8
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.end51, %if.end23
  %53 = load %struct.lua_State** %L.addr, align 8
  %top55 = getelementptr inbounds %struct.lua_State* %53, i32 0, i32 4
  %54 = load %struct.lua_TValue** %top55, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %54, i32 -1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %top55, align 8
  ret i32 1
}

; Function Attrs: nounwind uwtable
define void @lua_setuservalue(%struct.lua_State* %L, i32 %idx) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %idx.addr = alloca i32, align 4
  %o = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %idx.addr, align 4
  %call = call %struct.lua_TValue* @index2addr(%struct.lua_State* %0, i32 %1)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %o, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %2, i32 0, i32 4
  %3 = load %struct.lua_TValue** %top, align 8
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %3, i64 -1
  %tt_ = getelementptr inbounds %struct.lua_TValue* %add.ptr, i32 0, i32 1
  %4 = load i32* %tt_, align 4
  %cmp = icmp eq i32 %4, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %5 = load %struct.lua_TValue** %o, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %5, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %6 = load %union.GCObject** %gc, align 8
  %u = bitcast %union.GCObject* %6 to %union.Udata*
  %uv = bitcast %union.Udata* %u to %struct.anon.5*
  %env = getelementptr inbounds %struct.anon.5* %uv, i32 0, i32 4
  store %struct.Table* null, %struct.Table** %env, align 8
  br label %if.end30

if.else:                                          ; preds = %entry
  %7 = load %struct.lua_State** %L.addr, align 8
  %top1 = getelementptr inbounds %struct.lua_State* %7, i32 0, i32 4
  %8 = load %struct.lua_TValue** %top1, align 8
  %add.ptr2 = getelementptr inbounds %struct.lua_TValue* %8, i64 -1
  %value_3 = getelementptr inbounds %struct.lua_TValue* %add.ptr2, i32 0, i32 0
  %gc4 = bitcast %union.Value* %value_3 to %union.GCObject**
  %9 = load %union.GCObject** %gc4, align 8
  %h = bitcast %union.GCObject* %9 to %struct.Table*
  %10 = load %struct.lua_TValue** %o, align 8
  %value_5 = getelementptr inbounds %struct.lua_TValue* %10, i32 0, i32 0
  %gc6 = bitcast %union.Value* %value_5 to %union.GCObject**
  %11 = load %union.GCObject** %gc6, align 8
  %u7 = bitcast %union.GCObject* %11 to %union.Udata*
  %uv8 = bitcast %union.Udata* %u7 to %struct.anon.5*
  %env9 = getelementptr inbounds %struct.anon.5* %uv8, i32 0, i32 4
  store %struct.Table* %h, %struct.Table** %env9, align 8
  %12 = load %struct.lua_State** %L.addr, align 8
  %top10 = getelementptr inbounds %struct.lua_State* %12, i32 0, i32 4
  %13 = load %struct.lua_TValue** %top10, align 8
  %add.ptr11 = getelementptr inbounds %struct.lua_TValue* %13, i64 -1
  %value_12 = getelementptr inbounds %struct.lua_TValue* %add.ptr11, i32 0, i32 0
  %gc13 = bitcast %union.Value* %value_12 to %union.GCObject**
  %14 = load %union.GCObject** %gc13, align 8
  %h14 = bitcast %union.GCObject* %14 to %struct.Table*
  %15 = bitcast %struct.Table* %h14 to %union.GCObject*
  %gch = bitcast %union.GCObject* %15 to %struct.GCheader*
  %marked = getelementptr inbounds %struct.GCheader* %gch, i32 0, i32 2
  %16 = load i8* %marked, align 1
  %conv = zext i8 %16 to i32
  %and = and i32 %conv, 3
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.else
  %17 = load %struct.lua_TValue** %o, align 8
  %value_15 = getelementptr inbounds %struct.lua_TValue* %17, i32 0, i32 0
  %gc16 = bitcast %union.Value* %value_15 to %union.GCObject**
  %18 = load %union.GCObject** %gc16, align 8
  %gch17 = bitcast %union.GCObject* %18 to %struct.GCheader*
  %marked18 = getelementptr inbounds %struct.GCheader* %gch17, i32 0, i32 2
  %19 = load i8* %marked18, align 1
  %conv19 = zext i8 %19 to i32
  %and20 = and i32 %conv19, 4
  %tobool21 = icmp ne i32 %and20, 0
  br i1 %tobool21, label %if.then22, label %if.end

if.then22:                                        ; preds = %land.lhs.true
  %20 = load %struct.lua_State** %L.addr, align 8
  %21 = load %struct.lua_TValue** %o, align 8
  %value_23 = getelementptr inbounds %struct.lua_TValue* %21, i32 0, i32 0
  %gc24 = bitcast %union.Value* %value_23 to %union.GCObject**
  %22 = load %union.GCObject** %gc24, align 8
  %23 = load %struct.lua_State** %L.addr, align 8
  %top25 = getelementptr inbounds %struct.lua_State* %23, i32 0, i32 4
  %24 = load %struct.lua_TValue** %top25, align 8
  %add.ptr26 = getelementptr inbounds %struct.lua_TValue* %24, i64 -1
  %value_27 = getelementptr inbounds %struct.lua_TValue* %add.ptr26, i32 0, i32 0
  %gc28 = bitcast %union.Value* %value_27 to %union.GCObject**
  %25 = load %union.GCObject** %gc28, align 8
  %h29 = bitcast %union.GCObject* %25 to %struct.Table*
  %26 = bitcast %struct.Table* %h29 to %union.GCObject*
  call void @luaC_barrier_(%struct.lua_State* %20, %union.GCObject* %22, %union.GCObject* %26)
  br label %if.end

if.end:                                           ; preds = %if.then22, %land.lhs.true, %if.else
  br label %if.end30

if.end30:                                         ; preds = %if.end, %if.then
  %27 = load %struct.lua_State** %L.addr, align 8
  %top31 = getelementptr inbounds %struct.lua_State* %27, i32 0, i32 4
  %28 = load %struct.lua_TValue** %top31, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %28, i32 -1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %top31, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @lua_getctx(%struct.lua_State* %L, i32* %ctx) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %ctx.addr = alloca i32*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32* %ctx, i32** %ctx.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %ci = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 6
  %1 = load %struct.CallInfo** %ci, align 8
  %callstatus = getelementptr inbounds %struct.CallInfo* %1, i32 0, i32 5
  %2 = load i8* %callstatus, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 8
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load i32** %ctx.addr, align 8
  %tobool1 = icmp ne i32* %3, null
  br i1 %tobool1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %4 = load %struct.lua_State** %L.addr, align 8
  %ci3 = getelementptr inbounds %struct.lua_State* %4, i32 0, i32 6
  %5 = load %struct.CallInfo** %ci3, align 8
  %u = getelementptr inbounds %struct.CallInfo* %5, i32 0, i32 7
  %c = bitcast %union.anon.2* %u to %struct.anon.4*
  %ctx4 = getelementptr inbounds %struct.anon.4* %c, i32 0, i32 0
  %6 = load i32* %ctx4, align 4
  %7 = load i32** %ctx.addr, align 8
  store i32 %6, i32* %7, align 4
  br label %if.end

if.end:                                           ; preds = %if.then2, %if.then
  %8 = load %struct.lua_State** %L.addr, align 8
  %ci5 = getelementptr inbounds %struct.lua_State* %8, i32 0, i32 6
  %9 = load %struct.CallInfo** %ci5, align 8
  %u6 = getelementptr inbounds %struct.CallInfo* %9, i32 0, i32 7
  %c7 = bitcast %union.anon.2* %u6 to %struct.anon.4*
  %status = getelementptr inbounds %struct.anon.4* %c7, i32 0, i32 4
  %10 = load i8* %status, align 1
  %conv8 = zext i8 %10 to i32
  store i32 %conv8, i32* %retval
  br label %return

if.else:                                          ; preds = %entry
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.else, %if.end
  %11 = load i32* %retval
  ret i32 %11
}

; Function Attrs: nounwind uwtable
define void @lua_callk(%struct.lua_State* %L, i32 %nargs, i32 %nresults, i32 %ctx, i32 (%struct.lua_State*)* %k) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %nargs.addr = alloca i32, align 4
  %nresults.addr = alloca i32, align 4
  %ctx.addr = alloca i32, align 4
  %k.addr = alloca i32 (%struct.lua_State*)*, align 8
  %func = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %nargs, i32* %nargs.addr, align 4
  store i32 %nresults, i32* %nresults.addr, align 4
  store i32 %ctx, i32* %ctx.addr, align 4
  store i32 (%struct.lua_State*)* %k, i32 (%struct.lua_State*)** %k.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 4
  %1 = load %struct.lua_TValue** %top, align 8
  %2 = load i32* %nargs.addr, align 4
  %add = add nsw i32 %2, 1
  %idx.ext = sext i32 %add to i64
  %idx.neg = sub i64 0, %idx.ext
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %1, i64 %idx.neg
  store %struct.lua_TValue* %add.ptr, %struct.lua_TValue** %func, align 8
  %3 = load i32 (%struct.lua_State*)** %k.addr, align 8
  %cmp = icmp ne i32 (%struct.lua_State*)* %3, null
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %4 = load %struct.lua_State** %L.addr, align 8
  %nny = getelementptr inbounds %struct.lua_State* %4, i32 0, i32 11
  %5 = load i16* %nny, align 2
  %conv = zext i16 %5 to i32
  %cmp1 = icmp eq i32 %conv, 0
  br i1 %cmp1, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %6 = load i32 (%struct.lua_State*)** %k.addr, align 8
  %7 = load %struct.lua_State** %L.addr, align 8
  %ci = getelementptr inbounds %struct.lua_State* %7, i32 0, i32 6
  %8 = load %struct.CallInfo** %ci, align 8
  %u = getelementptr inbounds %struct.CallInfo* %8, i32 0, i32 7
  %c = bitcast %union.anon.2* %u to %struct.anon.4*
  %k3 = getelementptr inbounds %struct.anon.4* %c, i32 0, i32 1
  store i32 (%struct.lua_State*)* %6, i32 (%struct.lua_State*)** %k3, align 8
  %9 = load i32* %ctx.addr, align 4
  %10 = load %struct.lua_State** %L.addr, align 8
  %ci4 = getelementptr inbounds %struct.lua_State* %10, i32 0, i32 6
  %11 = load %struct.CallInfo** %ci4, align 8
  %u5 = getelementptr inbounds %struct.CallInfo* %11, i32 0, i32 7
  %c6 = bitcast %union.anon.2* %u5 to %struct.anon.4*
  %ctx7 = getelementptr inbounds %struct.anon.4* %c6, i32 0, i32 0
  store i32 %9, i32* %ctx7, align 4
  %12 = load %struct.lua_State** %L.addr, align 8
  %13 = load %struct.lua_TValue** %func, align 8
  %14 = load i32* %nresults.addr, align 4
  call void @luaD_call(%struct.lua_State* %12, %struct.lua_TValue* %13, i32 %14, i32 1)
  br label %if.end

if.else:                                          ; preds = %land.lhs.true, %entry
  %15 = load %struct.lua_State** %L.addr, align 8
  %16 = load %struct.lua_TValue** %func, align 8
  %17 = load i32* %nresults.addr, align 4
  call void @luaD_call(%struct.lua_State* %15, %struct.lua_TValue* %16, i32 %17, i32 0)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %18 = load i32* %nresults.addr, align 4
  %cmp8 = icmp eq i32 %18, -1
  br i1 %cmp8, label %land.lhs.true10, label %if.end20

land.lhs.true10:                                  ; preds = %if.end
  %19 = load %struct.lua_State** %L.addr, align 8
  %ci11 = getelementptr inbounds %struct.lua_State* %19, i32 0, i32 6
  %20 = load %struct.CallInfo** %ci11, align 8
  %top12 = getelementptr inbounds %struct.CallInfo* %20, i32 0, i32 1
  %21 = load %struct.lua_TValue** %top12, align 8
  %22 = load %struct.lua_State** %L.addr, align 8
  %top13 = getelementptr inbounds %struct.lua_State* %22, i32 0, i32 4
  %23 = load %struct.lua_TValue** %top13, align 8
  %cmp14 = icmp ult %struct.lua_TValue* %21, %23
  br i1 %cmp14, label %if.then16, label %if.end20

if.then16:                                        ; preds = %land.lhs.true10
  %24 = load %struct.lua_State** %L.addr, align 8
  %top17 = getelementptr inbounds %struct.lua_State* %24, i32 0, i32 4
  %25 = load %struct.lua_TValue** %top17, align 8
  %26 = load %struct.lua_State** %L.addr, align 8
  %ci18 = getelementptr inbounds %struct.lua_State* %26, i32 0, i32 6
  %27 = load %struct.CallInfo** %ci18, align 8
  %top19 = getelementptr inbounds %struct.CallInfo* %27, i32 0, i32 1
  store %struct.lua_TValue* %25, %struct.lua_TValue** %top19, align 8
  br label %if.end20

if.end20:                                         ; preds = %if.then16, %land.lhs.true10, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @lua_pcallk(%struct.lua_State* %L, i32 %nargs, i32 %nresults, i32 %errfunc, i32 %ctx, i32 (%struct.lua_State*)* %k) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %nargs.addr = alloca i32, align 4
  %nresults.addr = alloca i32, align 4
  %errfunc.addr = alloca i32, align 4
  %ctx.addr = alloca i32, align 4
  %k.addr = alloca i32 (%struct.lua_State*)*, align 8
  %c = alloca %struct.CallS, align 8
  %status = alloca i32, align 4
  %func = alloca i64, align 8
  %o = alloca %struct.lua_TValue*, align 8
  %ci = alloca %struct.CallInfo*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %nargs, i32* %nargs.addr, align 4
  store i32 %nresults, i32* %nresults.addr, align 4
  store i32 %errfunc, i32* %errfunc.addr, align 4
  store i32 %ctx, i32* %ctx.addr, align 4
  store i32 (%struct.lua_State*)* %k, i32 (%struct.lua_State*)** %k.addr, align 8
  %0 = load i32* %errfunc.addr, align 4
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i64 0, i64* %func, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load i32* %errfunc.addr, align 4
  %call = call %struct.lua_TValue* @index2addr(%struct.lua_State* %1, i32 %2)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %o, align 8
  %3 = load %struct.lua_TValue** %o, align 8
  %4 = bitcast %struct.lua_TValue* %3 to i8*
  %5 = load %struct.lua_State** %L.addr, align 8
  %stack = getelementptr inbounds %struct.lua_State* %5, i32 0, i32 9
  %6 = load %struct.lua_TValue** %stack, align 8
  %7 = bitcast %struct.lua_TValue* %6 to i8*
  %sub.ptr.lhs.cast = ptrtoint i8* %4 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %7 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, i64* %func, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %8 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %8, i32 0, i32 4
  %9 = load %struct.lua_TValue** %top, align 8
  %10 = load i32* %nargs.addr, align 4
  %add = add nsw i32 %10, 1
  %idx.ext = sext i32 %add to i64
  %idx.neg = sub i64 0, %idx.ext
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %9, i64 %idx.neg
  %func1 = getelementptr inbounds %struct.CallS* %c, i32 0, i32 0
  store %struct.lua_TValue* %add.ptr, %struct.lua_TValue** %func1, align 8
  %11 = load i32 (%struct.lua_State*)** %k.addr, align 8
  %cmp2 = icmp eq i32 (%struct.lua_State*)* %11, null
  br i1 %cmp2, label %if.then5, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %12 = load %struct.lua_State** %L.addr, align 8
  %nny = getelementptr inbounds %struct.lua_State* %12, i32 0, i32 11
  %13 = load i16* %nny, align 2
  %conv = zext i16 %13 to i32
  %cmp3 = icmp sgt i32 %conv, 0
  br i1 %cmp3, label %if.then5, label %if.else13

if.then5:                                         ; preds = %lor.lhs.false, %if.end
  %14 = load i32* %nresults.addr, align 4
  %nresults6 = getelementptr inbounds %struct.CallS* %c, i32 0, i32 1
  store i32 %14, i32* %nresults6, align 4
  %15 = load %struct.lua_State** %L.addr, align 8
  %16 = bitcast %struct.CallS* %c to i8*
  %func7 = getelementptr inbounds %struct.CallS* %c, i32 0, i32 0
  %17 = load %struct.lua_TValue** %func7, align 8
  %18 = bitcast %struct.lua_TValue* %17 to i8*
  %19 = load %struct.lua_State** %L.addr, align 8
  %stack8 = getelementptr inbounds %struct.lua_State* %19, i32 0, i32 9
  %20 = load %struct.lua_TValue** %stack8, align 8
  %21 = bitcast %struct.lua_TValue* %20 to i8*
  %sub.ptr.lhs.cast9 = ptrtoint i8* %18 to i64
  %sub.ptr.rhs.cast10 = ptrtoint i8* %21 to i64
  %sub.ptr.sub11 = sub i64 %sub.ptr.lhs.cast9, %sub.ptr.rhs.cast10
  %22 = load i64* %func, align 8
  %call12 = call i32 @luaD_pcall(%struct.lua_State* %15, void (%struct.lua_State*, i8*)* @f_call, i8* %16, i64 %sub.ptr.sub11, i64 %22)
  store i32 %call12, i32* %status, align 4
  br label %if.end41

if.else13:                                        ; preds = %lor.lhs.false
  %23 = load %struct.lua_State** %L.addr, align 8
  %ci14 = getelementptr inbounds %struct.lua_State* %23, i32 0, i32 6
  %24 = load %struct.CallInfo** %ci14, align 8
  store %struct.CallInfo* %24, %struct.CallInfo** %ci, align 8
  %25 = load i32 (%struct.lua_State*)** %k.addr, align 8
  %26 = load %struct.CallInfo** %ci, align 8
  %u = getelementptr inbounds %struct.CallInfo* %26, i32 0, i32 7
  %c15 = bitcast %union.anon.2* %u to %struct.anon.4*
  %k16 = getelementptr inbounds %struct.anon.4* %c15, i32 0, i32 1
  store i32 (%struct.lua_State*)* %25, i32 (%struct.lua_State*)** %k16, align 8
  %27 = load i32* %ctx.addr, align 4
  %28 = load %struct.CallInfo** %ci, align 8
  %u17 = getelementptr inbounds %struct.CallInfo* %28, i32 0, i32 7
  %c18 = bitcast %union.anon.2* %u17 to %struct.anon.4*
  %ctx19 = getelementptr inbounds %struct.anon.4* %c18, i32 0, i32 0
  store i32 %27, i32* %ctx19, align 4
  %func20 = getelementptr inbounds %struct.CallS* %c, i32 0, i32 0
  %29 = load %struct.lua_TValue** %func20, align 8
  %30 = bitcast %struct.lua_TValue* %29 to i8*
  %31 = load %struct.lua_State** %L.addr, align 8
  %stack21 = getelementptr inbounds %struct.lua_State* %31, i32 0, i32 9
  %32 = load %struct.lua_TValue** %stack21, align 8
  %33 = bitcast %struct.lua_TValue* %32 to i8*
  %sub.ptr.lhs.cast22 = ptrtoint i8* %30 to i64
  %sub.ptr.rhs.cast23 = ptrtoint i8* %33 to i64
  %sub.ptr.sub24 = sub i64 %sub.ptr.lhs.cast22, %sub.ptr.rhs.cast23
  %34 = load %struct.CallInfo** %ci, align 8
  %extra = getelementptr inbounds %struct.CallInfo* %34, i32 0, i32 6
  store i64 %sub.ptr.sub24, i64* %extra, align 8
  %35 = load %struct.lua_State** %L.addr, align 8
  %allowhook = getelementptr inbounds %struct.lua_State* %35, i32 0, i32 14
  %36 = load i8* %allowhook, align 1
  %37 = load %struct.CallInfo** %ci, align 8
  %u25 = getelementptr inbounds %struct.CallInfo* %37, i32 0, i32 7
  %c26 = bitcast %union.anon.2* %u25 to %struct.anon.4*
  %old_allowhook = getelementptr inbounds %struct.anon.4* %c26, i32 0, i32 3
  store i8 %36, i8* %old_allowhook, align 1
  %38 = load %struct.lua_State** %L.addr, align 8
  %errfunc27 = getelementptr inbounds %struct.lua_State* %38, i32 0, i32 21
  %39 = load i64* %errfunc27, align 8
  %40 = load %struct.CallInfo** %ci, align 8
  %u28 = getelementptr inbounds %struct.CallInfo* %40, i32 0, i32 7
  %c29 = bitcast %union.anon.2* %u28 to %struct.anon.4*
  %old_errfunc = getelementptr inbounds %struct.anon.4* %c29, i32 0, i32 2
  store i64 %39, i64* %old_errfunc, align 8
  %41 = load i64* %func, align 8
  %42 = load %struct.lua_State** %L.addr, align 8
  %errfunc30 = getelementptr inbounds %struct.lua_State* %42, i32 0, i32 21
  store i64 %41, i64* %errfunc30, align 8
  %43 = load %struct.CallInfo** %ci, align 8
  %callstatus = getelementptr inbounds %struct.CallInfo* %43, i32 0, i32 5
  %44 = load i8* %callstatus, align 1
  %conv31 = zext i8 %44 to i32
  %or = or i32 %conv31, 16
  %conv32 = trunc i32 %or to i8
  store i8 %conv32, i8* %callstatus, align 1
  %45 = load %struct.lua_State** %L.addr, align 8
  %func33 = getelementptr inbounds %struct.CallS* %c, i32 0, i32 0
  %46 = load %struct.lua_TValue** %func33, align 8
  %47 = load i32* %nresults.addr, align 4
  call void @luaD_call(%struct.lua_State* %45, %struct.lua_TValue* %46, i32 %47, i32 1)
  %48 = load %struct.CallInfo** %ci, align 8
  %callstatus34 = getelementptr inbounds %struct.CallInfo* %48, i32 0, i32 5
  %49 = load i8* %callstatus34, align 1
  %conv35 = zext i8 %49 to i32
  %and = and i32 %conv35, -17
  %conv36 = trunc i32 %and to i8
  store i8 %conv36, i8* %callstatus34, align 1
  %50 = load %struct.CallInfo** %ci, align 8
  %u37 = getelementptr inbounds %struct.CallInfo* %50, i32 0, i32 7
  %c38 = bitcast %union.anon.2* %u37 to %struct.anon.4*
  %old_errfunc39 = getelementptr inbounds %struct.anon.4* %c38, i32 0, i32 2
  %51 = load i64* %old_errfunc39, align 8
  %52 = load %struct.lua_State** %L.addr, align 8
  %errfunc40 = getelementptr inbounds %struct.lua_State* %52, i32 0, i32 21
  store i64 %51, i64* %errfunc40, align 8
  store i32 0, i32* %status, align 4
  br label %if.end41

if.end41:                                         ; preds = %if.else13, %if.then5
  %53 = load i32* %nresults.addr, align 4
  %cmp42 = icmp eq i32 %53, -1
  br i1 %cmp42, label %land.lhs.true, label %if.end53

land.lhs.true:                                    ; preds = %if.end41
  %54 = load %struct.lua_State** %L.addr, align 8
  %ci44 = getelementptr inbounds %struct.lua_State* %54, i32 0, i32 6
  %55 = load %struct.CallInfo** %ci44, align 8
  %top45 = getelementptr inbounds %struct.CallInfo* %55, i32 0, i32 1
  %56 = load %struct.lua_TValue** %top45, align 8
  %57 = load %struct.lua_State** %L.addr, align 8
  %top46 = getelementptr inbounds %struct.lua_State* %57, i32 0, i32 4
  %58 = load %struct.lua_TValue** %top46, align 8
  %cmp47 = icmp ult %struct.lua_TValue* %56, %58
  br i1 %cmp47, label %if.then49, label %if.end53

if.then49:                                        ; preds = %land.lhs.true
  %59 = load %struct.lua_State** %L.addr, align 8
  %top50 = getelementptr inbounds %struct.lua_State* %59, i32 0, i32 4
  %60 = load %struct.lua_TValue** %top50, align 8
  %61 = load %struct.lua_State** %L.addr, align 8
  %ci51 = getelementptr inbounds %struct.lua_State* %61, i32 0, i32 6
  %62 = load %struct.CallInfo** %ci51, align 8
  %top52 = getelementptr inbounds %struct.CallInfo* %62, i32 0, i32 1
  store %struct.lua_TValue* %60, %struct.lua_TValue** %top52, align 8
  br label %if.end53

if.end53:                                         ; preds = %if.then49, %land.lhs.true, %if.end41
  %63 = load i32* %status, align 4
  ret i32 %63
}

; Function Attrs: nounwind uwtable
define internal void @f_call(%struct.lua_State* %L, i8* %ud) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %ud.addr = alloca i8*, align 8
  %c = alloca %struct.CallS*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %ud, i8** %ud.addr, align 8
  %0 = load i8** %ud.addr, align 8
  %1 = bitcast i8* %0 to %struct.CallS*
  store %struct.CallS* %1, %struct.CallS** %c, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load %struct.CallS** %c, align 8
  %func = getelementptr inbounds %struct.CallS* %3, i32 0, i32 0
  %4 = load %struct.lua_TValue** %func, align 8
  %5 = load %struct.CallS** %c, align 8
  %nresults = getelementptr inbounds %struct.CallS* %5, i32 0, i32 1
  %6 = load i32* %nresults, align 4
  call void @luaD_call(%struct.lua_State* %2, %struct.lua_TValue* %4, i32 %6, i32 0)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @lua_load(%struct.lua_State* %L, i8* (%struct.lua_State*, i8*, i64*)* %reader, i8* %data, i8* %chunkname, i8* %mode) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %reader.addr = alloca i8* (%struct.lua_State*, i8*, i64*)*, align 8
  %data.addr = alloca i8*, align 8
  %chunkname.addr = alloca i8*, align 8
  %mode.addr = alloca i8*, align 8
  %z = alloca %struct.Zio, align 8
  %status = alloca i32, align 4
  %f = alloca %struct.LClosure*, align 8
  %reg = alloca %struct.Table*, align 8
  %gt = alloca %struct.lua_TValue*, align 8
  %io2 = alloca %struct.lua_TValue*, align 8
  %io1 = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* (%struct.lua_State*, i8*, i64*)* %reader, i8* (%struct.lua_State*, i8*, i64*)** %reader.addr, align 8
  store i8* %data, i8** %data.addr, align 8
  store i8* %chunkname, i8** %chunkname.addr, align 8
  store i8* %mode, i8** %mode.addr, align 8
  %0 = load i8** %chunkname.addr, align 8
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i8* getelementptr inbounds ([2 x i8]* @.str, i32 0, i32 0), i8** %chunkname.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load i8* (%struct.lua_State*, i8*, i64*)** %reader.addr, align 8
  %3 = load i8** %data.addr, align 8
  call void @luaZ_init(%struct.lua_State* %1, %struct.Zio* %z, i8* (%struct.lua_State*, i8*, i64*)* %2, i8* %3)
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load i8** %chunkname.addr, align 8
  %6 = load i8** %mode.addr, align 8
  %call = call i32 @luaD_protectedparser(%struct.lua_State* %4, %struct.Zio* %z, i8* %5, i8* %6)
  store i32 %call, i32* %status, align 4
  %7 = load i32* %status, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then1, label %if.end33

if.then1:                                         ; preds = %if.end
  %8 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %8, i32 0, i32 4
  %9 = load %struct.lua_TValue** %top, align 8
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %9, i64 -1
  %value_ = getelementptr inbounds %struct.lua_TValue* %add.ptr, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %10 = load %union.GCObject** %gc, align 8
  %cl = bitcast %union.GCObject* %10 to %union.Closure*
  %l = bitcast %union.Closure* %cl to %struct.LClosure*
  store %struct.LClosure* %l, %struct.LClosure** %f, align 8
  %11 = load %struct.LClosure** %f, align 8
  %nupvalues = getelementptr inbounds %struct.LClosure* %11, i32 0, i32 3
  %12 = load i8* %nupvalues, align 1
  %conv = zext i8 %12 to i32
  %cmp2 = icmp eq i32 %conv, 1
  br i1 %cmp2, label %if.then4, label %if.end32

if.then4:                                         ; preds = %if.then1
  %13 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %13, i32 0, i32 5
  %14 = load %struct.global_State** %l_G, align 8
  %l_registry = getelementptr inbounds %struct.global_State* %14, i32 0, i32 7
  %value_5 = getelementptr inbounds %struct.lua_TValue* %l_registry, i32 0, i32 0
  %gc6 = bitcast %union.Value* %value_5 to %union.GCObject**
  %15 = load %union.GCObject** %gc6, align 8
  %h = bitcast %union.GCObject* %15 to %struct.Table*
  store %struct.Table* %h, %struct.Table** %reg, align 8
  %16 = load %struct.Table** %reg, align 8
  %call7 = call %struct.lua_TValue* @luaH_getint(%struct.Table* %16, i32 2)
  store %struct.lua_TValue* %call7, %struct.lua_TValue** %gt, align 8
  %17 = load %struct.lua_TValue** %gt, align 8
  store %struct.lua_TValue* %17, %struct.lua_TValue** %io2, align 8
  %18 = load %struct.LClosure** %f, align 8
  %upvals = getelementptr inbounds %struct.LClosure* %18, i32 0, i32 6
  %arrayidx = getelementptr inbounds [1 x %struct.UpVal*]* %upvals, i32 0, i64 0
  %19 = load %struct.UpVal** %arrayidx, align 8
  %v = getelementptr inbounds %struct.UpVal* %19, i32 0, i32 3
  %20 = load %struct.lua_TValue** %v, align 8
  store %struct.lua_TValue* %20, %struct.lua_TValue** %io1, align 8
  %21 = load %struct.lua_TValue** %io1, align 8
  %value_8 = getelementptr inbounds %struct.lua_TValue* %21, i32 0, i32 0
  %22 = load %struct.lua_TValue** %io2, align 8
  %value_9 = getelementptr inbounds %struct.lua_TValue* %22, i32 0, i32 0
  %23 = bitcast %union.Value* %value_8 to i8*
  %24 = bitcast %union.Value* %value_9 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %23, i8* %24, i64 8, i32 8, i1 false)
  %25 = load %struct.lua_TValue** %io2, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %25, i32 0, i32 1
  %26 = load i32* %tt_, align 4
  %27 = load %struct.lua_TValue** %io1, align 8
  %tt_10 = getelementptr inbounds %struct.lua_TValue* %27, i32 0, i32 1
  store i32 %26, i32* %tt_10, align 4
  %28 = load %struct.lua_TValue** %gt, align 8
  %tt_11 = getelementptr inbounds %struct.lua_TValue* %28, i32 0, i32 1
  %29 = load i32* %tt_11, align 4
  %and = and i32 %29, 64
  %tobool12 = icmp ne i32 %and, 0
  br i1 %tobool12, label %land.lhs.true, label %if.end31

land.lhs.true:                                    ; preds = %if.then4
  %30 = load %struct.lua_TValue** %gt, align 8
  %value_13 = getelementptr inbounds %struct.lua_TValue* %30, i32 0, i32 0
  %gc14 = bitcast %union.Value* %value_13 to %union.GCObject**
  %31 = load %union.GCObject** %gc14, align 8
  %gch = bitcast %union.GCObject* %31 to %struct.GCheader*
  %marked = getelementptr inbounds %struct.GCheader* %gch, i32 0, i32 2
  %32 = load i8* %marked, align 1
  %conv15 = zext i8 %32 to i32
  %and16 = and i32 %conv15, 3
  %tobool17 = icmp ne i32 %and16, 0
  br i1 %tobool17, label %land.lhs.true18, label %if.end31

land.lhs.true18:                                  ; preds = %land.lhs.true
  %33 = load %struct.LClosure** %f, align 8
  %upvals19 = getelementptr inbounds %struct.LClosure* %33, i32 0, i32 6
  %arrayidx20 = getelementptr inbounds [1 x %struct.UpVal*]* %upvals19, i32 0, i64 0
  %34 = load %struct.UpVal** %arrayidx20, align 8
  %35 = bitcast %struct.UpVal* %34 to %union.GCObject*
  %gch21 = bitcast %union.GCObject* %35 to %struct.GCheader*
  %marked22 = getelementptr inbounds %struct.GCheader* %gch21, i32 0, i32 2
  %36 = load i8* %marked22, align 1
  %conv23 = zext i8 %36 to i32
  %and24 = and i32 %conv23, 4
  %tobool25 = icmp ne i32 %and24, 0
  br i1 %tobool25, label %if.then26, label %if.end31

if.then26:                                        ; preds = %land.lhs.true18
  %37 = load %struct.lua_State** %L.addr, align 8
  %38 = load %struct.LClosure** %f, align 8
  %upvals27 = getelementptr inbounds %struct.LClosure* %38, i32 0, i32 6
  %arrayidx28 = getelementptr inbounds [1 x %struct.UpVal*]* %upvals27, i32 0, i64 0
  %39 = load %struct.UpVal** %arrayidx28, align 8
  %40 = bitcast %struct.UpVal* %39 to %union.GCObject*
  %41 = load %struct.lua_TValue** %gt, align 8
  %value_29 = getelementptr inbounds %struct.lua_TValue* %41, i32 0, i32 0
  %gc30 = bitcast %union.Value* %value_29 to %union.GCObject**
  %42 = load %union.GCObject** %gc30, align 8
  call void @luaC_barrier_(%struct.lua_State* %37, %union.GCObject* %40, %union.GCObject* %42)
  br label %if.end31

if.end31:                                         ; preds = %if.then26, %land.lhs.true18, %land.lhs.true, %if.then4
  br label %if.end32

if.end32:                                         ; preds = %if.end31, %if.then1
  br label %if.end33

if.end33:                                         ; preds = %if.end32, %if.end
  %43 = load i32* %status, align 4
  ret i32 %43
}

; Function Attrs: nounwind uwtable
define i32 @lua_dump(%struct.lua_State* %L, i32 (%struct.lua_State*, i8*, i64, i8*)* %writer, i8* %data) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %writer.addr = alloca i32 (%struct.lua_State*, i8*, i64, i8*)*, align 8
  %data.addr = alloca i8*, align 8
  %status = alloca i32, align 4
  %o = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 (%struct.lua_State*, i8*, i64, i8*)* %writer, i32 (%struct.lua_State*, i8*, i64, i8*)** %writer.addr, align 8
  store i8* %data, i8** %data.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 4
  %1 = load %struct.lua_TValue** %top, align 8
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %1, i64 -1
  store %struct.lua_TValue* %add.ptr, %struct.lua_TValue** %o, align 8
  %2 = load %struct.lua_TValue** %o, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %2, i32 0, i32 1
  %3 = load i32* %tt_, align 4
  %cmp = icmp eq i32 %3, 70
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load %struct.lua_TValue** %o, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %5, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %6 = load %union.GCObject** %gc, align 8
  %cl = bitcast %union.GCObject* %6 to %union.Closure*
  %l = bitcast %union.Closure* %cl to %struct.LClosure*
  %p = getelementptr inbounds %struct.LClosure* %l, i32 0, i32 5
  %7 = load %struct.Proto** %p, align 8
  %8 = load i32 (%struct.lua_State*, i8*, i64, i8*)** %writer.addr, align 8
  %9 = load i8** %data.addr, align 8
  %call = call i32 @luaU_dump(%struct.lua_State* %4, %struct.Proto* %7, i32 (%struct.lua_State*, i8*, i64, i8*)* %8, i8* %9, i32 0)
  store i32 %call, i32* %status, align 4
  br label %if.end

if.else:                                          ; preds = %entry
  store i32 1, i32* %status, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %10 = load i32* %status, align 4
  ret i32 %10
}

; Function Attrs: nounwind uwtable
define i32 @lua_status(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %status = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 3
  %1 = load i8* %status, align 1
  %conv = zext i8 %1 to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define i32 @lua_gc(%struct.lua_State* %L, i32 %what, i32 %data) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %what.addr = alloca i32, align 4
  %data.addr = alloca i32, align 4
  %res = alloca i32, align 4
  %g = alloca %struct.global_State*, align 8
  %debt = alloca i64, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %what, i32* %what.addr, align 4
  store i32 %data, i32* %data.addr, align 4
  store i32 0, i32* %res, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 5
  %1 = load %struct.global_State** %l_G, align 8
  store %struct.global_State* %1, %struct.global_State** %g, align 8
  %2 = load i32* %what.addr, align 4
  switch i32 %2, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb1
    i32 2, label %sw.bb3
    i32 3, label %sw.bb4
    i32 4, label %sw.bb5
    i32 5, label %sw.bb10
    i32 6, label %sw.bb26
    i32 8, label %sw.bb28
    i32 7, label %sw.bb30
    i32 9, label %sw.bb32
    i32 10, label %sw.bb35
    i32 11, label %sw.bb36
  ]

sw.bb:                                            ; preds = %entry
  %3 = load %struct.global_State** %g, align 8
  %gcrunning = getelementptr inbounds %struct.global_State* %3, i32 0, i32 12
  store i8 0, i8* %gcrunning, align 1
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  %4 = load %struct.global_State** %g, align 8
  call void bitcast (void (%struct.global_State.337*, i64)* @luaE_setdebt to void (%struct.global_State*, i64)*)(%struct.global_State* %4, i64 0)
  %5 = load %struct.global_State** %g, align 8
  %gcrunning2 = getelementptr inbounds %struct.global_State* %5, i32 0, i32 12
  store i8 1, i8* %gcrunning2, align 1
  br label %sw.epilog

sw.bb3:                                           ; preds = %entry
  %6 = load %struct.lua_State** %L.addr, align 8
  call void @luaC_fullgc(%struct.lua_State* %6, i32 0)
  br label %sw.epilog

sw.bb4:                                           ; preds = %entry
  %7 = load %struct.global_State** %g, align 8
  %totalbytes = getelementptr inbounds %struct.global_State* %7, i32 0, i32 2
  %8 = load i64* %totalbytes, align 8
  %9 = load %struct.global_State** %g, align 8
  %GCdebt = getelementptr inbounds %struct.global_State* %9, i32 0, i32 3
  %10 = load i64* %GCdebt, align 8
  %add = add i64 %8, %10
  %shr = lshr i64 %add, 10
  %conv = trunc i64 %shr to i32
  store i32 %conv, i32* %res, align 4
  br label %sw.epilog

sw.bb5:                                           ; preds = %entry
  %11 = load %struct.global_State** %g, align 8
  %totalbytes6 = getelementptr inbounds %struct.global_State* %11, i32 0, i32 2
  %12 = load i64* %totalbytes6, align 8
  %13 = load %struct.global_State** %g, align 8
  %GCdebt7 = getelementptr inbounds %struct.global_State* %13, i32 0, i32 3
  %14 = load i64* %GCdebt7, align 8
  %add8 = add i64 %12, %14
  %and = and i64 %add8, 1023
  %conv9 = trunc i64 %and to i32
  store i32 %conv9, i32* %res, align 4
  br label %sw.epilog

sw.bb10:                                          ; preds = %entry
  %15 = load %struct.global_State** %g, align 8
  %gckind = getelementptr inbounds %struct.global_State* %15, i32 0, i32 11
  %16 = load i8* %gckind, align 1
  %conv11 = zext i8 %16 to i32
  %cmp = icmp eq i32 %conv11, 2
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb10
  %17 = load %struct.global_State** %g, align 8
  %GCestimate = getelementptr inbounds %struct.global_State* %17, i32 0, i32 5
  %18 = load i64* %GCestimate, align 8
  %cmp13 = icmp eq i64 %18, 0
  %conv14 = zext i1 %cmp13 to i32
  store i32 %conv14, i32* %res, align 4
  %19 = load %struct.lua_State** %L.addr, align 8
  call void @luaC_forcestep(%struct.lua_State* %19)
  br label %if.end25

if.else:                                          ; preds = %sw.bb10
  %20 = load i32* %data.addr, align 4
  %conv15 = sext i32 %20 to i64
  %mul = mul i64 %conv15, 1024
  %sub = sub i64 %mul, 2400
  store i64 %sub, i64* %debt, align 8
  %21 = load %struct.global_State** %g, align 8
  %gcrunning16 = getelementptr inbounds %struct.global_State* %21, i32 0, i32 12
  %22 = load i8* %gcrunning16, align 1
  %tobool = icmp ne i8 %22, 0
  br i1 %tobool, label %if.then17, label %if.end

if.then17:                                        ; preds = %if.else
  %23 = load %struct.global_State** %g, align 8
  %GCdebt18 = getelementptr inbounds %struct.global_State* %23, i32 0, i32 3
  %24 = load i64* %GCdebt18, align 8
  %25 = load i64* %debt, align 8
  %add19 = add i64 %25, %24
  store i64 %add19, i64* %debt, align 8
  br label %if.end

if.end:                                           ; preds = %if.then17, %if.else
  %26 = load %struct.global_State** %g, align 8
  %27 = load i64* %debt, align 8
  call void bitcast (void (%struct.global_State.337*, i64)* @luaE_setdebt to void (%struct.global_State*, i64)*)(%struct.global_State* %26, i64 %27)
  %28 = load %struct.lua_State** %L.addr, align 8
  call void @luaC_forcestep(%struct.lua_State* %28)
  %29 = load %struct.global_State** %g, align 8
  %gcstate = getelementptr inbounds %struct.global_State* %29, i32 0, i32 10
  %30 = load i8* %gcstate, align 1
  %conv20 = zext i8 %30 to i32
  %cmp21 = icmp eq i32 %conv20, 5
  br i1 %cmp21, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.end
  store i32 1, i32* %res, align 4
  br label %if.end24

if.end24:                                         ; preds = %if.then23, %if.end
  br label %if.end25

if.end25:                                         ; preds = %if.end24, %if.then
  br label %sw.epilog

sw.bb26:                                          ; preds = %entry
  %31 = load %struct.global_State** %g, align 8
  %gcpause = getelementptr inbounds %struct.global_State* %31, i32 0, i32 26
  %32 = load i32* %gcpause, align 4
  store i32 %32, i32* %res, align 4
  %33 = load i32* %data.addr, align 4
  %34 = load %struct.global_State** %g, align 8
  %gcpause27 = getelementptr inbounds %struct.global_State* %34, i32 0, i32 26
  store i32 %33, i32* %gcpause27, align 4
  br label %sw.epilog

sw.bb28:                                          ; preds = %entry
  %35 = load %struct.global_State** %g, align 8
  %gcmajorinc = getelementptr inbounds %struct.global_State* %35, i32 0, i32 27
  %36 = load i32* %gcmajorinc, align 4
  store i32 %36, i32* %res, align 4
  %37 = load i32* %data.addr, align 4
  %38 = load %struct.global_State** %g, align 8
  %gcmajorinc29 = getelementptr inbounds %struct.global_State* %38, i32 0, i32 27
  store i32 %37, i32* %gcmajorinc29, align 4
  br label %sw.epilog

sw.bb30:                                          ; preds = %entry
  %39 = load %struct.global_State** %g, align 8
  %gcstepmul = getelementptr inbounds %struct.global_State* %39, i32 0, i32 28
  %40 = load i32* %gcstepmul, align 4
  store i32 %40, i32* %res, align 4
  %41 = load i32* %data.addr, align 4
  %42 = load %struct.global_State** %g, align 8
  %gcstepmul31 = getelementptr inbounds %struct.global_State* %42, i32 0, i32 28
  store i32 %41, i32* %gcstepmul31, align 4
  br label %sw.epilog

sw.bb32:                                          ; preds = %entry
  %43 = load %struct.global_State** %g, align 8
  %gcrunning33 = getelementptr inbounds %struct.global_State* %43, i32 0, i32 12
  %44 = load i8* %gcrunning33, align 1
  %conv34 = zext i8 %44 to i32
  store i32 %conv34, i32* %res, align 4
  br label %sw.epilog

sw.bb35:                                          ; preds = %entry
  %45 = load %struct.lua_State** %L.addr, align 8
  call void @luaC_changemode(%struct.lua_State* %45, i32 2)
  br label %sw.epilog

sw.bb36:                                          ; preds = %entry
  %46 = load %struct.lua_State** %L.addr, align 8
  call void @luaC_changemode(%struct.lua_State* %46, i32 0)
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  store i32 -1, i32* %res, align 4
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb36, %sw.bb35, %sw.bb32, %sw.bb30, %sw.bb28, %sw.bb26, %if.end25, %sw.bb5, %sw.bb4, %sw.bb3, %sw.bb1, %sw.bb
  %47 = load i32* %res, align 4
  ret i32 %47
}

; Function Attrs: nounwind uwtable
define i32 @lua_error(%struct.lua_State* %L) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  call void @luaG_errormsg(%struct.lua_State* %0) #9
  unreachable

return:                                           ; No predecessors!
  %1 = load i32* %retval
  ret i32 %1
}

; Function Attrs: nounwind uwtable
define i32 @lua_next(%struct.lua_State* %L, i32 %idx) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %idx.addr = alloca i32, align 4
  %t = alloca %struct.lua_TValue*, align 8
  %more = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %idx.addr, align 4
  %call = call %struct.lua_TValue* @index2addr(%struct.lua_State* %0, i32 %1)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %t, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load %struct.lua_TValue** %t, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %3, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %4 = load %union.GCObject** %gc, align 8
  %h = bitcast %union.GCObject* %4 to %struct.Table*
  %5 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %5, i32 0, i32 4
  %6 = load %struct.lua_TValue** %top, align 8
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %6, i64 -1
  %call1 = call i32 @luaH_next(%struct.lua_State* %2, %struct.Table* %h, %struct.lua_TValue* %add.ptr)
  store i32 %call1, i32* %more, align 4
  %7 = load i32* %more, align 4
  %tobool = icmp ne i32 %7, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %8 = load %struct.lua_State** %L.addr, align 8
  %top2 = getelementptr inbounds %struct.lua_State* %8, i32 0, i32 4
  %9 = load %struct.lua_TValue** %top2, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %9, i32 1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %top2, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %10 = load %struct.lua_State** %L.addr, align 8
  %top3 = getelementptr inbounds %struct.lua_State* %10, i32 0, i32 4
  %11 = load %struct.lua_TValue** %top3, align 8
  %add.ptr4 = getelementptr inbounds %struct.lua_TValue* %11, i64 -1
  store %struct.lua_TValue* %add.ptr4, %struct.lua_TValue** %top3, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %12 = load i32* %more, align 4
  ret i32 %12
}

; Function Attrs: nounwind uwtable
define void @lua_concat(%struct.lua_State* %L, i32 %n) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %n.addr = alloca i32, align 4
  %io = alloca %struct.lua_TValue*, align 8
  %x_ = alloca %union.TString*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %n, i32* %n.addr, align 4
  %0 = load i32* %n.addr, align 4
  %cmp = icmp sge i32 %0, 2
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %1, i32 0, i32 5
  %2 = load %struct.global_State** %l_G, align 8
  %GCdebt = getelementptr inbounds %struct.global_State* %2, i32 0, i32 3
  %3 = load i64* %GCdebt, align 8
  %cmp1 = icmp sgt i64 %3, 0
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %4 = load %struct.lua_State** %L.addr, align 8
  call void @luaC_step(%struct.lua_State* %4)
  br label %if.end

if.end:                                           ; preds = %if.then2, %if.then
  %5 = load %struct.lua_State** %L.addr, align 8
  %6 = load i32* %n.addr, align 4
  call void bitcast (void (%struct.lua_State.364*, i32)* @luaV_concat to void (%struct.lua_State*, i32)*)(%struct.lua_State* %5, i32 %6)
  br label %if.end7

if.else:                                          ; preds = %entry
  %7 = load i32* %n.addr, align 4
  %cmp3 = icmp eq i32 %7, 0
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.else
  %8 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %8, i32 0, i32 4
  %9 = load %struct.lua_TValue** %top, align 8
  store %struct.lua_TValue* %9, %struct.lua_TValue** %io, align 8
  %10 = load %struct.lua_State** %L.addr, align 8
  %call = call %union.TString* bitcast (%union.TString.367* (%struct.lua_State.364*, i8*, i64)* @luaS_newlstr to %union.TString* (%struct.lua_State*, i8*, i64)*)(%struct.lua_State* %10, i8* getelementptr inbounds ([1 x i8]* @.str1, i32 0, i32 0), i64 0)
  store %union.TString* %call, %union.TString** %x_, align 8
  %11 = load %union.TString** %x_, align 8
  %12 = bitcast %union.TString* %11 to %union.GCObject*
  %13 = load %struct.lua_TValue** %io, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %13, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  store %union.GCObject* %12, %union.GCObject** %gc, align 8
  %14 = load %union.TString** %x_, align 8
  %tsv = bitcast %union.TString* %14 to %struct.anon.0*
  %tt = getelementptr inbounds %struct.anon.0* %tsv, i32 0, i32 1
  %15 = load i8* %tt, align 1
  %conv = zext i8 %15 to i32
  %or = or i32 %conv, 64
  %16 = load %struct.lua_TValue** %io, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %16, i32 0, i32 1
  store i32 %or, i32* %tt_, align 4
  %17 = load %struct.lua_State** %L.addr, align 8
  %top5 = getelementptr inbounds %struct.lua_State* %17, i32 0, i32 4
  %18 = load %struct.lua_TValue** %top5, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %18, i32 1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %top5, align 8
  br label %if.end6

if.end6:                                          ; preds = %if.then4, %if.else
  br label %if.end7

if.end7:                                          ; preds = %if.end6, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define void @lua_len(%struct.lua_State* %L, i32 %idx) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %idx.addr = alloca i32, align 4
  %t = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %idx.addr, align 4
  %call = call %struct.lua_TValue* @index2addr(%struct.lua_State* %0, i32 %1)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %t, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %3, i32 0, i32 4
  %4 = load %struct.lua_TValue** %top, align 8
  %5 = load %struct.lua_TValue** %t, align 8
  call void bitcast (void (%struct.lua_State.364*, %struct.lua_TValue.349*, %struct.lua_TValue.349*)* @luaV_objlen to void (%struct.lua_State*, %struct.lua_TValue*, %struct.lua_TValue*)*)(%struct.lua_State* %2, %struct.lua_TValue* %4, %struct.lua_TValue* %5)
  %6 = load %struct.lua_State** %L.addr, align 8
  %top1 = getelementptr inbounds %struct.lua_State* %6, i32 0, i32 4
  %7 = load %struct.lua_TValue** %top1, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %7, i32 1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %top1, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define i8* (i8*, i8*, i64, i64)* @lua_getallocf(%struct.lua_State* %L, i8** %ud) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %ud.addr = alloca i8**, align 8
  %f = alloca i8* (i8*, i8*, i64, i64)*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8** %ud, i8*** %ud.addr, align 8
  %0 = load i8*** %ud.addr, align 8
  %tobool = icmp ne i8** %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %1, i32 0, i32 5
  %2 = load %struct.global_State** %l_G, align 8
  %ud1 = getelementptr inbounds %struct.global_State* %2, i32 0, i32 1
  %3 = load i8** %ud1, align 8
  %4 = load i8*** %ud.addr, align 8
  store i8* %3, i8** %4, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load %struct.lua_State** %L.addr, align 8
  %l_G2 = getelementptr inbounds %struct.lua_State* %5, i32 0, i32 5
  %6 = load %struct.global_State** %l_G2, align 8
  %frealloc = getelementptr inbounds %struct.global_State* %6, i32 0, i32 0
  %7 = load i8* (i8*, i8*, i64, i64)** %frealloc, align 8
  store i8* (i8*, i8*, i64, i64)* %7, i8* (i8*, i8*, i64, i64)** %f, align 8
  %8 = load i8* (i8*, i8*, i64, i64)** %f, align 8
  ret i8* (i8*, i8*, i64, i64)* %8
}

; Function Attrs: nounwind uwtable
define void @lua_setallocf(%struct.lua_State* %L, i8* (i8*, i8*, i64, i64)* %f, i8* %ud) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %f.addr = alloca i8* (i8*, i8*, i64, i64)*, align 8
  %ud.addr = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* (i8*, i8*, i64, i64)* %f, i8* (i8*, i8*, i64, i64)** %f.addr, align 8
  store i8* %ud, i8** %ud.addr, align 8
  %0 = load i8** %ud.addr, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %1, i32 0, i32 5
  %2 = load %struct.global_State** %l_G, align 8
  %ud1 = getelementptr inbounds %struct.global_State* %2, i32 0, i32 1
  store i8* %0, i8** %ud1, align 8
  %3 = load i8* (i8*, i8*, i64, i64)** %f.addr, align 8
  %4 = load %struct.lua_State** %L.addr, align 8
  %l_G2 = getelementptr inbounds %struct.lua_State* %4, i32 0, i32 5
  %5 = load %struct.global_State** %l_G2, align 8
  %frealloc = getelementptr inbounds %struct.global_State* %5, i32 0, i32 0
  store i8* (i8*, i8*, i64, i64)* %3, i8* (i8*, i8*, i64, i64)** %frealloc, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define i8* @lua_newuserdata(%struct.lua_State* %L, i64 %size) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %size.addr = alloca i64, align 8
  %u = alloca %union.Udata*, align 8
  %io = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 5
  %1 = load %struct.global_State** %l_G, align 8
  %GCdebt = getelementptr inbounds %struct.global_State* %1, i32 0, i32 3
  %2 = load i64* %GCdebt, align 8
  %cmp = icmp sgt i64 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load %struct.lua_State** %L.addr, align 8
  call void @luaC_step(%struct.lua_State* %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load i64* %size.addr, align 8
  %call = call %union.Udata* bitcast (%union.Udata.369* (%struct.lua_State.364*, i64, %struct.Table.357*)* @luaS_newudata to %union.Udata* (%struct.lua_State*, i64, %struct.Table*)*)(%struct.lua_State* %4, i64 %5, %struct.Table* null)
  store %union.Udata* %call, %union.Udata** %u, align 8
  %6 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %6, i32 0, i32 4
  %7 = load %struct.lua_TValue** %top, align 8
  store %struct.lua_TValue* %7, %struct.lua_TValue** %io, align 8
  %8 = load %union.Udata** %u, align 8
  %9 = bitcast %union.Udata* %8 to %union.GCObject*
  %10 = load %struct.lua_TValue** %io, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %10, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  store %union.GCObject* %9, %union.GCObject** %gc, align 8
  %11 = load %struct.lua_TValue** %io, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %11, i32 0, i32 1
  store i32 71, i32* %tt_, align 4
  %12 = load %struct.lua_State** %L.addr, align 8
  %top1 = getelementptr inbounds %struct.lua_State* %12, i32 0, i32 4
  %13 = load %struct.lua_TValue** %top1, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %13, i32 1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %top1, align 8
  %14 = load %union.Udata** %u, align 8
  %add.ptr = getelementptr inbounds %union.Udata* %14, i64 1
  %15 = bitcast %union.Udata* %add.ptr to i8*
  ret i8* %15
}

; Function Attrs: nounwind uwtable
define i8* @lua_getupvalue(%struct.lua_State* %L, i32 %funcindex, i32 %n) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %funcindex.addr = alloca i32, align 4
  %n.addr = alloca i32, align 4
  %name = alloca i8*, align 8
  %val = alloca %struct.lua_TValue*, align 8
  %io2 = alloca %struct.lua_TValue*, align 8
  %io1 = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %funcindex, i32* %funcindex.addr, align 4
  store i32 %n, i32* %n.addr, align 4
  store %struct.lua_TValue* null, %struct.lua_TValue** %val, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %funcindex.addr, align 4
  %call = call %struct.lua_TValue* @index2addr(%struct.lua_State* %0, i32 %1)
  %2 = load i32* %n.addr, align 4
  %call1 = call i8* @aux_upvalue(%struct.lua_TValue* %call, i32 %2, %struct.lua_TValue** %val, %union.GCObject** null)
  store i8* %call1, i8** %name, align 8
  %3 = load i8** %name, align 8
  %tobool = icmp ne i8* %3, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load %struct.lua_TValue** %val, align 8
  store %struct.lua_TValue* %4, %struct.lua_TValue** %io2, align 8
  %5 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %5, i32 0, i32 4
  %6 = load %struct.lua_TValue** %top, align 8
  store %struct.lua_TValue* %6, %struct.lua_TValue** %io1, align 8
  %7 = load %struct.lua_TValue** %io1, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %7, i32 0, i32 0
  %8 = load %struct.lua_TValue** %io2, align 8
  %value_2 = getelementptr inbounds %struct.lua_TValue* %8, i32 0, i32 0
  %9 = bitcast %union.Value* %value_ to i8*
  %10 = bitcast %union.Value* %value_2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %9, i8* %10, i64 8, i32 8, i1 false)
  %11 = load %struct.lua_TValue** %io2, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %11, i32 0, i32 1
  %12 = load i32* %tt_, align 4
  %13 = load %struct.lua_TValue** %io1, align 8
  %tt_3 = getelementptr inbounds %struct.lua_TValue* %13, i32 0, i32 1
  store i32 %12, i32* %tt_3, align 4
  %14 = load %struct.lua_State** %L.addr, align 8
  %top4 = getelementptr inbounds %struct.lua_State* %14, i32 0, i32 4
  %15 = load %struct.lua_TValue** %top4, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %15, i32 1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %top4, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %16 = load i8** %name, align 8
  ret i8* %16
}

; Function Attrs: nounwind uwtable
define internal i8* @aux_upvalue(%struct.lua_TValue* %fi, i32 %n, %struct.lua_TValue** %val, %union.GCObject** %owner) #0 {
entry:
  %retval = alloca i8*, align 8
  %fi.addr = alloca %struct.lua_TValue*, align 8
  %n.addr = alloca i32, align 4
  %val.addr = alloca %struct.lua_TValue**, align 8
  %owner.addr = alloca %union.GCObject**, align 8
  %f = alloca %struct.CClosure*, align 8
  %f6 = alloca %struct.LClosure*, align 8
  %name = alloca %union.TString*, align 8
  %p = alloca %struct.Proto*, align 8
  store %struct.lua_TValue* %fi, %struct.lua_TValue** %fi.addr, align 8
  store i32 %n, i32* %n.addr, align 4
  store %struct.lua_TValue** %val, %struct.lua_TValue*** %val.addr, align 8
  store %union.GCObject** %owner, %union.GCObject*** %owner.addr, align 8
  %0 = load %struct.lua_TValue** %fi.addr, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %0, i32 0, i32 1
  %1 = load i32* %tt_, align 4
  %and = and i32 %1, 63
  switch i32 %and, label %sw.default [
    i32 38, label %sw.bb
    i32 6, label %sw.bb5
  ]

sw.bb:                                            ; preds = %entry
  %2 = load %struct.lua_TValue** %fi.addr, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %2, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %3 = load %union.GCObject** %gc, align 8
  %cl = bitcast %union.GCObject* %3 to %union.Closure*
  %c = bitcast %union.Closure* %cl to %struct.CClosure*
  store %struct.CClosure* %c, %struct.CClosure** %f, align 8
  %4 = load i32* %n.addr, align 4
  %cmp = icmp sle i32 1, %4
  br i1 %cmp, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %sw.bb
  %5 = load i32* %n.addr, align 4
  %6 = load %struct.CClosure** %f, align 8
  %nupvalues = getelementptr inbounds %struct.CClosure* %6, i32 0, i32 3
  %7 = load i8* %nupvalues, align 1
  %conv = zext i8 %7 to i32
  %cmp1 = icmp sle i32 %5, %conv
  br i1 %cmp1, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true, %sw.bb
  store i8* null, i8** %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true
  %8 = load i32* %n.addr, align 4
  %sub = sub nsw i32 %8, 1
  %idxprom = sext i32 %sub to i64
  %9 = load %struct.CClosure** %f, align 8
  %upvalue = getelementptr inbounds %struct.CClosure* %9, i32 0, i32 6
  %arrayidx = getelementptr inbounds [1 x %struct.lua_TValue]* %upvalue, i32 0, i64 %idxprom
  %10 = load %struct.lua_TValue*** %val.addr, align 8
  store %struct.lua_TValue* %arrayidx, %struct.lua_TValue** %10, align 8
  %11 = load %union.GCObject*** %owner.addr, align 8
  %tobool = icmp ne %union.GCObject** %11, null
  br i1 %tobool, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %12 = load %struct.CClosure** %f, align 8
  %13 = bitcast %struct.CClosure* %12 to %union.GCObject*
  %14 = load %union.GCObject*** %owner.addr, align 8
  store %union.GCObject* %13, %union.GCObject** %14, align 8
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end
  store i8* getelementptr inbounds ([1 x i8]* @.str1, i32 0, i32 0), i8** %retval
  br label %return

sw.bb5:                                           ; preds = %entry
  %15 = load %struct.lua_TValue** %fi.addr, align 8
  %value_7 = getelementptr inbounds %struct.lua_TValue* %15, i32 0, i32 0
  %gc8 = bitcast %union.Value* %value_7 to %union.GCObject**
  %16 = load %union.GCObject** %gc8, align 8
  %cl9 = bitcast %union.GCObject* %16 to %union.Closure*
  %l = bitcast %union.Closure* %cl9 to %struct.LClosure*
  store %struct.LClosure* %l, %struct.LClosure** %f6, align 8
  %17 = load %struct.LClosure** %f6, align 8
  %p10 = getelementptr inbounds %struct.LClosure* %17, i32 0, i32 5
  %18 = load %struct.Proto** %p10, align 8
  store %struct.Proto* %18, %struct.Proto** %p, align 8
  %19 = load i32* %n.addr, align 4
  %cmp11 = icmp sle i32 1, %19
  br i1 %cmp11, label %land.lhs.true13, label %if.then16

land.lhs.true13:                                  ; preds = %sw.bb5
  %20 = load i32* %n.addr, align 4
  %21 = load %struct.Proto** %p, align 8
  %sizeupvalues = getelementptr inbounds %struct.Proto* %21, i32 0, i32 11
  %22 = load i32* %sizeupvalues, align 4
  %cmp14 = icmp sle i32 %20, %22
  br i1 %cmp14, label %if.end17, label %if.then16

if.then16:                                        ; preds = %land.lhs.true13, %sw.bb5
  store i8* null, i8** %retval
  br label %return

if.end17:                                         ; preds = %land.lhs.true13
  %23 = load i32* %n.addr, align 4
  %sub18 = sub nsw i32 %23, 1
  %idxprom19 = sext i32 %sub18 to i64
  %24 = load %struct.LClosure** %f6, align 8
  %upvals = getelementptr inbounds %struct.LClosure* %24, i32 0, i32 6
  %arrayidx20 = getelementptr inbounds [1 x %struct.UpVal*]* %upvals, i32 0, i64 %idxprom19
  %25 = load %struct.UpVal** %arrayidx20, align 8
  %v = getelementptr inbounds %struct.UpVal* %25, i32 0, i32 3
  %26 = load %struct.lua_TValue** %v, align 8
  %27 = load %struct.lua_TValue*** %val.addr, align 8
  store %struct.lua_TValue* %26, %struct.lua_TValue** %27, align 8
  %28 = load %union.GCObject*** %owner.addr, align 8
  %tobool21 = icmp ne %union.GCObject** %28, null
  br i1 %tobool21, label %if.then22, label %if.end27

if.then22:                                        ; preds = %if.end17
  %29 = load i32* %n.addr, align 4
  %sub23 = sub nsw i32 %29, 1
  %idxprom24 = sext i32 %sub23 to i64
  %30 = load %struct.LClosure** %f6, align 8
  %upvals25 = getelementptr inbounds %struct.LClosure* %30, i32 0, i32 6
  %arrayidx26 = getelementptr inbounds [1 x %struct.UpVal*]* %upvals25, i32 0, i64 %idxprom24
  %31 = load %struct.UpVal** %arrayidx26, align 8
  %32 = bitcast %struct.UpVal* %31 to %union.GCObject*
  %33 = load %union.GCObject*** %owner.addr, align 8
  store %union.GCObject* %32, %union.GCObject** %33, align 8
  br label %if.end27

if.end27:                                         ; preds = %if.then22, %if.end17
  %34 = load i32* %n.addr, align 4
  %sub28 = sub nsw i32 %34, 1
  %idxprom29 = sext i32 %sub28 to i64
  %35 = load %struct.Proto** %p, align 8
  %upvalues = getelementptr inbounds %struct.Proto* %35, i32 0, i32 8
  %36 = load %struct.Upvaldesc** %upvalues, align 8
  %arrayidx30 = getelementptr inbounds %struct.Upvaldesc* %36, i64 %idxprom29
  %name31 = getelementptr inbounds %struct.Upvaldesc* %arrayidx30, i32 0, i32 0
  %37 = load %union.TString** %name31, align 8
  store %union.TString* %37, %union.TString** %name, align 8
  %38 = load %union.TString** %name, align 8
  %cmp32 = icmp eq %union.TString* %38, null
  br i1 %cmp32, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end27
  br label %cond.end

cond.false:                                       ; preds = %if.end27
  %39 = load %union.TString** %name, align 8
  %add.ptr = getelementptr inbounds %union.TString* %39, i64 1
  %40 = bitcast %union.TString* %add.ptr to i8*
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ getelementptr inbounds ([1 x i8]* @.str1, i32 0, i32 0), %cond.true ], [ %40, %cond.false ]
  store i8* %cond, i8** %retval
  br label %return

sw.default:                                       ; preds = %entry
  store i8* null, i8** %retval
  br label %return

return:                                           ; preds = %sw.default, %cond.end, %if.then16, %if.end4, %if.then
  %41 = load i8** %retval
  ret i8* %41
}

; Function Attrs: nounwind uwtable
define i8* @lua_setupvalue(%struct.lua_State* %L, i32 %funcindex, i32 %n) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %funcindex.addr = alloca i32, align 4
  %n.addr = alloca i32, align 4
  %name = alloca i8*, align 8
  %val = alloca %struct.lua_TValue*, align 8
  %owner = alloca %union.GCObject*, align 8
  %fi = alloca %struct.lua_TValue*, align 8
  %io2 = alloca %struct.lua_TValue*, align 8
  %io1 = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %funcindex, i32* %funcindex.addr, align 4
  store i32 %n, i32* %n.addr, align 4
  store %struct.lua_TValue* null, %struct.lua_TValue** %val, align 8
  store %union.GCObject* null, %union.GCObject** %owner, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %funcindex.addr, align 4
  %call = call %struct.lua_TValue* @index2addr(%struct.lua_State* %0, i32 %1)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %fi, align 8
  %2 = load %struct.lua_TValue** %fi, align 8
  %3 = load i32* %n.addr, align 4
  %call1 = call i8* @aux_upvalue(%struct.lua_TValue* %2, i32 %3, %struct.lua_TValue** %val, %union.GCObject** %owner)
  store i8* %call1, i8** %name, align 8
  %4 = load i8** %name, align 8
  %tobool = icmp ne i8* %4, null
  br i1 %tobool, label %if.then, label %if.end22

if.then:                                          ; preds = %entry
  %5 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %5, i32 0, i32 4
  %6 = load %struct.lua_TValue** %top, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %6, i32 -1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %top, align 8
  %7 = load %struct.lua_State** %L.addr, align 8
  %top2 = getelementptr inbounds %struct.lua_State* %7, i32 0, i32 4
  %8 = load %struct.lua_TValue** %top2, align 8
  store %struct.lua_TValue* %8, %struct.lua_TValue** %io2, align 8
  %9 = load %struct.lua_TValue** %val, align 8
  store %struct.lua_TValue* %9, %struct.lua_TValue** %io1, align 8
  %10 = load %struct.lua_TValue** %io1, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %10, i32 0, i32 0
  %11 = load %struct.lua_TValue** %io2, align 8
  %value_3 = getelementptr inbounds %struct.lua_TValue* %11, i32 0, i32 0
  %12 = bitcast %union.Value* %value_ to i8*
  %13 = bitcast %union.Value* %value_3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %12, i8* %13, i64 8, i32 8, i1 false)
  %14 = load %struct.lua_TValue** %io2, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %14, i32 0, i32 1
  %15 = load i32* %tt_, align 4
  %16 = load %struct.lua_TValue** %io1, align 8
  %tt_4 = getelementptr inbounds %struct.lua_TValue* %16, i32 0, i32 1
  store i32 %15, i32* %tt_4, align 4
  %17 = load %struct.lua_State** %L.addr, align 8
  %top5 = getelementptr inbounds %struct.lua_State* %17, i32 0, i32 4
  %18 = load %struct.lua_TValue** %top5, align 8
  %tt_6 = getelementptr inbounds %struct.lua_TValue* %18, i32 0, i32 1
  %19 = load i32* %tt_6, align 4
  %and = and i32 %19, 64
  %tobool7 = icmp ne i32 %and, 0
  br i1 %tobool7, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then
  %20 = load %struct.lua_State** %L.addr, align 8
  %top8 = getelementptr inbounds %struct.lua_State* %20, i32 0, i32 4
  %21 = load %struct.lua_TValue** %top8, align 8
  %value_9 = getelementptr inbounds %struct.lua_TValue* %21, i32 0, i32 0
  %gc = bitcast %union.Value* %value_9 to %union.GCObject**
  %22 = load %union.GCObject** %gc, align 8
  %gch = bitcast %union.GCObject* %22 to %struct.GCheader*
  %marked = getelementptr inbounds %struct.GCheader* %gch, i32 0, i32 2
  %23 = load i8* %marked, align 1
  %conv = zext i8 %23 to i32
  %and10 = and i32 %conv, 3
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %land.lhs.true12, label %if.end

land.lhs.true12:                                  ; preds = %land.lhs.true
  %24 = load %union.GCObject** %owner, align 8
  %gch13 = bitcast %union.GCObject* %24 to %struct.GCheader*
  %marked14 = getelementptr inbounds %struct.GCheader* %gch13, i32 0, i32 2
  %25 = load i8* %marked14, align 1
  %conv15 = zext i8 %25 to i32
  %and16 = and i32 %conv15, 4
  %tobool17 = icmp ne i32 %and16, 0
  br i1 %tobool17, label %if.then18, label %if.end

if.then18:                                        ; preds = %land.lhs.true12
  %26 = load %struct.lua_State** %L.addr, align 8
  %27 = load %union.GCObject** %owner, align 8
  %28 = load %struct.lua_State** %L.addr, align 8
  %top19 = getelementptr inbounds %struct.lua_State* %28, i32 0, i32 4
  %29 = load %struct.lua_TValue** %top19, align 8
  %value_20 = getelementptr inbounds %struct.lua_TValue* %29, i32 0, i32 0
  %gc21 = bitcast %union.Value* %value_20 to %union.GCObject**
  %30 = load %union.GCObject** %gc21, align 8
  call void @luaC_barrier_(%struct.lua_State* %26, %union.GCObject* %27, %union.GCObject* %30)
  br label %if.end

if.end:                                           ; preds = %if.then18, %land.lhs.true12, %land.lhs.true, %if.then
  br label %if.end22

if.end22:                                         ; preds = %if.end, %entry
  %31 = load i8** %name, align 8
  ret i8* %31
}

; Function Attrs: nounwind uwtable
define i8* @lua_upvalueid(%struct.lua_State* %L, i32 %fidx, i32 %n) #0 {
entry:
  %retval = alloca i8*, align 8
  %L.addr = alloca %struct.lua_State*, align 8
  %fidx.addr = alloca i32, align 4
  %n.addr = alloca i32, align 4
  %fi = alloca %struct.lua_TValue*, align 8
  %f = alloca %struct.CClosure*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %fidx, i32* %fidx.addr, align 4
  store i32 %n, i32* %n.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %fidx.addr, align 4
  %call = call %struct.lua_TValue* @index2addr(%struct.lua_State* %0, i32 %1)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %fi, align 8
  %2 = load %struct.lua_TValue** %fi, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %2, i32 0, i32 1
  %3 = load i32* %tt_, align 4
  %and = and i32 %3, 63
  switch i32 %and, label %sw.default [
    i32 6, label %sw.bb
    i32 38, label %sw.bb2
  ]

sw.bb:                                            ; preds = %entry
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load i32* %fidx.addr, align 4
  %6 = load i32* %n.addr, align 4
  %call1 = call %struct.UpVal** @getupvalref(%struct.lua_State* %4, i32 %5, i32 %6, %struct.LClosure** null)
  %7 = load %struct.UpVal** %call1, align 8
  %8 = bitcast %struct.UpVal* %7 to i8*
  store i8* %8, i8** %retval
  br label %return

sw.bb2:                                           ; preds = %entry
  %9 = load %struct.lua_TValue** %fi, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %9, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %10 = load %union.GCObject** %gc, align 8
  %cl = bitcast %union.GCObject* %10 to %union.Closure*
  %c = bitcast %union.Closure* %cl to %struct.CClosure*
  store %struct.CClosure* %c, %struct.CClosure** %f, align 8
  %11 = load i32* %n.addr, align 4
  %sub = sub nsw i32 %11, 1
  %idxprom = sext i32 %sub to i64
  %12 = load %struct.CClosure** %f, align 8
  %upvalue = getelementptr inbounds %struct.CClosure* %12, i32 0, i32 6
  %arrayidx = getelementptr inbounds [1 x %struct.lua_TValue]* %upvalue, i32 0, i64 %idxprom
  %13 = bitcast %struct.lua_TValue* %arrayidx to i8*
  store i8* %13, i8** %retval
  br label %return

sw.default:                                       ; preds = %entry
  store i8* null, i8** %retval
  br label %return

return:                                           ; preds = %sw.default, %sw.bb2, %sw.bb
  %14 = load i8** %retval
  ret i8* %14
}

; Function Attrs: nounwind uwtable
define internal %struct.UpVal** @getupvalref(%struct.lua_State* %L, i32 %fidx, i32 %n, %struct.LClosure** %pf) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %fidx.addr = alloca i32, align 4
  %n.addr = alloca i32, align 4
  %pf.addr = alloca %struct.LClosure**, align 8
  %f = alloca %struct.LClosure*, align 8
  %fi = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %fidx, i32* %fidx.addr, align 4
  store i32 %n, i32* %n.addr, align 4
  store %struct.LClosure** %pf, %struct.LClosure*** %pf.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %fidx.addr, align 4
  %call = call %struct.lua_TValue* @index2addr(%struct.lua_State* %0, i32 %1)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %fi, align 8
  %2 = load %struct.lua_TValue** %fi, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %2, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %3 = load %union.GCObject** %gc, align 8
  %cl = bitcast %union.GCObject* %3 to %union.Closure*
  %l = bitcast %union.Closure* %cl to %struct.LClosure*
  store %struct.LClosure* %l, %struct.LClosure** %f, align 8
  %4 = load %struct.LClosure*** %pf.addr, align 8
  %tobool = icmp ne %struct.LClosure** %4, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load %struct.LClosure** %f, align 8
  %6 = load %struct.LClosure*** %pf.addr, align 8
  store %struct.LClosure* %5, %struct.LClosure** %6, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %7 = load i32* %n.addr, align 4
  %sub = sub nsw i32 %7, 1
  %idxprom = sext i32 %sub to i64
  %8 = load %struct.LClosure** %f, align 8
  %upvals = getelementptr inbounds %struct.LClosure* %8, i32 0, i32 6
  %arrayidx = getelementptr inbounds [1 x %struct.UpVal*]* %upvals, i32 0, i64 %idxprom
  ret %struct.UpVal** %arrayidx
}

; Function Attrs: nounwind uwtable
define void @lua_upvaluejoin(%struct.lua_State* %L, i32 %fidx1, i32 %n1, i32 %fidx2, i32 %n2) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %fidx1.addr = alloca i32, align 4
  %n1.addr = alloca i32, align 4
  %fidx2.addr = alloca i32, align 4
  %n2.addr = alloca i32, align 4
  %f1 = alloca %struct.LClosure*, align 8
  %up1 = alloca %struct.UpVal**, align 8
  %up2 = alloca %struct.UpVal**, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %fidx1, i32* %fidx1.addr, align 4
  store i32 %n1, i32* %n1.addr, align 4
  store i32 %fidx2, i32* %fidx2.addr, align 4
  store i32 %n2, i32* %n2.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %fidx1.addr, align 4
  %2 = load i32* %n1.addr, align 4
  %call = call %struct.UpVal** @getupvalref(%struct.lua_State* %0, i32 %1, i32 %2, %struct.LClosure** %f1)
  store %struct.UpVal** %call, %struct.UpVal*** %up1, align 8
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load i32* %fidx2.addr, align 4
  %5 = load i32* %n2.addr, align 4
  %call1 = call %struct.UpVal** @getupvalref(%struct.lua_State* %3, i32 %4, i32 %5, %struct.LClosure** null)
  store %struct.UpVal** %call1, %struct.UpVal*** %up2, align 8
  %6 = load %struct.UpVal*** %up2, align 8
  %7 = load %struct.UpVal** %6, align 8
  %8 = load %struct.UpVal*** %up1, align 8
  store %struct.UpVal* %7, %struct.UpVal** %8, align 8
  %9 = load %struct.UpVal*** %up2, align 8
  %10 = load %struct.UpVal** %9, align 8
  %11 = bitcast %struct.UpVal* %10 to %union.GCObject*
  %gch = bitcast %union.GCObject* %11 to %struct.GCheader*
  %marked = getelementptr inbounds %struct.GCheader* %gch, i32 0, i32 2
  %12 = load i8* %marked, align 1
  %conv = zext i8 %12 to i32
  %and = and i32 %conv, 3
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %13 = load %struct.LClosure** %f1, align 8
  %14 = bitcast %struct.LClosure* %13 to %union.GCObject*
  %gch2 = bitcast %union.GCObject* %14 to %struct.GCheader*
  %marked3 = getelementptr inbounds %struct.GCheader* %gch2, i32 0, i32 2
  %15 = load i8* %marked3, align 1
  %conv4 = zext i8 %15 to i32
  %and5 = and i32 %conv4, 4
  %tobool6 = icmp ne i32 %and5, 0
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %16 = load %struct.lua_State** %L.addr, align 8
  %17 = load %struct.LClosure** %f1, align 8
  %18 = bitcast %struct.LClosure* %17 to %union.GCObject*
  %19 = load %struct.UpVal*** %up2, align 8
  %20 = load %struct.UpVal** %19, align 8
  %21 = bitcast %struct.UpVal* %20 to %union.GCObject*
  call void @luaC_barrier_(%struct.lua_State* %16, %union.GCObject* %18, %union.GCObject* %21)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @luaL_traceback(%struct.lua_State* %L, %struct.lua_State* %L1, i8* %msg, i32 %level) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %L1.addr = alloca %struct.lua_State*, align 8
  %msg.addr = alloca i8*, align 8
  %level.addr = alloca i32, align 4
  %ar = alloca %struct.lua_Debug, align 8
  %top = alloca i32, align 4
  %numlevels = alloca i32, align 4
  %mark = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.lua_State* %L1, %struct.lua_State** %L1.addr, align 8
  store i8* %msg, i8** %msg.addr, align 8
  store i32 %level, i32* %level.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_gettop(%struct.lua_State* %0)
  store i32 %call, i32* %top, align 4
  %1 = load %struct.lua_State** %L1.addr, align 8
  %call1 = call i32 @countlevels(%struct.lua_State* %1)
  store i32 %call1, i32* %numlevels, align 4
  %2 = load i32* %numlevels, align 4
  %cmp = icmp sgt i32 %2, 22
  %cond = select i1 %cmp, i32 12, i32 0
  store i32 %cond, i32* %mark, align 4
  %3 = load i8** %msg.addr, align 8
  %tobool = icmp ne i8* %3, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load i8** %msg.addr, align 8
  %call2 = call i8* (%struct.lua_State*, i8*, ...)* @lua_pushfstring(%struct.lua_State* %4, i8* getelementptr inbounds ([4 x i8]* @.str2, i32 0, i32 0), i8* %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load %struct.lua_State** %L.addr, align 8
  %call3 = call i8* @lua_pushlstring(%struct.lua_State* %6, i8* getelementptr inbounds ([17 x i8]* @.str13, i32 0, i32 0), i64 16)
  br label %while.cond

while.cond:                                       ; preds = %if.end23, %if.end
  %7 = load %struct.lua_State** %L1.addr, align 8
  %8 = load i32* %level.addr, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, i32* %level.addr, align 4
  %call4 = call i32 @lua_getstack(%struct.lua_State* %7, i32 %8, %struct.lua_Debug* %ar)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %9 = load i32* %level.addr, align 4
  %10 = load i32* %mark, align 4
  %cmp6 = icmp eq i32 %9, %10
  br i1 %cmp6, label %if.then7, label %if.else

if.then7:                                         ; preds = %while.body
  %11 = load %struct.lua_State** %L.addr, align 8
  %call8 = call i8* @lua_pushlstring(%struct.lua_State* %11, i8* getelementptr inbounds ([6 x i8]* @.str24, i32 0, i32 0), i64 5)
  %12 = load i32* %numlevels, align 4
  %sub = sub nsw i32 %12, 10
  store i32 %sub, i32* %level.addr, align 4
  br label %if.end23

if.else:                                          ; preds = %while.body
  %13 = load %struct.lua_State** %L1.addr, align 8
  %call9 = call i32 @lua_getinfo(%struct.lua_State* %13, i8* getelementptr inbounds ([5 x i8]* @.str3, i32 0, i32 0), %struct.lua_Debug* %ar)
  %14 = load %struct.lua_State** %L.addr, align 8
  %short_src = getelementptr inbounds %struct.lua_Debug* %ar, i32 0, i32 12
  %arraydecay = getelementptr inbounds [60 x i8]* %short_src, i32 0, i32 0
  %call10 = call i8* (%struct.lua_State*, i8*, ...)* @lua_pushfstring(%struct.lua_State* %14, i8* getelementptr inbounds ([6 x i8]* @.str4, i32 0, i32 0), i8* %arraydecay)
  %currentline = getelementptr inbounds %struct.lua_Debug* %ar, i32 0, i32 5
  %15 = load i32* %currentline, align 4
  %cmp11 = icmp sgt i32 %15, 0
  br i1 %cmp11, label %if.then12, label %if.end15

if.then12:                                        ; preds = %if.else
  %16 = load %struct.lua_State** %L.addr, align 8
  %currentline13 = getelementptr inbounds %struct.lua_Debug* %ar, i32 0, i32 5
  %17 = load i32* %currentline13, align 4
  %call14 = call i8* (%struct.lua_State*, i8*, ...)* @lua_pushfstring(%struct.lua_State* %16, i8* getelementptr inbounds ([4 x i8]* @.str5, i32 0, i32 0), i32 %17)
  br label %if.end15

if.end15:                                         ; preds = %if.then12, %if.else
  %18 = load %struct.lua_State** %L.addr, align 8
  %call16 = call i8* @lua_pushlstring(%struct.lua_State* %18, i8* getelementptr inbounds ([5 x i8]* @.str6, i32 0, i32 0), i64 4)
  %19 = load %struct.lua_State** %L.addr, align 8
  call void @pushfuncname(%struct.lua_State* %19, %struct.lua_Debug* %ar)
  %istailcall = getelementptr inbounds %struct.lua_Debug* %ar, i32 0, i32 11
  %20 = load i8* %istailcall, align 1
  %tobool17 = icmp ne i8 %20, 0
  br i1 %tobool17, label %if.then18, label %if.end20

if.then18:                                        ; preds = %if.end15
  %21 = load %struct.lua_State** %L.addr, align 8
  %call19 = call i8* @lua_pushlstring(%struct.lua_State* %21, i8* getelementptr inbounds ([21 x i8]* @.str7, i32 0, i32 0), i64 20)
  br label %if.end20

if.end20:                                         ; preds = %if.then18, %if.end15
  %22 = load %struct.lua_State** %L.addr, align 8
  %23 = load %struct.lua_State** %L.addr, align 8
  %call21 = call i32 @lua_gettop(%struct.lua_State* %23)
  %24 = load i32* %top, align 4
  %sub22 = sub nsw i32 %call21, %24
  call void @lua_concat(%struct.lua_State* %22, i32 %sub22)
  br label %if.end23

if.end23:                                         ; preds = %if.end20, %if.then7
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %25 = load %struct.lua_State** %L.addr, align 8
  %26 = load %struct.lua_State** %L.addr, align 8
  %call24 = call i32 @lua_gettop(%struct.lua_State* %26)
  %27 = load i32* %top, align 4
  %sub25 = sub nsw i32 %call24, %27
  call void @lua_concat(%struct.lua_State* %25, i32 %sub25)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @luaL_argerror(%struct.lua_State* %L, i32 %narg, i8* %extramsg) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %narg.addr = alloca i32, align 4
  %extramsg.addr = alloca i8*, align 8
  %ar = alloca %struct.lua_Debug, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %narg, i32* %narg.addr, align 4
  store i8* %extramsg, i8** %extramsg.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_getstack(%struct.lua_State* %0, i32 0, %struct.lua_Debug* %ar)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load i32* %narg.addr, align 4
  %3 = load i8** %extramsg.addr, align 8
  %call1 = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %1, i8* getelementptr inbounds ([22 x i8]* @.str8, i32 0, i32 0), i32 %2, i8* %3)
  store i32 %call1, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %4 = load %struct.lua_State** %L.addr, align 8
  %call2 = call i32 @lua_getinfo(%struct.lua_State* %4, i8* getelementptr inbounds ([2 x i8]* @.str9, i32 0, i32 0), %struct.lua_Debug* %ar)
  %namewhat = getelementptr inbounds %struct.lua_Debug* %ar, i32 0, i32 2
  %5 = load i8** %namewhat, align 8
  %call3 = call i32 @strcmp(i8* %5, i8* getelementptr inbounds ([7 x i8]* @.str10, i32 0, i32 0)) #10
  %cmp = icmp eq i32 %call3, 0
  br i1 %cmp, label %if.then4, label %if.end9

if.then4:                                         ; preds = %if.end
  %6 = load i32* %narg.addr, align 4
  %dec = add nsw i32 %6, -1
  store i32 %dec, i32* %narg.addr, align 4
  %7 = load i32* %narg.addr, align 4
  %cmp5 = icmp eq i32 %7, 0
  br i1 %cmp5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.then4
  %8 = load %struct.lua_State** %L.addr, align 8
  %name = getelementptr inbounds %struct.lua_Debug* %ar, i32 0, i32 1
  %9 = load i8** %name, align 8
  %10 = load i8** %extramsg.addr, align 8
  %call7 = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %8, i8* getelementptr inbounds ([30 x i8]* @.str11, i32 0, i32 0), i8* %9, i8* %10)
  store i32 %call7, i32* %retval
  br label %return

if.end8:                                          ; preds = %if.then4
  br label %if.end9

if.end9:                                          ; preds = %if.end8, %if.end
  %name10 = getelementptr inbounds %struct.lua_Debug* %ar, i32 0, i32 1
  %11 = load i8** %name10, align 8
  %cmp11 = icmp eq i8* %11, null
  br i1 %cmp11, label %if.then12, label %if.end17

if.then12:                                        ; preds = %if.end9
  %12 = load %struct.lua_State** %L.addr, align 8
  %call13 = call i32 @pushglobalfuncname(%struct.lua_State* %12, %struct.lua_Debug* %ar)
  %tobool14 = icmp ne i32 %call13, 0
  br i1 %tobool14, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then12
  %13 = load %struct.lua_State** %L.addr, align 8
  %call15 = call i8* @lua_tolstring(%struct.lua_State* %13, i32 -1, i64* null)
  br label %cond.end

cond.false:                                       ; preds = %if.then12
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %call15, %cond.true ], [ getelementptr inbounds ([2 x i8]* @.str12, i32 0, i32 0), %cond.false ]
  %name16 = getelementptr inbounds %struct.lua_Debug* %ar, i32 0, i32 1
  store i8* %cond, i8** %name16, align 8
  br label %if.end17

if.end17:                                         ; preds = %cond.end, %if.end9
  %14 = load %struct.lua_State** %L.addr, align 8
  %15 = load i32* %narg.addr, align 4
  %name18 = getelementptr inbounds %struct.lua_Debug* %ar, i32 0, i32 1
  %16 = load i8** %name18, align 8
  %17 = load i8** %extramsg.addr, align 8
  %call19 = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %14, i8* getelementptr inbounds ([30 x i8]* @.str135, i32 0, i32 0), i32 %15, i8* %16, i8* %17)
  store i32 %call19, i32* %retval
  br label %return

return:                                           ; preds = %if.end17, %if.then6, %if.then
  %18 = load i32* %retval
  ret i32 %18
}

; Function Attrs: nounwind uwtable
define i32 @luaL_error(%struct.lua_State* %L, i8* %fmt, ...) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %fmt.addr = alloca i8*, align 8
  %argp = alloca [1 x %struct.__va_list_tag], align 16
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %fmt, i8** %fmt.addr, align 8
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag]* %argp, i32 0, i32 0
  %arraydecay1 = bitcast %struct.__va_list_tag* %arraydecay to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  %0 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_where(%struct.lua_State* %0, i32 1)
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load i8** %fmt.addr, align 8
  %arraydecay2 = getelementptr inbounds [1 x %struct.__va_list_tag]* %argp, i32 0, i32 0
  %call = call i8* @lua_pushvfstring(%struct.lua_State* %1, i8* %2, %struct.__va_list_tag* %arraydecay2)
  %arraydecay3 = getelementptr inbounds [1 x %struct.__va_list_tag]* %argp, i32 0, i32 0
  %arraydecay34 = bitcast %struct.__va_list_tag* %arraydecay3 to i8*
  call void @llvm.va_end(i8* %arraydecay34)
  %3 = load %struct.lua_State** %L.addr, align 8
  call void @lua_concat(%struct.lua_State* %3, i32 2)
  %4 = load %struct.lua_State** %L.addr, align 8
  %call5 = call i32 @lua_error(%struct.lua_State* %4)
  ret i32 %call5
}

; Function Attrs: nounwind readonly
declare i32 @strcmp(i8*, i8*) #2

; Function Attrs: nounwind uwtable
define void @luaL_where(%struct.lua_State* %L, i32 %level) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %level.addr = alloca i32, align 4
  %ar = alloca %struct.lua_Debug, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %level, i32* %level.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %level.addr, align 4
  %call = call i32 @lua_getstack(%struct.lua_State* %0, i32 %1, %struct.lua_Debug* %ar)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end5

if.then:                                          ; preds = %entry
  %2 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i32 @lua_getinfo(%struct.lua_State* %2, i8* getelementptr inbounds ([3 x i8]* @.str14, i32 0, i32 0), %struct.lua_Debug* %ar)
  %currentline = getelementptr inbounds %struct.lua_Debug* %ar, i32 0, i32 5
  %3 = load i32* %currentline, align 4
  %cmp = icmp sgt i32 %3, 0
  br i1 %cmp, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %4 = load %struct.lua_State** %L.addr, align 8
  %short_src = getelementptr inbounds %struct.lua_Debug* %ar, i32 0, i32 12
  %arraydecay = getelementptr inbounds [60 x i8]* %short_src, i32 0, i32 0
  %currentline3 = getelementptr inbounds %struct.lua_Debug* %ar, i32 0, i32 5
  %5 = load i32* %currentline3, align 4
  %call4 = call i8* (%struct.lua_State*, i8*, ...)* @lua_pushfstring(%struct.lua_State* %4, i8* getelementptr inbounds ([8 x i8]* @.str15, i32 0, i32 0), i8* %arraydecay, i32 %5)
  br label %return

if.end:                                           ; preds = %if.then
  br label %if.end5

if.end5:                                          ; preds = %if.end, %entry
  %6 = load %struct.lua_State** %L.addr, align 8
  %call6 = call i8* @lua_pushlstring(%struct.lua_State* %6, i8* getelementptr inbounds ([1 x i8]* @.str16, i32 0, i32 0), i64 0)
  br label %return

return:                                           ; preds = %if.end5, %if.then2
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @luaL_fileresult(%struct.lua_State* %L, i32 %stat, i8* %fname) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %stat.addr = alloca i32, align 4
  %fname.addr = alloca i8*, align 8
  %en = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %stat, i32* %stat.addr, align 4
  store i8* %fname, i8** %fname.addr, align 8
  %call = call i32* @__errno_location() #11
  %0 = load i32* %call, align 4
  store i32 %0, i32* %en, align 4
  %1 = load i32* %stat.addr, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushboolean(%struct.lua_State* %2, i32 1)
  store i32 1, i32* %retval
  br label %return

if.else:                                          ; preds = %entry
  %3 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushnil(%struct.lua_State* %3)
  %4 = load i8** %fname.addr, align 8
  %tobool1 = icmp ne i8* %4, null
  br i1 %tobool1, label %if.then2, label %if.else5

if.then2:                                         ; preds = %if.else
  %5 = load %struct.lua_State** %L.addr, align 8
  %6 = load i8** %fname.addr, align 8
  %7 = load i32* %en, align 4
  %call3 = call i8* @strerror(i32 %7) #1
  %call4 = call i8* (%struct.lua_State*, i8*, ...)* @lua_pushfstring(%struct.lua_State* %5, i8* getelementptr inbounds ([7 x i8]* @.str17, i32 0, i32 0), i8* %6, i8* %call3)
  br label %if.end

if.else5:                                         ; preds = %if.else
  %8 = load %struct.lua_State** %L.addr, align 8
  %9 = load i32* %en, align 4
  %call6 = call i8* @strerror(i32 %9) #1
  %call7 = call i8* @lua_pushstring(%struct.lua_State* %8, i8* %call6)
  br label %if.end

if.end:                                           ; preds = %if.else5, %if.then2
  %10 = load %struct.lua_State** %L.addr, align 8
  %11 = load i32* %en, align 4
  %conv = sext i32 %11 to i64
  call void @lua_pushinteger(%struct.lua_State* %10, i64 %conv)
  store i32 3, i32* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %12 = load i32* %retval
  ret i32 %12
}

; Function Attrs: nounwind readnone
declare i32* @__errno_location() #3

; Function Attrs: nounwind
declare i8* @strerror(i32) #4

; Function Attrs: nounwind uwtable
define i32 @luaL_execresult(%struct.lua_State* %L, i32 %stat) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %stat.addr = alloca i32, align 4
  %what = alloca i8*, align 8
  %.compoundliteral = alloca %union.anon.4, align 4
  %.compoundliteral3 = alloca %union.anon.0, align 4
  %.compoundliteral8 = alloca %union.anon.1, align 4
  %.compoundliteral17 = alloca %union.anon.2.5, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %stat, i32* %stat.addr, align 4
  store i8* getelementptr inbounds ([5 x i8]* @.str18, i32 0, i32 0), i8** %what, align 8
  %0 = load i32* %stat.addr, align 4
  %cmp = icmp eq i32 %0, -1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @luaL_fileresult(%struct.lua_State* %1, i32 0, i8* null)
  store i32 %call, i32* %retval
  br label %return

if.else:                                          ; preds = %entry
  %__in = bitcast %union.anon.4* %.compoundliteral to i32*
  %2 = load i32* %stat.addr, align 4
  store i32 %2, i32* %__in, align 4
  %__i = bitcast %union.anon.4* %.compoundliteral to i32*
  %3 = load i32* %__i, align 4
  %and = and i32 %3, 127
  %cmp1 = icmp eq i32 %and, 0
  br i1 %cmp1, label %if.then2, label %if.else7

if.then2:                                         ; preds = %if.else
  %__in4 = bitcast %union.anon.0* %.compoundliteral3 to i32*
  %4 = load i32* %stat.addr, align 4
  store i32 %4, i32* %__in4, align 4
  %__i5 = bitcast %union.anon.0* %.compoundliteral3 to i32*
  %5 = load i32* %__i5, align 4
  %and6 = and i32 %5, 65280
  %shr = ashr i32 %and6, 8
  store i32 %shr, i32* %stat.addr, align 4
  br label %if.end21

if.else7:                                         ; preds = %if.else
  %__in9 = bitcast %union.anon.1* %.compoundliteral8 to i32*
  %6 = load i32* %stat.addr, align 4
  store i32 %6, i32* %__in9, align 4
  %__i10 = bitcast %union.anon.1* %.compoundliteral8 to i32*
  %7 = load i32* %__i10, align 4
  %and11 = and i32 %7, 127
  %add = add nsw i32 %and11, 1
  %conv = trunc i32 %add to i8
  %conv12 = sext i8 %conv to i32
  %shr13 = ashr i32 %conv12, 1
  %cmp14 = icmp sgt i32 %shr13, 0
  br i1 %cmp14, label %if.then16, label %if.end

if.then16:                                        ; preds = %if.else7
  %__in18 = bitcast %union.anon.2.5* %.compoundliteral17 to i32*
  %8 = load i32* %stat.addr, align 4
  store i32 %8, i32* %__in18, align 4
  %__i19 = bitcast %union.anon.2.5* %.compoundliteral17 to i32*
  %9 = load i32* %__i19, align 4
  %and20 = and i32 %9, 127
  store i32 %and20, i32* %stat.addr, align 4
  store i8* getelementptr inbounds ([7 x i8]* @.str19, i32 0, i32 0), i8** %what, align 8
  br label %if.end

if.end:                                           ; preds = %if.then16, %if.else7
  br label %if.end21

if.end21:                                         ; preds = %if.end, %if.then2
  %10 = load i8** %what, align 8
  %11 = load i8* %10, align 1
  %conv22 = sext i8 %11 to i32
  %cmp23 = icmp eq i32 %conv22, 101
  br i1 %cmp23, label %land.lhs.true, label %if.else28

land.lhs.true:                                    ; preds = %if.end21
  %12 = load i32* %stat.addr, align 4
  %cmp25 = icmp eq i32 %12, 0
  br i1 %cmp25, label %if.then27, label %if.else28

if.then27:                                        ; preds = %land.lhs.true
  %13 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushboolean(%struct.lua_State* %13, i32 1)
  br label %if.end29

if.else28:                                        ; preds = %land.lhs.true, %if.end21
  %14 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushnil(%struct.lua_State* %14)
  br label %if.end29

if.end29:                                         ; preds = %if.else28, %if.then27
  %15 = load %struct.lua_State** %L.addr, align 8
  %16 = load i8** %what, align 8
  %call30 = call i8* @lua_pushstring(%struct.lua_State* %15, i8* %16)
  %17 = load %struct.lua_State** %L.addr, align 8
  %18 = load i32* %stat.addr, align 4
  %conv31 = sext i32 %18 to i64
  call void @lua_pushinteger(%struct.lua_State* %17, i64 %conv31)
  store i32 3, i32* %retval
  br label %return

return:                                           ; preds = %if.end29, %if.then
  %19 = load i32* %retval
  ret i32 %19
}

; Function Attrs: nounwind uwtable
define i32 @luaL_newmetatable(%struct.lua_State* %L, i8* %tname) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %tname.addr = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %tname, i8** %tname.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i8** %tname.addr, align 8
  call void @lua_getfield(%struct.lua_State* %0, i32 -1001000, i8* %1)
  %2 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_type(%struct.lua_State* %2, i32 -1)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %3 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %3, i32 -2)
  %4 = load %struct.lua_State** %L.addr, align 8
  call void @lua_createtable(%struct.lua_State* %4, i32 0, i32 0)
  %5 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushvalue(%struct.lua_State* %5, i32 -1)
  %6 = load %struct.lua_State** %L.addr, align 8
  %7 = load i8** %tname.addr, align 8
  call void @lua_setfield(%struct.lua_State* %6, i32 -1001000, i8* %7)
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load i32* %retval
  ret i32 %8
}

; Function Attrs: nounwind uwtable
define void @luaL_setmetatable(%struct.lua_State* %L, i8* %tname) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %tname.addr = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %tname, i8** %tname.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i8** %tname.addr, align 8
  call void @lua_getfield(%struct.lua_State* %0, i32 -1001000, i8* %1)
  %2 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_setmetatable(%struct.lua_State* %2, i32 -2)
  ret void
}

; Function Attrs: nounwind uwtable
define i8* @luaL_testudata(%struct.lua_State* %L, i32 %ud, i8* %tname) #0 {
entry:
  %retval = alloca i8*, align 8
  %L.addr = alloca %struct.lua_State*, align 8
  %ud.addr = alloca i32, align 4
  %tname.addr = alloca i8*, align 8
  %p = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %ud, i32* %ud.addr, align 4
  store i8* %tname, i8** %tname.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %ud.addr, align 4
  %call = call i8* @lua_touserdata(%struct.lua_State* %0, i32 %1)
  store i8* %call, i8** %p, align 8
  %2 = load i8** %p, align 8
  %cmp = icmp ne i8* %2, null
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load i32* %ud.addr, align 4
  %call1 = call i32 @lua_getmetatable(%struct.lua_State* %3, i32 %4)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then2, label %if.end6

if.then2:                                         ; preds = %if.then
  %5 = load %struct.lua_State** %L.addr, align 8
  %6 = load i8** %tname.addr, align 8
  call void @lua_getfield(%struct.lua_State* %5, i32 -1001000, i8* %6)
  %7 = load %struct.lua_State** %L.addr, align 8
  %call3 = call i32 @lua_rawequal(%struct.lua_State* %7, i32 -1, i32 -2)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.end, label %if.then5

if.then5:                                         ; preds = %if.then2
  store i8* null, i8** %p, align 8
  br label %if.end

if.end:                                           ; preds = %if.then5, %if.then2
  %8 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %8, i32 -3)
  %9 = load i8** %p, align 8
  store i8* %9, i8** %retval
  br label %return

if.end6:                                          ; preds = %if.then
  br label %if.end7

if.end7:                                          ; preds = %if.end6, %entry
  store i8* null, i8** %retval
  br label %return

return:                                           ; preds = %if.end7, %if.end
  %10 = load i8** %retval
  ret i8* %10
}

; Function Attrs: nounwind uwtable
define i8* @luaL_checkudata(%struct.lua_State* %L, i32 %ud, i8* %tname) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %ud.addr = alloca i32, align 4
  %tname.addr = alloca i8*, align 8
  %p = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %ud, i32* %ud.addr, align 4
  store i8* %tname, i8** %tname.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %ud.addr, align 4
  %2 = load i8** %tname.addr, align 8
  %call = call i8* @luaL_testudata(%struct.lua_State* %0, i32 %1, i8* %2)
  store i8* %call, i8** %p, align 8
  %3 = load i8** %p, align 8
  %cmp = icmp eq i8* %3, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load i32* %ud.addr, align 4
  %6 = load i8** %tname.addr, align 8
  %call1 = call i32 @typeerror(%struct.lua_State* %4, i32 %5, i8* %6)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %7 = load i8** %p, align 8
  ret i8* %7
}

; Function Attrs: nounwind uwtable
define i32 @luaL_checkoption(%struct.lua_State* %L, i32 %narg, i8* %def, i8** %lst) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %narg.addr = alloca i32, align 4
  %def.addr = alloca i8*, align 8
  %lst.addr = alloca i8**, align 8
  %name = alloca i8*, align 8
  %i = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %narg, i32* %narg.addr, align 4
  store i8* %def, i8** %def.addr, align 8
  store i8** %lst, i8*** %lst.addr, align 8
  %0 = load i8** %def.addr, align 8
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load i32* %narg.addr, align 4
  %3 = load i8** %def.addr, align 8
  %call = call i8* @luaL_optlstring(%struct.lua_State* %1, i32 %2, i8* %3, i64* null)
  br label %cond.end

cond.false:                                       ; preds = %entry
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load i32* %narg.addr, align 4
  %call1 = call i8* @luaL_checklstring(%struct.lua_State* %4, i32 %5, i64* null)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %call, %cond.true ], [ %call1, %cond.false ]
  store i8* %cond, i8** %name, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %6 = load i32* %i, align 4
  %idxprom = sext i32 %6 to i64
  %7 = load i8*** %lst.addr, align 8
  %arrayidx = getelementptr inbounds i8** %7, i64 %idxprom
  %8 = load i8** %arrayidx, align 8
  %tobool2 = icmp ne i8* %8, null
  br i1 %tobool2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load i32* %i, align 4
  %idxprom3 = sext i32 %9 to i64
  %10 = load i8*** %lst.addr, align 8
  %arrayidx4 = getelementptr inbounds i8** %10, i64 %idxprom3
  %11 = load i8** %arrayidx4, align 8
  %12 = load i8** %name, align 8
  %call5 = call i32 @strcmp(i8* %11, i8* %12) #10
  %cmp = icmp eq i32 %call5, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %13 = load i32* %i, align 4
  store i32 %13, i32* %retval
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %14 = load i32* %i, align 4
  %inc = add nsw i32 %14, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %15 = load %struct.lua_State** %L.addr, align 8
  %16 = load i32* %narg.addr, align 4
  %17 = load %struct.lua_State** %L.addr, align 8
  %18 = load i8** %name, align 8
  %call6 = call i8* (%struct.lua_State*, i8*, ...)* @lua_pushfstring(%struct.lua_State* %17, i8* getelementptr inbounds ([20 x i8]* @.str20, i32 0, i32 0), i8* %18)
  %call7 = call i32 @luaL_argerror(%struct.lua_State* %15, i32 %16, i8* %call6)
  store i32 %call7, i32* %retval
  br label %return

return:                                           ; preds = %for.end, %if.then
  %19 = load i32* %retval
  ret i32 %19
}

; Function Attrs: nounwind uwtable
define i8* @luaL_optlstring(%struct.lua_State* %L, i32 %narg, i8* %def, i64* %len) #0 {
entry:
  %retval = alloca i8*, align 8
  %L.addr = alloca %struct.lua_State*, align 8
  %narg.addr = alloca i32, align 4
  %def.addr = alloca i8*, align 8
  %len.addr = alloca i64*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %narg, i32* %narg.addr, align 4
  store i8* %def, i8** %def.addr, align 8
  store i64* %len, i64** %len.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %narg.addr, align 4
  %call = call i32 @lua_type(%struct.lua_State* %0, i32 %1)
  %cmp = icmp sle i32 %call, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load i64** %len.addr, align 8
  %tobool = icmp ne i64* %2, null
  br i1 %tobool, label %if.then1, label %if.end

if.then1:                                         ; preds = %if.then
  %3 = load i8** %def.addr, align 8
  %tobool2 = icmp ne i8* %3, null
  br i1 %tobool2, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then1
  %4 = load i8** %def.addr, align 8
  %call3 = call i64 @strlen(i8* %4) #10
  br label %cond.end

cond.false:                                       ; preds = %if.then1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call3, %cond.true ], [ 0, %cond.false ]
  %5 = load i64** %len.addr, align 8
  store i64 %cond, i64* %5, align 8
  br label %if.end

if.end:                                           ; preds = %cond.end, %if.then
  %6 = load i8** %def.addr, align 8
  store i8* %6, i8** %retval
  br label %return

if.else:                                          ; preds = %entry
  %7 = load %struct.lua_State** %L.addr, align 8
  %8 = load i32* %narg.addr, align 4
  %9 = load i64** %len.addr, align 8
  %call4 = call i8* @luaL_checklstring(%struct.lua_State* %7, i32 %8, i64* %9)
  store i8* %call4, i8** %retval
  br label %return

return:                                           ; preds = %if.else, %if.end
  %10 = load i8** %retval
  ret i8* %10
}

; Function Attrs: nounwind uwtable
define i8* @luaL_checklstring(%struct.lua_State* %L, i32 %narg, i64* %len) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %narg.addr = alloca i32, align 4
  %len.addr = alloca i64*, align 8
  %s = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %narg, i32* %narg.addr, align 4
  store i64* %len, i64** %len.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %narg.addr, align 4
  %2 = load i64** %len.addr, align 8
  %call = call i8* @lua_tolstring(%struct.lua_State* %0, i32 %1, i64* %2)
  store i8* %call, i8** %s, align 8
  %3 = load i8** %s, align 8
  %tobool = icmp ne i8* %3, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load i32* %narg.addr, align 4
  call void @tag_error(%struct.lua_State* %4, i32 %5, i32 4)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load i8** %s, align 8
  ret i8* %6
}

; Function Attrs: nounwind uwtable
define void @luaL_checkstack(%struct.lua_State* %L, i32 %space, i8* %msg) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %space.addr = alloca i32, align 4
  %msg.addr = alloca i8*, align 8
  %extra = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %space, i32* %space.addr, align 4
  store i8* %msg, i8** %msg.addr, align 8
  store i32 20, i32* %extra, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %space.addr, align 4
  %add = add nsw i32 %1, 20
  %call = call i32 @lua_checkstack(%struct.lua_State* %0, i32 %add)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end5, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i8** %msg.addr, align 8
  %tobool1 = icmp ne i8* %2, null
  br i1 %tobool1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load i8** %msg.addr, align 8
  %call3 = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %3, i8* getelementptr inbounds ([20 x i8]* @.str21, i32 0, i32 0), i8* %4)
  br label %if.end

if.else:                                          ; preds = %if.then
  %5 = load %struct.lua_State** %L.addr, align 8
  %call4 = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %5, i8* getelementptr inbounds ([15 x i8]* @.str22, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then2
  br label %if.end5

if.end5:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @luaL_checktype(%struct.lua_State* %L, i32 %narg, i32 %t) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %narg.addr = alloca i32, align 4
  %t.addr = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %narg, i32* %narg.addr, align 4
  store i32 %t, i32* %t.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %narg.addr, align 4
  %call = call i32 @lua_type(%struct.lua_State* %0, i32 %1)
  %2 = load i32* %t.addr, align 4
  %cmp = icmp ne i32 %call, %2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load i32* %narg.addr, align 4
  %5 = load i32* %t.addr, align 4
  call void @tag_error(%struct.lua_State* %3, i32 %4, i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @luaL_checkany(%struct.lua_State* %L, i32 %narg) #0 {
entry:
  %L.addr.i = alloca %struct.lua_State*, align 8
  %idx.addr.i = alloca i32, align 4
  %o.i = alloca %struct.lua_TValue*, align 8
  %L.addr = alloca %struct.lua_State*, align 8
  %narg.addr = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %narg, i32* %narg.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %narg.addr, align 4
  %2 = bitcast %struct.lua_State** %L.addr.i to i8*
  call void @llvm.lifetime.start(i64 8, i8* %2) #1
  %3 = bitcast i32* %idx.addr.i to i8*
  call void @llvm.lifetime.start(i64 4, i8* %3) #1
  %4 = bitcast %struct.lua_TValue** %o.i to i8*
  call void @llvm.lifetime.start(i64 8, i8* %4) #1
  store %struct.lua_State* %0, %struct.lua_State** %L.addr.i, align 8
  store i32 %1, i32* %idx.addr.i, align 4
  %5 = load %struct.lua_State** %L.addr.i, align 8
  %6 = load i32* %idx.addr.i, align 4
  %call.i = call %struct.lua_TValue* @index2addr(%struct.lua_State* %5, i32 %6) #1
  store %struct.lua_TValue* %call.i, %struct.lua_TValue** %o.i, align 8
  %7 = load %struct.lua_TValue** %o.i, align 8
  %cmp.i = icmp ne %struct.lua_TValue* %7, bitcast ({ %union.Value.281, i32, [4 x i8] }* @luaO_nilobject_ to %struct.lua_TValue*)
  br i1 %cmp.i, label %cond.true.i, label %cond.false.i

cond.true.i:                                      ; preds = %entry
  %8 = load %struct.lua_TValue** %o.i, align 8
  %tt_.i = getelementptr inbounds %struct.lua_TValue* %8, i32 0, i32 1
  %9 = load i32* %tt_.i, align 4
  %and.i = and i32 %9, 15
  br label %lua_type.exit

cond.false.i:                                     ; preds = %entry
  br label %lua_type.exit

lua_type.exit:                                    ; preds = %cond.false.i, %cond.true.i
  %cond.i = phi i32 [ %and.i, %cond.true.i ], [ -1, %cond.false.i ]
  %10 = bitcast %struct.lua_State** %L.addr.i to i8*
  call void @llvm.lifetime.end(i64 8, i8* %10) #1
  %11 = bitcast i32* %idx.addr.i to i8*
  call void @llvm.lifetime.end(i64 4, i8* %11) #1
  %12 = bitcast %struct.lua_TValue** %o.i to i8*
  call void @llvm.lifetime.end(i64 8, i8* %12) #1
  %cmp = icmp eq i32 %cond.i, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lua_type.exit
  %13 = load %struct.lua_State** %L.addr, align 8
  %14 = load i32* %narg.addr, align 4
  %call1 = call i32 @luaL_argerror(%struct.lua_State* %13, i32 %14, i8* getelementptr inbounds ([15 x i8]* @.str23, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %lua_type.exit
  ret void
}

; Function Attrs: nounwind readonly
declare i64 @strlen(i8*) #2

; Function Attrs: nounwind uwtable
define double @luaL_checknumber(%struct.lua_State* %L, i32 %narg) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %narg.addr = alloca i32, align 4
  %isnum = alloca i32, align 4
  %d = alloca double, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %narg, i32* %narg.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %narg.addr, align 4
  %call = call double @lua_tonumberx(%struct.lua_State* %0, i32 %1, i32* %isnum)
  store double %call, double* %d, align 8
  %2 = load i32* %isnum, align 4
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load i32* %narg.addr, align 4
  call void @tag_error(%struct.lua_State* %3, i32 %4, i32 3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load double* %d, align 8
  ret double %5
}

; Function Attrs: nounwind uwtable
define double @luaL_optnumber(%struct.lua_State* %L, i32 %narg, double %def) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %narg.addr = alloca i32, align 4
  %def.addr = alloca double, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %narg, i32* %narg.addr, align 4
  store double %def, double* %def.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %narg.addr, align 4
  %call = call i32 @lua_type(%struct.lua_State* %0, i32 %1)
  %cmp = icmp sle i32 %call, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load double* %def.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load i32* %narg.addr, align 4
  %call1 = call double @luaL_checknumber(%struct.lua_State* %3, i32 %4)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi double [ %2, %cond.true ], [ %call1, %cond.false ]
  ret double %cond
}

; Function Attrs: nounwind uwtable
define i64 @luaL_checkinteger(%struct.lua_State* %L, i32 %narg) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %narg.addr = alloca i32, align 4
  %isnum = alloca i32, align 4
  %d = alloca i64, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %narg, i32* %narg.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %narg.addr, align 4
  %call = call i64 @lua_tointegerx(%struct.lua_State* %0, i32 %1, i32* %isnum)
  store i64 %call, i64* %d, align 8
  %2 = load i32* %isnum, align 4
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load i32* %narg.addr, align 4
  call void @tag_error(%struct.lua_State* %3, i32 %4, i32 3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load i64* %d, align 8
  ret i64 %5
}

; Function Attrs: nounwind uwtable
define i32 @luaL_checkunsigned(%struct.lua_State* %L, i32 %narg) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %narg.addr = alloca i32, align 4
  %isnum = alloca i32, align 4
  %d = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %narg, i32* %narg.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %narg.addr, align 4
  %call = call i32 @lua_tounsignedx(%struct.lua_State* %0, i32 %1, i32* %isnum)
  store i32 %call, i32* %d, align 4
  %2 = load i32* %isnum, align 4
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load i32* %narg.addr, align 4
  call void @tag_error(%struct.lua_State* %3, i32 %4, i32 3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load i32* %d, align 4
  ret i32 %5
}

; Function Attrs: nounwind uwtable
define i64 @luaL_optinteger(%struct.lua_State* %L, i32 %narg, i64 %def) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %narg.addr = alloca i32, align 4
  %def.addr = alloca i64, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %narg, i32* %narg.addr, align 4
  store i64 %def, i64* %def.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %narg.addr, align 4
  %call = call i32 @lua_type(%struct.lua_State* %0, i32 %1)
  %cmp = icmp sle i32 %call, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load i64* %def.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load i32* %narg.addr, align 4
  %call1 = call i64 @luaL_checkinteger(%struct.lua_State* %3, i32 %4)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %2, %cond.true ], [ %call1, %cond.false ]
  ret i64 %cond
}

; Function Attrs: nounwind uwtable
define i32 @luaL_optunsigned(%struct.lua_State* %L, i32 %narg, i32 %def) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %narg.addr = alloca i32, align 4
  %def.addr = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %narg, i32* %narg.addr, align 4
  store i32 %def, i32* %def.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %narg.addr, align 4
  %call = call i32 @lua_type(%struct.lua_State* %0, i32 %1)
  %cmp = icmp sle i32 %call, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load i32* %def.addr, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load i32* %narg.addr, align 4
  %call1 = call i32 @luaL_checkunsigned(%struct.lua_State* %3, i32 %4)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %2, %cond.true ], [ %call1, %cond.false ]
  ret i32 %cond
}

; Function Attrs: nounwind uwtable
define i8* @luaL_prepbuffsize(%struct.luaL_Buffer* %B, i64 %sz) #0 {
entry:
  %B.addr = alloca %struct.luaL_Buffer*, align 8
  %sz.addr = alloca i64, align 8
  %L = alloca %struct.lua_State*, align 8
  %newbuff = alloca i8*, align 8
  %newsize = alloca i64, align 8
  store %struct.luaL_Buffer* %B, %struct.luaL_Buffer** %B.addr, align 8
  store i64 %sz, i64* %sz.addr, align 8
  %0 = load %struct.luaL_Buffer** %B.addr, align 8
  %L1 = getelementptr inbounds %struct.luaL_Buffer* %0, i32 0, i32 3
  %1 = load %struct.lua_State** %L1, align 8
  store %struct.lua_State* %1, %struct.lua_State** %L, align 8
  %2 = load %struct.luaL_Buffer** %B.addr, align 8
  %size = getelementptr inbounds %struct.luaL_Buffer* %2, i32 0, i32 1
  %3 = load i64* %size, align 8
  %4 = load %struct.luaL_Buffer** %B.addr, align 8
  %n = getelementptr inbounds %struct.luaL_Buffer* %4, i32 0, i32 2
  %5 = load i64* %n, align 8
  %sub = sub i64 %3, %5
  %6 = load i64* %sz.addr, align 8
  %cmp = icmp ult i64 %sub, %6
  br i1 %cmp, label %if.then, label %if.end25

if.then:                                          ; preds = %entry
  %7 = load %struct.luaL_Buffer** %B.addr, align 8
  %size2 = getelementptr inbounds %struct.luaL_Buffer* %7, i32 0, i32 1
  %8 = load i64* %size2, align 8
  %mul = mul i64 %8, 2
  store i64 %mul, i64* %newsize, align 8
  %9 = load i64* %newsize, align 8
  %10 = load %struct.luaL_Buffer** %B.addr, align 8
  %n3 = getelementptr inbounds %struct.luaL_Buffer* %10, i32 0, i32 2
  %11 = load i64* %n3, align 8
  %sub4 = sub i64 %9, %11
  %12 = load i64* %sz.addr, align 8
  %cmp5 = icmp ult i64 %sub4, %12
  br i1 %cmp5, label %if.then6, label %if.end

if.then6:                                         ; preds = %if.then
  %13 = load %struct.luaL_Buffer** %B.addr, align 8
  %n7 = getelementptr inbounds %struct.luaL_Buffer* %13, i32 0, i32 2
  %14 = load i64* %n7, align 8
  %15 = load i64* %sz.addr, align 8
  %add = add i64 %14, %15
  store i64 %add, i64* %newsize, align 8
  br label %if.end

if.end:                                           ; preds = %if.then6, %if.then
  %16 = load i64* %newsize, align 8
  %17 = load %struct.luaL_Buffer** %B.addr, align 8
  %n8 = getelementptr inbounds %struct.luaL_Buffer* %17, i32 0, i32 2
  %18 = load i64* %n8, align 8
  %cmp9 = icmp ult i64 %16, %18
  br i1 %cmp9, label %if.then13, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %19 = load i64* %newsize, align 8
  %20 = load %struct.luaL_Buffer** %B.addr, align 8
  %n10 = getelementptr inbounds %struct.luaL_Buffer* %20, i32 0, i32 2
  %21 = load i64* %n10, align 8
  %sub11 = sub i64 %19, %21
  %22 = load i64* %sz.addr, align 8
  %cmp12 = icmp ult i64 %sub11, %22
  br i1 %cmp12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %lor.lhs.false, %if.end
  %23 = load %struct.lua_State** %L, align 8
  %call = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %23, i8* getelementptr inbounds ([17 x i8]* @.str246, i32 0, i32 0))
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %lor.lhs.false
  %24 = load %struct.lua_State** %L, align 8
  %25 = load i64* %newsize, align 8
  %mul15 = mul i64 %25, 1
  %call16 = call i8* @lua_newuserdata(%struct.lua_State* %24, i64 %mul15)
  store i8* %call16, i8** %newbuff, align 8
  %26 = load i8** %newbuff, align 8
  %27 = load %struct.luaL_Buffer** %B.addr, align 8
  %b = getelementptr inbounds %struct.luaL_Buffer* %27, i32 0, i32 0
  %28 = load i8** %b, align 8
  %29 = load %struct.luaL_Buffer** %B.addr, align 8
  %n17 = getelementptr inbounds %struct.luaL_Buffer* %29, i32 0, i32 2
  %30 = load i64* %n17, align 8
  %mul18 = mul i64 %30, 1
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %26, i8* %28, i64 %mul18, i32 1, i1 false)
  %31 = load %struct.luaL_Buffer** %B.addr, align 8
  %b19 = getelementptr inbounds %struct.luaL_Buffer* %31, i32 0, i32 0
  %32 = load i8** %b19, align 8
  %33 = load %struct.luaL_Buffer** %B.addr, align 8
  %initb = getelementptr inbounds %struct.luaL_Buffer* %33, i32 0, i32 4
  %arraydecay = getelementptr inbounds [8192 x i8]* %initb, i32 0, i32 0
  %cmp20 = icmp ne i8* %32, %arraydecay
  br i1 %cmp20, label %if.then21, label %if.end22

if.then21:                                        ; preds = %if.end14
  %34 = load %struct.lua_State** %L, align 8
  call void @lua_remove(%struct.lua_State* %34, i32 -2)
  br label %if.end22

if.end22:                                         ; preds = %if.then21, %if.end14
  %35 = load i8** %newbuff, align 8
  %36 = load %struct.luaL_Buffer** %B.addr, align 8
  %b23 = getelementptr inbounds %struct.luaL_Buffer* %36, i32 0, i32 0
  store i8* %35, i8** %b23, align 8
  %37 = load i64* %newsize, align 8
  %38 = load %struct.luaL_Buffer** %B.addr, align 8
  %size24 = getelementptr inbounds %struct.luaL_Buffer* %38, i32 0, i32 1
  store i64 %37, i64* %size24, align 8
  br label %if.end25

if.end25:                                         ; preds = %if.end22, %entry
  %39 = load %struct.luaL_Buffer** %B.addr, align 8
  %n26 = getelementptr inbounds %struct.luaL_Buffer* %39, i32 0, i32 2
  %40 = load i64* %n26, align 8
  %41 = load %struct.luaL_Buffer** %B.addr, align 8
  %b27 = getelementptr inbounds %struct.luaL_Buffer* %41, i32 0, i32 0
  %42 = load i8** %b27, align 8
  %arrayidx = getelementptr inbounds i8* %42, i64 %40
  ret i8* %arrayidx
}

; Function Attrs: nounwind uwtable
define void @luaL_addlstring(%struct.luaL_Buffer* %B, i8* %s, i64 %l) #0 {
entry:
  %B.addr = alloca %struct.luaL_Buffer*, align 8
  %s.addr = alloca i8*, align 8
  %l.addr = alloca i64, align 8
  %b = alloca i8*, align 8
  store %struct.luaL_Buffer* %B, %struct.luaL_Buffer** %B.addr, align 8
  store i8* %s, i8** %s.addr, align 8
  store i64 %l, i64* %l.addr, align 8
  %0 = load %struct.luaL_Buffer** %B.addr, align 8
  %1 = load i64* %l.addr, align 8
  %call = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* %0, i64 %1)
  store i8* %call, i8** %b, align 8
  %2 = load i8** %b, align 8
  %3 = load i8** %s.addr, align 8
  %4 = load i64* %l.addr, align 8
  %mul = mul i64 %4, 1
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %2, i8* %3, i64 %mul, i32 1, i1 false)
  %5 = load i64* %l.addr, align 8
  %6 = load %struct.luaL_Buffer** %B.addr, align 8
  %n = getelementptr inbounds %struct.luaL_Buffer* %6, i32 0, i32 2
  %7 = load i64* %n, align 8
  %add = add i64 %7, %5
  store i64 %add, i64* %n, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define void @luaL_addstring(%struct.luaL_Buffer* %B, i8* %s) #0 {
entry:
  %B.addr = alloca %struct.luaL_Buffer*, align 8
  %s.addr = alloca i8*, align 8
  store %struct.luaL_Buffer* %B, %struct.luaL_Buffer** %B.addr, align 8
  store i8* %s, i8** %s.addr, align 8
  %0 = load %struct.luaL_Buffer** %B.addr, align 8
  %1 = load i8** %s.addr, align 8
  %2 = load i8** %s.addr, align 8
  %call = call i64 @strlen(i8* %2) #10
  call void @luaL_addlstring(%struct.luaL_Buffer* %0, i8* %1, i64 %call)
  ret void
}

; Function Attrs: nounwind uwtable
define void @luaL_pushresult(%struct.luaL_Buffer* %B) #0 {
entry:
  %B.addr = alloca %struct.luaL_Buffer*, align 8
  %L = alloca %struct.lua_State*, align 8
  store %struct.luaL_Buffer* %B, %struct.luaL_Buffer** %B.addr, align 8
  %0 = load %struct.luaL_Buffer** %B.addr, align 8
  %L1 = getelementptr inbounds %struct.luaL_Buffer* %0, i32 0, i32 3
  %1 = load %struct.lua_State** %L1, align 8
  store %struct.lua_State* %1, %struct.lua_State** %L, align 8
  %2 = load %struct.lua_State** %L, align 8
  %3 = load %struct.luaL_Buffer** %B.addr, align 8
  %b = getelementptr inbounds %struct.luaL_Buffer* %3, i32 0, i32 0
  %4 = load i8** %b, align 8
  %5 = load %struct.luaL_Buffer** %B.addr, align 8
  %n = getelementptr inbounds %struct.luaL_Buffer* %5, i32 0, i32 2
  %6 = load i64* %n, align 8
  %call = call i8* @lua_pushlstring(%struct.lua_State* %2, i8* %4, i64 %6)
  %7 = load %struct.luaL_Buffer** %B.addr, align 8
  %b2 = getelementptr inbounds %struct.luaL_Buffer* %7, i32 0, i32 0
  %8 = load i8** %b2, align 8
  %9 = load %struct.luaL_Buffer** %B.addr, align 8
  %initb = getelementptr inbounds %struct.luaL_Buffer* %9, i32 0, i32 4
  %arraydecay = getelementptr inbounds [8192 x i8]* %initb, i32 0, i32 0
  %cmp = icmp ne i8* %8, %arraydecay
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %10 = load %struct.lua_State** %L, align 8
  call void @lua_remove(%struct.lua_State* %10, i32 -2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @luaL_pushresultsize(%struct.luaL_Buffer* %B, i64 %sz) #0 {
entry:
  %B.addr = alloca %struct.luaL_Buffer*, align 8
  %sz.addr = alloca i64, align 8
  store %struct.luaL_Buffer* %B, %struct.luaL_Buffer** %B.addr, align 8
  store i64 %sz, i64* %sz.addr, align 8
  %0 = load i64* %sz.addr, align 8
  %1 = load %struct.luaL_Buffer** %B.addr, align 8
  %n = getelementptr inbounds %struct.luaL_Buffer* %1, i32 0, i32 2
  %2 = load i64* %n, align 8
  %add = add i64 %2, %0
  store i64 %add, i64* %n, align 8
  %3 = load %struct.luaL_Buffer** %B.addr, align 8
  call void @luaL_pushresult(%struct.luaL_Buffer* %3)
  ret void
}

; Function Attrs: nounwind uwtable
define void @luaL_addvalue(%struct.luaL_Buffer* %B) #0 {
entry:
  %B.addr = alloca %struct.luaL_Buffer*, align 8
  %L = alloca %struct.lua_State*, align 8
  %l = alloca i64, align 8
  %s = alloca i8*, align 8
  store %struct.luaL_Buffer* %B, %struct.luaL_Buffer** %B.addr, align 8
  %0 = load %struct.luaL_Buffer** %B.addr, align 8
  %L1 = getelementptr inbounds %struct.luaL_Buffer* %0, i32 0, i32 3
  %1 = load %struct.lua_State** %L1, align 8
  store %struct.lua_State* %1, %struct.lua_State** %L, align 8
  %2 = load %struct.lua_State** %L, align 8
  %call = call i8* @lua_tolstring(%struct.lua_State* %2, i32 -1, i64* %l)
  store i8* %call, i8** %s, align 8
  %3 = load %struct.luaL_Buffer** %B.addr, align 8
  %b = getelementptr inbounds %struct.luaL_Buffer* %3, i32 0, i32 0
  %4 = load i8** %b, align 8
  %5 = load %struct.luaL_Buffer** %B.addr, align 8
  %initb = getelementptr inbounds %struct.luaL_Buffer* %5, i32 0, i32 4
  %arraydecay = getelementptr inbounds [8192 x i8]* %initb, i32 0, i32 0
  %cmp = icmp ne i8* %4, %arraydecay
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load %struct.lua_State** %L, align 8
  call void @lua_insert(%struct.lua_State* %6, i32 -2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %7 = load %struct.luaL_Buffer** %B.addr, align 8
  %8 = load i8** %s, align 8
  %9 = load i64* %l, align 8
  call void @luaL_addlstring(%struct.luaL_Buffer* %7, i8* %8, i64 %9)
  %10 = load %struct.lua_State** %L, align 8
  %11 = load %struct.luaL_Buffer** %B.addr, align 8
  %b2 = getelementptr inbounds %struct.luaL_Buffer* %11, i32 0, i32 0
  %12 = load i8** %b2, align 8
  %13 = load %struct.luaL_Buffer** %B.addr, align 8
  %initb3 = getelementptr inbounds %struct.luaL_Buffer* %13, i32 0, i32 4
  %arraydecay4 = getelementptr inbounds [8192 x i8]* %initb3, i32 0, i32 0
  %cmp5 = icmp ne i8* %12, %arraydecay4
  %cond = select i1 %cmp5, i32 -2, i32 -1
  call void @lua_remove(%struct.lua_State* %10, i32 %cond)
  ret void
}

; Function Attrs: nounwind uwtable
define void @luaL_buffinit(%struct.lua_State* %L, %struct.luaL_Buffer* %B) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %B.addr = alloca %struct.luaL_Buffer*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.luaL_Buffer* %B, %struct.luaL_Buffer** %B.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load %struct.luaL_Buffer** %B.addr, align 8
  %L1 = getelementptr inbounds %struct.luaL_Buffer* %1, i32 0, i32 3
  store %struct.lua_State* %0, %struct.lua_State** %L1, align 8
  %2 = load %struct.luaL_Buffer** %B.addr, align 8
  %initb = getelementptr inbounds %struct.luaL_Buffer* %2, i32 0, i32 4
  %arraydecay = getelementptr inbounds [8192 x i8]* %initb, i32 0, i32 0
  %3 = load %struct.luaL_Buffer** %B.addr, align 8
  %b = getelementptr inbounds %struct.luaL_Buffer* %3, i32 0, i32 0
  store i8* %arraydecay, i8** %b, align 8
  %4 = load %struct.luaL_Buffer** %B.addr, align 8
  %n = getelementptr inbounds %struct.luaL_Buffer* %4, i32 0, i32 2
  store i64 0, i64* %n, align 8
  %5 = load %struct.luaL_Buffer** %B.addr, align 8
  %size = getelementptr inbounds %struct.luaL_Buffer* %5, i32 0, i32 1
  store i64 8192, i64* %size, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define i8* @luaL_buffinitsize(%struct.lua_State* %L, %struct.luaL_Buffer* %B, i64 %sz) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %B.addr = alloca %struct.luaL_Buffer*, align 8
  %sz.addr = alloca i64, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.luaL_Buffer* %B, %struct.luaL_Buffer** %B.addr, align 8
  store i64 %sz, i64* %sz.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load %struct.luaL_Buffer** %B.addr, align 8
  call void @luaL_buffinit(%struct.lua_State* %0, %struct.luaL_Buffer* %1)
  %2 = load %struct.luaL_Buffer** %B.addr, align 8
  %3 = load i64* %sz.addr, align 8
  %call = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* %2, i64 %3)
  ret i8* %call
}

; Function Attrs: nounwind uwtable
define i32 @luaL_ref(%struct.lua_State* %L, i32 %t) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %t.addr = alloca i32, align 4
  %ref = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %t, i32* %t.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_type(%struct.lua_State* %0, i32 -1)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %1, i32 -2)
  store i32 -1, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load i32* %t.addr, align 4
  %call1 = call i32 @lua_absindex(%struct.lua_State* %2, i32 %3)
  store i32 %call1, i32* %t.addr, align 4
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load i32* %t.addr, align 4
  call void @lua_rawgeti(%struct.lua_State* %4, i32 %5, i32 0)
  %6 = load %struct.lua_State** %L.addr, align 8
  %call2 = call i64 @lua_tointegerx(%struct.lua_State* %6, i32 -1, i32* null)
  %conv = trunc i64 %call2 to i32
  store i32 %conv, i32* %ref, align 4
  %7 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %7, i32 -2)
  %8 = load i32* %ref, align 4
  %cmp3 = icmp ne i32 %8, 0
  br i1 %cmp3, label %if.then5, label %if.else

if.then5:                                         ; preds = %if.end
  %9 = load %struct.lua_State** %L.addr, align 8
  %10 = load i32* %t.addr, align 4
  %11 = load i32* %ref, align 4
  call void @lua_rawgeti(%struct.lua_State* %9, i32 %10, i32 %11)
  %12 = load %struct.lua_State** %L.addr, align 8
  %13 = load i32* %t.addr, align 4
  call void @lua_rawseti(%struct.lua_State* %12, i32 %13, i32 0)
  br label %if.end8

if.else:                                          ; preds = %if.end
  %14 = load %struct.lua_State** %L.addr, align 8
  %15 = load i32* %t.addr, align 4
  %call6 = call i64 @lua_rawlen(%struct.lua_State* %14, i32 %15)
  %conv7 = trunc i64 %call6 to i32
  %add = add nsw i32 %conv7, 1
  store i32 %add, i32* %ref, align 4
  br label %if.end8

if.end8:                                          ; preds = %if.else, %if.then5
  %16 = load %struct.lua_State** %L.addr, align 8
  %17 = load i32* %t.addr, align 4
  %18 = load i32* %ref, align 4
  call void @lua_rawseti(%struct.lua_State* %16, i32 %17, i32 %18)
  %19 = load i32* %ref, align 4
  store i32 %19, i32* %retval
  br label %return

return:                                           ; preds = %if.end8, %if.then
  %20 = load i32* %retval
  ret i32 %20
}

; Function Attrs: nounwind uwtable
define void @luaL_unref(%struct.lua_State* %L, i32 %t, i32 %ref) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %t.addr = alloca i32, align 4
  %ref.addr = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %t, i32* %t.addr, align 4
  store i32 %ref, i32* %ref.addr, align 4
  %0 = load i32* %ref.addr, align 4
  %cmp = icmp sge i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load i32* %t.addr, align 4
  %call = call i32 @lua_absindex(%struct.lua_State* %1, i32 %2)
  store i32 %call, i32* %t.addr, align 4
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load i32* %t.addr, align 4
  call void @lua_rawgeti(%struct.lua_State* %3, i32 %4, i32 0)
  %5 = load %struct.lua_State** %L.addr, align 8
  %6 = load i32* %t.addr, align 4
  %7 = load i32* %ref.addr, align 4
  call void @lua_rawseti(%struct.lua_State* %5, i32 %6, i32 %7)
  %8 = load %struct.lua_State** %L.addr, align 8
  %9 = load i32* %ref.addr, align 4
  %conv = sext i32 %9 to i64
  call void @lua_pushinteger(%struct.lua_State* %8, i64 %conv)
  %10 = load %struct.lua_State** %L.addr, align 8
  %11 = load i32* %t.addr, align 4
  call void @lua_rawseti(%struct.lua_State* %10, i32 %11, i32 0)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @luaL_loadfilex(%struct.lua_State* %L, i8* %filename, i8* %mode) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %filename.addr = alloca i8*, align 8
  %mode.addr = alloca i8*, align 8
  %lf = alloca %struct.LoadF, align 8
  %status = alloca i32, align 4
  %readstatus = alloca i32, align 4
  %c = alloca i32, align 4
  %fnameindex = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %filename, i8** %filename.addr, align 8
  store i8* %mode, i8** %mode.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_gettop(%struct.lua_State* %0)
  %add = add nsw i32 %call, 1
  store i32 %add, i32* %fnameindex, align 4
  %1 = load i8** %filename.addr, align 8
  %cmp = icmp eq i8* %1, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i8* @lua_pushlstring(%struct.lua_State* %2, i8* getelementptr inbounds ([7 x i8]* @.str25, i32 0, i32 0), i64 6)
  %3 = load %struct._IO_FILE** @stdin, align 8
  %f = getelementptr inbounds %struct.LoadF* %lf, i32 0, i32 1
  store %struct._IO_FILE* %3, %struct._IO_FILE** %f, align 8
  br label %if.end9

if.else:                                          ; preds = %entry
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load i8** %filename.addr, align 8
  %call2 = call i8* (%struct.lua_State*, i8*, ...)* @lua_pushfstring(%struct.lua_State* %4, i8* getelementptr inbounds ([4 x i8]* @.str26, i32 0, i32 0), i8* %5)
  %6 = load i8** %filename.addr, align 8
  %call3 = call %struct._IO_FILE* @fopen(i8* %6, i8* getelementptr inbounds ([2 x i8]* @.str27, i32 0, i32 0))
  %f4 = getelementptr inbounds %struct.LoadF* %lf, i32 0, i32 1
  store %struct._IO_FILE* %call3, %struct._IO_FILE** %f4, align 8
  %f5 = getelementptr inbounds %struct.LoadF* %lf, i32 0, i32 1
  %7 = load %struct._IO_FILE** %f5, align 8
  %cmp6 = icmp eq %struct._IO_FILE* %7, null
  br i1 %cmp6, label %if.then7, label %if.end

if.then7:                                         ; preds = %if.else
  %8 = load %struct.lua_State** %L.addr, align 8
  %9 = load i32* %fnameindex, align 4
  %call8 = call i32 @errfile(%struct.lua_State* %8, i8* getelementptr inbounds ([5 x i8]* @.str28, i32 0, i32 0), i32 %9)
  store i32 %call8, i32* %retval
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end9

if.end9:                                          ; preds = %if.end, %if.then
  %call10 = call i32 @skipcomment(%struct.LoadF* %lf, i32* %c)
  %tobool = icmp ne i32 %call10, 0
  br i1 %tobool, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end9
  %n = getelementptr inbounds %struct.LoadF* %lf, i32 0, i32 0
  %10 = load i32* %n, align 4
  %inc = add nsw i32 %10, 1
  store i32 %inc, i32* %n, align 4
  %idxprom = sext i32 %10 to i64
  %buff = getelementptr inbounds %struct.LoadF* %lf, i32 0, i32 2
  %arrayidx = getelementptr inbounds [8192 x i8]* %buff, i32 0, i64 %idxprom
  store i8 10, i8* %arrayidx, align 1
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %if.end9
  %11 = load i32* %c, align 4
  %12 = load i8* getelementptr inbounds ([5 x i8]* @.str29, i32 0, i64 0), align 1
  %conv = sext i8 %12 to i32
  %cmp13 = icmp eq i32 %11, %conv
  br i1 %cmp13, label %land.lhs.true, label %if.end27

land.lhs.true:                                    ; preds = %if.end12
  %13 = load i8** %filename.addr, align 8
  %tobool15 = icmp ne i8* %13, null
  br i1 %tobool15, label %if.then16, label %if.end27

if.then16:                                        ; preds = %land.lhs.true
  %14 = load i8** %filename.addr, align 8
  %f17 = getelementptr inbounds %struct.LoadF* %lf, i32 0, i32 1
  %15 = load %struct._IO_FILE** %f17, align 8
  %call18 = call %struct._IO_FILE* @freopen(i8* %14, i8* getelementptr inbounds ([3 x i8]* @.str30, i32 0, i32 0), %struct._IO_FILE* %15)
  %f19 = getelementptr inbounds %struct.LoadF* %lf, i32 0, i32 1
  store %struct._IO_FILE* %call18, %struct._IO_FILE** %f19, align 8
  %f20 = getelementptr inbounds %struct.LoadF* %lf, i32 0, i32 1
  %16 = load %struct._IO_FILE** %f20, align 8
  %cmp21 = icmp eq %struct._IO_FILE* %16, null
  br i1 %cmp21, label %if.then23, label %if.end25

if.then23:                                        ; preds = %if.then16
  %17 = load %struct.lua_State** %L.addr, align 8
  %18 = load i32* %fnameindex, align 4
  %call24 = call i32 @errfile(%struct.lua_State* %17, i8* getelementptr inbounds ([7 x i8]* @.str31, i32 0, i32 0), i32 %18)
  store i32 %call24, i32* %retval
  br label %return

if.end25:                                         ; preds = %if.then16
  %call26 = call i32 @skipcomment(%struct.LoadF* %lf, i32* %c)
  br label %if.end27

if.end27:                                         ; preds = %if.end25, %land.lhs.true, %if.end12
  %19 = load i32* %c, align 4
  %cmp28 = icmp ne i32 %19, -1
  br i1 %cmp28, label %if.then30, label %if.end37

if.then30:                                        ; preds = %if.end27
  %20 = load i32* %c, align 4
  %conv31 = trunc i32 %20 to i8
  %n32 = getelementptr inbounds %struct.LoadF* %lf, i32 0, i32 0
  %21 = load i32* %n32, align 4
  %inc33 = add nsw i32 %21, 1
  store i32 %inc33, i32* %n32, align 4
  %idxprom34 = sext i32 %21 to i64
  %buff35 = getelementptr inbounds %struct.LoadF* %lf, i32 0, i32 2
  %arrayidx36 = getelementptr inbounds [8192 x i8]* %buff35, i32 0, i64 %idxprom34
  store i8 %conv31, i8* %arrayidx36, align 1
  br label %if.end37

if.end37:                                         ; preds = %if.then30, %if.end27
  %22 = load %struct.lua_State** %L.addr, align 8
  %23 = bitcast %struct.LoadF* %lf to i8*
  %24 = load %struct.lua_State** %L.addr, align 8
  %call38 = call i8* @lua_tolstring(%struct.lua_State* %24, i32 -1, i64* null)
  %25 = load i8** %mode.addr, align 8
  %call39 = call i32 @lua_load(%struct.lua_State* %22, i8* (%struct.lua_State*, i8*, i64*)* @getF, i8* %23, i8* %call38, i8* %25)
  store i32 %call39, i32* %status, align 4
  %f40 = getelementptr inbounds %struct.LoadF* %lf, i32 0, i32 1
  %26 = load %struct._IO_FILE** %f40, align 8
  %call41 = call i32 @ferror(%struct._IO_FILE* %26) #1
  store i32 %call41, i32* %readstatus, align 4
  %27 = load i8** %filename.addr, align 8
  %tobool42 = icmp ne i8* %27, null
  br i1 %tobool42, label %if.then43, label %if.end46

if.then43:                                        ; preds = %if.end37
  %f44 = getelementptr inbounds %struct.LoadF* %lf, i32 0, i32 1
  %28 = load %struct._IO_FILE** %f44, align 8
  %call45 = call i32 @fclose(%struct._IO_FILE* %28)
  br label %if.end46

if.end46:                                         ; preds = %if.then43, %if.end37
  %29 = load i32* %readstatus, align 4
  %tobool47 = icmp ne i32 %29, 0
  br i1 %tobool47, label %if.then48, label %if.end50

if.then48:                                        ; preds = %if.end46
  %30 = load %struct.lua_State** %L.addr, align 8
  %31 = load i32* %fnameindex, align 4
  call void @lua_settop(%struct.lua_State* %30, i32 %31)
  %32 = load %struct.lua_State** %L.addr, align 8
  %33 = load i32* %fnameindex, align 4
  %call49 = call i32 @errfile(%struct.lua_State* %32, i8* getelementptr inbounds ([5 x i8]* @.str32, i32 0, i32 0), i32 %33)
  store i32 %call49, i32* %retval
  br label %return

if.end50:                                         ; preds = %if.end46
  %34 = load %struct.lua_State** %L.addr, align 8
  %35 = load i32* %fnameindex, align 4
  call void @lua_remove(%struct.lua_State* %34, i32 %35)
  %36 = load i32* %status, align 4
  store i32 %36, i32* %retval
  br label %return

return:                                           ; preds = %if.end50, %if.then48, %if.then23, %if.then7
  %37 = load i32* %retval
  ret i32 %37
}

declare %struct._IO_FILE* @fopen(i8*, i8*) #5

declare %struct._IO_FILE* @freopen(i8*, i8*, %struct._IO_FILE*) #5

; Function Attrs: nounwind
declare i32 @ferror(%struct._IO_FILE*) #4

declare i32 @fclose(%struct._IO_FILE*) #5

; Function Attrs: nounwind uwtable
define i32 @luaL_loadbufferx(%struct.lua_State* %L, i8* %buff, i64 %size, i8* %name, i8* %mode) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %buff.addr = alloca i8*, align 8
  %size.addr = alloca i64, align 8
  %name.addr = alloca i8*, align 8
  %mode.addr = alloca i8*, align 8
  %ls = alloca %struct.LoadS, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %buff, i8** %buff.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i8* %name, i8** %name.addr, align 8
  store i8* %mode, i8** %mode.addr, align 8
  %0 = load i8** %buff.addr, align 8
  %s = getelementptr inbounds %struct.LoadS* %ls, i32 0, i32 0
  store i8* %0, i8** %s, align 8
  %1 = load i64* %size.addr, align 8
  %size1 = getelementptr inbounds %struct.LoadS* %ls, i32 0, i32 1
  store i64 %1, i64* %size1, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = bitcast %struct.LoadS* %ls to i8*
  %4 = load i8** %name.addr, align 8
  %5 = load i8** %mode.addr, align 8
  %call = call i32 @lua_load(%struct.lua_State* %2, i8* (%struct.lua_State*, i8*, i64*)* @getS, i8* %3, i8* %4, i8* %5)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define i32 @luaL_loadstring(%struct.lua_State* %L, i8* %s) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %s.addr = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %s, i8** %s.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i8** %s.addr, align 8
  %2 = load i8** %s.addr, align 8
  %call = call i64 @strlen(i8* %2) #10
  %3 = load i8** %s.addr, align 8
  %call1 = call i32 @luaL_loadbufferx(%struct.lua_State* %0, i8* %1, i64 %call, i8* %3, i8* null)
  ret i32 %call1
}

; Function Attrs: nounwind uwtable
define i32 @luaL_getmetafield(%struct.lua_State* %L, i32 %obj, i8* %event) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %obj.addr = alloca i32, align 4
  %event.addr = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %obj, i32* %obj.addr, align 4
  store i8* %event, i8** %event.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %obj.addr, align 4
  %call = call i32 @lua_getmetatable(%struct.lua_State* %0, i32 %1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load i8** %event.addr, align 8
  %call1 = call i8* @lua_pushstring(%struct.lua_State* %2, i8* %3)
  %4 = load %struct.lua_State** %L.addr, align 8
  call void @lua_rawget(%struct.lua_State* %4, i32 -2)
  %5 = load %struct.lua_State** %L.addr, align 8
  %call2 = call i32 @lua_type(%struct.lua_State* %5, i32 -1)
  %cmp = icmp eq i32 %call2, 0
  br i1 %cmp, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  %6 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %6, i32 -3)
  store i32 0, i32* %retval
  br label %return

if.else:                                          ; preds = %if.end
  %7 = load %struct.lua_State** %L.addr, align 8
  call void @lua_remove(%struct.lua_State* %7, i32 -2)
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %if.else, %if.then3, %if.then
  %8 = load i32* %retval
  ret i32 %8
}

; Function Attrs: nounwind uwtable
define i32 @luaL_callmeta(%struct.lua_State* %L, i32 %obj, i8* %event) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %obj.addr = alloca i32, align 4
  %event.addr = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %obj, i32* %obj.addr, align 4
  store i8* %event, i8** %event.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %obj.addr, align 4
  %call = call i32 @lua_absindex(%struct.lua_State* %0, i32 %1)
  store i32 %call, i32* %obj.addr, align 4
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load i32* %obj.addr, align 4
  %4 = load i8** %event.addr, align 8
  %call1 = call i32 @luaL_getmetafield(%struct.lua_State* %2, i32 %3, i8* %4)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %5 = load %struct.lua_State** %L.addr, align 8
  %6 = load i32* %obj.addr, align 4
  call void @lua_pushvalue(%struct.lua_State* %5, i32 %6)
  %7 = load %struct.lua_State** %L.addr, align 8
  call void @lua_callk(%struct.lua_State* %7, i32 1, i32 1, i32 0, i32 (%struct.lua_State*)* null)
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load i32* %retval
  ret i32 %8
}

; Function Attrs: nounwind uwtable
define i32 @luaL_len(%struct.lua_State* %L, i32 %idx) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %idx.addr = alloca i32, align 4
  %l = alloca i32, align 4
  %isnum = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %idx.addr, align 4
  call void @lua_len(%struct.lua_State* %0, i32 %1)
  %2 = load %struct.lua_State** %L.addr, align 8
  %call = call i64 @lua_tointegerx(%struct.lua_State* %2, i32 -1, i32* %isnum)
  %conv = trunc i64 %call to i32
  store i32 %conv, i32* %l, align 4
  %3 = load i32* %isnum, align 4
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %4 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %4, i8* getelementptr inbounds ([30 x i8]* @.str33, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %5, i32 -2)
  %6 = load i32* %l, align 4
  ret i32 %6
}

; Function Attrs: nounwind uwtable
define i8* @luaL_tolstring(%struct.lua_State* %L, i32 %idx, i64* %len) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %idx.addr = alloca i32, align 4
  %len.addr = alloca i64*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  store i64* %len, i64** %len.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %idx.addr, align 4
  %call = call i32 @luaL_callmeta(%struct.lua_State* %0, i32 %1, i8* getelementptr inbounds ([11 x i8]* @.str34, i32 0, i32 0))
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load i32* %idx.addr, align 4
  %call1 = call i32 @lua_type(%struct.lua_State* %2, i32 %3)
  switch i32 %call1, label %sw.default [
    i32 3, label %sw.bb
    i32 4, label %sw.bb
    i32 1, label %sw.bb2
    i32 0, label %sw.bb6
  ]

sw.bb:                                            ; preds = %if.then, %if.then
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load i32* %idx.addr, align 4
  call void @lua_pushvalue(%struct.lua_State* %4, i32 %5)
  br label %sw.epilog

sw.bb2:                                           ; preds = %if.then
  %6 = load %struct.lua_State** %L.addr, align 8
  %7 = load %struct.lua_State** %L.addr, align 8
  %8 = load i32* %idx.addr, align 4
  %call3 = call i32 @lua_toboolean(%struct.lua_State* %7, i32 %8)
  %tobool4 = icmp ne i32 %call3, 0
  %cond = select i1 %tobool4, i8* getelementptr inbounds ([5 x i8]* @.str35, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8]* @.str36, i32 0, i32 0)
  %call5 = call i8* @lua_pushstring(%struct.lua_State* %6, i8* %cond)
  br label %sw.epilog

sw.bb6:                                           ; preds = %if.then
  %9 = load %struct.lua_State** %L.addr, align 8
  %call7 = call i8* @lua_pushlstring(%struct.lua_State* %9, i8* getelementptr inbounds ([4 x i8]* @.str37, i32 0, i32 0), i64 3)
  br label %sw.epilog

sw.default:                                       ; preds = %if.then
  %10 = load %struct.lua_State** %L.addr, align 8
  %11 = load %struct.lua_State** %L.addr, align 8
  %12 = load %struct.lua_State** %L.addr, align 8
  %13 = load i32* %idx.addr, align 4
  %call8 = call i32 @lua_type(%struct.lua_State* %12, i32 %13)
  %call9 = call i8* @lua_typename(%struct.lua_State* %11, i32 %call8)
  %14 = load %struct.lua_State** %L.addr, align 8
  %15 = load i32* %idx.addr, align 4
  %call10 = call i8* @lua_topointer(%struct.lua_State* %14, i32 %15)
  %call11 = call i8* (%struct.lua_State*, i8*, ...)* @lua_pushfstring(%struct.lua_State* %10, i8* getelementptr inbounds ([7 x i8]* @.str38, i32 0, i32 0), i8* %call9, i8* %call10)
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb6, %sw.bb2, %sw.bb
  br label %if.end

if.end:                                           ; preds = %sw.epilog, %entry
  %16 = load %struct.lua_State** %L.addr, align 8
  %17 = load i64** %len.addr, align 8
  %call12 = call i8* @lua_tolstring(%struct.lua_State* %16, i32 -1, i64* %17)
  ret i8* %call12
}

; Function Attrs: nounwind uwtable
define void @luaL_setfuncs(%struct.lua_State* %L, %struct.luaL_Reg* %l, i32 %nup) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %l.addr = alloca %struct.luaL_Reg*, align 8
  %nup.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.luaL_Reg* %l, %struct.luaL_Reg** %l.addr, align 8
  store i32 %nup, i32* %nup.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_checkversion_(%struct.lua_State* %0, double 5.020000e+02)
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load i32* %nup.addr, align 4
  call void @luaL_checkstack(%struct.lua_State* %1, i32 %2, i8* getelementptr inbounds ([18 x i8]* @.str39, i32 0, i32 0))
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %3 = load %struct.luaL_Reg** %l.addr, align 8
  %name = getelementptr inbounds %struct.luaL_Reg* %3, i32 0, i32 0
  %4 = load i8** %name, align 8
  %cmp = icmp ne i8* %4, null
  br i1 %cmp, label %for.body, label %for.end7

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %i, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %5 = load i32* %i, align 4
  %6 = load i32* %nup.addr, align 4
  %cmp2 = icmp slt i32 %5, %6
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %7 = load %struct.lua_State** %L.addr, align 8
  %8 = load i32* %nup.addr, align 4
  %sub = sub nsw i32 0, %8
  call void @lua_pushvalue(%struct.lua_State* %7, i32 %sub)
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32* %i, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load %struct.lua_State** %L.addr, align 8
  %11 = load %struct.luaL_Reg** %l.addr, align 8
  %func = getelementptr inbounds %struct.luaL_Reg* %11, i32 0, i32 1
  %12 = load i32 (%struct.lua_State*)** %func, align 8
  %13 = load i32* %nup.addr, align 4
  call void @lua_pushcclosure(%struct.lua_State* %10, i32 (%struct.lua_State*)* %12, i32 %13)
  %14 = load %struct.lua_State** %L.addr, align 8
  %15 = load i32* %nup.addr, align 4
  %add = add nsw i32 %15, 2
  %sub4 = sub nsw i32 0, %add
  %16 = load %struct.luaL_Reg** %l.addr, align 8
  %name5 = getelementptr inbounds %struct.luaL_Reg* %16, i32 0, i32 0
  %17 = load i8** %name5, align 8
  call void @lua_setfield(%struct.lua_State* %14, i32 %sub4, i8* %17)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %18 = load %struct.luaL_Reg** %l.addr, align 8
  %incdec.ptr = getelementptr inbounds %struct.luaL_Reg* %18, i32 1
  store %struct.luaL_Reg* %incdec.ptr, %struct.luaL_Reg** %l.addr, align 8
  br label %for.cond

for.end7:                                         ; preds = %for.cond
  %19 = load %struct.lua_State** %L.addr, align 8
  %20 = load i32* %nup.addr, align 4
  %sub8 = sub nsw i32 0, %20
  %sub9 = sub nsw i32 %sub8, 1
  call void @lua_settop(%struct.lua_State* %19, i32 %sub9)
  ret void
}

; Function Attrs: nounwind uwtable
define void @luaL_checkversion_(%struct.lua_State* %L, double %ver) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %ver.addr = alloca double, align 8
  %v = alloca double*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store double %ver, double* %ver.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call double* @lua_version(%struct.lua_State* %0)
  store double* %call, double** %v, align 8
  %1 = load double** %v, align 8
  %call1 = call double* @lua_version(%struct.lua_State* null)
  %cmp = icmp ne double* %1, %call1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load %struct.lua_State** %L.addr, align 8
  %call2 = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %2, i8* getelementptr inbounds ([26 x i8]* @.str41, i32 0, i32 0))
  br label %if.end6

if.else:                                          ; preds = %entry
  %3 = load double** %v, align 8
  %4 = load double* %3, align 8
  %5 = load double* %ver.addr, align 8
  %cmp3 = fcmp une double %4, %5
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.else
  %6 = load %struct.lua_State** %L.addr, align 8
  %7 = load double* %ver.addr, align 8
  %8 = load double** %v, align 8
  %9 = load double* %8, align 8
  %call5 = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %6, i8* getelementptr inbounds ([54 x i8]* @.str42, i32 0, i32 0), double %7, double %9)
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.else
  br label %if.end6

if.end6:                                          ; preds = %if.end, %if.then
  %10 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushnumber(%struct.lua_State* %10, double -4.660000e+03)
  %11 = load %struct.lua_State** %L.addr, align 8
  %call7 = call i64 @lua_tointegerx(%struct.lua_State* %11, i32 -1, i32* null)
  %cmp8 = icmp ne i64 %call7, -4660
  br i1 %cmp8, label %if.then11, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end6
  %12 = load %struct.lua_State** %L.addr, align 8
  %call9 = call i32 @lua_tounsignedx(%struct.lua_State* %12, i32 -1, i32* null)
  %cmp10 = icmp ne i32 %call9, -4660
  br i1 %cmp10, label %if.then11, label %if.end13

if.then11:                                        ; preds = %lor.lhs.false, %if.end6
  %13 = load %struct.lua_State** %L.addr, align 8
  %call12 = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %13, i8* getelementptr inbounds ([68 x i8]* @.str43, i32 0, i32 0))
  br label %if.end13

if.end13:                                         ; preds = %if.then11, %lor.lhs.false
  %14 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %14, i32 -2)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @luaL_getsubtable(%struct.lua_State* %L, i32 %idx, i8* %fname) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %idx.addr = alloca i32, align 4
  %fname.addr = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  store i8* %fname, i8** %fname.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %idx.addr, align 4
  %2 = load i8** %fname.addr, align 8
  call void @lua_getfield(%struct.lua_State* %0, i32 %1, i8* %2)
  %3 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_type(%struct.lua_State* %3, i32 -1)
  %cmp = icmp eq i32 %call, 5
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval
  br label %return

if.else:                                          ; preds = %entry
  %4 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %4, i32 -2)
  %5 = load %struct.lua_State** %L.addr, align 8
  %6 = load i32* %idx.addr, align 4
  %call1 = call i32 @lua_absindex(%struct.lua_State* %5, i32 %6)
  store i32 %call1, i32* %idx.addr, align 4
  %7 = load %struct.lua_State** %L.addr, align 8
  call void @lua_createtable(%struct.lua_State* %7, i32 0, i32 0)
  %8 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushvalue(%struct.lua_State* %8, i32 -1)
  %9 = load %struct.lua_State** %L.addr, align 8
  %10 = load i32* %idx.addr, align 4
  %11 = load i8** %fname.addr, align 8
  call void @lua_setfield(%struct.lua_State* %9, i32 %10, i8* %11)
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %12 = load i32* %retval
  ret i32 %12
}

; Function Attrs: nounwind uwtable
define void @luaL_requiref(%struct.lua_State* %L, i8* %modname, i32 (%struct.lua_State*)* %openf, i32 %glb) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %modname.addr = alloca i8*, align 8
  %openf.addr = alloca i32 (%struct.lua_State*)*, align 8
  %glb.addr = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %modname, i8** %modname.addr, align 8
  store i32 (%struct.lua_State*)* %openf, i32 (%struct.lua_State*)** %openf.addr, align 8
  store i32 %glb, i32* %glb.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32 (%struct.lua_State*)** %openf.addr, align 8
  call void @lua_pushcclosure(%struct.lua_State* %0, i32 (%struct.lua_State*)* %1, i32 0)
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load i8** %modname.addr, align 8
  %call = call i8* @lua_pushstring(%struct.lua_State* %2, i8* %3)
  %4 = load %struct.lua_State** %L.addr, align 8
  call void @lua_callk(%struct.lua_State* %4, i32 1, i32 1, i32 0, i32 (%struct.lua_State*)* null)
  %5 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i32 @luaL_getsubtable(%struct.lua_State* %5, i32 -1001000, i8* getelementptr inbounds ([8 x i8]* @.str40, i32 0, i32 0))
  %6 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushvalue(%struct.lua_State* %6, i32 -2)
  %7 = load %struct.lua_State** %L.addr, align 8
  %8 = load i8** %modname.addr, align 8
  call void @lua_setfield(%struct.lua_State* %7, i32 -2, i8* %8)
  %9 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %9, i32 -2)
  %10 = load i32* %glb.addr, align 4
  %tobool = icmp ne i32 %10, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %11 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushvalue(%struct.lua_State* %11, i32 -1)
  %12 = load %struct.lua_State** %L.addr, align 8
  %13 = load i8** %modname.addr, align 8
  call void @lua_setglobal(%struct.lua_State* %12, i8* %13)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define i8* @luaL_gsub(%struct.lua_State* %L, i8* %s, i8* %p, i8* %r) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %s.addr = alloca i8*, align 8
  %p.addr = alloca i8*, align 8
  %r.addr = alloca i8*, align 8
  %wild = alloca i8*, align 8
  %l = alloca i64, align 8
  %b = alloca %struct.luaL_Buffer, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %s, i8** %s.addr, align 8
  store i8* %p, i8** %p.addr, align 8
  store i8* %r, i8** %r.addr, align 8
  %0 = load i8** %p.addr, align 8
  %call = call i64 @strlen(i8* %0) #10
  store i64 %call, i64* %l, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_buffinit(%struct.lua_State* %1, %struct.luaL_Buffer* %b)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %2 = load i8** %s.addr, align 8
  %3 = load i8** %p.addr, align 8
  %call1 = call i8* @strstr(i8* %2, i8* %3) #10
  store i8* %call1, i8** %wild, align 8
  %cmp = icmp ne i8* %call1, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %4 = load i8** %s.addr, align 8
  %5 = load i8** %wild, align 8
  %6 = load i8** %s.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %5 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %6 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  call void @luaL_addlstring(%struct.luaL_Buffer* %b, i8* %4, i64 %sub.ptr.sub)
  %7 = load i8** %r.addr, align 8
  call void @luaL_addstring(%struct.luaL_Buffer* %b, i8* %7)
  %8 = load i8** %wild, align 8
  %9 = load i64* %l, align 8
  %add.ptr = getelementptr inbounds i8* %8, i64 %9
  store i8* %add.ptr, i8** %s.addr, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %10 = load i8** %s.addr, align 8
  call void @luaL_addstring(%struct.luaL_Buffer* %b, i8* %10)
  call void @luaL_pushresult(%struct.luaL_Buffer* %b)
  %11 = load %struct.lua_State** %L.addr, align 8
  %call2 = call i8* @lua_tolstring(%struct.lua_State* %11, i32 -1, i64* null)
  ret i8* %call2
}

; Function Attrs: nounwind readonly
declare i8* @strstr(i8*, i8*) #2

; Function Attrs: nounwind uwtable
define %struct.lua_State* @luaL_newstate() #0 {
entry:
  %L = alloca %struct.lua_State*, align 8
  %call = call %struct.lua_State* bitcast (%struct.lua_State.343* (i8* (i8*, i8*, i64, i64)*, i8*)* @lua_newstate to %struct.lua_State* (i8* (i8*, i8*, i64, i64)*, i8*)*)(i8* (i8*, i8*, i64, i64)* @l_alloc, i8* null)
  store %struct.lua_State* %call, %struct.lua_State** %L, align 8
  %0 = load %struct.lua_State** %L, align 8
  %tobool = icmp ne %struct.lua_State* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.lua_State** %L, align 8
  %call1 = call i32 (%struct.lua_State*)* (%struct.lua_State*, i32 (%struct.lua_State*)*)* @lua_atpanic(%struct.lua_State* %1, i32 (%struct.lua_State*)* @panic)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load %struct.lua_State** %L, align 8
  ret %struct.lua_State* %2
}

declare i32 @fprintf(%struct._IO_FILE*, i8*, ...) #5

declare i32 @fflush(%struct._IO_FILE*) #5

; Function Attrs: nounwind
declare void @free(i8*) #4

; Function Attrs: nounwind
declare i8* @realloc(i8*, i64) #4

; Function Attrs: nounwind
declare i32 @feof(%struct._IO_FILE*) #4

declare i64 @fread(i8*, i64, i64, %struct._IO_FILE*) #5

declare i32 @_IO_getc(%struct._IO_FILE*) #5

; Function Attrs: nounwind uwtable
define internal i32 @countlevels(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %ar = alloca %struct.lua_Debug, align 8
  %li = alloca i32, align 4
  %le = alloca i32, align 4
  %m = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 1, i32* %li, align 4
  store i32 1, i32* %le, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %le, align 4
  %call = call i32 @lua_getstack(%struct.lua_State* %0, i32 %1, %struct.lua_Debug* %ar)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load i32* %le, align 4
  store i32 %2, i32* %li, align 4
  %3 = load i32* %le, align 4
  %mul = mul nsw i32 %3, 2
  store i32 %mul, i32* %le, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  br label %while.cond1

while.cond1:                                      ; preds = %if.end, %while.end
  %4 = load i32* %li, align 4
  %5 = load i32* %le, align 4
  %cmp = icmp slt i32 %4, %5
  br i1 %cmp, label %while.body2, label %while.end6

while.body2:                                      ; preds = %while.cond1
  %6 = load i32* %li, align 4
  %7 = load i32* %le, align 4
  %add = add nsw i32 %6, %7
  %div = sdiv i32 %add, 2
  store i32 %div, i32* %m, align 4
  %8 = load %struct.lua_State** %L.addr, align 8
  %9 = load i32* %m, align 4
  %call3 = call i32 @lua_getstack(%struct.lua_State* %8, i32 %9, %struct.lua_Debug* %ar)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then, label %if.else

if.then:                                          ; preds = %while.body2
  %10 = load i32* %m, align 4
  %add5 = add nsw i32 %10, 1
  store i32 %add5, i32* %li, align 4
  br label %if.end

if.else:                                          ; preds = %while.body2
  %11 = load i32* %m, align 4
  store i32 %11, i32* %le, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  br label %while.cond1

while.end6:                                       ; preds = %while.cond1
  %12 = load i32* %le, align 4
  %sub = sub nsw i32 %12, 1
  ret i32 %sub
}

; Function Attrs: nounwind uwtable
define internal void @pushfuncname(%struct.lua_State* %L, %struct.lua_Debug* %ar) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %ar.addr = alloca %struct.lua_Debug*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.lua_Debug* %ar, %struct.lua_Debug** %ar.addr, align 8
  %0 = load %struct.lua_Debug** %ar.addr, align 8
  %namewhat = getelementptr inbounds %struct.lua_Debug* %0, i32 0, i32 2
  %1 = load i8** %namewhat, align 8
  %2 = load i8* %1, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load %struct.lua_Debug** %ar.addr, align 8
  %name = getelementptr inbounds %struct.lua_Debug* %4, i32 0, i32 1
  %5 = load i8** %name, align 8
  %call = call i8* (%struct.lua_State*, i8*, ...)* @lua_pushfstring(%struct.lua_State* %3, i8* getelementptr inbounds ([14 x i8]* @.str50, i32 0, i32 0), i8* %5)
  br label %if.end23

if.else:                                          ; preds = %entry
  %6 = load %struct.lua_Debug** %ar.addr, align 8
  %what = getelementptr inbounds %struct.lua_Debug* %6, i32 0, i32 3
  %7 = load i8** %what, align 8
  %8 = load i8* %7, align 1
  %conv2 = sext i8 %8 to i32
  %cmp3 = icmp eq i32 %conv2, 109
  br i1 %cmp3, label %if.then5, label %if.else7

if.then5:                                         ; preds = %if.else
  %9 = load %struct.lua_State** %L.addr, align 8
  %call6 = call i8* @lua_pushlstring(%struct.lua_State* %9, i8* getelementptr inbounds ([11 x i8]* @.str51, i32 0, i32 0), i64 10)
  br label %if.end22

if.else7:                                         ; preds = %if.else
  %10 = load %struct.lua_Debug** %ar.addr, align 8
  %what8 = getelementptr inbounds %struct.lua_Debug* %10, i32 0, i32 3
  %11 = load i8** %what8, align 8
  %12 = load i8* %11, align 1
  %conv9 = sext i8 %12 to i32
  %cmp10 = icmp eq i32 %conv9, 67
  br i1 %cmp10, label %if.then12, label %if.else19

if.then12:                                        ; preds = %if.else7
  %13 = load %struct.lua_State** %L.addr, align 8
  %14 = load %struct.lua_Debug** %ar.addr, align 8
  %call13 = call i32 @pushglobalfuncname(%struct.lua_State* %13, %struct.lua_Debug* %14)
  %tobool = icmp ne i32 %call13, 0
  br i1 %tobool, label %if.then14, label %if.else17

if.then14:                                        ; preds = %if.then12
  %15 = load %struct.lua_State** %L.addr, align 8
  %16 = load %struct.lua_State** %L.addr, align 8
  %call15 = call i8* @lua_tolstring(%struct.lua_State* %16, i32 -1, i64* null)
  %call16 = call i8* (%struct.lua_State*, i8*, ...)* @lua_pushfstring(%struct.lua_State* %15, i8* getelementptr inbounds ([14 x i8]* @.str50, i32 0, i32 0), i8* %call15)
  %17 = load %struct.lua_State** %L.addr, align 8
  call void @lua_remove(%struct.lua_State* %17, i32 -2)
  br label %if.end

if.else17:                                        ; preds = %if.then12
  %18 = load %struct.lua_State** %L.addr, align 8
  %call18 = call i8* @lua_pushlstring(%struct.lua_State* %18, i8* getelementptr inbounds ([2 x i8]* @.str12, i32 0, i32 0), i64 1)
  br label %if.end

if.end:                                           ; preds = %if.else17, %if.then14
  br label %if.end21

if.else19:                                        ; preds = %if.else7
  %19 = load %struct.lua_State** %L.addr, align 8
  %20 = load %struct.lua_Debug** %ar.addr, align 8
  %short_src = getelementptr inbounds %struct.lua_Debug* %20, i32 0, i32 12
  %arraydecay = getelementptr inbounds [60 x i8]* %short_src, i32 0, i32 0
  %21 = load %struct.lua_Debug** %ar.addr, align 8
  %linedefined = getelementptr inbounds %struct.lua_Debug* %21, i32 0, i32 6
  %22 = load i32* %linedefined, align 4
  %call20 = call i8* (%struct.lua_State*, i8*, ...)* @lua_pushfstring(%struct.lua_State* %19, i8* getelementptr inbounds ([17 x i8]* @.str52, i32 0, i32 0), i8* %arraydecay, i32 %22)
  br label %if.end21

if.end21:                                         ; preds = %if.else19, %if.end
  br label %if.end22

if.end22:                                         ; preds = %if.end21, %if.then5
  br label %if.end23

if.end23:                                         ; preds = %if.end22, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @pushglobalfuncname(%struct.lua_State* %L, %struct.lua_Debug* %ar) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %ar.addr = alloca %struct.lua_Debug*, align 8
  %top = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.lua_Debug* %ar, %struct.lua_Debug** %ar.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_gettop(%struct.lua_State* %0)
  store i32 %call, i32* %top, align 4
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load %struct.lua_Debug** %ar.addr, align 8
  %call1 = call i32 @lua_getinfo(%struct.lua_State* %1, i8* getelementptr inbounds ([2 x i8]* @.str48, i32 0, i32 0), %struct.lua_Debug* %2)
  %3 = load %struct.lua_State** %L.addr, align 8
  call void @lua_rawgeti(%struct.lua_State* %3, i32 -1001000, i32 2)
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load i32* %top, align 4
  %add = add nsw i32 %5, 1
  %call2 = call i32 @findfield(%struct.lua_State* %4, i32 %add, i32 2)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %6 = load %struct.lua_State** %L.addr, align 8
  %7 = load i32* %top, align 4
  %add3 = add nsw i32 %7, 1
  call void @lua_copy(%struct.lua_State* %6, i32 -1, i32 %add3)
  %8 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %8, i32 -3)
  store i32 1, i32* %retval
  br label %return

if.else:                                          ; preds = %entry
  %9 = load %struct.lua_State** %L.addr, align 8
  %10 = load i32* %top, align 4
  call void @lua_settop(%struct.lua_State* %9, i32 %10)
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %11 = load i32* %retval
  ret i32 %11
}

; Function Attrs: nounwind uwtable
define internal i32 @typeerror(%struct.lua_State* %L, i32 %narg, i8* %tname) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %narg.addr = alloca i32, align 4
  %tname.addr = alloca i8*, align 8
  %msg = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %narg, i32* %narg.addr, align 4
  store i8* %tname, i8** %tname.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i8** %tname.addr, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load i32* %narg.addr, align 4
  %call = call i32 @lua_type(%struct.lua_State* %3, i32 %4)
  %call1 = call i8* @lua_typename(%struct.lua_State* %2, i32 %call)
  %call2 = call i8* (%struct.lua_State*, i8*, ...)* @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([20 x i8]* @.str47, i32 0, i32 0), i8* %1, i8* %call1)
  store i8* %call2, i8** %msg, align 8
  %5 = load %struct.lua_State** %L.addr, align 8
  %6 = load i32* %narg.addr, align 4
  %7 = load i8** %msg, align 8
  %call3 = call i32 @luaL_argerror(%struct.lua_State* %5, i32 %6, i8* %7)
  ret i32 %call3
}

; Function Attrs: nounwind uwtable
define internal void @tag_error(%struct.lua_State* %L, i32 %narg, i32 %tag) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %narg.addr = alloca i32, align 4
  %tag.addr = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %narg, i32* %narg.addr, align 4
  store i32 %tag, i32* %tag.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %narg.addr, align 4
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load i32* %tag.addr, align 4
  %call = call i8* @lua_typename(%struct.lua_State* %2, i32 %3)
  %call1 = call i32 @typeerror(%struct.lua_State* %0, i32 %1, i8* %call)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @errfile(%struct.lua_State* %L, i8* %what, i32 %fnameindex) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %what.addr = alloca i8*, align 8
  %fnameindex.addr = alloca i32, align 4
  %serr = alloca i8*, align 8
  %filename = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %what, i8** %what.addr, align 8
  store i32 %fnameindex, i32* %fnameindex.addr, align 4
  %call = call i32* @__errno_location() #11
  %0 = load i32* %call, align 4
  %call1 = call i8* @strerror(i32 %0) #1
  store i8* %call1, i8** %serr, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load i32* %fnameindex.addr, align 4
  %call2 = call i8* @lua_tolstring(%struct.lua_State* %1, i32 %2, i64* null)
  %add.ptr = getelementptr inbounds i8* %call2, i64 1
  store i8* %add.ptr, i8** %filename, align 8
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load i8** %what.addr, align 8
  %5 = load i8** %filename, align 8
  %6 = load i8** %serr, align 8
  %call3 = call i8* (%struct.lua_State*, i8*, ...)* @lua_pushfstring(%struct.lua_State* %3, i8* getelementptr inbounds ([17 x i8]* @.str46, i32 0, i32 0), i8* %4, i8* %5, i8* %6)
  %7 = load %struct.lua_State** %L.addr, align 8
  %8 = load i32* %fnameindex.addr, align 4
  call void @lua_remove(%struct.lua_State* %7, i32 %8)
  ret i32 7
}

; Function Attrs: nounwind uwtable
define internal i32 @skipcomment(%struct.LoadF* %lf, i32* %cp) #0 {
entry:
  %retval = alloca i32, align 4
  %lf.addr = alloca %struct.LoadF*, align 8
  %cp.addr = alloca i32*, align 8
  %c = alloca i32, align 4
  store %struct.LoadF* %lf, %struct.LoadF** %lf.addr, align 8
  store i32* %cp, i32** %cp.addr, align 8
  %0 = load %struct.LoadF** %lf.addr, align 8
  %call = call i32 @skipBOM(%struct.LoadF* %0)
  %1 = load i32** %cp.addr, align 8
  store i32 %call, i32* %1, align 4
  store i32 %call, i32* %c, align 4
  %2 = load i32* %c, align 4
  %cmp = icmp eq i32 %2, 35
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %land.end, %if.then
  %3 = load %struct.LoadF** %lf.addr, align 8
  %f = getelementptr inbounds %struct.LoadF* %3, i32 0, i32 1
  %4 = load %struct._IO_FILE** %f, align 8
  %call1 = call i32 @_IO_getc(%struct._IO_FILE* %4)
  store i32 %call1, i32* %c, align 4
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %5 = load i32* %c, align 4
  %cmp2 = icmp ne i32 %5, -1
  br i1 %cmp2, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %do.cond
  %6 = load i32* %c, align 4
  %cmp3 = icmp ne i32 %6, 10
  br label %land.end

land.end:                                         ; preds = %land.rhs, %do.cond
  %7 = phi i1 [ false, %do.cond ], [ %cmp3, %land.rhs ]
  br i1 %7, label %do.body, label %do.end

do.end:                                           ; preds = %land.end
  %8 = load %struct.LoadF** %lf.addr, align 8
  %f4 = getelementptr inbounds %struct.LoadF* %8, i32 0, i32 1
  %9 = load %struct._IO_FILE** %f4, align 8
  %call5 = call i32 @_IO_getc(%struct._IO_FILE* %9)
  %10 = load i32** %cp.addr, align 8
  store i32 %call5, i32* %10, align 4
  store i32 1, i32* %retval
  br label %return

if.else:                                          ; preds = %entry
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.else, %do.end
  %11 = load i32* %retval
  ret i32 %11
}

; Function Attrs: nounwind uwtable
define internal i8* @getF(%struct.lua_State* %L, i8* %ud, i64* %size) #0 {
entry:
  %retval = alloca i8*, align 8
  %L.addr = alloca %struct.lua_State*, align 8
  %ud.addr = alloca i8*, align 8
  %size.addr = alloca i64*, align 8
  %lf = alloca %struct.LoadF*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %ud, i8** %ud.addr, align 8
  store i64* %size, i64** %size.addr, align 8
  %0 = load i8** %ud.addr, align 8
  %1 = bitcast i8* %0 to %struct.LoadF*
  store %struct.LoadF* %1, %struct.LoadF** %lf, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load %struct.LoadF** %lf, align 8
  %n = getelementptr inbounds %struct.LoadF* %3, i32 0, i32 0
  %4 = load i32* %n, align 4
  %cmp = icmp sgt i32 %4, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %5 = load %struct.LoadF** %lf, align 8
  %n1 = getelementptr inbounds %struct.LoadF* %5, i32 0, i32 0
  %6 = load i32* %n1, align 4
  %conv = sext i32 %6 to i64
  %7 = load i64** %size.addr, align 8
  store i64 %conv, i64* %7, align 8
  %8 = load %struct.LoadF** %lf, align 8
  %n2 = getelementptr inbounds %struct.LoadF* %8, i32 0, i32 0
  store i32 0, i32* %n2, align 4
  br label %if.end6

if.else:                                          ; preds = %entry
  %9 = load %struct.LoadF** %lf, align 8
  %f = getelementptr inbounds %struct.LoadF* %9, i32 0, i32 1
  %10 = load %struct._IO_FILE** %f, align 8
  %call = call i32 @feof(%struct._IO_FILE* %10) #1
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.else
  store i8* null, i8** %retval
  br label %return

if.end:                                           ; preds = %if.else
  %11 = load %struct.LoadF** %lf, align 8
  %buff = getelementptr inbounds %struct.LoadF* %11, i32 0, i32 2
  %arraydecay = getelementptr inbounds [8192 x i8]* %buff, i32 0, i32 0
  %12 = load %struct.LoadF** %lf, align 8
  %f4 = getelementptr inbounds %struct.LoadF* %12, i32 0, i32 1
  %13 = load %struct._IO_FILE** %f4, align 8
  %call5 = call i64 @fread(i8* %arraydecay, i64 1, i64 8192, %struct._IO_FILE* %13)
  %14 = load i64** %size.addr, align 8
  store i64 %call5, i64* %14, align 8
  br label %if.end6

if.end6:                                          ; preds = %if.end, %if.then
  %15 = load %struct.LoadF** %lf, align 8
  %buff7 = getelementptr inbounds %struct.LoadF* %15, i32 0, i32 2
  %arraydecay8 = getelementptr inbounds [8192 x i8]* %buff7, i32 0, i32 0
  store i8* %arraydecay8, i8** %retval
  br label %return

return:                                           ; preds = %if.end6, %if.then3
  %16 = load i8** %retval
  ret i8* %16
}

; Function Attrs: nounwind uwtable
define internal i8* @getS(%struct.lua_State* %L, i8* %ud, i64* %size) #0 {
entry:
  %retval = alloca i8*, align 8
  %L.addr = alloca %struct.lua_State*, align 8
  %ud.addr = alloca i8*, align 8
  %size.addr = alloca i64*, align 8
  %ls = alloca %struct.LoadS*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %ud, i8** %ud.addr, align 8
  store i64* %size, i64** %size.addr, align 8
  %0 = load i8** %ud.addr, align 8
  %1 = bitcast i8* %0 to %struct.LoadS*
  store %struct.LoadS* %1, %struct.LoadS** %ls, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load %struct.LoadS** %ls, align 8
  %size1 = getelementptr inbounds %struct.LoadS* %3, i32 0, i32 1
  %4 = load i64* %size1, align 8
  %cmp = icmp eq i64 %4, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i8* null, i8** %retval
  br label %return

if.end:                                           ; preds = %entry
  %5 = load %struct.LoadS** %ls, align 8
  %size2 = getelementptr inbounds %struct.LoadS* %5, i32 0, i32 1
  %6 = load i64* %size2, align 8
  %7 = load i64** %size.addr, align 8
  store i64 %6, i64* %7, align 8
  %8 = load %struct.LoadS** %ls, align 8
  %size3 = getelementptr inbounds %struct.LoadS* %8, i32 0, i32 1
  store i64 0, i64* %size3, align 8
  %9 = load %struct.LoadS** %ls, align 8
  %s = getelementptr inbounds %struct.LoadS* %9, i32 0, i32 0
  %10 = load i8** %s, align 8
  store i8* %10, i8** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load i8** %retval
  ret i8* %11
}

; Function Attrs: nounwind uwtable
define internal i8* @l_alloc(i8* %ud, i8* %ptr, i64 %osize, i64 %nsize) #0 {
entry:
  %retval = alloca i8*, align 8
  %ud.addr = alloca i8*, align 8
  %ptr.addr = alloca i8*, align 8
  %osize.addr = alloca i64, align 8
  %nsize.addr = alloca i64, align 8
  store i8* %ud, i8** %ud.addr, align 8
  store i8* %ptr, i8** %ptr.addr, align 8
  store i64 %osize, i64* %osize.addr, align 8
  store i64 %nsize, i64* %nsize.addr, align 8
  %0 = load i8** %ud.addr, align 8
  %1 = load i64* %osize.addr, align 8
  %2 = load i64* %nsize.addr, align 8
  %cmp = icmp eq i64 %2, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load i8** %ptr.addr, align 8
  call void @free(i8* %3) #1
  store i8* null, i8** %retval
  br label %return

if.else:                                          ; preds = %entry
  %4 = load i8** %ptr.addr, align 8
  %5 = load i64* %nsize.addr, align 8
  %call = call i8* @realloc(i8* %4, i64 %5) #1
  store i8* %call, i8** %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %6 = load i8** %retval
  ret i8* %6
}

; Function Attrs: nounwind uwtable
define internal i32 @panic(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct._IO_FILE** @stderr, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @lua_tolstring(%struct.lua_State* %1, i32 -1, i64* null)
  %call1 = call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %0, i8* getelementptr inbounds ([50 x i8]* @.str44, i32 0, i32 0), i8* %call)
  %2 = load %struct._IO_FILE** @stderr, align 8
  %call2 = call i32 @fflush(%struct._IO_FILE* %2)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @findfield(%struct.lua_State* %L, i32 %objidx, i32 %level) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %objidx.addr = alloca i32, align 4
  %level.addr = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %objidx, i32* %objidx.addr, align 4
  store i32 %level, i32* %level.addr, align 4
  %0 = load i32* %level.addr, align 4
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_type(%struct.lua_State* %1, i32 -1)
  %cmp1 = icmp eq i32 %call, 5
  br i1 %cmp1, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 0, i32* %retval
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %2 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushnil(%struct.lua_State* %2)
  br label %while.cond

while.cond:                                       ; preds = %if.end15, %if.end
  %3 = load %struct.lua_State** %L.addr, align 8
  %call2 = call i32 @lua_next(%struct.lua_State* %3, i32 -2)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %4 = load %struct.lua_State** %L.addr, align 8
  %call3 = call i32 @lua_type(%struct.lua_State* %4, i32 -2)
  %cmp4 = icmp eq i32 %call3, 4
  br i1 %cmp4, label %if.then5, label %if.end15

if.then5:                                         ; preds = %while.body
  %5 = load %struct.lua_State** %L.addr, align 8
  %6 = load i32* %objidx.addr, align 4
  %call6 = call i32 @lua_rawequal(%struct.lua_State* %5, i32 %6, i32 -1)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then5
  %7 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %7, i32 -2)
  store i32 1, i32* %retval
  br label %return

if.else:                                          ; preds = %if.then5
  %8 = load %struct.lua_State** %L.addr, align 8
  %9 = load i32* %objidx.addr, align 4
  %10 = load i32* %level.addr, align 4
  %sub = sub nsw i32 %10, 1
  %call9 = call i32 @findfield(%struct.lua_State* %8, i32 %9, i32 %sub)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.then11, label %if.end13

if.then11:                                        ; preds = %if.else
  %11 = load %struct.lua_State** %L.addr, align 8
  call void @lua_remove(%struct.lua_State* %11, i32 -2)
  %12 = load %struct.lua_State** %L.addr, align 8
  %call12 = call i8* @lua_pushlstring(%struct.lua_State* %12, i8* getelementptr inbounds ([2 x i8]* @.str49, i32 0, i32 0), i64 1)
  %13 = load %struct.lua_State** %L.addr, align 8
  call void @lua_insert(%struct.lua_State* %13, i32 -2)
  %14 = load %struct.lua_State** %L.addr, align 8
  call void @lua_concat(%struct.lua_State* %14, i32 3)
  store i32 1, i32* %retval
  br label %return

if.end13:                                         ; preds = %if.else
  br label %if.end14

if.end14:                                         ; preds = %if.end13
  br label %if.end15

if.end15:                                         ; preds = %if.end14, %while.body
  %15 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %15, i32 -2)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %while.end, %if.then11, %if.then8, %if.then
  %16 = load i32* %retval
  ret i32 %16
}

; Function Attrs: nounwind uwtable
define internal i32 @skipBOM(%struct.LoadF* %lf) #0 {
entry:
  %retval = alloca i32, align 4
  %lf.addr = alloca %struct.LoadF*, align 8
  %p = alloca i8*, align 8
  %c = alloca i32, align 4
  store %struct.LoadF* %lf, %struct.LoadF** %lf.addr, align 8
  store i8* getelementptr inbounds ([4 x i8]* @.str45, i32 0, i32 0), i8** %p, align 8
  %0 = load %struct.LoadF** %lf.addr, align 8
  %n = getelementptr inbounds %struct.LoadF* %0, i32 0, i32 0
  store i32 0, i32* %n, align 4
  br label %do.body

do.body:                                          ; preds = %do.cond, %entry
  %1 = load %struct.LoadF** %lf.addr, align 8
  %f = getelementptr inbounds %struct.LoadF* %1, i32 0, i32 1
  %2 = load %struct._IO_FILE** %f, align 8
  %call = call i32 @_IO_getc(%struct._IO_FILE* %2)
  store i32 %call, i32* %c, align 4
  %3 = load i32* %c, align 4
  %cmp = icmp eq i32 %3, -1
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.body
  %4 = load i32* %c, align 4
  %5 = load i8** %p, align 8
  %incdec.ptr = getelementptr inbounds i8* %5, i32 1
  store i8* %incdec.ptr, i8** %p, align 8
  %6 = load i8* %5, align 1
  %conv = zext i8 %6 to i32
  %cmp1 = icmp ne i32 %4, %conv
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %do.body
  %7 = load i32* %c, align 4
  store i32 %7, i32* %retval
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %8 = load i32* %c, align 4
  %conv3 = trunc i32 %8 to i8
  %9 = load %struct.LoadF** %lf.addr, align 8
  %n4 = getelementptr inbounds %struct.LoadF* %9, i32 0, i32 0
  %10 = load i32* %n4, align 4
  %inc = add nsw i32 %10, 1
  store i32 %inc, i32* %n4, align 4
  %idxprom = sext i32 %10 to i64
  %11 = load %struct.LoadF** %lf.addr, align 8
  %buff = getelementptr inbounds %struct.LoadF* %11, i32 0, i32 2
  %arrayidx = getelementptr inbounds [8192 x i8]* %buff, i32 0, i64 %idxprom
  store i8 %conv3, i8* %arrayidx, align 1
  br label %do.cond

do.cond:                                          ; preds = %if.end
  %12 = load i8** %p, align 8
  %13 = load i8* %12, align 1
  %conv5 = sext i8 %13 to i32
  %cmp6 = icmp ne i32 %conv5, 0
  br i1 %cmp6, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  %14 = load %struct.LoadF** %lf.addr, align 8
  %n8 = getelementptr inbounds %struct.LoadF* %14, i32 0, i32 0
  store i32 0, i32* %n8, align 4
  %15 = load %struct.LoadF** %lf.addr, align 8
  %f9 = getelementptr inbounds %struct.LoadF* %15, i32 0, i32 1
  %16 = load %struct._IO_FILE** %f9, align 8
  %call10 = call i32 @_IO_getc(%struct._IO_FILE* %16)
  store i32 %call10, i32* %retval
  br label %return

return:                                           ; preds = %do.end, %if.then
  %17 = load i32* %retval
  ret i32 %17
}

; Function Attrs: nounwind uwtable
define i32 @luaopen_base(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  call void @lua_rawgeti(%struct.lua_State* %0, i32 -1001000, i32 2)
  %1 = load %struct.lua_State** %L.addr, align 8
  call void @lua_rawgeti(%struct.lua_State* %1, i32 -1001000, i32 2)
  %2 = load %struct.lua_State** %L.addr, align 8
  call void @lua_setfield(%struct.lua_State* %2, i32 -2, i8* getelementptr inbounds ([3 x i8]* @.str53, i32 0, i32 0))
  %3 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_setfuncs(%struct.lua_State* %3, %struct.luaL_Reg* getelementptr inbounds ([23 x %struct.luaL_Reg]* @base_funcs, i32 0, i32 0), i32 0)
  %4 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @lua_pushlstring(%struct.lua_State* %4, i8* getelementptr inbounds ([8 x i8]* @.str154, i32 0, i32 0), i64 7)
  %5 = load %struct.lua_State** %L.addr, align 8
  call void @lua_setfield(%struct.lua_State* %5, i32 -2, i8* getelementptr inbounds ([9 x i8]* @.str255, i32 0, i32 0))
  ret i32 1
}

; Function Attrs: nounwind readonly
declare i64 @strspn(i8*, i8*) #2

; Function Attrs: nounwind readnone
declare i16** @__ctype_b_loc() #3

; Function Attrs: nounwind
declare i32 @toupper(i32) #4

declare i64 @fwrite(i8*, i64, i64, %struct._IO_FILE*) #5

; Function Attrs: nounwind uwtable
define internal i32 @luaB_assert(%struct.lua_State* %L) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_toboolean(%struct.lua_State* %0, i32 1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i8* @luaL_optlstring(%struct.lua_State* %2, i32 2, i8* getelementptr inbounds ([18 x i8]* @.str55, i32 0, i32 0), i64* null)
  %call2 = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %1, i8* getelementptr inbounds ([3 x i8]* @.str54, i32 0, i32 0), i8* %call1)
  store i32 %call2, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %3 = load %struct.lua_State** %L.addr, align 8
  %call3 = call i32 @lua_gettop(%struct.lua_State* %3)
  store i32 %call3, i32* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load i32* %retval
  ret i32 %4
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_collectgarbage(%struct.lua_State* %L) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %o = alloca i32, align 4
  %ex = alloca i32, align 4
  %res = alloca i32, align 4
  %b = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @luaL_checkoption(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([8 x i8]* @.str4598, i32 0, i32 0), i8** getelementptr inbounds ([12 x i8*]* @luaB_collectgarbage.opts, i32 0, i32 0))
  %idxprom = sext i32 %call to i64
  %arrayidx = getelementptr inbounds [11 x i32]* @luaB_collectgarbage.optsnum, i32 0, i64 %idxprom
  %1 = load i32* %arrayidx, align 4
  store i32 %1, i32* %o, align 4
  %2 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i64 @luaL_optinteger(%struct.lua_State* %2, i32 2, i64 0)
  %conv = trunc i64 %call1 to i32
  store i32 %conv, i32* %ex, align 4
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load i32* %o, align 4
  %5 = load i32* %ex, align 4
  %call2 = call i32 @lua_gc(%struct.lua_State* %3, i32 %4, i32 %5)
  store i32 %call2, i32* %res, align 4
  %6 = load i32* %o, align 4
  switch i32 %6, label %sw.default [
    i32 3, label %sw.bb
    i32 5, label %sw.bb7
    i32 9, label %sw.bb7
  ]

sw.bb:                                            ; preds = %entry
  %7 = load %struct.lua_State** %L.addr, align 8
  %call3 = call i32 @lua_gc(%struct.lua_State* %7, i32 4, i32 0)
  store i32 %call3, i32* %b, align 4
  %8 = load %struct.lua_State** %L.addr, align 8
  %9 = load i32* %res, align 4
  %conv4 = sitofp i32 %9 to double
  %10 = load i32* %b, align 4
  %conv5 = sitofp i32 %10 to double
  %div = fdiv double %conv5, 1.024000e+03
  %add = fadd double %conv4, %div
  call void @lua_pushnumber(%struct.lua_State* %8, double %add)
  %11 = load %struct.lua_State** %L.addr, align 8
  %12 = load i32* %b, align 4
  %conv6 = sext i32 %12 to i64
  call void @lua_pushinteger(%struct.lua_State* %11, i64 %conv6)
  store i32 2, i32* %retval
  br label %return

sw.bb7:                                           ; preds = %entry, %entry
  %13 = load %struct.lua_State** %L.addr, align 8
  %14 = load i32* %res, align 4
  call void @lua_pushboolean(%struct.lua_State* %13, i32 %14)
  store i32 1, i32* %retval
  br label %return

sw.default:                                       ; preds = %entry
  %15 = load %struct.lua_State** %L.addr, align 8
  %16 = load i32* %res, align 4
  %conv8 = sext i32 %16 to i64
  call void @lua_pushinteger(%struct.lua_State* %15, i64 %conv8)
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %sw.default, %sw.bb7, %sw.bb
  %17 = load i32* %retval
  ret i32 %17
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_dofile(%struct.lua_State* %L) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %fname = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @luaL_optlstring(%struct.lua_State* %0, i32 1, i8* null, i64* null)
  store i8* %call, i8** %fname, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %1, i32 1)
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load i8** %fname, align 8
  %call1 = call i32 @luaL_loadfilex(%struct.lua_State* %2, i8* %3, i8* null)
  %cmp = icmp ne i32 %call1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load %struct.lua_State** %L.addr, align 8
  %call2 = call i32 @lua_error(%struct.lua_State* %4)
  store i32 %call2, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %5 = load %struct.lua_State** %L.addr, align 8
  call void @lua_callk(%struct.lua_State* %5, i32 0, i32 -1, i32 0, i32 (%struct.lua_State*)* @dofilecont)
  %6 = load %struct.lua_State** %L.addr, align 8
  %call3 = call i32 @dofilecont(%struct.lua_State* %6)
  store i32 %call3, i32* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i32* %retval
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_error(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %level = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i64 @luaL_optinteger(%struct.lua_State* %0, i32 2, i64 1)
  %conv = trunc i64 %call to i32
  store i32 %conv, i32* %level, align 4
  %1 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %1, i32 1)
  %2 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i32 @lua_isstring(%struct.lua_State* %2, i32 1)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %3 = load i32* %level, align 4
  %cmp = icmp sgt i32 %3, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load i32* %level, align 4
  call void @luaL_where(%struct.lua_State* %4, i32 %5)
  %6 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushvalue(%struct.lua_State* %6, i32 1)
  %7 = load %struct.lua_State** %L.addr, align 8
  call void @lua_concat(%struct.lua_State* %7, i32 2)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %8 = load %struct.lua_State** %L.addr, align 8
  %call3 = call i32 @lua_error(%struct.lua_State* %8)
  ret i32 %call3
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_getmetatable(%struct.lua_State* %L) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_checkany(%struct.lua_State* %0, i32 1)
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_getmetatable(%struct.lua_State* %1, i32 1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushnil(%struct.lua_State* %2)
  store i32 1, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %3 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i32 @luaL_getmetafield(%struct.lua_State* %3, i32 1, i8* getelementptr inbounds ([12 x i8]* @.str3083, i32 0, i32 0))
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load i32* %retval
  ret i32 %4
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_ipairs(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @pairsmeta(%struct.lua_State* %0, i8* getelementptr inbounds ([9 x i8]* @.str4295, i32 0, i32 0), i32 1, i32 (%struct.lua_State*)* @ipairsaux)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_loadfile(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %fname = alloca i8*, align 8
  %mode = alloca i8*, align 8
  %env = alloca i32, align 4
  %status = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @luaL_optlstring(%struct.lua_State* %0, i32 1, i8* null, i64* null)
  store i8* %call, i8** %fname, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i8* @luaL_optlstring(%struct.lua_State* %1, i32 2, i8* null, i64* null)
  store i8* %call1, i8** %mode, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %call2 = call i32 @lua_type(%struct.lua_State* %2, i32 3)
  %cmp = icmp eq i32 %call2, -1
  %lnot = xor i1 %cmp, true
  %cond = select i1 %lnot, i32 3, i32 0
  store i32 %cond, i32* %env, align 4
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load i8** %fname, align 8
  %5 = load i8** %mode, align 8
  %call3 = call i32 @luaL_loadfilex(%struct.lua_State* %3, i8* %4, i8* %5)
  store i32 %call3, i32* %status, align 4
  %6 = load %struct.lua_State** %L.addr, align 8
  %7 = load i32* %status, align 4
  %8 = load i32* %env, align 4
  %call4 = call i32 @load_aux(%struct.lua_State* %6, i32 %7, i32 %8)
  ret i32 %call4
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_load(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %status = alloca i32, align 4
  %l = alloca i64, align 8
  %s = alloca i8*, align 8
  %mode = alloca i8*, align 8
  %env = alloca i32, align 4
  %chunkname = alloca i8*, align 8
  %chunkname6 = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @lua_tolstring(%struct.lua_State* %0, i32 1, i64* %l)
  store i8* %call, i8** %s, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i8* @luaL_optlstring(%struct.lua_State* %1, i32 3, i8* getelementptr inbounds ([3 x i8]* @.str3891, i32 0, i32 0), i64* null)
  store i8* %call1, i8** %mode, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %call2 = call i32 @lua_type(%struct.lua_State* %2, i32 4)
  %cmp = icmp eq i32 %call2, -1
  %lnot = xor i1 %cmp, true
  %cond = select i1 %lnot, i32 4, i32 0
  store i32 %cond, i32* %env, align 4
  %3 = load i8** %s, align 8
  %cmp3 = icmp ne i8* %3, null
  br i1 %cmp3, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load i8** %s, align 8
  %call4 = call i8* @luaL_optlstring(%struct.lua_State* %4, i32 2, i8* %5, i64* null)
  store i8* %call4, i8** %chunkname, align 8
  %6 = load %struct.lua_State** %L.addr, align 8
  %7 = load i8** %s, align 8
  %8 = load i64* %l, align 8
  %9 = load i8** %chunkname, align 8
  %10 = load i8** %mode, align 8
  %call5 = call i32 @luaL_loadbufferx(%struct.lua_State* %6, i8* %7, i64 %8, i8* %9, i8* %10)
  store i32 %call5, i32* %status, align 4
  br label %if.end

if.else:                                          ; preds = %entry
  %11 = load %struct.lua_State** %L.addr, align 8
  %call7 = call i8* @luaL_optlstring(%struct.lua_State* %11, i32 2, i8* getelementptr inbounds ([8 x i8]* @.str3992, i32 0, i32 0), i64* null)
  store i8* %call7, i8** %chunkname6, align 8
  %12 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_checktype(%struct.lua_State* %12, i32 1, i32 6)
  %13 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %13, i32 5)
  %14 = load %struct.lua_State** %L.addr, align 8
  %15 = load i8** %chunkname6, align 8
  %16 = load i8** %mode, align 8
  %call8 = call i32 @lua_load(%struct.lua_State* %14, i8* (%struct.lua_State*, i8*, i64*)* @generic_reader, i8* null, i8* %15, i8* %16)
  store i32 %call8, i32* %status, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %17 = load %struct.lua_State** %L.addr, align 8
  %18 = load i32* %status, align 4
  %19 = load i32* %env, align 4
  %call9 = call i32 @load_aux(%struct.lua_State* %17, i32 %18, i32 %19)
  ret i32 %call9
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_next(%struct.lua_State* %L) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_checktype(%struct.lua_State* %0, i32 1, i32 5)
  %1 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %1, i32 2)
  %2 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_next(%struct.lua_State* %2, i32 1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 2, i32* %retval
  br label %return

if.else:                                          ; preds = %entry
  %3 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushnil(%struct.lua_State* %3)
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %4 = load i32* %retval
  ret i32 %4
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_pairs(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @pairsmeta(%struct.lua_State* %0, i8* getelementptr inbounds ([8 x i8]* @.str3790, i32 0, i32 0), i32 0, i32 (%struct.lua_State*)* @luaB_next)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_pcall(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %status = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_checkany(%struct.lua_State* %0, i32 1)
  %1 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushnil(%struct.lua_State* %1)
  %2 = load %struct.lua_State** %L.addr, align 8
  call void @lua_insert(%struct.lua_State* %2, i32 1)
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_gettop(%struct.lua_State* %4)
  %sub = sub nsw i32 %call, 2
  %call1 = call i32 @lua_pcallk(%struct.lua_State* %3, i32 %sub, i32 -1, i32 0, i32 0, i32 (%struct.lua_State*)* @pcallcont)
  store i32 %call1, i32* %status, align 4
  %5 = load %struct.lua_State** %L.addr, align 8
  %6 = load i32* %status, align 4
  %cmp = icmp eq i32 %6, 0
  %conv = zext i1 %cmp to i32
  %call2 = call i32 @finishpcall(%struct.lua_State* %5, i32 %conv)
  ret i32 %call2
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_print(%struct.lua_State* %L) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %n = alloca i32, align 4
  %i = alloca i32, align 4
  %s = alloca i8*, align 8
  %l = alloca i64, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_gettop(%struct.lua_State* %0)
  store i32 %call, i32* %n, align 4
  %1 = load %struct.lua_State** %L.addr, align 8
  call void @lua_getglobal(%struct.lua_State* %1, i8* getelementptr inbounds ([9 x i8]* @.str2275, i32 0, i32 0))
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32* %i, align 4
  %3 = load i32* %n, align 4
  %cmp = icmp sle i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushvalue(%struct.lua_State* %4, i32 -1)
  %5 = load %struct.lua_State** %L.addr, align 8
  %6 = load i32* %i, align 4
  call void @lua_pushvalue(%struct.lua_State* %5, i32 %6)
  %7 = load %struct.lua_State** %L.addr, align 8
  call void @lua_callk(%struct.lua_State* %7, i32 1, i32 1, i32 0, i32 (%struct.lua_State*)* null)
  %8 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i8* @lua_tolstring(%struct.lua_State* %8, i32 -1, i64* %l)
  store i8* %call1, i8** %s, align 8
  %9 = load i8** %s, align 8
  %cmp2 = icmp eq i8* %9, null
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %10 = load %struct.lua_State** %L.addr, align 8
  %call3 = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %10, i8* getelementptr inbounds ([43 x i8]* @.str3487, i32 0, i32 0))
  store i32 %call3, i32* %retval
  br label %return

if.end:                                           ; preds = %for.body
  %11 = load i32* %i, align 4
  %cmp4 = icmp sgt i32 %11, 1
  br i1 %cmp4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %12 = load %struct._IO_FILE** @stdout, align 8
  %call6 = call i64 @fwrite(i8* getelementptr inbounds ([2 x i8]* @.str3588, i32 0, i32 0), i64 1, i64 1, %struct._IO_FILE* %12)
  br label %if.end7

if.end7:                                          ; preds = %if.then5, %if.end
  %13 = load i8** %s, align 8
  %14 = load i64* %l, align 8
  %15 = load %struct._IO_FILE** @stdout, align 8
  %call8 = call i64 @fwrite(i8* %13, i64 1, i64 %14, %struct._IO_FILE* %15)
  %16 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %16, i32 -2)
  br label %for.inc

for.inc:                                          ; preds = %if.end7
  %17 = load i32* %i, align 4
  %inc = add nsw i32 %17, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %18 = load %struct._IO_FILE** @stdout, align 8
  %call9 = call i64 @fwrite(i8* getelementptr inbounds ([2 x i8]* @.str3689, i32 0, i32 0), i64 1, i64 1, %struct._IO_FILE* %18)
  %19 = load %struct._IO_FILE** @stdout, align 8
  %call10 = call i32 @fflush(%struct._IO_FILE* %19)
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %for.end, %if.then
  %20 = load i32* %retval
  ret i32 %20
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_rawequal(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_checkany(%struct.lua_State* %0, i32 1)
  %1 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_checkany(%struct.lua_State* %1, i32 2)
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_rawequal(%struct.lua_State* %3, i32 1, i32 2)
  call void @lua_pushboolean(%struct.lua_State* %2, i32 %call)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_rawlen(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %t = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_type(%struct.lua_State* %0, i32 1)
  store i32 %call, i32* %t, align 4
  %1 = load i32* %t, align 4
  %cmp = icmp eq i32 %1, 5
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load i32* %t, align 4
  %cmp1 = icmp eq i32 %2, 4
  br i1 %cmp1, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false
  %3 = load %struct.lua_State** %L.addr, align 8
  %call2 = call i32 @luaL_argerror(%struct.lua_State* %3, i32 1, i8* getelementptr inbounds ([25 x i8]* @.str3386, i32 0, i32 0))
  %tobool = icmp ne i32 %call2, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false, %entry
  %4 = phi i1 [ true, %lor.lhs.false ], [ true, %entry ], [ %tobool, %lor.rhs ]
  %lor.ext = zext i1 %4 to i32
  %5 = load %struct.lua_State** %L.addr, align 8
  %6 = load %struct.lua_State** %L.addr, align 8
  %call3 = call i64 @lua_rawlen(%struct.lua_State* %6, i32 1)
  call void @lua_pushinteger(%struct.lua_State* %5, i64 %call3)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_rawget(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_checktype(%struct.lua_State* %0, i32 1, i32 5)
  %1 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_checkany(%struct.lua_State* %1, i32 2)
  %2 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %2, i32 2)
  %3 = load %struct.lua_State** %L.addr, align 8
  call void @lua_rawget(%struct.lua_State* %3, i32 1)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_rawset(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_checktype(%struct.lua_State* %0, i32 1, i32 5)
  %1 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_checkany(%struct.lua_State* %1, i32 2)
  %2 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_checkany(%struct.lua_State* %2, i32 3)
  %3 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %3, i32 3)
  %4 = load %struct.lua_State** %L.addr, align 8
  call void @lua_rawset(%struct.lua_State* %4, i32 1)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_select(%struct.lua_State* %L) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %n = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_gettop(%struct.lua_State* %0)
  store i32 %call, i32* %n, align 4
  %1 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i32 @lua_type(%struct.lua_State* %1, i32 1)
  %cmp = icmp eq i32 %call1, 4
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %2 = load %struct.lua_State** %L.addr, align 8
  %call2 = call i8* @lua_tolstring(%struct.lua_State* %2, i32 1, i64* null)
  %3 = load i8* %call2, align 1
  %conv = sext i8 %3 to i32
  %cmp3 = icmp eq i32 %conv, 35
  br i1 %cmp3, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load i32* %n, align 4
  %sub = sub nsw i32 %5, 1
  %conv5 = sext i32 %sub to i64
  call void @lua_pushinteger(%struct.lua_State* %4, i64 %conv5)
  store i32 1, i32* %retval
  br label %return

if.else:                                          ; preds = %land.lhs.true, %entry
  %6 = load %struct.lua_State** %L.addr, align 8
  %call6 = call i64 @luaL_checkinteger(%struct.lua_State* %6, i32 1)
  %conv7 = trunc i64 %call6 to i32
  store i32 %conv7, i32* %i, align 4
  %7 = load i32* %i, align 4
  %cmp8 = icmp slt i32 %7, 0
  br i1 %cmp8, label %if.then10, label %if.else11

if.then10:                                        ; preds = %if.else
  %8 = load i32* %n, align 4
  %9 = load i32* %i, align 4
  %add = add nsw i32 %8, %9
  store i32 %add, i32* %i, align 4
  br label %if.end15

if.else11:                                        ; preds = %if.else
  %10 = load i32* %i, align 4
  %11 = load i32* %n, align 4
  %cmp12 = icmp sgt i32 %10, %11
  br i1 %cmp12, label %if.then14, label %if.end

if.then14:                                        ; preds = %if.else11
  %12 = load i32* %n, align 4
  store i32 %12, i32* %i, align 4
  br label %if.end

if.end:                                           ; preds = %if.then14, %if.else11
  br label %if.end15

if.end15:                                         ; preds = %if.end, %if.then10
  %13 = load i32* %i, align 4
  %cmp16 = icmp sle i32 1, %13
  br i1 %cmp16, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.end15
  %14 = load %struct.lua_State** %L.addr, align 8
  %call18 = call i32 @luaL_argerror(%struct.lua_State* %14, i32 1, i8* getelementptr inbounds ([19 x i8]* @.str3285, i32 0, i32 0))
  %tobool = icmp ne i32 %call18, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.end15
  %15 = phi i1 [ true, %if.end15 ], [ %tobool, %lor.rhs ]
  %lor.ext = zext i1 %15 to i32
  %16 = load i32* %n, align 4
  %17 = load i32* %i, align 4
  %sub19 = sub nsw i32 %16, %17
  store i32 %sub19, i32* %retval
  br label %return

return:                                           ; preds = %lor.end, %if.then
  %18 = load i32* %retval
  ret i32 %18
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_setmetatable(%struct.lua_State* %L) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %t = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_type(%struct.lua_State* %0, i32 2)
  store i32 %call, i32* %t, align 4
  %1 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_checktype(%struct.lua_State* %1, i32 1, i32 5)
  %2 = load i32* %t, align 4
  %cmp = icmp eq i32 %2, 0
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %3 = load i32* %t, align 4
  %cmp1 = icmp eq i32 %3, 5
  br i1 %cmp1, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false
  %4 = load %struct.lua_State** %L.addr, align 8
  %call2 = call i32 @luaL_argerror(%struct.lua_State* %4, i32 2, i8* getelementptr inbounds ([22 x i8]* @.str2982, i32 0, i32 0))
  %tobool = icmp ne i32 %call2, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false, %entry
  %5 = phi i1 [ true, %lor.lhs.false ], [ true, %entry ], [ %tobool, %lor.rhs ]
  %lor.ext = zext i1 %5 to i32
  %6 = load %struct.lua_State** %L.addr, align 8
  %call3 = call i32 @luaL_getmetafield(%struct.lua_State* %6, i32 1, i8* getelementptr inbounds ([12 x i8]* @.str3083, i32 0, i32 0))
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then, label %if.end

if.then:                                          ; preds = %lor.end
  %7 = load %struct.lua_State** %L.addr, align 8
  %call5 = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %7, i8* getelementptr inbounds ([36 x i8]* @.str3184, i32 0, i32 0))
  store i32 %call5, i32* %retval
  br label %return

if.end:                                           ; preds = %lor.end
  %8 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %8, i32 2)
  %9 = load %struct.lua_State** %L.addr, align 8
  %call6 = call i32 @lua_setmetatable(%struct.lua_State* %9, i32 1)
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %10 = load i32* %retval
  ret i32 %10
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_tonumber(%struct.lua_State* %L) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %isnum = alloca i32, align 4
  %n = alloca double, align 8
  %l = alloca i64, align 8
  %s = alloca i8*, align 8
  %e = alloca i8*, align 8
  %base = alloca i32, align 4
  %neg = alloca i32, align 4
  %n30 = alloca double, align 8
  %digit = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_type(%struct.lua_State* %0, i32 2)
  %cmp = icmp sle i32 %call, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load %struct.lua_State** %L.addr, align 8
  %call1 = call double @lua_tonumberx(%struct.lua_State* %1, i32 1, i32* %isnum)
  store double %call1, double* %n, align 8
  %2 = load i32* %isnum, align 4
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load double* %n, align 8
  call void @lua_pushnumber(%struct.lua_State* %3, double %4)
  store i32 1, i32* %retval
  br label %return

if.end:                                           ; preds = %if.then
  %5 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_checkany(%struct.lua_State* %5, i32 1)
  br label %if.end70

if.else:                                          ; preds = %entry
  %6 = load %struct.lua_State** %L.addr, align 8
  %call3 = call i8* @luaL_checklstring(%struct.lua_State* %6, i32 1, i64* %l)
  store i8* %call3, i8** %s, align 8
  %7 = load i8** %s, align 8
  %8 = load i64* %l, align 8
  %add.ptr = getelementptr inbounds i8* %7, i64 %8
  store i8* %add.ptr, i8** %e, align 8
  %9 = load %struct.lua_State** %L.addr, align 8
  %call4 = call i64 @luaL_checkinteger(%struct.lua_State* %9, i32 2)
  %conv = trunc i64 %call4 to i32
  store i32 %conv, i32* %base, align 4
  store i32 0, i32* %neg, align 4
  %10 = load i32* %base, align 4
  %cmp5 = icmp sle i32 2, %10
  br i1 %cmp5, label %land.lhs.true, label %lor.rhs

land.lhs.true:                                    ; preds = %if.else
  %11 = load i32* %base, align 4
  %cmp7 = icmp sle i32 %11, 36
  br i1 %cmp7, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.lhs.true, %if.else
  %12 = load %struct.lua_State** %L.addr, align 8
  %call9 = call i32 @luaL_argerror(%struct.lua_State* %12, i32 2, i8* getelementptr inbounds ([18 x i8]* @.str2780, i32 0, i32 0))
  %tobool10 = icmp ne i32 %call9, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.lhs.true
  %13 = phi i1 [ true, %land.lhs.true ], [ %tobool10, %lor.rhs ]
  %lor.ext = zext i1 %13 to i32
  %14 = load i8** %s, align 8
  %call11 = call i64 @strspn(i8* %14, i8* getelementptr inbounds ([7 x i8]* @.str2881, i32 0, i32 0)) #10
  %15 = load i8** %s, align 8
  %add.ptr12 = getelementptr inbounds i8* %15, i64 %call11
  store i8* %add.ptr12, i8** %s, align 8
  %16 = load i8** %s, align 8
  %17 = load i8* %16, align 1
  %conv13 = sext i8 %17 to i32
  %cmp14 = icmp eq i32 %conv13, 45
  br i1 %cmp14, label %if.then16, label %if.else17

if.then16:                                        ; preds = %lor.end
  %18 = load i8** %s, align 8
  %incdec.ptr = getelementptr inbounds i8* %18, i32 1
  store i8* %incdec.ptr, i8** %s, align 8
  store i32 1, i32* %neg, align 4
  br label %if.end24

if.else17:                                        ; preds = %lor.end
  %19 = load i8** %s, align 8
  %20 = load i8* %19, align 1
  %conv18 = sext i8 %20 to i32
  %cmp19 = icmp eq i32 %conv18, 43
  br i1 %cmp19, label %if.then21, label %if.end23

if.then21:                                        ; preds = %if.else17
  %21 = load i8** %s, align 8
  %incdec.ptr22 = getelementptr inbounds i8* %21, i32 1
  store i8* %incdec.ptr22, i8** %s, align 8
  br label %if.end23

if.end23:                                         ; preds = %if.then21, %if.else17
  br label %if.end24

if.end24:                                         ; preds = %if.end23, %if.then16
  %22 = load i8** %s, align 8
  %23 = load i8* %22, align 1
  %conv25 = zext i8 %23 to i32
  %idxprom = sext i32 %conv25 to i64
  %call26 = call i16** @__ctype_b_loc() #11
  %24 = load i16** %call26, align 8
  %arrayidx = getelementptr inbounds i16* %24, i64 %idxprom
  %25 = load i16* %arrayidx, align 2
  %conv27 = zext i16 %25 to i32
  %and = and i32 %conv27, 8
  %tobool28 = icmp ne i32 %and, 0
  br i1 %tobool28, label %if.then29, label %if.end69

if.then29:                                        ; preds = %if.end24
  store double 0.000000e+00, double* %n30, align 8
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.then29
  %26 = load i8** %s, align 8
  %27 = load i8* %26, align 1
  %conv31 = zext i8 %27 to i32
  %idxprom32 = sext i32 %conv31 to i64
  %call33 = call i16** @__ctype_b_loc() #11
  %28 = load i16** %call33, align 8
  %arrayidx34 = getelementptr inbounds i16* %28, i64 %idxprom32
  %29 = load i16* %arrayidx34, align 2
  %conv35 = zext i16 %29 to i32
  %and36 = and i32 %conv35, 2048
  %tobool37 = icmp ne i32 %and36, 0
  br i1 %tobool37, label %cond.true, label %cond.false

cond.true:                                        ; preds = %do.body
  %30 = load i8** %s, align 8
  %31 = load i8* %30, align 1
  %conv38 = sext i8 %31 to i32
  %sub = sub nsw i32 %conv38, 48
  br label %cond.end

cond.false:                                       ; preds = %do.body
  %32 = load i8** %s, align 8
  %33 = load i8* %32, align 1
  %conv39 = zext i8 %33 to i32
  %call40 = call i32 @toupper(i32 %conv39) #1
  %sub41 = sub nsw i32 %call40, 65
  %add = add nsw i32 %sub41, 10
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %sub, %cond.true ], [ %add, %cond.false ]
  store i32 %cond, i32* %digit, align 4
  %34 = load i32* %digit, align 4
  %35 = load i32* %base, align 4
  %cmp42 = icmp sge i32 %34, %35
  br i1 %cmp42, label %if.then44, label %if.end45

if.then44:                                        ; preds = %cond.end
  br label %do.end

if.end45:                                         ; preds = %cond.end
  %36 = load double* %n30, align 8
  %37 = load i32* %base, align 4
  %conv46 = sitofp i32 %37 to double
  %mul = fmul double %36, %conv46
  %38 = load i32* %digit, align 4
  %conv47 = sitofp i32 %38 to double
  %add48 = fadd double %mul, %conv47
  store double %add48, double* %n30, align 8
  %39 = load i8** %s, align 8
  %incdec.ptr49 = getelementptr inbounds i8* %39, i32 1
  store i8* %incdec.ptr49, i8** %s, align 8
  br label %do.cond

do.cond:                                          ; preds = %if.end45
  %40 = load i8** %s, align 8
  %41 = load i8* %40, align 1
  %conv50 = zext i8 %41 to i32
  %idxprom51 = sext i32 %conv50 to i64
  %call52 = call i16** @__ctype_b_loc() #11
  %42 = load i16** %call52, align 8
  %arrayidx53 = getelementptr inbounds i16* %42, i64 %idxprom51
  %43 = load i16* %arrayidx53, align 2
  %conv54 = zext i16 %43 to i32
  %and55 = and i32 %conv54, 8
  %tobool56 = icmp ne i32 %and55, 0
  br i1 %tobool56, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond, %if.then44
  %44 = load i8** %s, align 8
  %call57 = call i64 @strspn(i8* %44, i8* getelementptr inbounds ([7 x i8]* @.str2881, i32 0, i32 0)) #10
  %45 = load i8** %s, align 8
  %add.ptr58 = getelementptr inbounds i8* %45, i64 %call57
  store i8* %add.ptr58, i8** %s, align 8
  %46 = load i8** %s, align 8
  %47 = load i8** %e, align 8
  %cmp59 = icmp eq i8* %46, %47
  br i1 %cmp59, label %if.then61, label %if.end68

if.then61:                                        ; preds = %do.end
  %48 = load %struct.lua_State** %L.addr, align 8
  %49 = load i32* %neg, align 4
  %tobool62 = icmp ne i32 %49, 0
  br i1 %tobool62, label %cond.true63, label %cond.false65

cond.true63:                                      ; preds = %if.then61
  %50 = load double* %n30, align 8
  %sub64 = fsub double -0.000000e+00, %50
  br label %cond.end66

cond.false65:                                     ; preds = %if.then61
  %51 = load double* %n30, align 8
  br label %cond.end66

cond.end66:                                       ; preds = %cond.false65, %cond.true63
  %cond67 = phi double [ %sub64, %cond.true63 ], [ %51, %cond.false65 ]
  call void @lua_pushnumber(%struct.lua_State* %48, double %cond67)
  store i32 1, i32* %retval
  br label %return

if.end68:                                         ; preds = %do.end
  br label %if.end69

if.end69:                                         ; preds = %if.end68, %if.end24
  br label %if.end70

if.end70:                                         ; preds = %if.end69, %if.end
  %52 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushnil(%struct.lua_State* %52)
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %if.end70, %cond.end66, %if.then2
  %53 = load i32* %retval
  ret i32 %53
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_tostring(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_checkany(%struct.lua_State* %0, i32 1)
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @luaL_tolstring(%struct.lua_State* %1, i32 1, i64* null)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_type(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_checkany(%struct.lua_State* %0, i32 1)
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_type(%struct.lua_State* %3, i32 1)
  %call1 = call i8* @lua_typename(%struct.lua_State* %2, i32 %call)
  %call2 = call i8* @lua_pushstring(%struct.lua_State* %1, i8* %call1)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_xpcall(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %status = alloca i32, align 4
  %n = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_gettop(%struct.lua_State* %0)
  store i32 %call, i32* %n, align 4
  %1 = load i32* %n, align 4
  %cmp = icmp sge i32 %1, 2
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %2 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i32 @luaL_argerror(%struct.lua_State* %2, i32 2, i8* getelementptr inbounds ([15 x i8]* @.str2578, i32 0, i32 0))
  %tobool = icmp ne i32 %call1, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %3 = phi i1 [ true, %entry ], [ %tobool, %lor.rhs ]
  %lor.ext = zext i1 %3 to i32
  %4 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushvalue(%struct.lua_State* %4, i32 1)
  %5 = load %struct.lua_State** %L.addr, align 8
  call void @lua_copy(%struct.lua_State* %5, i32 2, i32 1)
  %6 = load %struct.lua_State** %L.addr, align 8
  call void @lua_replace(%struct.lua_State* %6, i32 2)
  %7 = load %struct.lua_State** %L.addr, align 8
  %8 = load i32* %n, align 4
  %sub = sub nsw i32 %8, 2
  %call2 = call i32 @lua_pcallk(%struct.lua_State* %7, i32 %sub, i32 -1, i32 1, i32 0, i32 (%struct.lua_State*)* @pcallcont)
  store i32 %call2, i32* %status, align 4
  %9 = load %struct.lua_State** %L.addr, align 8
  %10 = load i32* %status, align 4
  %cmp3 = icmp eq i32 %10, 0
  %conv = zext i1 %cmp3 to i32
  %call4 = call i32 @finishpcall(%struct.lua_State* %9, i32 %conv)
  ret i32 %call4
}

; Function Attrs: nounwind uwtable
define internal i32 @dofilecont(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_gettop(%struct.lua_State* %0)
  %sub = sub nsw i32 %call, 1
  ret i32 %sub
}

; Function Attrs: nounwind uwtable
define internal i32 @ipairsaux(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %i = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 2)
  %conv = trunc i64 %call to i32
  store i32 %conv, i32* %i, align 4
  %1 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_checktype(%struct.lua_State* %1, i32 1, i32 5)
  %2 = load i32* %i, align 4
  %inc = add nsw i32 %2, 1
  store i32 %inc, i32* %i, align 4
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load i32* %i, align 4
  %conv1 = sext i32 %4 to i64
  call void @lua_pushinteger(%struct.lua_State* %3, i64 %conv1)
  %5 = load %struct.lua_State** %L.addr, align 8
  %6 = load i32* %i, align 4
  call void @lua_rawgeti(%struct.lua_State* %5, i32 1, i32 %6)
  %7 = load %struct.lua_State** %L.addr, align 8
  %call2 = call i32 @lua_type(%struct.lua_State* %7, i32 -1)
  %cmp = icmp eq i32 %call2, 0
  %cond = select i1 %cmp, i32 1, i32 2
  ret i32 %cond
}

; Function Attrs: nounwind uwtable
define internal i32 @pairsmeta(%struct.lua_State* %L, i8* %method, i32 %iszero, i32 (%struct.lua_State*)* %iter) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %method.addr = alloca i8*, align 8
  %iszero.addr = alloca i32, align 4
  %iter.addr = alloca i32 (%struct.lua_State*)*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %method, i8** %method.addr, align 8
  store i32 %iszero, i32* %iszero.addr, align 4
  store i32 (%struct.lua_State*)* %iter, i32 (%struct.lua_State*)** %iter.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i8** %method.addr, align 8
  %call = call i32 @luaL_getmetafield(%struct.lua_State* %0, i32 1, i8* %1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.else3, label %if.then

if.then:                                          ; preds = %entry
  %2 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_checktype(%struct.lua_State* %2, i32 1, i32 5)
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load i32 (%struct.lua_State*)** %iter.addr, align 8
  call void @lua_pushcclosure(%struct.lua_State* %3, i32 (%struct.lua_State*)* %4, i32 0)
  %5 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushvalue(%struct.lua_State* %5, i32 1)
  %6 = load i32* %iszero.addr, align 4
  %tobool1 = icmp ne i32 %6, 0
  br i1 %tobool1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  %7 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushinteger(%struct.lua_State* %7, i64 0)
  br label %if.end

if.else:                                          ; preds = %if.then
  %8 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushnil(%struct.lua_State* %8)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then2
  br label %if.end4

if.else3:                                         ; preds = %entry
  %9 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushvalue(%struct.lua_State* %9, i32 1)
  %10 = load %struct.lua_State** %L.addr, align 8
  call void @lua_callk(%struct.lua_State* %10, i32 1, i32 3, i32 0, i32 (%struct.lua_State*)* null)
  br label %if.end4

if.end4:                                          ; preds = %if.else3, %if.end
  ret i32 3
}

; Function Attrs: nounwind uwtable
define internal i32 @load_aux(%struct.lua_State* %L, i32 %status, i32 %envidx) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %status.addr = alloca i32, align 4
  %envidx.addr = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %status, i32* %status.addr, align 4
  store i32 %envidx, i32* %envidx.addr, align 4
  %0 = load i32* %status.addr, align 4
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i32* %envidx.addr, align 4
  %cmp1 = icmp ne i32 %1, 0
  br i1 %cmp1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.then
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load i32* %envidx.addr, align 4
  call void @lua_pushvalue(%struct.lua_State* %2, i32 %3)
  %4 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @lua_setupvalue(%struct.lua_State* %4, i32 -2, i32 1)
  %tobool = icmp ne i8* %call, null
  br i1 %tobool, label %if.end, label %if.then3

if.then3:                                         ; preds = %if.then2
  %5 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %5, i32 -2)
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.then2
  br label %if.end4

if.end4:                                          ; preds = %if.end, %if.then
  store i32 1, i32* %retval
  br label %return

if.else:                                          ; preds = %entry
  %6 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushnil(%struct.lua_State* %6)
  %7 = load %struct.lua_State** %L.addr, align 8
  call void @lua_insert(%struct.lua_State* %7, i32 -2)
  store i32 2, i32* %retval
  br label %return

return:                                           ; preds = %if.else, %if.end4
  %8 = load i32* %retval
  ret i32 %8
}

; Function Attrs: nounwind uwtable
define internal i8* @generic_reader(%struct.lua_State* %L, i8* %ud, i64* %size) #0 {
entry:
  %retval = alloca i8*, align 8
  %L.addr = alloca %struct.lua_State*, align 8
  %ud.addr = alloca i8*, align 8
  %size.addr = alloca i64*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %ud, i8** %ud.addr, align 8
  store i64* %size, i64** %size.addr, align 8
  %0 = load i8** %ud.addr, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_checkstack(%struct.lua_State* %1, i32 2, i8* getelementptr inbounds ([26 x i8]* @.str4093, i32 0, i32 0))
  %2 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushvalue(%struct.lua_State* %2, i32 1)
  %3 = load %struct.lua_State** %L.addr, align 8
  call void @lua_callk(%struct.lua_State* %3, i32 0, i32 1, i32 0, i32 (%struct.lua_State*)* null)
  %4 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_type(%struct.lua_State* %4, i32 -1)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %5 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %5, i32 -2)
  %6 = load i64** %size.addr, align 8
  store i64 0, i64* %6, align 8
  store i8* null, i8** %retval
  br label %return

if.else:                                          ; preds = %entry
  %7 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i32 @lua_isstring(%struct.lua_State* %7, i32 -1)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.end, label %if.then2

if.then2:                                         ; preds = %if.else
  %8 = load %struct.lua_State** %L.addr, align 8
  %call3 = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %8, i8* getelementptr inbounds ([37 x i8]* @.str4194, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then2, %if.else
  br label %if.end4

if.end4:                                          ; preds = %if.end
  %9 = load %struct.lua_State** %L.addr, align 8
  call void @lua_replace(%struct.lua_State* %9, i32 5)
  %10 = load %struct.lua_State** %L.addr, align 8
  %11 = load i64** %size.addr, align 8
  %call5 = call i8* @lua_tolstring(%struct.lua_State* %10, i32 5, i64* %11)
  store i8* %call5, i8** %retval
  br label %return

return:                                           ; preds = %if.end4, %if.then
  %12 = load i8** %retval
  ret i8* %12
}

; Function Attrs: nounwind uwtable
define internal i32 @pcallcont(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %status = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_getctx(%struct.lua_State* %0, i32* null)
  store i32 %call, i32* %status, align 4
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load i32* %status, align 4
  %cmp = icmp eq i32 %2, 1
  %conv = zext i1 %cmp to i32
  %call1 = call i32 @finishpcall(%struct.lua_State* %1, i32 %conv)
  ret i32 %call1
}

; Function Attrs: nounwind uwtable
define internal i32 @finishpcall(%struct.lua_State* %L, i32 %status) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %status.addr = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %status, i32* %status.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_checkstack(%struct.lua_State* %0, i32 1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %1, i32 0)
  %2 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushboolean(%struct.lua_State* %2, i32 0)
  %3 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i8* @lua_pushstring(%struct.lua_State* %3, i8* getelementptr inbounds ([15 x i8]* @.str2679, i32 0, i32 0))
  store i32 2, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load i32* %status.addr, align 4
  call void @lua_pushboolean(%struct.lua_State* %4, i32 %5)
  %6 = load %struct.lua_State** %L.addr, align 8
  call void @lua_replace(%struct.lua_State* %6, i32 1)
  %7 = load %struct.lua_State** %L.addr, align 8
  %call2 = call i32 @lua_gettop(%struct.lua_State* %7)
  store i32 %call2, i32* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load i32* %retval
  ret i32 %8
}

; Function Attrs: nounwind uwtable
define i32 @luaopen_bit32(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 12)
  %1 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_setfuncs(%struct.lua_State* %1, %struct.luaL_Reg* getelementptr inbounds ([13 x %struct.luaL_Reg]* @bitlib, i32 0, i32 0), i32 0)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @b_arshift(%struct.lua_State* %L) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %r = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @luaL_checkunsigned(%struct.lua_State* %0, i32 1)
  store i32 %call, i32* %r, align 4
  %1 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i64 @luaL_checkinteger(%struct.lua_State* %1, i32 2)
  %conv = trunc i64 %call1 to i32
  store i32 %conv, i32* %i, align 4
  %2 = load i32* %i, align 4
  %cmp = icmp slt i32 %2, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %3 = load i32* %r, align 4
  %and = and i32 %3, -2147483648
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load i32* %r, align 4
  %6 = load i32* %i, align 4
  %sub = sub nsw i32 0, %6
  %call3 = call i32 @b_shift(%struct.lua_State* %4, i32 %5, i32 %sub)
  store i32 %call3, i32* %retval
  br label %return

if.else:                                          ; preds = %lor.lhs.false
  %7 = load i32* %i, align 4
  %cmp4 = icmp sge i32 %7, 32
  br i1 %cmp4, label %if.then6, label %if.else7

if.then6:                                         ; preds = %if.else
  store i32 -1, i32* %r, align 4
  br label %if.end

if.else7:                                         ; preds = %if.else
  %8 = load i32* %r, align 4
  %9 = load i32* %i, align 4
  %shr = lshr i32 %8, %9
  %10 = load i32* %i, align 4
  %shr8 = lshr i32 -1, %10
  %neg = xor i32 %shr8, -1
  %or = or i32 %shr, %neg
  store i32 %or, i32* %r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else7, %if.then6
  %11 = load %struct.lua_State** %L.addr, align 8
  %12 = load i32* %r, align 4
  call void @lua_pushunsigned(%struct.lua_State* %11, i32 %12)
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %13 = load i32* %retval
  ret i32 %13
}

; Function Attrs: nounwind uwtable
define internal i32 @b_and(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %r = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @andaux(%struct.lua_State* %0)
  store i32 %call, i32* %r, align 4
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load i32* %r, align 4
  call void @lua_pushunsigned(%struct.lua_State* %1, i32 %2)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @b_not(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %r = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @luaL_checkunsigned(%struct.lua_State* %0, i32 1)
  %neg = xor i32 %call, -1
  store i32 %neg, i32* %r, align 4
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load i32* %r, align 4
  call void @lua_pushunsigned(%struct.lua_State* %1, i32 %2)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @b_or(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %i = alloca i32, align 4
  %n = alloca i32, align 4
  %r = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_gettop(%struct.lua_State* %0)
  store i32 %call, i32* %n, align 4
  store i32 0, i32* %r, align 4
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32* %i, align 4
  %2 = load i32* %n, align 4
  %cmp = icmp sle i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load i32* %i, align 4
  %call1 = call i32 @luaL_checkunsigned(%struct.lua_State* %3, i32 %4)
  %5 = load i32* %r, align 4
  %or = or i32 %5, %call1
  store i32 %or, i32* %r, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %6 = load i32* %i, align 4
  %inc = add nsw i32 %6, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %7 = load %struct.lua_State** %L.addr, align 8
  %8 = load i32* %r, align 4
  call void @lua_pushunsigned(%struct.lua_State* %7, i32 %8)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @b_xor(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %i = alloca i32, align 4
  %n = alloca i32, align 4
  %r = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_gettop(%struct.lua_State* %0)
  store i32 %call, i32* %n, align 4
  store i32 0, i32* %r, align 4
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32* %i, align 4
  %2 = load i32* %n, align 4
  %cmp = icmp sle i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load i32* %i, align 4
  %call1 = call i32 @luaL_checkunsigned(%struct.lua_State* %3, i32 %4)
  %5 = load i32* %r, align 4
  %xor = xor i32 %5, %call1
  store i32 %xor, i32* %r, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %6 = load i32* %i, align 4
  %inc = add nsw i32 %6, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %7 = load %struct.lua_State** %L.addr, align 8
  %8 = load i32* %r, align 4
  call void @lua_pushunsigned(%struct.lua_State* %7, i32 %8)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @b_test(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %r = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @andaux(%struct.lua_State* %0)
  store i32 %call, i32* %r, align 4
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load i32* %r, align 4
  %cmp = icmp ne i32 %2, 0
  %conv = zext i1 %cmp to i32
  call void @lua_pushboolean(%struct.lua_State* %1, i32 %conv)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @b_extract(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %w = alloca i32, align 4
  %r = alloca i32, align 4
  %f = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @luaL_checkunsigned(%struct.lua_State* %0, i32 1)
  store i32 %call, i32* %r, align 4
  %1 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i32 @fieldargs(%struct.lua_State* %1, i32 2, i32* %w)
  store i32 %call1, i32* %f, align 4
  %2 = load i32* %r, align 4
  %3 = load i32* %f, align 4
  %shr = lshr i32 %2, %3
  %4 = load i32* %w, align 4
  %sub = sub nsw i32 %4, 1
  %shl = shl i32 -2, %sub
  %neg = xor i32 %shl, -1
  %and = and i32 %shr, %neg
  store i32 %and, i32* %r, align 4
  %5 = load %struct.lua_State** %L.addr, align 8
  %6 = load i32* %r, align 4
  call void @lua_pushunsigned(%struct.lua_State* %5, i32 %6)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @b_lrot(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call i64 @luaL_checkinteger(%struct.lua_State* %1, i32 2)
  %conv = trunc i64 %call to i32
  %call1 = call i32 @b_rot(%struct.lua_State* %0, i32 %conv)
  ret i32 %call1
}

; Function Attrs: nounwind uwtable
define internal i32 @b_lshift(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @luaL_checkunsigned(%struct.lua_State* %1, i32 1)
  %2 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i64 @luaL_checkinteger(%struct.lua_State* %2, i32 2)
  %conv = trunc i64 %call1 to i32
  %call2 = call i32 @b_shift(%struct.lua_State* %0, i32 %call, i32 %conv)
  ret i32 %call2
}

; Function Attrs: nounwind uwtable
define internal i32 @b_replace(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %w = alloca i32, align 4
  %r = alloca i32, align 4
  %v = alloca i32, align 4
  %f = alloca i32, align 4
  %m = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @luaL_checkunsigned(%struct.lua_State* %0, i32 1)
  store i32 %call, i32* %r, align 4
  %1 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i32 @luaL_checkunsigned(%struct.lua_State* %1, i32 2)
  store i32 %call1, i32* %v, align 4
  %2 = load %struct.lua_State** %L.addr, align 8
  %call2 = call i32 @fieldargs(%struct.lua_State* %2, i32 3, i32* %w)
  store i32 %call2, i32* %f, align 4
  %3 = load i32* %w, align 4
  %sub = sub nsw i32 %3, 1
  %shl = shl i32 -2, %sub
  %neg = xor i32 %shl, -1
  store i32 %neg, i32* %m, align 4
  %4 = load i32* %m, align 4
  %5 = load i32* %v, align 4
  %and = and i32 %5, %4
  store i32 %and, i32* %v, align 4
  %6 = load i32* %r, align 4
  %7 = load i32* %m, align 4
  %8 = load i32* %f, align 4
  %shl3 = shl i32 %7, %8
  %neg4 = xor i32 %shl3, -1
  %and5 = and i32 %6, %neg4
  %9 = load i32* %v, align 4
  %10 = load i32* %f, align 4
  %shl6 = shl i32 %9, %10
  %or = or i32 %and5, %shl6
  store i32 %or, i32* %r, align 4
  %11 = load %struct.lua_State** %L.addr, align 8
  %12 = load i32* %r, align 4
  call void @lua_pushunsigned(%struct.lua_State* %11, i32 %12)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @b_rrot(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call i64 @luaL_checkinteger(%struct.lua_State* %1, i32 2)
  %conv = trunc i64 %call to i32
  %sub = sub nsw i32 0, %conv
  %call1 = call i32 @b_rot(%struct.lua_State* %0, i32 %sub)
  ret i32 %call1
}

; Function Attrs: nounwind uwtable
define internal i32 @b_rshift(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @luaL_checkunsigned(%struct.lua_State* %1, i32 1)
  %2 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i64 @luaL_checkinteger(%struct.lua_State* %2, i32 2)
  %conv = trunc i64 %call1 to i32
  %sub = sub nsw i32 0, %conv
  %call2 = call i32 @b_shift(%struct.lua_State* %0, i32 %call, i32 %sub)
  ret i32 %call2
}

; Function Attrs: nounwind uwtable
define internal i32 @b_shift(%struct.lua_State* %L, i32 %r, i32 %i) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %r.addr = alloca i32, align 4
  %i.addr = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %r, i32* %r.addr, align 4
  store i32 %i, i32* %i.addr, align 4
  %0 = load i32* %i.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.else3

if.then:                                          ; preds = %entry
  %1 = load i32* %i.addr, align 4
  %sub = sub nsw i32 0, %1
  store i32 %sub, i32* %i.addr, align 4
  %2 = load i32* %r.addr, align 4
  store i32 %2, i32* %r.addr, align 4
  %3 = load i32* %i.addr, align 4
  %cmp1 = icmp sge i32 %3, 32
  br i1 %cmp1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  store i32 0, i32* %r.addr, align 4
  br label %if.end

if.else:                                          ; preds = %if.then
  %4 = load i32* %i.addr, align 4
  %5 = load i32* %r.addr, align 4
  %shr = lshr i32 %5, %4
  store i32 %shr, i32* %r.addr, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then2
  br label %if.end8

if.else3:                                         ; preds = %entry
  %6 = load i32* %i.addr, align 4
  %cmp4 = icmp sge i32 %6, 32
  br i1 %cmp4, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.else3
  store i32 0, i32* %r.addr, align 4
  br label %if.end7

if.else6:                                         ; preds = %if.else3
  %7 = load i32* %i.addr, align 4
  %8 = load i32* %r.addr, align 4
  %shl = shl i32 %8, %7
  store i32 %shl, i32* %r.addr, align 4
  br label %if.end7

if.end7:                                          ; preds = %if.else6, %if.then5
  %9 = load i32* %r.addr, align 4
  store i32 %9, i32* %r.addr, align 4
  br label %if.end8

if.end8:                                          ; preds = %if.end7, %if.end
  %10 = load %struct.lua_State** %L.addr, align 8
  %11 = load i32* %r.addr, align 4
  call void @lua_pushunsigned(%struct.lua_State* %10, i32 %11)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @andaux(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %i = alloca i32, align 4
  %n = alloca i32, align 4
  %r = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_gettop(%struct.lua_State* %0)
  store i32 %call, i32* %n, align 4
  store i32 -1, i32* %r, align 4
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32* %i, align 4
  %2 = load i32* %n, align 4
  %cmp = icmp sle i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load i32* %i, align 4
  %call1 = call i32 @luaL_checkunsigned(%struct.lua_State* %3, i32 %4)
  %5 = load i32* %r, align 4
  %and = and i32 %5, %call1
  store i32 %and, i32* %r, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %6 = load i32* %i, align 4
  %inc = add nsw i32 %6, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %7 = load i32* %r, align 4
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal i32 @fieldargs(%struct.lua_State* %L, i32 %farg, i32* %width) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %farg.addr = alloca i32, align 4
  %width.addr = alloca i32*, align 8
  %f = alloca i32, align 4
  %w = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %farg, i32* %farg.addr, align 4
  store i32* %width, i32** %width.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %farg.addr, align 4
  %call = call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 %1)
  %conv = trunc i64 %call to i32
  store i32 %conv, i32* %f, align 4
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load i32* %farg.addr, align 4
  %add = add nsw i32 %3, 1
  %call1 = call i64 @luaL_optinteger(%struct.lua_State* %2, i32 %add, i64 1)
  %conv2 = trunc i64 %call1 to i32
  store i32 %conv2, i32* %w, align 4
  %4 = load i32* %f, align 4
  %cmp = icmp sle i32 0, %4
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %5 = load %struct.lua_State** %L.addr, align 8
  %6 = load i32* %farg.addr, align 4
  %call4 = call i32 @luaL_argerror(%struct.lua_State* %5, i32 %6, i8* getelementptr inbounds ([25 x i8]* @.str12119, i32 0, i32 0))
  %tobool = icmp ne i32 %call4, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %7 = phi i1 [ true, %entry ], [ %tobool, %lor.rhs ]
  %lor.ext = zext i1 %7 to i32
  %8 = load i32* %w, align 4
  %cmp5 = icmp slt i32 0, %8
  br i1 %cmp5, label %lor.end11, label %lor.rhs7

lor.rhs7:                                         ; preds = %lor.end
  %9 = load %struct.lua_State** %L.addr, align 8
  %10 = load i32* %farg.addr, align 4
  %add8 = add nsw i32 %10, 1
  %call9 = call i32 @luaL_argerror(%struct.lua_State* %9, i32 %add8, i8* getelementptr inbounds ([23 x i8]* @.str13120, i32 0, i32 0))
  %tobool10 = icmp ne i32 %call9, 0
  br label %lor.end11

lor.end11:                                        ; preds = %lor.rhs7, %lor.end
  %11 = phi i1 [ true, %lor.end ], [ %tobool10, %lor.rhs7 ]
  %lor.ext12 = zext i1 %11 to i32
  %12 = load i32* %f, align 4
  %13 = load i32* %w, align 4
  %add13 = add nsw i32 %12, %13
  %cmp14 = icmp sgt i32 %add13, 32
  br i1 %cmp14, label %if.then, label %if.end

if.then:                                          ; preds = %lor.end11
  %14 = load %struct.lua_State** %L.addr, align 8
  %call16 = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %14, i8* getelementptr inbounds ([35 x i8]* @.str14121, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.end11
  %15 = load i32* %w, align 4
  %16 = load i32** %width.addr, align 8
  store i32 %15, i32* %16, align 4
  %17 = load i32* %f, align 4
  ret i32 %17
}

; Function Attrs: nounwind uwtable
define internal i32 @b_rot(%struct.lua_State* %L, i32 %i) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %i.addr = alloca i32, align 4
  %r = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %i, i32* %i.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @luaL_checkunsigned(%struct.lua_State* %0, i32 1)
  store i32 %call, i32* %r, align 4
  %1 = load i32* %i.addr, align 4
  %and = and i32 %1, 31
  store i32 %and, i32* %i.addr, align 4
  %2 = load i32* %r, align 4
  store i32 %2, i32* %r, align 4
  %3 = load i32* %r, align 4
  %4 = load i32* %i.addr, align 4
  %shl = shl i32 %3, %4
  %5 = load i32* %r, align 4
  %6 = load i32* %i.addr, align 4
  %sub = sub nsw i32 32, %6
  %shr = lshr i32 %5, %sub
  %or = or i32 %shl, %shr
  store i32 %or, i32* %r, align 4
  %7 = load %struct.lua_State** %L.addr, align 8
  %8 = load i32* %r, align 4
  call void @lua_pushunsigned(%struct.lua_State* %7, i32 %8)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define hidden void @luaK_nil(%struct.FuncState* %fs, i32 %from, i32 %n) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %from.addr = alloca i32, align 4
  %n.addr = alloca i32, align 4
  %previous = alloca i32*, align 8
  %l = alloca i32, align 4
  %pfrom = alloca i32, align 4
  %pl = alloca i32, align 4
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store i32 %from, i32* %from.addr, align 4
  store i32 %n, i32* %n.addr, align 4
  %0 = load i32* %from.addr, align 4
  %1 = load i32* %n.addr, align 4
  %add = add nsw i32 %0, %1
  %sub = sub nsw i32 %add, 1
  store i32 %sub, i32* %l, align 4
  %2 = load %struct.FuncState** %fs.addr, align 8
  %pc = getelementptr inbounds %struct.FuncState* %2, i32 0, i32 5
  %3 = load i32* %pc, align 4
  %4 = load %struct.FuncState** %fs.addr, align 8
  %lasttarget = getelementptr inbounds %struct.FuncState* %4, i32 0, i32 6
  %5 = load i32* %lasttarget, align 4
  %cmp = icmp sgt i32 %3, %5
  br i1 %cmp, label %if.then, label %if.end32

if.then:                                          ; preds = %entry
  %6 = load %struct.FuncState** %fs.addr, align 8
  %pc1 = getelementptr inbounds %struct.FuncState* %6, i32 0, i32 5
  %7 = load i32* %pc1, align 4
  %sub2 = sub nsw i32 %7, 1
  %idxprom = sext i32 %sub2 to i64
  %8 = load %struct.FuncState** %fs.addr, align 8
  %f = getelementptr inbounds %struct.FuncState* %8, i32 0, i32 0
  %9 = load %struct.Proto.36** %f, align 8
  %code = getelementptr inbounds %struct.Proto.36* %9, i32 0, i32 4
  %10 = load i32** %code, align 8
  %arrayidx = getelementptr inbounds i32* %10, i64 %idxprom
  store i32* %arrayidx, i32** %previous, align 8
  %11 = load i32** %previous, align 8
  %12 = load i32* %11, align 4
  %shr = lshr i32 %12, 0
  %and = and i32 %shr, 63
  %cmp3 = icmp eq i32 %and, 4
  br i1 %cmp3, label %if.then4, label %if.end31

if.then4:                                         ; preds = %if.then
  %13 = load i32** %previous, align 8
  %14 = load i32* %13, align 4
  %shr5 = lshr i32 %14, 6
  %and6 = and i32 %shr5, 255
  store i32 %and6, i32* %pfrom, align 4
  %15 = load i32* %pfrom, align 4
  %16 = load i32** %previous, align 8
  %17 = load i32* %16, align 4
  %shr7 = lshr i32 %17, 23
  %and8 = and i32 %shr7, 511
  %add9 = add nsw i32 %15, %and8
  store i32 %add9, i32* %pl, align 4
  %18 = load i32* %pfrom, align 4
  %19 = load i32* %from.addr, align 4
  %cmp10 = icmp sle i32 %18, %19
  br i1 %cmp10, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %if.then4
  %20 = load i32* %from.addr, align 4
  %21 = load i32* %pl, align 4
  %add11 = add nsw i32 %21, 1
  %cmp12 = icmp sle i32 %20, %add11
  br i1 %cmp12, label %if.then17, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %if.then4
  %22 = load i32* %from.addr, align 4
  %23 = load i32* %pfrom, align 4
  %cmp13 = icmp sle i32 %22, %23
  br i1 %cmp13, label %land.lhs.true14, label %if.end30

land.lhs.true14:                                  ; preds = %lor.lhs.false
  %24 = load i32* %pfrom, align 4
  %25 = load i32* %l, align 4
  %add15 = add nsw i32 %25, 1
  %cmp16 = icmp sle i32 %24, %add15
  br i1 %cmp16, label %if.then17, label %if.end30

if.then17:                                        ; preds = %land.lhs.true14, %land.lhs.true
  %26 = load i32* %pfrom, align 4
  %27 = load i32* %from.addr, align 4
  %cmp18 = icmp slt i32 %26, %27
  br i1 %cmp18, label %if.then19, label %if.end

if.then19:                                        ; preds = %if.then17
  %28 = load i32* %pfrom, align 4
  store i32 %28, i32* %from.addr, align 4
  br label %if.end

if.end:                                           ; preds = %if.then19, %if.then17
  %29 = load i32* %pl, align 4
  %30 = load i32* %l, align 4
  %cmp20 = icmp sgt i32 %29, %30
  br i1 %cmp20, label %if.then21, label %if.end22

if.then21:                                        ; preds = %if.end
  %31 = load i32* %pl, align 4
  store i32 %31, i32* %l, align 4
  br label %if.end22

if.end22:                                         ; preds = %if.then21, %if.end
  %32 = load i32** %previous, align 8
  %33 = load i32* %32, align 4
  %and23 = and i32 %33, -16321
  %34 = load i32* %from.addr, align 4
  %shl = shl i32 %34, 6
  %and24 = and i32 %shl, 16320
  %or = or i32 %and23, %and24
  %35 = load i32** %previous, align 8
  store i32 %or, i32* %35, align 4
  %36 = load i32** %previous, align 8
  %37 = load i32* %36, align 4
  %and25 = and i32 %37, 8388607
  %38 = load i32* %l, align 4
  %39 = load i32* %from.addr, align 4
  %sub26 = sub nsw i32 %38, %39
  %shl27 = shl i32 %sub26, 23
  %and28 = and i32 %shl27, -8388608
  %or29 = or i32 %and25, %and28
  %40 = load i32** %previous, align 8
  store i32 %or29, i32* %40, align 4
  br label %return

if.end30:                                         ; preds = %land.lhs.true14, %lor.lhs.false
  br label %if.end31

if.end31:                                         ; preds = %if.end30, %if.then
  br label %if.end32

if.end32:                                         ; preds = %if.end31, %entry
  %41 = load %struct.FuncState** %fs.addr, align 8
  %42 = load i32* %from.addr, align 4
  %43 = load i32* %n.addr, align 4
  %sub33 = sub nsw i32 %43, 1
  %call = call i32 @luaK_codeABC(%struct.FuncState* %41, i32 4, i32 %42, i32 %sub33, i32 0)
  br label %return

return:                                           ; preds = %if.end32, %if.end22
  ret void
}

; Function Attrs: nounwind uwtable
define hidden i32 @luaK_codeABC(%struct.FuncState* %fs, i32 %o, i32 %a, i32 %b, i32 %c) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %o.addr = alloca i32, align 4
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %c.addr = alloca i32, align 4
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store i32 %o, i32* %o.addr, align 4
  store i32 %a, i32* %a.addr, align 4
  store i32 %b, i32* %b.addr, align 4
  store i32 %c, i32* %c.addr, align 4
  %0 = load %struct.FuncState** %fs.addr, align 8
  %1 = load i32* %o.addr, align 4
  %shl = shl i32 %1, 0
  %2 = load i32* %a.addr, align 4
  %shl1 = shl i32 %2, 6
  %or = or i32 %shl, %shl1
  %3 = load i32* %b.addr, align 4
  %shl2 = shl i32 %3, 23
  %or3 = or i32 %or, %shl2
  %4 = load i32* %c.addr, align 4
  %shl4 = shl i32 %4, 14
  %or5 = or i32 %or3, %shl4
  %call = call i32 @luaK_code(%struct.FuncState* %0, i32 %or5)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define hidden i32 @luaK_jump(%struct.FuncState* %fs) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %jpc = alloca i32, align 4
  %j = alloca i32, align 4
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  %0 = load %struct.FuncState** %fs.addr, align 8
  %jpc1 = getelementptr inbounds %struct.FuncState* %0, i32 0, i32 7
  %1 = load i32* %jpc1, align 4
  store i32 %1, i32* %jpc, align 4
  %2 = load %struct.FuncState** %fs.addr, align 8
  %jpc2 = getelementptr inbounds %struct.FuncState* %2, i32 0, i32 7
  store i32 -1, i32* %jpc2, align 4
  %3 = load %struct.FuncState** %fs.addr, align 8
  %call = call i32 @luaK_codeABx(%struct.FuncState* %3, i32 23, i32 0, i32 131070)
  store i32 %call, i32* %j, align 4
  %4 = load %struct.FuncState** %fs.addr, align 8
  %5 = load i32* %jpc, align 4
  call void @luaK_concat(%struct.FuncState* %4, i32* %j, i32 %5)
  %6 = load i32* %j, align 4
  ret i32 %6
}

; Function Attrs: nounwind uwtable
define hidden i32 @luaK_codeABx(%struct.FuncState* %fs, i32 %o, i32 %a, i32 %bc) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %o.addr = alloca i32, align 4
  %a.addr = alloca i32, align 4
  %bc.addr = alloca i32, align 4
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store i32 %o, i32* %o.addr, align 4
  store i32 %a, i32* %a.addr, align 4
  store i32 %bc, i32* %bc.addr, align 4
  %0 = load %struct.FuncState** %fs.addr, align 8
  %1 = load i32* %o.addr, align 4
  %shl = shl i32 %1, 0
  %2 = load i32* %a.addr, align 4
  %shl1 = shl i32 %2, 6
  %or = or i32 %shl, %shl1
  %3 = load i32* %bc.addr, align 4
  %shl2 = shl i32 %3, 14
  %or3 = or i32 %or, %shl2
  %call = call i32 @luaK_code(%struct.FuncState* %0, i32 %or3)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define hidden void @luaK_concat(%struct.FuncState* %fs, i32* %l1, i32 %l2) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %l1.addr = alloca i32*, align 8
  %l2.addr = alloca i32, align 4
  %list = alloca i32, align 4
  %next = alloca i32, align 4
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store i32* %l1, i32** %l1.addr, align 8
  store i32 %l2, i32* %l2.addr, align 4
  %0 = load i32* %l2.addr, align 4
  %cmp = icmp eq i32 %0, -1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end5

if.else:                                          ; preds = %entry
  %1 = load i32** %l1.addr, align 8
  %2 = load i32* %1, align 4
  %cmp1 = icmp eq i32 %2, -1
  br i1 %cmp1, label %if.then2, label %if.else3

if.then2:                                         ; preds = %if.else
  %3 = load i32* %l2.addr, align 4
  %4 = load i32** %l1.addr, align 8
  store i32 %3, i32* %4, align 4
  br label %if.end

if.else3:                                         ; preds = %if.else
  %5 = load i32** %l1.addr, align 8
  %6 = load i32* %5, align 4
  store i32 %6, i32* %list, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.else3
  %7 = load %struct.FuncState** %fs.addr, align 8
  %8 = load i32* %list, align 4
  %call = call i32 @getjump(%struct.FuncState* %7, i32 %8)
  store i32 %call, i32* %next, align 4
  %cmp4 = icmp ne i32 %call, -1
  br i1 %cmp4, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %9 = load i32* %next, align 4
  store i32 %9, i32* %list, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %10 = load %struct.FuncState** %fs.addr, align 8
  %11 = load i32* %list, align 4
  %12 = load i32* %l2.addr, align 4
  call void @fixjump(%struct.FuncState* %10, i32 %11, i32 %12)
  br label %if.end

if.end:                                           ; preds = %while.end, %if.then2
  br label %if.end5

if.end5:                                          ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @luaK_ret(%struct.FuncState* %fs, i32 %first, i32 %nret) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %first.addr = alloca i32, align 4
  %nret.addr = alloca i32, align 4
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store i32 %first, i32* %first.addr, align 4
  store i32 %nret, i32* %nret.addr, align 4
  %0 = load %struct.FuncState** %fs.addr, align 8
  %1 = load i32* %first.addr, align 4
  %2 = load i32* %nret.addr, align 4
  %add = add nsw i32 %2, 1
  %call = call i32 @luaK_codeABC(%struct.FuncState* %0, i32 31, i32 %1, i32 %add, i32 0)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden i32 @luaK_getlabel(%struct.FuncState* %fs) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  %0 = load %struct.FuncState** %fs.addr, align 8
  %pc = getelementptr inbounds %struct.FuncState* %0, i32 0, i32 5
  %1 = load i32* %pc, align 4
  %2 = load %struct.FuncState** %fs.addr, align 8
  %lasttarget = getelementptr inbounds %struct.FuncState* %2, i32 0, i32 6
  store i32 %1, i32* %lasttarget, align 4
  %3 = load %struct.FuncState** %fs.addr, align 8
  %pc1 = getelementptr inbounds %struct.FuncState* %3, i32 0, i32 5
  %4 = load i32* %pc1, align 4
  ret i32 %4
}

; Function Attrs: nounwind uwtable
define hidden void @luaK_patchlist(%struct.FuncState* %fs, i32 %list, i32 %target) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %list.addr = alloca i32, align 4
  %target.addr = alloca i32, align 4
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store i32 %list, i32* %list.addr, align 4
  store i32 %target, i32* %target.addr, align 4
  %0 = load i32* %target.addr, align 4
  %1 = load %struct.FuncState** %fs.addr, align 8
  %pc = getelementptr inbounds %struct.FuncState* %1, i32 0, i32 5
  %2 = load i32* %pc, align 4
  %cmp = icmp eq i32 %0, %2
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load %struct.FuncState** %fs.addr, align 8
  %4 = load i32* %list.addr, align 4
  call void @luaK_patchtohere(%struct.FuncState* %3, i32 %4)
  br label %if.end

if.else:                                          ; preds = %entry
  %5 = load %struct.FuncState** %fs.addr, align 8
  %6 = load i32* %list.addr, align 4
  %7 = load i32* %target.addr, align 4
  %8 = load i32* %target.addr, align 4
  call void @patchlistaux(%struct.FuncState* %5, i32 %6, i32 %7, i32 255, i32 %8)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @luaK_patchtohere(%struct.FuncState* %fs, i32 %list) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %list.addr = alloca i32, align 4
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store i32 %list, i32* %list.addr, align 4
  %0 = load %struct.FuncState** %fs.addr, align 8
  %call = call i32 @luaK_getlabel(%struct.FuncState* %0)
  %1 = load %struct.FuncState** %fs.addr, align 8
  %2 = load %struct.FuncState** %fs.addr, align 8
  %jpc = getelementptr inbounds %struct.FuncState* %2, i32 0, i32 7
  %3 = load i32* %list.addr, align 4
  call void @luaK_concat(%struct.FuncState* %1, i32* %jpc, i32 %3)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @luaK_patchclose(%struct.FuncState* %fs, i32 %list, i32 %level) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %list.addr = alloca i32, align 4
  %level.addr = alloca i32, align 4
  %next = alloca i32, align 4
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store i32 %list, i32* %list.addr, align 4
  store i32 %level, i32* %level.addr, align 4
  %0 = load i32* %level.addr, align 4
  %inc = add nsw i32 %0, 1
  store i32 %inc, i32* %level.addr, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %1 = load i32* %list.addr, align 4
  %cmp = icmp ne i32 %1, -1
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load %struct.FuncState** %fs.addr, align 8
  %3 = load i32* %list.addr, align 4
  %call = call i32 @getjump(%struct.FuncState* %2, i32 %3)
  store i32 %call, i32* %next, align 4
  %4 = load i32* %list.addr, align 4
  %idxprom = sext i32 %4 to i64
  %5 = load %struct.FuncState** %fs.addr, align 8
  %f = getelementptr inbounds %struct.FuncState* %5, i32 0, i32 0
  %6 = load %struct.Proto.36** %f, align 8
  %code = getelementptr inbounds %struct.Proto.36* %6, i32 0, i32 4
  %7 = load i32** %code, align 8
  %arrayidx = getelementptr inbounds i32* %7, i64 %idxprom
  %8 = load i32* %arrayidx, align 4
  %and = and i32 %8, -16321
  %9 = load i32* %level.addr, align 4
  %shl = shl i32 %9, 6
  %and1 = and i32 %shl, 16320
  %or = or i32 %and, %and1
  %10 = load i32* %list.addr, align 4
  %idxprom2 = sext i32 %10 to i64
  %11 = load %struct.FuncState** %fs.addr, align 8
  %f3 = getelementptr inbounds %struct.FuncState* %11, i32 0, i32 0
  %12 = load %struct.Proto.36** %f3, align 8
  %code4 = getelementptr inbounds %struct.Proto.36* %12, i32 0, i32 4
  %13 = load i32** %code4, align 8
  %arrayidx5 = getelementptr inbounds i32* %13, i64 %idxprom2
  store i32 %or, i32* %arrayidx5, align 4
  %14 = load i32* %next, align 4
  store i32 %14, i32* %list.addr, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: nounwind uwtable
define hidden i32 @luaK_codek(%struct.FuncState* %fs, i32 %reg, i32 %k) #0 {
entry:
  %retval = alloca i32, align 4
  %fs.addr = alloca %struct.FuncState*, align 8
  %reg.addr = alloca i32, align 4
  %k.addr = alloca i32, align 4
  %p = alloca i32, align 4
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store i32 %reg, i32* %reg.addr, align 4
  store i32 %k, i32* %k.addr, align 4
  %0 = load i32* %k.addr, align 4
  %cmp = icmp sle i32 %0, 262143
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load %struct.FuncState** %fs.addr, align 8
  %2 = load i32* %reg.addr, align 4
  %3 = load i32* %k.addr, align 4
  %call = call i32 @luaK_codeABx(%struct.FuncState* %1, i32 1, i32 %2, i32 %3)
  store i32 %call, i32* %retval
  br label %return

if.else:                                          ; preds = %entry
  %4 = load %struct.FuncState** %fs.addr, align 8
  %5 = load i32* %reg.addr, align 4
  %call1 = call i32 @luaK_codeABx(%struct.FuncState* %4, i32 2, i32 %5, i32 0)
  store i32 %call1, i32* %p, align 4
  %6 = load %struct.FuncState** %fs.addr, align 8
  %7 = load i32* %k.addr, align 4
  %call2 = call i32 @codeextraarg(%struct.FuncState* %6, i32 %7)
  %8 = load i32* %p, align 4
  store i32 %8, i32* %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %9 = load i32* %retval
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define hidden void @luaK_checkstack(%struct.FuncState* %fs, i32 %n) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %n.addr = alloca i32, align 4
  %newstack = alloca i32, align 4
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store i32 %n, i32* %n.addr, align 4
  %0 = load %struct.FuncState** %fs.addr, align 8
  %freereg = getelementptr inbounds %struct.FuncState* %0, i32 0, i32 14
  %1 = load i8* %freereg, align 1
  %conv = zext i8 %1 to i32
  %2 = load i32* %n.addr, align 4
  %add = add nsw i32 %conv, %2
  store i32 %add, i32* %newstack, align 4
  %3 = load i32* %newstack, align 4
  %4 = load %struct.FuncState** %fs.addr, align 8
  %f = getelementptr inbounds %struct.FuncState* %4, i32 0, i32 0
  %5 = load %struct.Proto.36** %f, align 8
  %maxstacksize = getelementptr inbounds %struct.Proto.36* %5, i32 0, i32 22
  %6 = load i8* %maxstacksize, align 1
  %conv1 = zext i8 %6 to i32
  %cmp = icmp sgt i32 %3, %conv1
  br i1 %cmp, label %if.then, label %if.end9

if.then:                                          ; preds = %entry
  %7 = load i32* %newstack, align 4
  %cmp3 = icmp sge i32 %7, 250
  br i1 %cmp3, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.then
  %8 = load %struct.FuncState** %fs.addr, align 8
  %ls = getelementptr inbounds %struct.FuncState* %8, i32 0, i32 3
  %9 = load %struct.LexState** %ls, align 8
  call void bitcast (void (%struct.LexState.235*, i8*)* @luaX_syntaxerror to void (%struct.LexState*, i8*)*)(%struct.LexState* %9, i8* getelementptr inbounds ([35 x i8]* @.str122, i32 0, i32 0)) #9
  unreachable

if.end:                                           ; preds = %if.then
  %10 = load i32* %newstack, align 4
  %conv6 = trunc i32 %10 to i8
  %11 = load %struct.FuncState** %fs.addr, align 8
  %f7 = getelementptr inbounds %struct.FuncState* %11, i32 0, i32 0
  %12 = load %struct.Proto.36** %f7, align 8
  %maxstacksize8 = getelementptr inbounds %struct.Proto.36* %12, i32 0, i32 22
  store i8 %conv6, i8* %maxstacksize8, align 1
  br label %if.end9

if.end9:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @luaK_reserveregs(%struct.FuncState* %fs, i32 %n) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %n.addr = alloca i32, align 4
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store i32 %n, i32* %n.addr, align 4
  %0 = load %struct.FuncState** %fs.addr, align 8
  %1 = load i32* %n.addr, align 4
  call void @luaK_checkstack(%struct.FuncState* %0, i32 %1)
  %2 = load i32* %n.addr, align 4
  %3 = load %struct.FuncState** %fs.addr, align 8
  %freereg = getelementptr inbounds %struct.FuncState* %3, i32 0, i32 14
  %4 = load i8* %freereg, align 1
  %conv = zext i8 %4 to i32
  %add = add nsw i32 %conv, %2
  %conv1 = trunc i32 %add to i8
  store i8 %conv1, i8* %freereg, align 1
  ret void
}

; Function Attrs: nounwind uwtable
define hidden i32 @luaK_stringK(%struct.FuncState* %fs, %union.TString.19* %s) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %s.addr = alloca %union.TString.19*, align 8
  %o = alloca %struct.lua_TValue.13, align 8
  %io = alloca %struct.lua_TValue.13*, align 8
  %x_ = alloca %union.TString.19*, align 8
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store %union.TString.19* %s, %union.TString.19** %s.addr, align 8
  store %struct.lua_TValue.13* %o, %struct.lua_TValue.13** %io, align 8
  %0 = load %union.TString.19** %s.addr, align 8
  store %union.TString.19* %0, %union.TString.19** %x_, align 8
  %1 = load %union.TString.19** %x_, align 8
  %2 = bitcast %union.TString.19* %1 to %union.GCObject.31*
  %3 = load %struct.lua_TValue.13** %io, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue.13* %3, i32 0, i32 0
  %gc = bitcast %union.Value.12* %value_ to %union.GCObject.31**
  store %union.GCObject.31* %2, %union.GCObject.31** %gc, align 8
  %4 = load %union.TString.19** %x_, align 8
  %tsv = bitcast %union.TString.19* %4 to %struct.anon.1.18*
  %tt = getelementptr inbounds %struct.anon.1.18* %tsv, i32 0, i32 1
  %5 = load i8* %tt, align 1
  %conv = zext i8 %5 to i32
  %or = or i32 %conv, 64
  %6 = load %struct.lua_TValue.13** %io, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue.13* %6, i32 0, i32 1
  store i32 %or, i32* %tt_, align 4
  %7 = load %struct.FuncState** %fs.addr, align 8
  %call = call i32 @addk(%struct.FuncState* %7, %struct.lua_TValue.13* %o, %struct.lua_TValue.13* %o)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define hidden i32 @luaK_numberK(%struct.FuncState* %fs, double %r) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %r.addr = alloca double, align 8
  %n = alloca i32, align 4
  %L = alloca %struct.lua_State.30*, align 8
  %o = alloca %struct.lua_TValue.13, align 8
  %io = alloca %struct.lua_TValue.13*, align 8
  %io4 = alloca %struct.lua_TValue.13*, align 8
  %x_ = alloca %union.TString.19*, align 8
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store double %r, double* %r.addr, align 8
  %0 = load %struct.FuncState** %fs.addr, align 8
  %ls = getelementptr inbounds %struct.FuncState* %0, i32 0, i32 3
  %1 = load %struct.LexState** %ls, align 8
  %L1 = getelementptr inbounds %struct.LexState* %1, i32 0, i32 6
  %2 = load %struct.lua_State.30** %L1, align 8
  store %struct.lua_State.30* %2, %struct.lua_State.30** %L, align 8
  store %struct.lua_TValue.13* %o, %struct.lua_TValue.13** %io, align 8
  %3 = load double* %r.addr, align 8
  %4 = load %struct.lua_TValue.13** %io, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue.13* %4, i32 0, i32 0
  %n2 = bitcast %union.Value.12* %value_ to double*
  store double %3, double* %n2, align 8
  %5 = load %struct.lua_TValue.13** %io, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue.13* %5, i32 0, i32 1
  store i32 3, i32* %tt_, align 4
  %6 = load double* %r.addr, align 8
  %cmp = fcmp oeq double %6, 0.000000e+00
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %7 = load double* %r.addr, align 8
  %8 = load double* %r.addr, align 8
  %cmp3 = fcmp oeq double %7, %8
  br i1 %cmp3, label %if.else, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  %9 = load %struct.lua_State.30** %L, align 8
  %top = getelementptr inbounds %struct.lua_State.30* %9, i32 0, i32 4
  %10 = load %struct.lua_TValue.13** %top, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue.13* %10, i32 1
  store %struct.lua_TValue.13* %incdec.ptr, %struct.lua_TValue.13** %top, align 8
  store %struct.lua_TValue.13* %10, %struct.lua_TValue.13** %io4, align 8
  %11 = load %struct.lua_State.30** %L, align 8
  %12 = bitcast double* %r.addr to i8*
  %call = call %union.TString.19* bitcast (%union.TString.367* (%struct.lua_State.364*, i8*, i64)* @luaS_newlstr to %union.TString.19* (%struct.lua_State.30*, i8*, i64)*)(%struct.lua_State.30* %11, i8* %12, i64 8)
  store %union.TString.19* %call, %union.TString.19** %x_, align 8
  %13 = load %union.TString.19** %x_, align 8
  %14 = bitcast %union.TString.19* %13 to %union.GCObject.31*
  %15 = load %struct.lua_TValue.13** %io4, align 8
  %value_5 = getelementptr inbounds %struct.lua_TValue.13* %15, i32 0, i32 0
  %gc = bitcast %union.Value.12* %value_5 to %union.GCObject.31**
  store %union.GCObject.31* %14, %union.GCObject.31** %gc, align 8
  %16 = load %union.TString.19** %x_, align 8
  %tsv = bitcast %union.TString.19* %16 to %struct.anon.1.18*
  %tt = getelementptr inbounds %struct.anon.1.18* %tsv, i32 0, i32 1
  %17 = load i8* %tt, align 1
  %conv = zext i8 %17 to i32
  %or = or i32 %conv, 64
  %18 = load %struct.lua_TValue.13** %io4, align 8
  %tt_6 = getelementptr inbounds %struct.lua_TValue.13* %18, i32 0, i32 1
  store i32 %or, i32* %tt_6, align 4
  %19 = load %struct.FuncState** %fs.addr, align 8
  %20 = load %struct.lua_State.30** %L, align 8
  %top7 = getelementptr inbounds %struct.lua_State.30* %20, i32 0, i32 4
  %21 = load %struct.lua_TValue.13** %top7, align 8
  %add.ptr = getelementptr inbounds %struct.lua_TValue.13* %21, i64 -1
  %call8 = call i32 @addk(%struct.FuncState* %19, %struct.lua_TValue.13* %add.ptr, %struct.lua_TValue.13* %o)
  store i32 %call8, i32* %n, align 4
  %22 = load %struct.lua_State.30** %L, align 8
  %top9 = getelementptr inbounds %struct.lua_State.30* %22, i32 0, i32 4
  %23 = load %struct.lua_TValue.13** %top9, align 8
  %incdec.ptr10 = getelementptr inbounds %struct.lua_TValue.13* %23, i32 -1
  store %struct.lua_TValue.13* %incdec.ptr10, %struct.lua_TValue.13** %top9, align 8
  br label %if.end

if.else:                                          ; preds = %lor.lhs.false
  %24 = load %struct.FuncState** %fs.addr, align 8
  %call11 = call i32 @addk(%struct.FuncState* %24, %struct.lua_TValue.13* %o, %struct.lua_TValue.13* %o)
  store i32 %call11, i32* %n, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %25 = load i32* %n, align 4
  ret i32 %25
}

; Function Attrs: nounwind uwtable
define hidden void @luaK_setreturns(%struct.FuncState* %fs, %struct.expdesc* %e, i32 %nresults) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %e.addr = alloca %struct.expdesc*, align 8
  %nresults.addr = alloca i32, align 4
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store %struct.expdesc* %e, %struct.expdesc** %e.addr, align 8
  store i32 %nresults, i32* %nresults.addr, align 4
  %0 = load %struct.expdesc** %e.addr, align 8
  %k = getelementptr inbounds %struct.expdesc* %0, i32 0, i32 0
  %1 = load i32* %k, align 4
  %cmp = icmp eq i32 %1, 12
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load %struct.expdesc** %e.addr, align 8
  %u = getelementptr inbounds %struct.expdesc* %2, i32 0, i32 1
  %info = bitcast %union.anon.7* %u to i32*
  %3 = load i32* %info, align 4
  %idxprom = sext i32 %3 to i64
  %4 = load %struct.FuncState** %fs.addr, align 8
  %f = getelementptr inbounds %struct.FuncState* %4, i32 0, i32 0
  %5 = load %struct.Proto.36** %f, align 8
  %code = getelementptr inbounds %struct.Proto.36* %5, i32 0, i32 4
  %6 = load i32** %code, align 8
  %arrayidx = getelementptr inbounds i32* %6, i64 %idxprom
  %7 = load i32* %arrayidx, align 4
  %and = and i32 %7, -8372225
  %8 = load i32* %nresults.addr, align 4
  %add = add nsw i32 %8, 1
  %shl = shl i32 %add, 14
  %and1 = and i32 %shl, 8372224
  %or = or i32 %and, %and1
  %9 = load %struct.expdesc** %e.addr, align 8
  %u2 = getelementptr inbounds %struct.expdesc* %9, i32 0, i32 1
  %info3 = bitcast %union.anon.7* %u2 to i32*
  %10 = load i32* %info3, align 4
  %idxprom4 = sext i32 %10 to i64
  %11 = load %struct.FuncState** %fs.addr, align 8
  %f5 = getelementptr inbounds %struct.FuncState* %11, i32 0, i32 0
  %12 = load %struct.Proto.36** %f5, align 8
  %code6 = getelementptr inbounds %struct.Proto.36* %12, i32 0, i32 4
  %13 = load i32** %code6, align 8
  %arrayidx7 = getelementptr inbounds i32* %13, i64 %idxprom4
  store i32 %or, i32* %arrayidx7, align 4
  br label %if.end44

if.else:                                          ; preds = %entry
  %14 = load %struct.expdesc** %e.addr, align 8
  %k8 = getelementptr inbounds %struct.expdesc* %14, i32 0, i32 0
  %15 = load i32* %k8, align 4
  %cmp9 = icmp eq i32 %15, 13
  br i1 %cmp9, label %if.then10, label %if.end

if.then10:                                        ; preds = %if.else
  %16 = load %struct.expdesc** %e.addr, align 8
  %u11 = getelementptr inbounds %struct.expdesc* %16, i32 0, i32 1
  %info12 = bitcast %union.anon.7* %u11 to i32*
  %17 = load i32* %info12, align 4
  %idxprom13 = sext i32 %17 to i64
  %18 = load %struct.FuncState** %fs.addr, align 8
  %f14 = getelementptr inbounds %struct.FuncState* %18, i32 0, i32 0
  %19 = load %struct.Proto.36** %f14, align 8
  %code15 = getelementptr inbounds %struct.Proto.36* %19, i32 0, i32 4
  %20 = load i32** %code15, align 8
  %arrayidx16 = getelementptr inbounds i32* %20, i64 %idxprom13
  %21 = load i32* %arrayidx16, align 4
  %and17 = and i32 %21, 8388607
  %22 = load i32* %nresults.addr, align 4
  %add18 = add nsw i32 %22, 1
  %shl19 = shl i32 %add18, 23
  %and20 = and i32 %shl19, -8388608
  %or21 = or i32 %and17, %and20
  %23 = load %struct.expdesc** %e.addr, align 8
  %u22 = getelementptr inbounds %struct.expdesc* %23, i32 0, i32 1
  %info23 = bitcast %union.anon.7* %u22 to i32*
  %24 = load i32* %info23, align 4
  %idxprom24 = sext i32 %24 to i64
  %25 = load %struct.FuncState** %fs.addr, align 8
  %f25 = getelementptr inbounds %struct.FuncState* %25, i32 0, i32 0
  %26 = load %struct.Proto.36** %f25, align 8
  %code26 = getelementptr inbounds %struct.Proto.36* %26, i32 0, i32 4
  %27 = load i32** %code26, align 8
  %arrayidx27 = getelementptr inbounds i32* %27, i64 %idxprom24
  store i32 %or21, i32* %arrayidx27, align 4
  %28 = load %struct.expdesc** %e.addr, align 8
  %u28 = getelementptr inbounds %struct.expdesc* %28, i32 0, i32 1
  %info29 = bitcast %union.anon.7* %u28 to i32*
  %29 = load i32* %info29, align 4
  %idxprom30 = sext i32 %29 to i64
  %30 = load %struct.FuncState** %fs.addr, align 8
  %f31 = getelementptr inbounds %struct.FuncState* %30, i32 0, i32 0
  %31 = load %struct.Proto.36** %f31, align 8
  %code32 = getelementptr inbounds %struct.Proto.36* %31, i32 0, i32 4
  %32 = load i32** %code32, align 8
  %arrayidx33 = getelementptr inbounds i32* %32, i64 %idxprom30
  %33 = load i32* %arrayidx33, align 4
  %and34 = and i32 %33, -16321
  %34 = load %struct.FuncState** %fs.addr, align 8
  %freereg = getelementptr inbounds %struct.FuncState* %34, i32 0, i32 14
  %35 = load i8* %freereg, align 1
  %conv = zext i8 %35 to i32
  %shl35 = shl i32 %conv, 6
  %and36 = and i32 %shl35, 16320
  %or37 = or i32 %and34, %and36
  %36 = load %struct.expdesc** %e.addr, align 8
  %u38 = getelementptr inbounds %struct.expdesc* %36, i32 0, i32 1
  %info39 = bitcast %union.anon.7* %u38 to i32*
  %37 = load i32* %info39, align 4
  %idxprom40 = sext i32 %37 to i64
  %38 = load %struct.FuncState** %fs.addr, align 8
  %f41 = getelementptr inbounds %struct.FuncState* %38, i32 0, i32 0
  %39 = load %struct.Proto.36** %f41, align 8
  %code42 = getelementptr inbounds %struct.Proto.36* %39, i32 0, i32 4
  %40 = load i32** %code42, align 8
  %arrayidx43 = getelementptr inbounds i32* %40, i64 %idxprom40
  store i32 %or37, i32* %arrayidx43, align 4
  %41 = load %struct.FuncState** %fs.addr, align 8
  call void @luaK_reserveregs(%struct.FuncState* %41, i32 1)
  br label %if.end

if.end:                                           ; preds = %if.then10, %if.else
  br label %if.end44

if.end44:                                         ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @luaK_setoneret(%struct.FuncState* %fs, %struct.expdesc* %e) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %e.addr = alloca %struct.expdesc*, align 8
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store %struct.expdesc* %e, %struct.expdesc** %e.addr, align 8
  %0 = load %struct.expdesc** %e.addr, align 8
  %k = getelementptr inbounds %struct.expdesc* %0, i32 0, i32 0
  %1 = load i32* %k, align 4
  %cmp = icmp eq i32 %1, 12
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load %struct.expdesc** %e.addr, align 8
  %k1 = getelementptr inbounds %struct.expdesc* %2, i32 0, i32 0
  store i32 6, i32* %k1, align 4
  %3 = load %struct.expdesc** %e.addr, align 8
  %u = getelementptr inbounds %struct.expdesc* %3, i32 0, i32 1
  %info = bitcast %union.anon.7* %u to i32*
  %4 = load i32* %info, align 4
  %idxprom = sext i32 %4 to i64
  %5 = load %struct.FuncState** %fs.addr, align 8
  %f = getelementptr inbounds %struct.FuncState* %5, i32 0, i32 0
  %6 = load %struct.Proto.36** %f, align 8
  %code = getelementptr inbounds %struct.Proto.36* %6, i32 0, i32 4
  %7 = load i32** %code, align 8
  %arrayidx = getelementptr inbounds i32* %7, i64 %idxprom
  %8 = load i32* %arrayidx, align 4
  %shr = lshr i32 %8, 6
  %and = and i32 %shr, 255
  %9 = load %struct.expdesc** %e.addr, align 8
  %u2 = getelementptr inbounds %struct.expdesc* %9, i32 0, i32 1
  %info3 = bitcast %union.anon.7* %u2 to i32*
  store i32 %and, i32* %info3, align 4
  br label %if.end21

if.else:                                          ; preds = %entry
  %10 = load %struct.expdesc** %e.addr, align 8
  %k4 = getelementptr inbounds %struct.expdesc* %10, i32 0, i32 0
  %11 = load i32* %k4, align 4
  %cmp5 = icmp eq i32 %11, 13
  br i1 %cmp5, label %if.then6, label %if.end

if.then6:                                         ; preds = %if.else
  %12 = load %struct.expdesc** %e.addr, align 8
  %u7 = getelementptr inbounds %struct.expdesc* %12, i32 0, i32 1
  %info8 = bitcast %union.anon.7* %u7 to i32*
  %13 = load i32* %info8, align 4
  %idxprom9 = sext i32 %13 to i64
  %14 = load %struct.FuncState** %fs.addr, align 8
  %f10 = getelementptr inbounds %struct.FuncState* %14, i32 0, i32 0
  %15 = load %struct.Proto.36** %f10, align 8
  %code11 = getelementptr inbounds %struct.Proto.36* %15, i32 0, i32 4
  %16 = load i32** %code11, align 8
  %arrayidx12 = getelementptr inbounds i32* %16, i64 %idxprom9
  %17 = load i32* %arrayidx12, align 4
  %and13 = and i32 %17, 8388607
  %or = or i32 %and13, 16777216
  %18 = load %struct.expdesc** %e.addr, align 8
  %u14 = getelementptr inbounds %struct.expdesc* %18, i32 0, i32 1
  %info15 = bitcast %union.anon.7* %u14 to i32*
  %19 = load i32* %info15, align 4
  %idxprom16 = sext i32 %19 to i64
  %20 = load %struct.FuncState** %fs.addr, align 8
  %f17 = getelementptr inbounds %struct.FuncState* %20, i32 0, i32 0
  %21 = load %struct.Proto.36** %f17, align 8
  %code18 = getelementptr inbounds %struct.Proto.36* %21, i32 0, i32 4
  %22 = load i32** %code18, align 8
  %arrayidx19 = getelementptr inbounds i32* %22, i64 %idxprom16
  store i32 %or, i32* %arrayidx19, align 4
  %23 = load %struct.expdesc** %e.addr, align 8
  %k20 = getelementptr inbounds %struct.expdesc* %23, i32 0, i32 0
  store i32 11, i32* %k20, align 4
  br label %if.end

if.end:                                           ; preds = %if.then6, %if.else
  br label %if.end21

if.end21:                                         ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @luaK_dischargevars(%struct.FuncState* %fs, %struct.expdesc* %e) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %e.addr = alloca %struct.expdesc*, align 8
  %op = alloca i32, align 4
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store %struct.expdesc* %e, %struct.expdesc** %e.addr, align 8
  %0 = load %struct.expdesc** %e.addr, align 8
  %k = getelementptr inbounds %struct.expdesc* %0, i32 0, i32 0
  %1 = load i32* %k, align 4
  switch i32 %1, label %sw.default [
    i32 7, label %sw.bb
    i32 8, label %sw.bb2
    i32 9, label %sw.bb6
    i32 13, label %sw.bb27
    i32 12, label %sw.bb27
  ]

sw.bb:                                            ; preds = %entry
  %2 = load %struct.expdesc** %e.addr, align 8
  %k1 = getelementptr inbounds %struct.expdesc* %2, i32 0, i32 0
  store i32 6, i32* %k1, align 4
  br label %sw.epilog

sw.bb2:                                           ; preds = %entry
  %3 = load %struct.FuncState** %fs.addr, align 8
  %4 = load %struct.expdesc** %e.addr, align 8
  %u = getelementptr inbounds %struct.expdesc* %4, i32 0, i32 1
  %info = bitcast %union.anon.7* %u to i32*
  %5 = load i32* %info, align 4
  %call = call i32 @luaK_codeABC(%struct.FuncState* %3, i32 5, i32 0, i32 %5, i32 0)
  %6 = load %struct.expdesc** %e.addr, align 8
  %u3 = getelementptr inbounds %struct.expdesc* %6, i32 0, i32 1
  %info4 = bitcast %union.anon.7* %u3 to i32*
  store i32 %call, i32* %info4, align 4
  %7 = load %struct.expdesc** %e.addr, align 8
  %k5 = getelementptr inbounds %struct.expdesc* %7, i32 0, i32 0
  store i32 11, i32* %k5, align 4
  br label %sw.epilog

sw.bb6:                                           ; preds = %entry
  store i32 6, i32* %op, align 4
  %8 = load %struct.FuncState** %fs.addr, align 8
  %9 = load %struct.expdesc** %e.addr, align 8
  %u7 = getelementptr inbounds %struct.expdesc* %9, i32 0, i32 1
  %ind = bitcast %union.anon.7* %u7 to %struct.anon.8*
  %idx = getelementptr inbounds %struct.anon.8* %ind, i32 0, i32 0
  %10 = load i16* %idx, align 2
  %conv = sext i16 %10 to i32
  call void @freereg(%struct.FuncState* %8, i32 %conv)
  %11 = load %struct.expdesc** %e.addr, align 8
  %u8 = getelementptr inbounds %struct.expdesc* %11, i32 0, i32 1
  %ind9 = bitcast %union.anon.7* %u8 to %struct.anon.8*
  %vt = getelementptr inbounds %struct.anon.8* %ind9, i32 0, i32 2
  %12 = load i8* %vt, align 1
  %conv10 = zext i8 %12 to i32
  %cmp = icmp eq i32 %conv10, 7
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb6
  %13 = load %struct.FuncState** %fs.addr, align 8
  %14 = load %struct.expdesc** %e.addr, align 8
  %u12 = getelementptr inbounds %struct.expdesc* %14, i32 0, i32 1
  %ind13 = bitcast %union.anon.7* %u12 to %struct.anon.8*
  %t = getelementptr inbounds %struct.anon.8* %ind13, i32 0, i32 1
  %15 = load i8* %t, align 1
  %conv14 = zext i8 %15 to i32
  call void @freereg(%struct.FuncState* %13, i32 %conv14)
  store i32 7, i32* %op, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %sw.bb6
  %16 = load %struct.FuncState** %fs.addr, align 8
  %17 = load i32* %op, align 4
  %18 = load %struct.expdesc** %e.addr, align 8
  %u15 = getelementptr inbounds %struct.expdesc* %18, i32 0, i32 1
  %ind16 = bitcast %union.anon.7* %u15 to %struct.anon.8*
  %t17 = getelementptr inbounds %struct.anon.8* %ind16, i32 0, i32 1
  %19 = load i8* %t17, align 1
  %conv18 = zext i8 %19 to i32
  %20 = load %struct.expdesc** %e.addr, align 8
  %u19 = getelementptr inbounds %struct.expdesc* %20, i32 0, i32 1
  %ind20 = bitcast %union.anon.7* %u19 to %struct.anon.8*
  %idx21 = getelementptr inbounds %struct.anon.8* %ind20, i32 0, i32 0
  %21 = load i16* %idx21, align 2
  %conv22 = sext i16 %21 to i32
  %call23 = call i32 @luaK_codeABC(%struct.FuncState* %16, i32 %17, i32 0, i32 %conv18, i32 %conv22)
  %22 = load %struct.expdesc** %e.addr, align 8
  %u24 = getelementptr inbounds %struct.expdesc* %22, i32 0, i32 1
  %info25 = bitcast %union.anon.7* %u24 to i32*
  store i32 %call23, i32* %info25, align 4
  %23 = load %struct.expdesc** %e.addr, align 8
  %k26 = getelementptr inbounds %struct.expdesc* %23, i32 0, i32 0
  store i32 11, i32* %k26, align 4
  br label %sw.epilog

sw.bb27:                                          ; preds = %entry, %entry
  %24 = load %struct.FuncState** %fs.addr, align 8
  %25 = load %struct.expdesc** %e.addr, align 8
  call void @luaK_setoneret(%struct.FuncState* %24, %struct.expdesc* %25)
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb27, %if.end, %sw.bb2, %sw.bb
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @luaK_exp2nextreg(%struct.FuncState* %fs, %struct.expdesc* %e) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %e.addr = alloca %struct.expdesc*, align 8
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store %struct.expdesc* %e, %struct.expdesc** %e.addr, align 8
  %0 = load %struct.FuncState** %fs.addr, align 8
  %1 = load %struct.expdesc** %e.addr, align 8
  call void @luaK_dischargevars(%struct.FuncState* %0, %struct.expdesc* %1)
  %2 = load %struct.FuncState** %fs.addr, align 8
  %3 = load %struct.expdesc** %e.addr, align 8
  call void @freeexp(%struct.FuncState* %2, %struct.expdesc* %3)
  %4 = load %struct.FuncState** %fs.addr, align 8
  call void @luaK_reserveregs(%struct.FuncState* %4, i32 1)
  %5 = load %struct.FuncState** %fs.addr, align 8
  %6 = load %struct.expdesc** %e.addr, align 8
  %7 = load %struct.FuncState** %fs.addr, align 8
  %freereg = getelementptr inbounds %struct.FuncState* %7, i32 0, i32 14
  %8 = load i8* %freereg, align 1
  %conv = zext i8 %8 to i32
  %sub = sub nsw i32 %conv, 1
  call void @exp2reg(%struct.FuncState* %5, %struct.expdesc* %6, i32 %sub)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden i32 @luaK_exp2anyreg(%struct.FuncState* %fs, %struct.expdesc* %e) #0 {
entry:
  %retval = alloca i32, align 4
  %fs.addr = alloca %struct.FuncState*, align 8
  %e.addr = alloca %struct.expdesc*, align 8
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store %struct.expdesc* %e, %struct.expdesc** %e.addr, align 8
  %0 = load %struct.FuncState** %fs.addr, align 8
  %1 = load %struct.expdesc** %e.addr, align 8
  call void @luaK_dischargevars(%struct.FuncState* %0, %struct.expdesc* %1)
  %2 = load %struct.expdesc** %e.addr, align 8
  %k = getelementptr inbounds %struct.expdesc* %2, i32 0, i32 0
  %3 = load i32* %k, align 4
  %cmp = icmp eq i32 %3, 6
  br i1 %cmp, label %if.then, label %if.end13

if.then:                                          ; preds = %entry
  %4 = load %struct.expdesc** %e.addr, align 8
  %t = getelementptr inbounds %struct.expdesc* %4, i32 0, i32 2
  %5 = load i32* %t, align 4
  %6 = load %struct.expdesc** %e.addr, align 8
  %f = getelementptr inbounds %struct.expdesc* %6, i32 0, i32 3
  %7 = load i32* %f, align 4
  %cmp1 = icmp ne i32 %5, %7
  br i1 %cmp1, label %if.end, label %if.then2

if.then2:                                         ; preds = %if.then
  %8 = load %struct.expdesc** %e.addr, align 8
  %u = getelementptr inbounds %struct.expdesc* %8, i32 0, i32 1
  %info = bitcast %union.anon.7* %u to i32*
  %9 = load i32* %info, align 4
  store i32 %9, i32* %retval
  br label %return

if.end:                                           ; preds = %if.then
  %10 = load %struct.expdesc** %e.addr, align 8
  %u3 = getelementptr inbounds %struct.expdesc* %10, i32 0, i32 1
  %info4 = bitcast %union.anon.7* %u3 to i32*
  %11 = load i32* %info4, align 4
  %12 = load %struct.FuncState** %fs.addr, align 8
  %nactvar = getelementptr inbounds %struct.FuncState* %12, i32 0, i32 12
  %13 = load i8* %nactvar, align 1
  %conv = zext i8 %13 to i32
  %cmp5 = icmp sge i32 %11, %conv
  br i1 %cmp5, label %if.then7, label %if.end12

if.then7:                                         ; preds = %if.end
  %14 = load %struct.FuncState** %fs.addr, align 8
  %15 = load %struct.expdesc** %e.addr, align 8
  %16 = load %struct.expdesc** %e.addr, align 8
  %u8 = getelementptr inbounds %struct.expdesc* %16, i32 0, i32 1
  %info9 = bitcast %union.anon.7* %u8 to i32*
  %17 = load i32* %info9, align 4
  call void @exp2reg(%struct.FuncState* %14, %struct.expdesc* %15, i32 %17)
  %18 = load %struct.expdesc** %e.addr, align 8
  %u10 = getelementptr inbounds %struct.expdesc* %18, i32 0, i32 1
  %info11 = bitcast %union.anon.7* %u10 to i32*
  %19 = load i32* %info11, align 4
  store i32 %19, i32* %retval
  br label %return

if.end12:                                         ; preds = %if.end
  br label %if.end13

if.end13:                                         ; preds = %if.end12, %entry
  %20 = load %struct.FuncState** %fs.addr, align 8
  %21 = load %struct.expdesc** %e.addr, align 8
  call void @luaK_exp2nextreg(%struct.FuncState* %20, %struct.expdesc* %21)
  %22 = load %struct.expdesc** %e.addr, align 8
  %u14 = getelementptr inbounds %struct.expdesc* %22, i32 0, i32 1
  %info15 = bitcast %union.anon.7* %u14 to i32*
  %23 = load i32* %info15, align 4
  store i32 %23, i32* %retval
  br label %return

return:                                           ; preds = %if.end13, %if.then7, %if.then2
  %24 = load i32* %retval
  ret i32 %24
}

; Function Attrs: nounwind uwtable
define hidden void @luaK_exp2anyregup(%struct.FuncState* %fs, %struct.expdesc* %e) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %e.addr = alloca %struct.expdesc*, align 8
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store %struct.expdesc* %e, %struct.expdesc** %e.addr, align 8
  %0 = load %struct.expdesc** %e.addr, align 8
  %k = getelementptr inbounds %struct.expdesc* %0, i32 0, i32 0
  %1 = load i32* %k, align 4
  %cmp = icmp ne i32 %1, 8
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load %struct.expdesc** %e.addr, align 8
  %t = getelementptr inbounds %struct.expdesc* %2, i32 0, i32 2
  %3 = load i32* %t, align 4
  %4 = load %struct.expdesc** %e.addr, align 8
  %f = getelementptr inbounds %struct.expdesc* %4, i32 0, i32 3
  %5 = load i32* %f, align 4
  %cmp1 = icmp ne i32 %3, %5
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %6 = load %struct.FuncState** %fs.addr, align 8
  %7 = load %struct.expdesc** %e.addr, align 8
  %call = call i32 @luaK_exp2anyreg(%struct.FuncState* %6, %struct.expdesc* %7)
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @luaK_exp2val(%struct.FuncState* %fs, %struct.expdesc* %e) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %e.addr = alloca %struct.expdesc*, align 8
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store %struct.expdesc* %e, %struct.expdesc** %e.addr, align 8
  %0 = load %struct.expdesc** %e.addr, align 8
  %t = getelementptr inbounds %struct.expdesc* %0, i32 0, i32 2
  %1 = load i32* %t, align 4
  %2 = load %struct.expdesc** %e.addr, align 8
  %f = getelementptr inbounds %struct.expdesc* %2, i32 0, i32 3
  %3 = load i32* %f, align 4
  %cmp = icmp ne i32 %1, %3
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %4 = load %struct.FuncState** %fs.addr, align 8
  %5 = load %struct.expdesc** %e.addr, align 8
  %call = call i32 @luaK_exp2anyreg(%struct.FuncState* %4, %struct.expdesc* %5)
  br label %if.end

if.else:                                          ; preds = %entry
  %6 = load %struct.FuncState** %fs.addr, align 8
  %7 = load %struct.expdesc** %e.addr, align 8
  call void @luaK_dischargevars(%struct.FuncState* %6, %struct.expdesc* %7)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define hidden i32 @luaK_exp2RK(%struct.FuncState* %fs, %struct.expdesc* %e) #0 {
entry:
  %retval = alloca i32, align 4
  %fs.addr = alloca %struct.FuncState*, align 8
  %e.addr = alloca %struct.expdesc*, align 8
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store %struct.expdesc* %e, %struct.expdesc** %e.addr, align 8
  %0 = load %struct.FuncState** %fs.addr, align 8
  %1 = load %struct.expdesc** %e.addr, align 8
  call void @luaK_exp2val(%struct.FuncState* %0, %struct.expdesc* %1)
  %2 = load %struct.expdesc** %e.addr, align 8
  %k = getelementptr inbounds %struct.expdesc* %2, i32 0, i32 0
  %3 = load i32* %k, align 4
  switch i32 %3, label %sw.default [
    i32 2, label %sw.bb
    i32 3, label %sw.bb
    i32 1, label %sw.bb
    i32 5, label %sw.bb9
    i32 4, label %sw.bb15
  ]

sw.bb:                                            ; preds = %entry, %entry, %entry
  %4 = load %struct.FuncState** %fs.addr, align 8
  %nk = getelementptr inbounds %struct.FuncState* %4, i32 0, i32 8
  %5 = load i32* %nk, align 4
  %cmp = icmp sle i32 %5, 255
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb
  %6 = load %struct.expdesc** %e.addr, align 8
  %k1 = getelementptr inbounds %struct.expdesc* %6, i32 0, i32 0
  %7 = load i32* %k1, align 4
  %cmp2 = icmp eq i32 %7, 1
  br i1 %cmp2, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  %8 = load %struct.FuncState** %fs.addr, align 8
  %call = call i32 @nilK(%struct.FuncState* %8)
  br label %cond.end

cond.false:                                       ; preds = %if.then
  %9 = load %struct.FuncState** %fs.addr, align 8
  %10 = load %struct.expdesc** %e.addr, align 8
  %k3 = getelementptr inbounds %struct.expdesc* %10, i32 0, i32 0
  %11 = load i32* %k3, align 4
  %cmp4 = icmp eq i32 %11, 2
  %conv = zext i1 %cmp4 to i32
  %call5 = call i32 @boolK(%struct.FuncState* %9, i32 %conv)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %call, %cond.true ], [ %call5, %cond.false ]
  %12 = load %struct.expdesc** %e.addr, align 8
  %u = getelementptr inbounds %struct.expdesc* %12, i32 0, i32 1
  %info = bitcast %union.anon.7* %u to i32*
  store i32 %cond, i32* %info, align 4
  %13 = load %struct.expdesc** %e.addr, align 8
  %k6 = getelementptr inbounds %struct.expdesc* %13, i32 0, i32 0
  store i32 4, i32* %k6, align 4
  %14 = load %struct.expdesc** %e.addr, align 8
  %u7 = getelementptr inbounds %struct.expdesc* %14, i32 0, i32 1
  %info8 = bitcast %union.anon.7* %u7 to i32*
  %15 = load i32* %info8, align 4
  %or = or i32 %15, 256
  store i32 %or, i32* %retval
  br label %return

if.else:                                          ; preds = %sw.bb
  br label %sw.epilog

sw.bb9:                                           ; preds = %entry
  %16 = load %struct.FuncState** %fs.addr, align 8
  %17 = load %struct.expdesc** %e.addr, align 8
  %u10 = getelementptr inbounds %struct.expdesc* %17, i32 0, i32 1
  %nval = bitcast %union.anon.7* %u10 to double*
  %18 = load double* %nval, align 8
  %call11 = call i32 @luaK_numberK(%struct.FuncState* %16, double %18)
  %19 = load %struct.expdesc** %e.addr, align 8
  %u12 = getelementptr inbounds %struct.expdesc* %19, i32 0, i32 1
  %info13 = bitcast %union.anon.7* %u12 to i32*
  store i32 %call11, i32* %info13, align 4
  %20 = load %struct.expdesc** %e.addr, align 8
  %k14 = getelementptr inbounds %struct.expdesc* %20, i32 0, i32 0
  store i32 4, i32* %k14, align 4
  br label %sw.bb15

sw.bb15:                                          ; preds = %sw.bb9, %entry
  %21 = load %struct.expdesc** %e.addr, align 8
  %u16 = getelementptr inbounds %struct.expdesc* %21, i32 0, i32 1
  %info17 = bitcast %union.anon.7* %u16 to i32*
  %22 = load i32* %info17, align 4
  %cmp18 = icmp sle i32 %22, 255
  br i1 %cmp18, label %if.then20, label %if.else24

if.then20:                                        ; preds = %sw.bb15
  %23 = load %struct.expdesc** %e.addr, align 8
  %u21 = getelementptr inbounds %struct.expdesc* %23, i32 0, i32 1
  %info22 = bitcast %union.anon.7* %u21 to i32*
  %24 = load i32* %info22, align 4
  %or23 = or i32 %24, 256
  store i32 %or23, i32* %retval
  br label %return

if.else24:                                        ; preds = %sw.bb15
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.else24, %if.else
  %25 = load %struct.FuncState** %fs.addr, align 8
  %26 = load %struct.expdesc** %e.addr, align 8
  %call25 = call i32 @luaK_exp2anyreg(%struct.FuncState* %25, %struct.expdesc* %26)
  store i32 %call25, i32* %retval
  br label %return

return:                                           ; preds = %sw.epilog, %if.then20, %cond.end
  %27 = load i32* %retval
  ret i32 %27
}

; Function Attrs: nounwind uwtable
define hidden void @luaK_storevar(%struct.FuncState* %fs, %struct.expdesc* %var, %struct.expdesc* %ex) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %var.addr = alloca %struct.expdesc*, align 8
  %ex.addr = alloca %struct.expdesc*, align 8
  %e = alloca i32, align 4
  %op = alloca i32, align 4
  %e8 = alloca i32, align 4
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store %struct.expdesc* %var, %struct.expdesc** %var.addr, align 8
  store %struct.expdesc* %ex, %struct.expdesc** %ex.addr, align 8
  %0 = load %struct.expdesc** %var.addr, align 8
  %k = getelementptr inbounds %struct.expdesc* %0, i32 0, i32 0
  %1 = load i32* %k, align 4
  switch i32 %1, label %sw.default [
    i32 7, label %sw.bb
    i32 8, label %sw.bb1
    i32 9, label %sw.bb5
  ]

sw.bb:                                            ; preds = %entry
  %2 = load %struct.FuncState** %fs.addr, align 8
  %3 = load %struct.expdesc** %ex.addr, align 8
  call void @freeexp(%struct.FuncState* %2, %struct.expdesc* %3)
  %4 = load %struct.FuncState** %fs.addr, align 8
  %5 = load %struct.expdesc** %ex.addr, align 8
  %6 = load %struct.expdesc** %var.addr, align 8
  %u = getelementptr inbounds %struct.expdesc* %6, i32 0, i32 1
  %info = bitcast %union.anon.7* %u to i32*
  %7 = load i32* %info, align 4
  call void @exp2reg(%struct.FuncState* %4, %struct.expdesc* %5, i32 %7)
  br label %return

sw.bb1:                                           ; preds = %entry
  %8 = load %struct.FuncState** %fs.addr, align 8
  %9 = load %struct.expdesc** %ex.addr, align 8
  %call = call i32 @luaK_exp2anyreg(%struct.FuncState* %8, %struct.expdesc* %9)
  store i32 %call, i32* %e, align 4
  %10 = load %struct.FuncState** %fs.addr, align 8
  %11 = load i32* %e, align 4
  %12 = load %struct.expdesc** %var.addr, align 8
  %u2 = getelementptr inbounds %struct.expdesc* %12, i32 0, i32 1
  %info3 = bitcast %union.anon.7* %u2 to i32*
  %13 = load i32* %info3, align 4
  %call4 = call i32 @luaK_codeABC(%struct.FuncState* %10, i32 9, i32 %11, i32 %13, i32 0)
  br label %sw.epilog

sw.bb5:                                           ; preds = %entry
  %14 = load %struct.expdesc** %var.addr, align 8
  %u6 = getelementptr inbounds %struct.expdesc* %14, i32 0, i32 1
  %ind = bitcast %union.anon.7* %u6 to %struct.anon.8*
  %vt = getelementptr inbounds %struct.anon.8* %ind, i32 0, i32 2
  %15 = load i8* %vt, align 1
  %conv = zext i8 %15 to i32
  %cmp = icmp eq i32 %conv, 7
  %cond = select i1 %cmp, i32 10, i32 8
  store i32 %cond, i32* %op, align 4
  %16 = load %struct.FuncState** %fs.addr, align 8
  %17 = load %struct.expdesc** %ex.addr, align 8
  %call9 = call i32 @luaK_exp2RK(%struct.FuncState* %16, %struct.expdesc* %17)
  store i32 %call9, i32* %e8, align 4
  %18 = load %struct.FuncState** %fs.addr, align 8
  %19 = load i32* %op, align 4
  %20 = load %struct.expdesc** %var.addr, align 8
  %u10 = getelementptr inbounds %struct.expdesc* %20, i32 0, i32 1
  %ind11 = bitcast %union.anon.7* %u10 to %struct.anon.8*
  %t = getelementptr inbounds %struct.anon.8* %ind11, i32 0, i32 1
  %21 = load i8* %t, align 1
  %conv12 = zext i8 %21 to i32
  %22 = load %struct.expdesc** %var.addr, align 8
  %u13 = getelementptr inbounds %struct.expdesc* %22, i32 0, i32 1
  %ind14 = bitcast %union.anon.7* %u13 to %struct.anon.8*
  %idx = getelementptr inbounds %struct.anon.8* %ind14, i32 0, i32 0
  %23 = load i16* %idx, align 2
  %conv15 = sext i16 %23 to i32
  %24 = load i32* %e8, align 4
  %call16 = call i32 @luaK_codeABC(%struct.FuncState* %18, i32 %19, i32 %conv12, i32 %conv15, i32 %24)
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb5, %sw.bb1
  %25 = load %struct.FuncState** %fs.addr, align 8
  %26 = load %struct.expdesc** %ex.addr, align 8
  call void @freeexp(%struct.FuncState* %25, %struct.expdesc* %26)
  br label %return

return:                                           ; preds = %sw.epilog, %sw.bb
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @luaK_self(%struct.FuncState* %fs, %struct.expdesc* %e, %struct.expdesc* %key) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %e.addr = alloca %struct.expdesc*, align 8
  %key.addr = alloca %struct.expdesc*, align 8
  %ereg = alloca i32, align 4
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store %struct.expdesc* %e, %struct.expdesc** %e.addr, align 8
  store %struct.expdesc* %key, %struct.expdesc** %key.addr, align 8
  %0 = load %struct.FuncState** %fs.addr, align 8
  %1 = load %struct.expdesc** %e.addr, align 8
  %call = call i32 @luaK_exp2anyreg(%struct.FuncState* %0, %struct.expdesc* %1)
  %2 = load %struct.expdesc** %e.addr, align 8
  %u = getelementptr inbounds %struct.expdesc* %2, i32 0, i32 1
  %info = bitcast %union.anon.7* %u to i32*
  %3 = load i32* %info, align 4
  store i32 %3, i32* %ereg, align 4
  %4 = load %struct.FuncState** %fs.addr, align 8
  %5 = load %struct.expdesc** %e.addr, align 8
  call void @freeexp(%struct.FuncState* %4, %struct.expdesc* %5)
  %6 = load %struct.FuncState** %fs.addr, align 8
  %freereg = getelementptr inbounds %struct.FuncState* %6, i32 0, i32 14
  %7 = load i8* %freereg, align 1
  %conv = zext i8 %7 to i32
  %8 = load %struct.expdesc** %e.addr, align 8
  %u1 = getelementptr inbounds %struct.expdesc* %8, i32 0, i32 1
  %info2 = bitcast %union.anon.7* %u1 to i32*
  store i32 %conv, i32* %info2, align 4
  %9 = load %struct.expdesc** %e.addr, align 8
  %k = getelementptr inbounds %struct.expdesc* %9, i32 0, i32 0
  store i32 6, i32* %k, align 4
  %10 = load %struct.FuncState** %fs.addr, align 8
  call void @luaK_reserveregs(%struct.FuncState* %10, i32 2)
  %11 = load %struct.FuncState** %fs.addr, align 8
  %12 = load %struct.expdesc** %e.addr, align 8
  %u3 = getelementptr inbounds %struct.expdesc* %12, i32 0, i32 1
  %info4 = bitcast %union.anon.7* %u3 to i32*
  %13 = load i32* %info4, align 4
  %14 = load i32* %ereg, align 4
  %15 = load %struct.FuncState** %fs.addr, align 8
  %16 = load %struct.expdesc** %key.addr, align 8
  %call5 = call i32 @luaK_exp2RK(%struct.FuncState* %15, %struct.expdesc* %16)
  %call6 = call i32 @luaK_codeABC(%struct.FuncState* %11, i32 12, i32 %13, i32 %14, i32 %call5)
  %17 = load %struct.FuncState** %fs.addr, align 8
  %18 = load %struct.expdesc** %key.addr, align 8
  call void @freeexp(%struct.FuncState* %17, %struct.expdesc* %18)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @luaK_goiftrue(%struct.FuncState* %fs, %struct.expdesc* %e) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %e.addr = alloca %struct.expdesc*, align 8
  %pc = alloca i32, align 4
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store %struct.expdesc* %e, %struct.expdesc** %e.addr, align 8
  %0 = load %struct.FuncState** %fs.addr, align 8
  %1 = load %struct.expdesc** %e.addr, align 8
  call void @luaK_dischargevars(%struct.FuncState* %0, %struct.expdesc* %1)
  %2 = load %struct.expdesc** %e.addr, align 8
  %k = getelementptr inbounds %struct.expdesc* %2, i32 0, i32 0
  %3 = load i32* %k, align 4
  switch i32 %3, label %sw.default [
    i32 10, label %sw.bb
    i32 4, label %sw.bb1
    i32 5, label %sw.bb1
    i32 2, label %sw.bb1
  ]

sw.bb:                                            ; preds = %entry
  %4 = load %struct.FuncState** %fs.addr, align 8
  %5 = load %struct.expdesc** %e.addr, align 8
  call void @invertjump(%struct.FuncState* %4, %struct.expdesc* %5)
  %6 = load %struct.expdesc** %e.addr, align 8
  %u = getelementptr inbounds %struct.expdesc* %6, i32 0, i32 1
  %info = bitcast %union.anon.7* %u to i32*
  %7 = load i32* %info, align 4
  store i32 %7, i32* %pc, align 4
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry, %entry, %entry
  store i32 -1, i32* %pc, align 4
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %8 = load %struct.FuncState** %fs.addr, align 8
  %9 = load %struct.expdesc** %e.addr, align 8
  %call = call i32 @jumponcond(%struct.FuncState* %8, %struct.expdesc* %9, i32 0)
  store i32 %call, i32* %pc, align 4
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb1, %sw.bb
  %10 = load %struct.FuncState** %fs.addr, align 8
  %11 = load %struct.expdesc** %e.addr, align 8
  %f = getelementptr inbounds %struct.expdesc* %11, i32 0, i32 3
  %12 = load i32* %pc, align 4
  call void @luaK_concat(%struct.FuncState* %10, i32* %f, i32 %12)
  %13 = load %struct.FuncState** %fs.addr, align 8
  %14 = load %struct.expdesc** %e.addr, align 8
  %t = getelementptr inbounds %struct.expdesc* %14, i32 0, i32 2
  %15 = load i32* %t, align 4
  call void @luaK_patchtohere(%struct.FuncState* %13, i32 %15)
  %16 = load %struct.expdesc** %e.addr, align 8
  %t2 = getelementptr inbounds %struct.expdesc* %16, i32 0, i32 2
  store i32 -1, i32* %t2, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @luaK_goiffalse(%struct.FuncState* %fs, %struct.expdesc* %e) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %e.addr = alloca %struct.expdesc*, align 8
  %pc = alloca i32, align 4
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store %struct.expdesc* %e, %struct.expdesc** %e.addr, align 8
  %0 = load %struct.FuncState** %fs.addr, align 8
  %1 = load %struct.expdesc** %e.addr, align 8
  call void @luaK_dischargevars(%struct.FuncState* %0, %struct.expdesc* %1)
  %2 = load %struct.expdesc** %e.addr, align 8
  %k = getelementptr inbounds %struct.expdesc* %2, i32 0, i32 0
  %3 = load i32* %k, align 4
  switch i32 %3, label %sw.default [
    i32 10, label %sw.bb
    i32 1, label %sw.bb1
    i32 3, label %sw.bb1
  ]

sw.bb:                                            ; preds = %entry
  %4 = load %struct.expdesc** %e.addr, align 8
  %u = getelementptr inbounds %struct.expdesc* %4, i32 0, i32 1
  %info = bitcast %union.anon.7* %u to i32*
  %5 = load i32* %info, align 4
  store i32 %5, i32* %pc, align 4
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry, %entry
  store i32 -1, i32* %pc, align 4
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %6 = load %struct.FuncState** %fs.addr, align 8
  %7 = load %struct.expdesc** %e.addr, align 8
  %call = call i32 @jumponcond(%struct.FuncState* %6, %struct.expdesc* %7, i32 1)
  store i32 %call, i32* %pc, align 4
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb1, %sw.bb
  %8 = load %struct.FuncState** %fs.addr, align 8
  %9 = load %struct.expdesc** %e.addr, align 8
  %t = getelementptr inbounds %struct.expdesc* %9, i32 0, i32 2
  %10 = load i32* %pc, align 4
  call void @luaK_concat(%struct.FuncState* %8, i32* %t, i32 %10)
  %11 = load %struct.FuncState** %fs.addr, align 8
  %12 = load %struct.expdesc** %e.addr, align 8
  %f = getelementptr inbounds %struct.expdesc* %12, i32 0, i32 3
  %13 = load i32* %f, align 4
  call void @luaK_patchtohere(%struct.FuncState* %11, i32 %13)
  %14 = load %struct.expdesc** %e.addr, align 8
  %f2 = getelementptr inbounds %struct.expdesc* %14, i32 0, i32 3
  store i32 -1, i32* %f2, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @luaK_indexed(%struct.FuncState* %fs, %struct.expdesc* %t, %struct.expdesc* %k) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %t.addr = alloca %struct.expdesc*, align 8
  %k.addr = alloca %struct.expdesc*, align 8
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store %struct.expdesc* %t, %struct.expdesc** %t.addr, align 8
  store %struct.expdesc* %k, %struct.expdesc** %k.addr, align 8
  %0 = load %struct.expdesc** %t.addr, align 8
  %u = getelementptr inbounds %struct.expdesc* %0, i32 0, i32 1
  %info = bitcast %union.anon.7* %u to i32*
  %1 = load i32* %info, align 4
  %conv = trunc i32 %1 to i8
  %2 = load %struct.expdesc** %t.addr, align 8
  %u1 = getelementptr inbounds %struct.expdesc* %2, i32 0, i32 1
  %ind = bitcast %union.anon.7* %u1 to %struct.anon.8*
  %t2 = getelementptr inbounds %struct.anon.8* %ind, i32 0, i32 1
  store i8 %conv, i8* %t2, align 1
  %3 = load %struct.FuncState** %fs.addr, align 8
  %4 = load %struct.expdesc** %k.addr, align 8
  %call = call i32 @luaK_exp2RK(%struct.FuncState* %3, %struct.expdesc* %4)
  %conv3 = trunc i32 %call to i16
  %5 = load %struct.expdesc** %t.addr, align 8
  %u4 = getelementptr inbounds %struct.expdesc* %5, i32 0, i32 1
  %ind5 = bitcast %union.anon.7* %u4 to %struct.anon.8*
  %idx = getelementptr inbounds %struct.anon.8* %ind5, i32 0, i32 0
  store i16 %conv3, i16* %idx, align 2
  %6 = load %struct.expdesc** %t.addr, align 8
  %k6 = getelementptr inbounds %struct.expdesc* %6, i32 0, i32 0
  %7 = load i32* %k6, align 4
  %cmp = icmp eq i32 %7, 8
  %cond = select i1 %cmp, i32 8, i32 7
  %conv8 = trunc i32 %cond to i8
  %8 = load %struct.expdesc** %t.addr, align 8
  %u9 = getelementptr inbounds %struct.expdesc* %8, i32 0, i32 1
  %ind10 = bitcast %union.anon.7* %u9 to %struct.anon.8*
  %vt = getelementptr inbounds %struct.anon.8* %ind10, i32 0, i32 2
  store i8 %conv8, i8* %vt, align 1
  %9 = load %struct.expdesc** %t.addr, align 8
  %k11 = getelementptr inbounds %struct.expdesc* %9, i32 0, i32 0
  store i32 9, i32* %k11, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @luaK_prefix(%struct.FuncState* %fs, i32 %op, %struct.expdesc* %e, i32 %line) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %op.addr = alloca i32, align 4
  %e.addr = alloca %struct.expdesc*, align 8
  %line.addr = alloca i32, align 4
  %e2 = alloca %struct.expdesc, align 8
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store i32 %op, i32* %op.addr, align 4
  store %struct.expdesc* %e, %struct.expdesc** %e.addr, align 8
  store i32 %line, i32* %line.addr, align 4
  %f = getelementptr inbounds %struct.expdesc* %e2, i32 0, i32 3
  store i32 -1, i32* %f, align 4
  %t = getelementptr inbounds %struct.expdesc* %e2, i32 0, i32 2
  store i32 -1, i32* %t, align 4
  %k = getelementptr inbounds %struct.expdesc* %e2, i32 0, i32 0
  store i32 5, i32* %k, align 4
  %u = getelementptr inbounds %struct.expdesc* %e2, i32 0, i32 1
  %nval = bitcast %union.anon.7* %u to double*
  store double 0.000000e+00, double* %nval, align 8
  %0 = load i32* %op.addr, align 4
  switch i32 %0, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb6
    i32 2, label %sw.bb7
  ]

sw.bb:                                            ; preds = %entry
  %1 = load %struct.expdesc** %e.addr, align 8
  %call = call i32 @isnumeral(%struct.expdesc* %1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb
  %2 = load %struct.expdesc** %e.addr, align 8
  %u1 = getelementptr inbounds %struct.expdesc* %2, i32 0, i32 1
  %nval2 = bitcast %union.anon.7* %u1 to double*
  %3 = load double* %nval2, align 8
  %sub = fsub double -0.000000e+00, %3
  %4 = load %struct.expdesc** %e.addr, align 8
  %u3 = getelementptr inbounds %struct.expdesc* %4, i32 0, i32 1
  %nval4 = bitcast %union.anon.7* %u3 to double*
  store double %sub, double* %nval4, align 8
  br label %if.end

if.else:                                          ; preds = %sw.bb
  %5 = load %struct.FuncState** %fs.addr, align 8
  %6 = load %struct.expdesc** %e.addr, align 8
  %call5 = call i32 @luaK_exp2anyreg(%struct.FuncState* %5, %struct.expdesc* %6)
  %7 = load %struct.FuncState** %fs.addr, align 8
  %8 = load %struct.expdesc** %e.addr, align 8
  %9 = load i32* %line.addr, align 4
  call void @codearith(%struct.FuncState* %7, i32 19, %struct.expdesc* %8, %struct.expdesc* %e2, i32 %9)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  br label %sw.epilog

sw.bb6:                                           ; preds = %entry
  %10 = load %struct.FuncState** %fs.addr, align 8
  %11 = load %struct.expdesc** %e.addr, align 8
  call void @codenot(%struct.FuncState* %10, %struct.expdesc* %11)
  br label %sw.epilog

sw.bb7:                                           ; preds = %entry
  %12 = load %struct.FuncState** %fs.addr, align 8
  %13 = load %struct.expdesc** %e.addr, align 8
  %call8 = call i32 @luaK_exp2anyreg(%struct.FuncState* %12, %struct.expdesc* %13)
  %14 = load %struct.FuncState** %fs.addr, align 8
  %15 = load %struct.expdesc** %e.addr, align 8
  %16 = load i32* %line.addr, align 4
  call void @codearith(%struct.FuncState* %14, i32 21, %struct.expdesc* %15, %struct.expdesc* %e2, i32 %16)
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb7, %sw.bb6, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @luaK_infix(%struct.FuncState* %fs, i32 %op, %struct.expdesc* %v) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %op.addr = alloca i32, align 4
  %v.addr = alloca %struct.expdesc*, align 8
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store i32 %op, i32* %op.addr, align 4
  store %struct.expdesc* %v, %struct.expdesc** %v.addr, align 8
  %0 = load i32* %op.addr, align 4
  switch i32 %0, label %sw.default [
    i32 13, label %sw.bb
    i32 14, label %sw.bb1
    i32 6, label %sw.bb2
    i32 0, label %sw.bb3
    i32 1, label %sw.bb3
    i32 2, label %sw.bb3
    i32 3, label %sw.bb3
    i32 4, label %sw.bb3
    i32 5, label %sw.bb3
  ]

sw.bb:                                            ; preds = %entry
  %1 = load %struct.FuncState** %fs.addr, align 8
  %2 = load %struct.expdesc** %v.addr, align 8
  call void @luaK_goiftrue(%struct.FuncState* %1, %struct.expdesc* %2)
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  %3 = load %struct.FuncState** %fs.addr, align 8
  %4 = load %struct.expdesc** %v.addr, align 8
  call void @luaK_goiffalse(%struct.FuncState* %3, %struct.expdesc* %4)
  br label %sw.epilog

sw.bb2:                                           ; preds = %entry
  %5 = load %struct.FuncState** %fs.addr, align 8
  %6 = load %struct.expdesc** %v.addr, align 8
  call void @luaK_exp2nextreg(%struct.FuncState* %5, %struct.expdesc* %6)
  br label %sw.epilog

sw.bb3:                                           ; preds = %entry, %entry, %entry, %entry, %entry, %entry
  %7 = load %struct.expdesc** %v.addr, align 8
  %call = call i32 @isnumeral(%struct.expdesc* %7)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %sw.bb3
  %8 = load %struct.FuncState** %fs.addr, align 8
  %9 = load %struct.expdesc** %v.addr, align 8
  %call4 = call i32 @luaK_exp2RK(%struct.FuncState* %8, %struct.expdesc* %9)
  br label %if.end

if.end:                                           ; preds = %if.then, %sw.bb3
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %10 = load %struct.FuncState** %fs.addr, align 8
  %11 = load %struct.expdesc** %v.addr, align 8
  %call5 = call i32 @luaK_exp2RK(%struct.FuncState* %10, %struct.expdesc* %11)
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.end, %sw.bb2, %sw.bb1, %sw.bb
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @luaK_posfix(%struct.FuncState* %fs, i32 %op, %struct.expdesc* %e1, %struct.expdesc* %e2, i32 %line) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %op.addr = alloca i32, align 4
  %e1.addr = alloca %struct.expdesc*, align 8
  %e2.addr = alloca %struct.expdesc*, align 8
  %line.addr = alloca i32, align 4
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store i32 %op, i32* %op.addr, align 4
  store %struct.expdesc* %e1, %struct.expdesc** %e1.addr, align 8
  store %struct.expdesc* %e2, %struct.expdesc** %e2.addr, align 8
  store i32 %line, i32* %line.addr, align 4
  %0 = load i32* %op.addr, align 4
  switch i32 %0, label %sw.default [
    i32 13, label %sw.bb
    i32 14, label %sw.bb2
    i32 6, label %sw.bb4
    i32 0, label %sw.bb28
    i32 1, label %sw.bb28
    i32 2, label %sw.bb28
    i32 3, label %sw.bb28
    i32 4, label %sw.bb28
    i32 5, label %sw.bb28
    i32 7, label %sw.bb29
    i32 8, label %sw.bb29
    i32 9, label %sw.bb29
    i32 10, label %sw.bb32
    i32 11, label %sw.bb32
    i32 12, label %sw.bb32
  ]

sw.bb:                                            ; preds = %entry
  %1 = load %struct.FuncState** %fs.addr, align 8
  %2 = load %struct.expdesc** %e2.addr, align 8
  call void @luaK_dischargevars(%struct.FuncState* %1, %struct.expdesc* %2)
  %3 = load %struct.FuncState** %fs.addr, align 8
  %4 = load %struct.expdesc** %e2.addr, align 8
  %f = getelementptr inbounds %struct.expdesc* %4, i32 0, i32 3
  %5 = load %struct.expdesc** %e1.addr, align 8
  %f1 = getelementptr inbounds %struct.expdesc* %5, i32 0, i32 3
  %6 = load i32* %f1, align 4
  call void @luaK_concat(%struct.FuncState* %3, i32* %f, i32 %6)
  %7 = load %struct.expdesc** %e1.addr, align 8
  %8 = load %struct.expdesc** %e2.addr, align 8
  %9 = bitcast %struct.expdesc* %7 to i8*
  %10 = bitcast %struct.expdesc* %8 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %9, i8* %10, i64 24, i32 8, i1 false)
  br label %sw.epilog

sw.bb2:                                           ; preds = %entry
  %11 = load %struct.FuncState** %fs.addr, align 8
  %12 = load %struct.expdesc** %e2.addr, align 8
  call void @luaK_dischargevars(%struct.FuncState* %11, %struct.expdesc* %12)
  %13 = load %struct.FuncState** %fs.addr, align 8
  %14 = load %struct.expdesc** %e2.addr, align 8
  %t = getelementptr inbounds %struct.expdesc* %14, i32 0, i32 2
  %15 = load %struct.expdesc** %e1.addr, align 8
  %t3 = getelementptr inbounds %struct.expdesc* %15, i32 0, i32 2
  %16 = load i32* %t3, align 4
  call void @luaK_concat(%struct.FuncState* %13, i32* %t, i32 %16)
  %17 = load %struct.expdesc** %e1.addr, align 8
  %18 = load %struct.expdesc** %e2.addr, align 8
  %19 = bitcast %struct.expdesc* %17 to i8*
  %20 = bitcast %struct.expdesc* %18 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %19, i8* %20, i64 24, i32 8, i1 false)
  br label %sw.epilog

sw.bb4:                                           ; preds = %entry
  %21 = load %struct.FuncState** %fs.addr, align 8
  %22 = load %struct.expdesc** %e2.addr, align 8
  call void @luaK_exp2val(%struct.FuncState* %21, %struct.expdesc* %22)
  %23 = load %struct.expdesc** %e2.addr, align 8
  %k = getelementptr inbounds %struct.expdesc* %23, i32 0, i32 0
  %24 = load i32* %k, align 4
  %cmp = icmp eq i32 %24, 11
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %sw.bb4
  %25 = load %struct.expdesc** %e2.addr, align 8
  %u = getelementptr inbounds %struct.expdesc* %25, i32 0, i32 1
  %info = bitcast %union.anon.7* %u to i32*
  %26 = load i32* %info, align 4
  %idxprom = sext i32 %26 to i64
  %27 = load %struct.FuncState** %fs.addr, align 8
  %f5 = getelementptr inbounds %struct.FuncState* %27, i32 0, i32 0
  %28 = load %struct.Proto.36** %f5, align 8
  %code = getelementptr inbounds %struct.Proto.36* %28, i32 0, i32 4
  %29 = load i32** %code, align 8
  %arrayidx = getelementptr inbounds i32* %29, i64 %idxprom
  %30 = load i32* %arrayidx, align 4
  %shr = lshr i32 %30, 0
  %and = and i32 %shr, 63
  %cmp6 = icmp eq i32 %and, 22
  br i1 %cmp6, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %31 = load %struct.FuncState** %fs.addr, align 8
  %32 = load %struct.expdesc** %e1.addr, align 8
  call void @freeexp(%struct.FuncState* %31, %struct.expdesc* %32)
  %33 = load %struct.expdesc** %e2.addr, align 8
  %u7 = getelementptr inbounds %struct.expdesc* %33, i32 0, i32 1
  %info8 = bitcast %union.anon.7* %u7 to i32*
  %34 = load i32* %info8, align 4
  %idxprom9 = sext i32 %34 to i64
  %35 = load %struct.FuncState** %fs.addr, align 8
  %f10 = getelementptr inbounds %struct.FuncState* %35, i32 0, i32 0
  %36 = load %struct.Proto.36** %f10, align 8
  %code11 = getelementptr inbounds %struct.Proto.36* %36, i32 0, i32 4
  %37 = load i32** %code11, align 8
  %arrayidx12 = getelementptr inbounds i32* %37, i64 %idxprom9
  %38 = load i32* %arrayidx12, align 4
  %and13 = and i32 %38, 8388607
  %39 = load %struct.expdesc** %e1.addr, align 8
  %u14 = getelementptr inbounds %struct.expdesc* %39, i32 0, i32 1
  %info15 = bitcast %union.anon.7* %u14 to i32*
  %40 = load i32* %info15, align 4
  %shl = shl i32 %40, 23
  %and16 = and i32 %shl, -8388608
  %or = or i32 %and13, %and16
  %41 = load %struct.expdesc** %e2.addr, align 8
  %u17 = getelementptr inbounds %struct.expdesc* %41, i32 0, i32 1
  %info18 = bitcast %union.anon.7* %u17 to i32*
  %42 = load i32* %info18, align 4
  %idxprom19 = sext i32 %42 to i64
  %43 = load %struct.FuncState** %fs.addr, align 8
  %f20 = getelementptr inbounds %struct.FuncState* %43, i32 0, i32 0
  %44 = load %struct.Proto.36** %f20, align 8
  %code21 = getelementptr inbounds %struct.Proto.36* %44, i32 0, i32 4
  %45 = load i32** %code21, align 8
  %arrayidx22 = getelementptr inbounds i32* %45, i64 %idxprom19
  store i32 %or, i32* %arrayidx22, align 4
  %46 = load %struct.expdesc** %e1.addr, align 8
  %k23 = getelementptr inbounds %struct.expdesc* %46, i32 0, i32 0
  store i32 11, i32* %k23, align 4
  %47 = load %struct.expdesc** %e2.addr, align 8
  %u24 = getelementptr inbounds %struct.expdesc* %47, i32 0, i32 1
  %info25 = bitcast %union.anon.7* %u24 to i32*
  %48 = load i32* %info25, align 4
  %49 = load %struct.expdesc** %e1.addr, align 8
  %u26 = getelementptr inbounds %struct.expdesc* %49, i32 0, i32 1
  %info27 = bitcast %union.anon.7* %u26 to i32*
  store i32 %48, i32* %info27, align 4
  br label %if.end

if.else:                                          ; preds = %land.lhs.true, %sw.bb4
  %50 = load %struct.FuncState** %fs.addr, align 8
  %51 = load %struct.expdesc** %e2.addr, align 8
  call void @luaK_exp2nextreg(%struct.FuncState* %50, %struct.expdesc* %51)
  %52 = load %struct.FuncState** %fs.addr, align 8
  %53 = load %struct.expdesc** %e1.addr, align 8
  %54 = load %struct.expdesc** %e2.addr, align 8
  %55 = load i32* %line.addr, align 4
  call void @codearith(%struct.FuncState* %52, i32 22, %struct.expdesc* %53, %struct.expdesc* %54, i32 %55)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  br label %sw.epilog

sw.bb28:                                          ; preds = %entry, %entry, %entry, %entry, %entry, %entry
  %56 = load %struct.FuncState** %fs.addr, align 8
  %57 = load i32* %op.addr, align 4
  %sub = sub i32 %57, 0
  %add = add i32 %sub, 13
  %58 = load %struct.expdesc** %e1.addr, align 8
  %59 = load %struct.expdesc** %e2.addr, align 8
  %60 = load i32* %line.addr, align 4
  call void @codearith(%struct.FuncState* %56, i32 %add, %struct.expdesc* %58, %struct.expdesc* %59, i32 %60)
  br label %sw.epilog

sw.bb29:                                          ; preds = %entry, %entry, %entry
  %61 = load %struct.FuncState** %fs.addr, align 8
  %62 = load i32* %op.addr, align 4
  %sub30 = sub i32 %62, 7
  %add31 = add i32 %sub30, 24
  %63 = load %struct.expdesc** %e1.addr, align 8
  %64 = load %struct.expdesc** %e2.addr, align 8
  call void @codecomp(%struct.FuncState* %61, i32 %add31, i32 1, %struct.expdesc* %63, %struct.expdesc* %64)
  br label %sw.epilog

sw.bb32:                                          ; preds = %entry, %entry, %entry
  %65 = load %struct.FuncState** %fs.addr, align 8
  %66 = load i32* %op.addr, align 4
  %sub33 = sub i32 %66, 10
  %add34 = add i32 %sub33, 24
  %67 = load %struct.expdesc** %e1.addr, align 8
  %68 = load %struct.expdesc** %e2.addr, align 8
  call void @codecomp(%struct.FuncState* %65, i32 %add34, i32 0, %struct.expdesc* %67, %struct.expdesc* %68)
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb32, %sw.bb29, %sw.bb28, %if.end, %sw.bb2, %sw.bb
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @luaK_fixline(%struct.FuncState* %fs, i32 %line) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %line.addr = alloca i32, align 4
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store i32 %line, i32* %line.addr, align 4
  %0 = load i32* %line.addr, align 4
  %1 = load %struct.FuncState** %fs.addr, align 8
  %pc = getelementptr inbounds %struct.FuncState* %1, i32 0, i32 5
  %2 = load i32* %pc, align 4
  %sub = sub nsw i32 %2, 1
  %idxprom = sext i32 %sub to i64
  %3 = load %struct.FuncState** %fs.addr, align 8
  %f = getelementptr inbounds %struct.FuncState* %3, i32 0, i32 0
  %4 = load %struct.Proto.36** %f, align 8
  %lineinfo = getelementptr inbounds %struct.Proto.36* %4, i32 0, i32 6
  %5 = load i32** %lineinfo, align 8
  %arrayidx = getelementptr inbounds i32* %5, i64 %idxprom
  store i32 %0, i32* %arrayidx, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @luaK_setlist(%struct.FuncState* %fs, i32 %base, i32 %nelems, i32 %tostore) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %base.addr = alloca i32, align 4
  %nelems.addr = alloca i32, align 4
  %tostore.addr = alloca i32, align 4
  %c = alloca i32, align 4
  %b = alloca i32, align 4
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store i32 %base, i32* %base.addr, align 4
  store i32 %nelems, i32* %nelems.addr, align 4
  store i32 %tostore, i32* %tostore.addr, align 4
  %0 = load i32* %nelems.addr, align 4
  %sub = sub nsw i32 %0, 1
  %div = sdiv i32 %sub, 50
  %add = add nsw i32 %div, 1
  store i32 %add, i32* %c, align 4
  %1 = load i32* %tostore.addr, align 4
  %cmp = icmp eq i32 %1, -1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %2 = load i32* %tostore.addr, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 0, %cond.true ], [ %2, %cond.false ]
  store i32 %cond, i32* %b, align 4
  %3 = load i32* %c, align 4
  %cmp1 = icmp sle i32 %3, 511
  br i1 %cmp1, label %if.then, label %if.else

if.then:                                          ; preds = %cond.end
  %4 = load %struct.FuncState** %fs.addr, align 8
  %5 = load i32* %base.addr, align 4
  %6 = load i32* %b, align 4
  %7 = load i32* %c, align 4
  %call = call i32 @luaK_codeABC(%struct.FuncState* %4, i32 36, i32 %5, i32 %6, i32 %7)
  br label %if.end7

if.else:                                          ; preds = %cond.end
  %8 = load i32* %c, align 4
  %cmp2 = icmp sle i32 %8, 67108863
  br i1 %cmp2, label %if.then3, label %if.else6

if.then3:                                         ; preds = %if.else
  %9 = load %struct.FuncState** %fs.addr, align 8
  %10 = load i32* %base.addr, align 4
  %11 = load i32* %b, align 4
  %call4 = call i32 @luaK_codeABC(%struct.FuncState* %9, i32 36, i32 %10, i32 %11, i32 0)
  %12 = load %struct.FuncState** %fs.addr, align 8
  %13 = load i32* %c, align 4
  %call5 = call i32 @codeextraarg(%struct.FuncState* %12, i32 %13)
  br label %if.end

if.else6:                                         ; preds = %if.else
  %14 = load %struct.FuncState** %fs.addr, align 8
  %ls = getelementptr inbounds %struct.FuncState* %14, i32 0, i32 3
  %15 = load %struct.LexState** %ls, align 8
  call void bitcast (void (%struct.LexState.235*, i8*)* @luaX_syntaxerror to void (%struct.LexState*, i8*)*)(%struct.LexState* %15, i8* getelementptr inbounds ([21 x i8]* @.str1123, i32 0, i32 0)) #9
  unreachable

if.end:                                           ; preds = %if.then3
  br label %if.end7

if.end7:                                          ; preds = %if.end, %if.then
  %16 = load i32* %base.addr, align 4
  %add8 = add nsw i32 %16, 1
  %conv = trunc i32 %add8 to i8
  %17 = load %struct.FuncState** %fs.addr, align 8
  %freereg = getelementptr inbounds %struct.FuncState* %17, i32 0, i32 14
  store i8 %conv, i8* %freereg, align 1
  ret void
}

; Function Attrs: nounwind readnone
declare i32 @abs(i32) #3

; Function Attrs: nounwind uwtable
define internal i32 @luaK_code(%struct.FuncState* %fs, i32 %i) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %i.addr = alloca i32, align 4
  %f = alloca %struct.Proto.36*, align 8
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store i32 %i, i32* %i.addr, align 4
  %0 = load %struct.FuncState** %fs.addr, align 8
  %f1 = getelementptr inbounds %struct.FuncState* %0, i32 0, i32 0
  %1 = load %struct.Proto.36** %f1, align 8
  store %struct.Proto.36* %1, %struct.Proto.36** %f, align 8
  %2 = load %struct.FuncState** %fs.addr, align 8
  call void @dischargejpc(%struct.FuncState* %2)
  %3 = load %struct.FuncState** %fs.addr, align 8
  %pc = getelementptr inbounds %struct.FuncState* %3, i32 0, i32 5
  %4 = load i32* %pc, align 4
  %add = add nsw i32 %4, 1
  %5 = load %struct.Proto.36** %f, align 8
  %sizecode = getelementptr inbounds %struct.Proto.36* %5, i32 0, i32 13
  %6 = load i32* %sizecode, align 4
  %cmp = icmp sgt i32 %add, %6
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %7 = load %struct.FuncState** %fs.addr, align 8
  %ls = getelementptr inbounds %struct.FuncState* %7, i32 0, i32 3
  %8 = load %struct.LexState** %ls, align 8
  %L = getelementptr inbounds %struct.LexState* %8, i32 0, i32 6
  %9 = load %struct.lua_State.30** %L, align 8
  %10 = load %struct.Proto.36** %f, align 8
  %code = getelementptr inbounds %struct.Proto.36* %10, i32 0, i32 4
  %11 = load i32** %code, align 8
  %12 = bitcast i32* %11 to i8*
  %13 = load %struct.Proto.36** %f, align 8
  %sizecode2 = getelementptr inbounds %struct.Proto.36* %13, i32 0, i32 13
  %call = call i8* bitcast (i8* (%struct.lua_State*, i8*, i32*, i64, i32, i8*)* @luaM_growaux_ to i8* (%struct.lua_State.30*, i8*, i32*, i64, i32, i8*)*)(%struct.lua_State.30* %9, i8* %12, i32* %sizecode2, i64 4, i32 2147483645, i8* getelementptr inbounds ([8 x i8]* @.str3125, i32 0, i32 0))
  %14 = bitcast i8* %call to i32*
  %15 = load %struct.Proto.36** %f, align 8
  %code3 = getelementptr inbounds %struct.Proto.36* %15, i32 0, i32 4
  store i32* %14, i32** %code3, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %16 = load i32* %i.addr, align 4
  %17 = load %struct.FuncState** %fs.addr, align 8
  %pc4 = getelementptr inbounds %struct.FuncState* %17, i32 0, i32 5
  %18 = load i32* %pc4, align 4
  %idxprom = sext i32 %18 to i64
  %19 = load %struct.Proto.36** %f, align 8
  %code5 = getelementptr inbounds %struct.Proto.36* %19, i32 0, i32 4
  %20 = load i32** %code5, align 8
  %arrayidx = getelementptr inbounds i32* %20, i64 %idxprom
  store i32 %16, i32* %arrayidx, align 4
  %21 = load %struct.FuncState** %fs.addr, align 8
  %pc6 = getelementptr inbounds %struct.FuncState* %21, i32 0, i32 5
  %22 = load i32* %pc6, align 4
  %add7 = add nsw i32 %22, 1
  %23 = load %struct.Proto.36** %f, align 8
  %sizelineinfo = getelementptr inbounds %struct.Proto.36* %23, i32 0, i32 14
  %24 = load i32* %sizelineinfo, align 4
  %cmp8 = icmp sgt i32 %add7, %24
  br i1 %cmp8, label %if.then9, label %if.end15

if.then9:                                         ; preds = %if.end
  %25 = load %struct.FuncState** %fs.addr, align 8
  %ls10 = getelementptr inbounds %struct.FuncState* %25, i32 0, i32 3
  %26 = load %struct.LexState** %ls10, align 8
  %L11 = getelementptr inbounds %struct.LexState* %26, i32 0, i32 6
  %27 = load %struct.lua_State.30** %L11, align 8
  %28 = load %struct.Proto.36** %f, align 8
  %lineinfo = getelementptr inbounds %struct.Proto.36* %28, i32 0, i32 6
  %29 = load i32** %lineinfo, align 8
  %30 = bitcast i32* %29 to i8*
  %31 = load %struct.Proto.36** %f, align 8
  %sizelineinfo12 = getelementptr inbounds %struct.Proto.36* %31, i32 0, i32 14
  %call13 = call i8* bitcast (i8* (%struct.lua_State*, i8*, i32*, i64, i32, i8*)* @luaM_growaux_ to i8* (%struct.lua_State.30*, i8*, i32*, i64, i32, i8*)*)(%struct.lua_State.30* %27, i8* %30, i32* %sizelineinfo12, i64 4, i32 2147483645, i8* getelementptr inbounds ([8 x i8]* @.str3125, i32 0, i32 0))
  %32 = bitcast i8* %call13 to i32*
  %33 = load %struct.Proto.36** %f, align 8
  %lineinfo14 = getelementptr inbounds %struct.Proto.36* %33, i32 0, i32 6
  store i32* %32, i32** %lineinfo14, align 8
  br label %if.end15

if.end15:                                         ; preds = %if.then9, %if.end
  %34 = load %struct.FuncState** %fs.addr, align 8
  %ls16 = getelementptr inbounds %struct.FuncState* %34, i32 0, i32 3
  %35 = load %struct.LexState** %ls16, align 8
  %lastline = getelementptr inbounds %struct.LexState* %35, i32 0, i32 2
  %36 = load i32* %lastline, align 4
  %37 = load %struct.FuncState** %fs.addr, align 8
  %pc17 = getelementptr inbounds %struct.FuncState* %37, i32 0, i32 5
  %38 = load i32* %pc17, align 4
  %idxprom18 = sext i32 %38 to i64
  %39 = load %struct.Proto.36** %f, align 8
  %lineinfo19 = getelementptr inbounds %struct.Proto.36* %39, i32 0, i32 6
  %40 = load i32** %lineinfo19, align 8
  %arrayidx20 = getelementptr inbounds i32* %40, i64 %idxprom18
  store i32 %36, i32* %arrayidx20, align 4
  %41 = load %struct.FuncState** %fs.addr, align 8
  %pc21 = getelementptr inbounds %struct.FuncState* %41, i32 0, i32 5
  %42 = load i32* %pc21, align 4
  %inc = add nsw i32 %42, 1
  store i32 %inc, i32* %pc21, align 4
  ret i32 %42
}

; Function Attrs: nounwind uwtable
define internal i32 @getjump(%struct.FuncState* %fs, i32 %pc) #0 {
entry:
  %retval = alloca i32, align 4
  %fs.addr = alloca %struct.FuncState*, align 8
  %pc.addr = alloca i32, align 4
  %offset = alloca i32, align 4
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store i32 %pc, i32* %pc.addr, align 4
  %0 = load i32* %pc.addr, align 4
  %idxprom = sext i32 %0 to i64
  %1 = load %struct.FuncState** %fs.addr, align 8
  %f = getelementptr inbounds %struct.FuncState* %1, i32 0, i32 0
  %2 = load %struct.Proto.36** %f, align 8
  %code = getelementptr inbounds %struct.Proto.36* %2, i32 0, i32 4
  %3 = load i32** %code, align 8
  %arrayidx = getelementptr inbounds i32* %3, i64 %idxprom
  %4 = load i32* %arrayidx, align 4
  %shr = lshr i32 %4, 14
  %and = and i32 %shr, 262143
  %sub = sub nsw i32 %and, 131071
  store i32 %sub, i32* %offset, align 4
  %5 = load i32* %offset, align 4
  %cmp = icmp eq i32 %5, -1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 -1, i32* %retval
  br label %return

if.else:                                          ; preds = %entry
  %6 = load i32* %pc.addr, align 4
  %add = add nsw i32 %6, 1
  %7 = load i32* %offset, align 4
  %add1 = add nsw i32 %add, %7
  store i32 %add1, i32* %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %8 = load i32* %retval
  ret i32 %8
}

; Function Attrs: nounwind uwtable
define internal void @fixjump(%struct.FuncState* %fs, i32 %pc, i32 %dest) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %pc.addr = alloca i32, align 4
  %dest.addr = alloca i32, align 4
  %jmp = alloca i32*, align 8
  %offset = alloca i32, align 4
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store i32 %pc, i32* %pc.addr, align 4
  store i32 %dest, i32* %dest.addr, align 4
  %0 = load i32* %pc.addr, align 4
  %idxprom = sext i32 %0 to i64
  %1 = load %struct.FuncState** %fs.addr, align 8
  %f = getelementptr inbounds %struct.FuncState* %1, i32 0, i32 0
  %2 = load %struct.Proto.36** %f, align 8
  %code = getelementptr inbounds %struct.Proto.36* %2, i32 0, i32 4
  %3 = load i32** %code, align 8
  %arrayidx = getelementptr inbounds i32* %3, i64 %idxprom
  store i32* %arrayidx, i32** %jmp, align 8
  %4 = load i32* %dest.addr, align 4
  %5 = load i32* %pc.addr, align 4
  %add = add nsw i32 %5, 1
  %sub = sub nsw i32 %4, %add
  store i32 %sub, i32* %offset, align 4
  %6 = load i32* %offset, align 4
  %call = call i32 @abs(i32 %6) #11
  %cmp = icmp sgt i32 %call, 131071
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %7 = load %struct.FuncState** %fs.addr, align 8
  %ls = getelementptr inbounds %struct.FuncState* %7, i32 0, i32 3
  %8 = load %struct.LexState** %ls, align 8
  call void bitcast (void (%struct.LexState.235*, i8*)* @luaX_syntaxerror to void (%struct.LexState*, i8*)*)(%struct.LexState* %8, i8* getelementptr inbounds ([27 x i8]* @.str4126, i32 0, i32 0)) #9
  unreachable

if.end:                                           ; preds = %entry
  %9 = load i32** %jmp, align 8
  %10 = load i32* %9, align 4
  %and = and i32 %10, 16383
  %11 = load i32* %offset, align 4
  %add1 = add nsw i32 %11, 131071
  %shl = shl i32 %add1, 14
  %and2 = and i32 %shl, -16384
  %or = or i32 %and, %and2
  %12 = load i32** %jmp, align 8
  store i32 %or, i32* %12, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @patchlistaux(%struct.FuncState* %fs, i32 %list, i32 %vtarget, i32 %reg, i32 %dtarget) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %list.addr = alloca i32, align 4
  %vtarget.addr = alloca i32, align 4
  %reg.addr = alloca i32, align 4
  %dtarget.addr = alloca i32, align 4
  %next = alloca i32, align 4
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store i32 %list, i32* %list.addr, align 4
  store i32 %vtarget, i32* %vtarget.addr, align 4
  store i32 %reg, i32* %reg.addr, align 4
  store i32 %dtarget, i32* %dtarget.addr, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %0 = load i32* %list.addr, align 4
  %cmp = icmp ne i32 %0, -1
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load %struct.FuncState** %fs.addr, align 8
  %2 = load i32* %list.addr, align 4
  %call = call i32 @getjump(%struct.FuncState* %1, i32 %2)
  store i32 %call, i32* %next, align 4
  %3 = load %struct.FuncState** %fs.addr, align 8
  %4 = load i32* %list.addr, align 4
  %5 = load i32* %reg.addr, align 4
  %call1 = call i32 @patchtestreg(%struct.FuncState* %3, i32 %4, i32 %5)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %while.body
  %6 = load %struct.FuncState** %fs.addr, align 8
  %7 = load i32* %list.addr, align 4
  %8 = load i32* %vtarget.addr, align 4
  call void @fixjump(%struct.FuncState* %6, i32 %7, i32 %8)
  br label %if.end

if.else:                                          ; preds = %while.body
  %9 = load %struct.FuncState** %fs.addr, align 8
  %10 = load i32* %list.addr, align 4
  %11 = load i32* %dtarget.addr, align 4
  call void @fixjump(%struct.FuncState* %9, i32 %10, i32 %11)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %12 = load i32* %next, align 4
  store i32 %12, i32* %list.addr, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @codeextraarg(%struct.FuncState* %fs, i32 %a) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %a.addr = alloca i32, align 4
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store i32 %a, i32* %a.addr, align 4
  %0 = load %struct.FuncState** %fs.addr, align 8
  %1 = load i32* %a.addr, align 4
  %shl = shl i32 %1, 6
  %or = or i32 39, %shl
  %call = call i32 @luaK_code(%struct.FuncState* %0, i32 %or)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @addk(%struct.FuncState* %fs, %struct.lua_TValue.13* %key, %struct.lua_TValue.13* %v) #0 {
entry:
  %retval = alloca i32, align 4
  %fs.addr = alloca %struct.FuncState*, align 8
  %key.addr = alloca %struct.lua_TValue.13*, align 8
  %v.addr = alloca %struct.lua_TValue.13*, align 8
  %L = alloca %struct.lua_State.30*, align 8
  %idx = alloca %struct.lua_TValue.13*, align 8
  %f = alloca %struct.Proto.36*, align 8
  %k = alloca i32, align 4
  %oldsize = alloca i32, align 4
  %n = alloca double, align 8
  %u = alloca %union.luai_Cast, align 8
  %io = alloca %struct.lua_TValue.13*, align 8
  %io2 = alloca %struct.lua_TValue.13*, align 8
  %io1 = alloca %struct.lua_TValue.13*, align 8
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store %struct.lua_TValue.13* %key, %struct.lua_TValue.13** %key.addr, align 8
  store %struct.lua_TValue.13* %v, %struct.lua_TValue.13** %v.addr, align 8
  %0 = load %struct.FuncState** %fs.addr, align 8
  %ls = getelementptr inbounds %struct.FuncState* %0, i32 0, i32 3
  %1 = load %struct.LexState** %ls, align 8
  %L1 = getelementptr inbounds %struct.LexState* %1, i32 0, i32 6
  %2 = load %struct.lua_State.30** %L1, align 8
  store %struct.lua_State.30* %2, %struct.lua_State.30** %L, align 8
  %3 = load %struct.lua_State.30** %L, align 8
  %4 = load %struct.FuncState** %fs.addr, align 8
  %h = getelementptr inbounds %struct.FuncState* %4, i32 0, i32 1
  %5 = load %struct.Table.23** %h, align 8
  %6 = load %struct.lua_TValue.13** %key.addr, align 8
  %call = call %struct.lua_TValue.13* bitcast (%struct.lua_TValue* (%struct.lua_State*, %struct.Table*, %struct.lua_TValue*)* @luaH_set to %struct.lua_TValue.13* (%struct.lua_State.30*, %struct.Table.23*, %struct.lua_TValue.13*)*)(%struct.lua_State.30* %3, %struct.Table.23* %5, %struct.lua_TValue.13* %6)
  store %struct.lua_TValue.13* %call, %struct.lua_TValue.13** %idx, align 8
  %7 = load %struct.FuncState** %fs.addr, align 8
  %f2 = getelementptr inbounds %struct.FuncState* %7, i32 0, i32 0
  %8 = load %struct.Proto.36** %f2, align 8
  store %struct.Proto.36* %8, %struct.Proto.36** %f, align 8
  %9 = load %struct.lua_TValue.13** %idx, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue.13* %9, i32 0, i32 1
  %10 = load i32* %tt_, align 4
  %cmp = icmp eq i32 %10, 3
  br i1 %cmp, label %if.then, label %if.end14

if.then:                                          ; preds = %entry
  %11 = load %struct.lua_TValue.13** %idx, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue.13* %11, i32 0, i32 0
  %n3 = bitcast %union.Value.12* %value_ to double*
  %12 = load double* %n3, align 8
  store double %12, double* %n, align 8
  %13 = load double* %n, align 8
  %add = fadd double %13, 0x4338000000000000
  %l_d = bitcast %union.luai_Cast* %u to double*
  store volatile double %add, double* %l_d, align 8
  %l_p = bitcast %union.luai_Cast* %u to [2 x i32]*
  %arrayidx = getelementptr inbounds [2 x i32]* %l_p, i32 0, i64 0
  %14 = load volatile i32* %arrayidx, align 4
  store i32 %14, i32* %k, align 4
  %15 = load i32* %k, align 4
  %idxprom = sext i32 %15 to i64
  %16 = load %struct.Proto.36** %f, align 8
  %k4 = getelementptr inbounds %struct.Proto.36* %16, i32 0, i32 3
  %17 = load %struct.lua_TValue.13** %k4, align 8
  %arrayidx5 = getelementptr inbounds %struct.lua_TValue.13* %17, i64 %idxprom
  %tt_6 = getelementptr inbounds %struct.lua_TValue.13* %arrayidx5, i32 0, i32 1
  %18 = load i32* %tt_6, align 4
  %19 = load %struct.lua_TValue.13** %v.addr, align 8
  %tt_7 = getelementptr inbounds %struct.lua_TValue.13* %19, i32 0, i32 1
  %20 = load i32* %tt_7, align 4
  %cmp8 = icmp eq i32 %18, %20
  br i1 %cmp8, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then
  %21 = load i32* %k, align 4
  %idxprom9 = sext i32 %21 to i64
  %22 = load %struct.Proto.36** %f, align 8
  %k10 = getelementptr inbounds %struct.Proto.36* %22, i32 0, i32 3
  %23 = load %struct.lua_TValue.13** %k10, align 8
  %arrayidx11 = getelementptr inbounds %struct.lua_TValue.13* %23, i64 %idxprom9
  %24 = load %struct.lua_TValue.13** %v.addr, align 8
  %call12 = call i32 bitcast (i32 (%struct.lua_State.364*, %struct.lua_TValue.349*, %struct.lua_TValue.349*)* @luaV_equalobj_ to i32 (%struct.lua_State.30*, %struct.lua_TValue.13*, %struct.lua_TValue.13*)*)(%struct.lua_State.30* null, %struct.lua_TValue.13* %arrayidx11, %struct.lua_TValue.13* %24)
  %tobool = icmp ne i32 %call12, 0
  br i1 %tobool, label %if.then13, label %if.end

if.then13:                                        ; preds = %land.lhs.true
  %25 = load i32* %k, align 4
  store i32 %25, i32* %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true, %if.then
  br label %if.end14

if.end14:                                         ; preds = %if.end, %entry
  %26 = load %struct.Proto.36** %f, align 8
  %sizek = getelementptr inbounds %struct.Proto.36* %26, i32 0, i32 12
  %27 = load i32* %sizek, align 4
  store i32 %27, i32* %oldsize, align 4
  %28 = load %struct.FuncState** %fs.addr, align 8
  %nk = getelementptr inbounds %struct.FuncState* %28, i32 0, i32 8
  %29 = load i32* %nk, align 4
  store i32 %29, i32* %k, align 4
  %30 = load %struct.lua_TValue.13** %idx, align 8
  store %struct.lua_TValue.13* %30, %struct.lua_TValue.13** %io, align 8
  %31 = load i32* %k, align 4
  %conv = sitofp i32 %31 to double
  %32 = load %struct.lua_TValue.13** %io, align 8
  %value_15 = getelementptr inbounds %struct.lua_TValue.13* %32, i32 0, i32 0
  %n16 = bitcast %union.Value.12* %value_15 to double*
  store double %conv, double* %n16, align 8
  %33 = load %struct.lua_TValue.13** %io, align 8
  %tt_17 = getelementptr inbounds %struct.lua_TValue.13* %33, i32 0, i32 1
  store i32 3, i32* %tt_17, align 4
  %34 = load i32* %k, align 4
  %add18 = add nsw i32 %34, 1
  %35 = load %struct.Proto.36** %f, align 8
  %sizek19 = getelementptr inbounds %struct.Proto.36* %35, i32 0, i32 12
  %36 = load i32* %sizek19, align 4
  %cmp20 = icmp sgt i32 %add18, %36
  br i1 %cmp20, label %if.then22, label %if.end27

if.then22:                                        ; preds = %if.end14
  %37 = load %struct.lua_State.30** %L, align 8
  %38 = load %struct.Proto.36** %f, align 8
  %k23 = getelementptr inbounds %struct.Proto.36* %38, i32 0, i32 3
  %39 = load %struct.lua_TValue.13** %k23, align 8
  %40 = bitcast %struct.lua_TValue.13* %39 to i8*
  %41 = load %struct.Proto.36** %f, align 8
  %sizek24 = getelementptr inbounds %struct.Proto.36* %41, i32 0, i32 12
  %call25 = call i8* bitcast (i8* (%struct.lua_State*, i8*, i32*, i64, i32, i8*)* @luaM_growaux_ to i8* (%struct.lua_State.30*, i8*, i32*, i64, i32, i8*)*)(%struct.lua_State.30* %37, i8* %40, i32* %sizek24, i64 16, i32 67108863, i8* getelementptr inbounds ([10 x i8]* @.str2124, i32 0, i32 0))
  %42 = bitcast i8* %call25 to %struct.lua_TValue.13*
  %43 = load %struct.Proto.36** %f, align 8
  %k26 = getelementptr inbounds %struct.Proto.36* %43, i32 0, i32 3
  store %struct.lua_TValue.13* %42, %struct.lua_TValue.13** %k26, align 8
  br label %if.end27

if.end27:                                         ; preds = %if.then22, %if.end14
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end27
  %44 = load i32* %oldsize, align 4
  %45 = load %struct.Proto.36** %f, align 8
  %sizek28 = getelementptr inbounds %struct.Proto.36* %45, i32 0, i32 12
  %46 = load i32* %sizek28, align 4
  %cmp29 = icmp slt i32 %44, %46
  br i1 %cmp29, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %47 = load i32* %oldsize, align 4
  %inc = add nsw i32 %47, 1
  store i32 %inc, i32* %oldsize, align 4
  %idxprom31 = sext i32 %47 to i64
  %48 = load %struct.Proto.36** %f, align 8
  %k32 = getelementptr inbounds %struct.Proto.36* %48, i32 0, i32 3
  %49 = load %struct.lua_TValue.13** %k32, align 8
  %arrayidx33 = getelementptr inbounds %struct.lua_TValue.13* %49, i64 %idxprom31
  %tt_34 = getelementptr inbounds %struct.lua_TValue.13* %arrayidx33, i32 0, i32 1
  store i32 0, i32* %tt_34, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %50 = load %struct.lua_TValue.13** %v.addr, align 8
  store %struct.lua_TValue.13* %50, %struct.lua_TValue.13** %io2, align 8
  %51 = load i32* %k, align 4
  %idxprom35 = sext i32 %51 to i64
  %52 = load %struct.Proto.36** %f, align 8
  %k36 = getelementptr inbounds %struct.Proto.36* %52, i32 0, i32 3
  %53 = load %struct.lua_TValue.13** %k36, align 8
  %arrayidx37 = getelementptr inbounds %struct.lua_TValue.13* %53, i64 %idxprom35
  store %struct.lua_TValue.13* %arrayidx37, %struct.lua_TValue.13** %io1, align 8
  %54 = load %struct.lua_TValue.13** %io1, align 8
  %value_38 = getelementptr inbounds %struct.lua_TValue.13* %54, i32 0, i32 0
  %55 = load %struct.lua_TValue.13** %io2, align 8
  %value_39 = getelementptr inbounds %struct.lua_TValue.13* %55, i32 0, i32 0
  %56 = bitcast %union.Value.12* %value_38 to i8*
  %57 = bitcast %union.Value.12* %value_39 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %56, i8* %57, i64 8, i32 8, i1 false)
  %58 = load %struct.lua_TValue.13** %io2, align 8
  %tt_40 = getelementptr inbounds %struct.lua_TValue.13* %58, i32 0, i32 1
  %59 = load i32* %tt_40, align 4
  %60 = load %struct.lua_TValue.13** %io1, align 8
  %tt_41 = getelementptr inbounds %struct.lua_TValue.13* %60, i32 0, i32 1
  store i32 %59, i32* %tt_41, align 4
  %61 = load %struct.FuncState** %fs.addr, align 8
  %nk42 = getelementptr inbounds %struct.FuncState* %61, i32 0, i32 8
  %62 = load i32* %nk42, align 4
  %inc43 = add nsw i32 %62, 1
  store i32 %inc43, i32* %nk42, align 4
  %63 = load %struct.lua_TValue.13** %v.addr, align 8
  %tt_44 = getelementptr inbounds %struct.lua_TValue.13* %63, i32 0, i32 1
  %64 = load i32* %tt_44, align 4
  %and = and i32 %64, 64
  %tobool45 = icmp ne i32 %and, 0
  br i1 %tobool45, label %land.lhs.true46, label %if.end60

land.lhs.true46:                                  ; preds = %while.end
  %65 = load %struct.lua_TValue.13** %v.addr, align 8
  %value_47 = getelementptr inbounds %struct.lua_TValue.13* %65, i32 0, i32 0
  %gc = bitcast %union.Value.12* %value_47 to %union.GCObject.31**
  %66 = load %union.GCObject.31** %gc, align 8
  %gch = bitcast %union.GCObject.31* %66 to %struct.GCheader.40*
  %marked = getelementptr inbounds %struct.GCheader.40* %gch, i32 0, i32 2
  %67 = load i8* %marked, align 1
  %conv48 = zext i8 %67 to i32
  %and49 = and i32 %conv48, 3
  %tobool50 = icmp ne i32 %and49, 0
  br i1 %tobool50, label %land.lhs.true51, label %if.end60

land.lhs.true51:                                  ; preds = %land.lhs.true46
  %68 = load %struct.Proto.36** %f, align 8
  %69 = bitcast %struct.Proto.36* %68 to %union.GCObject.31*
  %gch52 = bitcast %union.GCObject.31* %69 to %struct.GCheader.40*
  %marked53 = getelementptr inbounds %struct.GCheader.40* %gch52, i32 0, i32 2
  %70 = load i8* %marked53, align 1
  %conv54 = zext i8 %70 to i32
  %and55 = and i32 %conv54, 4
  %tobool56 = icmp ne i32 %and55, 0
  br i1 %tobool56, label %if.then57, label %if.end60

if.then57:                                        ; preds = %land.lhs.true51
  %71 = load %struct.lua_State.30** %L, align 8
  %72 = load %struct.Proto.36** %f, align 8
  %73 = bitcast %struct.Proto.36* %72 to %union.GCObject.31*
  %74 = load %struct.lua_TValue.13** %v.addr, align 8
  %value_58 = getelementptr inbounds %struct.lua_TValue.13* %74, i32 0, i32 0
  %gc59 = bitcast %union.Value.12* %value_58 to %union.GCObject.31**
  %75 = load %union.GCObject.31** %gc59, align 8
  call void bitcast (void (%struct.lua_State*, %union.GCObject*, %union.GCObject*)* @luaC_barrier_ to void (%struct.lua_State.30*, %union.GCObject.31*, %union.GCObject.31*)*)(%struct.lua_State.30* %71, %union.GCObject.31* %73, %union.GCObject.31* %75)
  br label %if.end60

if.end60:                                         ; preds = %if.then57, %land.lhs.true51, %land.lhs.true46, %while.end
  %76 = load i32* %k, align 4
  store i32 %76, i32* %retval
  br label %return

return:                                           ; preds = %if.end60, %if.then13
  %77 = load i32* %retval
  ret i32 %77
}

; Function Attrs: nounwind uwtable
define internal void @freereg(%struct.FuncState* %fs, i32 %reg) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %reg.addr = alloca i32, align 4
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store i32 %reg, i32* %reg.addr, align 4
  %0 = load i32* %reg.addr, align 4
  %and = and i32 %0, 256
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %1 = load i32* %reg.addr, align 4
  %2 = load %struct.FuncState** %fs.addr, align 8
  %nactvar = getelementptr inbounds %struct.FuncState* %2, i32 0, i32 12
  %3 = load i8* %nactvar, align 1
  %conv = zext i8 %3 to i32
  %cmp = icmp sge i32 %1, %conv
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %4 = load %struct.FuncState** %fs.addr, align 8
  %freereg = getelementptr inbounds %struct.FuncState* %4, i32 0, i32 14
  %5 = load i8* %freereg, align 1
  %dec = add i8 %5, -1
  store i8 %dec, i8* %freereg, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @freeexp(%struct.FuncState* %fs, %struct.expdesc* %e) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %e.addr = alloca %struct.expdesc*, align 8
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store %struct.expdesc* %e, %struct.expdesc** %e.addr, align 8
  %0 = load %struct.expdesc** %e.addr, align 8
  %k = getelementptr inbounds %struct.expdesc* %0, i32 0, i32 0
  %1 = load i32* %k, align 4
  %cmp = icmp eq i32 %1, 6
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.FuncState** %fs.addr, align 8
  %3 = load %struct.expdesc** %e.addr, align 8
  %u = getelementptr inbounds %struct.expdesc* %3, i32 0, i32 1
  %info = bitcast %union.anon.7* %u to i32*
  %4 = load i32* %info, align 4
  call void @freereg(%struct.FuncState* %2, i32 %4)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @exp2reg(%struct.FuncState* %fs, %struct.expdesc* %e, i32 %reg) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %e.addr = alloca %struct.expdesc*, align 8
  %reg.addr = alloca i32, align 4
  %final = alloca i32, align 4
  %p_f = alloca i32, align 4
  %p_t = alloca i32, align 4
  %fj = alloca i32, align 4
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store %struct.expdesc* %e, %struct.expdesc** %e.addr, align 8
  store i32 %reg, i32* %reg.addr, align 4
  %0 = load %struct.FuncState** %fs.addr, align 8
  %1 = load %struct.expdesc** %e.addr, align 8
  %2 = load i32* %reg.addr, align 4
  call void @discharge2reg(%struct.FuncState* %0, %struct.expdesc* %1, i32 %2)
  %3 = load %struct.expdesc** %e.addr, align 8
  %k = getelementptr inbounds %struct.expdesc* %3, i32 0, i32 0
  %4 = load i32* %k, align 4
  %cmp = icmp eq i32 %4, 10
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load %struct.FuncState** %fs.addr, align 8
  %6 = load %struct.expdesc** %e.addr, align 8
  %t = getelementptr inbounds %struct.expdesc* %6, i32 0, i32 2
  %7 = load %struct.expdesc** %e.addr, align 8
  %u = getelementptr inbounds %struct.expdesc* %7, i32 0, i32 1
  %info = bitcast %union.anon.7* %u to i32*
  %8 = load i32* %info, align 4
  call void @luaK_concat(%struct.FuncState* %5, i32* %t, i32 %8)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %9 = load %struct.expdesc** %e.addr, align 8
  %t1 = getelementptr inbounds %struct.expdesc* %9, i32 0, i32 2
  %10 = load i32* %t1, align 4
  %11 = load %struct.expdesc** %e.addr, align 8
  %f = getelementptr inbounds %struct.expdesc* %11, i32 0, i32 3
  %12 = load i32* %f, align 4
  %cmp2 = icmp ne i32 %10, %12
  br i1 %cmp2, label %if.then3, label %if.end18

if.then3:                                         ; preds = %if.end
  store i32 -1, i32* %p_f, align 4
  store i32 -1, i32* %p_t, align 4
  %13 = load %struct.FuncState** %fs.addr, align 8
  %14 = load %struct.expdesc** %e.addr, align 8
  %t4 = getelementptr inbounds %struct.expdesc* %14, i32 0, i32 2
  %15 = load i32* %t4, align 4
  %call = call i32 @need_value(%struct.FuncState* %13, i32 %15)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then8, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then3
  %16 = load %struct.FuncState** %fs.addr, align 8
  %17 = load %struct.expdesc** %e.addr, align 8
  %f5 = getelementptr inbounds %struct.expdesc* %17, i32 0, i32 3
  %18 = load i32* %f5, align 4
  %call6 = call i32 @need_value(%struct.FuncState* %16, i32 %18)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.then8, label %if.end14

if.then8:                                         ; preds = %lor.lhs.false, %if.then3
  %19 = load %struct.expdesc** %e.addr, align 8
  %k9 = getelementptr inbounds %struct.expdesc* %19, i32 0, i32 0
  %20 = load i32* %k9, align 4
  %cmp10 = icmp eq i32 %20, 10
  br i1 %cmp10, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then8
  br label %cond.end

cond.false:                                       ; preds = %if.then8
  %21 = load %struct.FuncState** %fs.addr, align 8
  %call11 = call i32 @luaK_jump(%struct.FuncState* %21)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ -1, %cond.true ], [ %call11, %cond.false ]
  store i32 %cond, i32* %fj, align 4
  %22 = load %struct.FuncState** %fs.addr, align 8
  %23 = load i32* %reg.addr, align 4
  %call12 = call i32 @code_label(%struct.FuncState* %22, i32 %23, i32 0, i32 1)
  store i32 %call12, i32* %p_f, align 4
  %24 = load %struct.FuncState** %fs.addr, align 8
  %25 = load i32* %reg.addr, align 4
  %call13 = call i32 @code_label(%struct.FuncState* %24, i32 %25, i32 1, i32 0)
  store i32 %call13, i32* %p_t, align 4
  %26 = load %struct.FuncState** %fs.addr, align 8
  %27 = load i32* %fj, align 4
  call void @luaK_patchtohere(%struct.FuncState* %26, i32 %27)
  br label %if.end14

if.end14:                                         ; preds = %cond.end, %lor.lhs.false
  %28 = load %struct.FuncState** %fs.addr, align 8
  %call15 = call i32 @luaK_getlabel(%struct.FuncState* %28)
  store i32 %call15, i32* %final, align 4
  %29 = load %struct.FuncState** %fs.addr, align 8
  %30 = load %struct.expdesc** %e.addr, align 8
  %f16 = getelementptr inbounds %struct.expdesc* %30, i32 0, i32 3
  %31 = load i32* %f16, align 4
  %32 = load i32* %final, align 4
  %33 = load i32* %reg.addr, align 4
  %34 = load i32* %p_f, align 4
  call void @patchlistaux(%struct.FuncState* %29, i32 %31, i32 %32, i32 %33, i32 %34)
  %35 = load %struct.FuncState** %fs.addr, align 8
  %36 = load %struct.expdesc** %e.addr, align 8
  %t17 = getelementptr inbounds %struct.expdesc* %36, i32 0, i32 2
  %37 = load i32* %t17, align 4
  %38 = load i32* %final, align 4
  %39 = load i32* %reg.addr, align 4
  %40 = load i32* %p_t, align 4
  call void @patchlistaux(%struct.FuncState* %35, i32 %37, i32 %38, i32 %39, i32 %40)
  br label %if.end18

if.end18:                                         ; preds = %if.end14, %if.end
  %41 = load %struct.expdesc** %e.addr, align 8
  %t19 = getelementptr inbounds %struct.expdesc* %41, i32 0, i32 2
  store i32 -1, i32* %t19, align 4
  %42 = load %struct.expdesc** %e.addr, align 8
  %f20 = getelementptr inbounds %struct.expdesc* %42, i32 0, i32 3
  store i32 -1, i32* %f20, align 4
  %43 = load i32* %reg.addr, align 4
  %44 = load %struct.expdesc** %e.addr, align 8
  %u21 = getelementptr inbounds %struct.expdesc* %44, i32 0, i32 1
  %info22 = bitcast %union.anon.7* %u21 to i32*
  store i32 %43, i32* %info22, align 4
  %45 = load %struct.expdesc** %e.addr, align 8
  %k23 = getelementptr inbounds %struct.expdesc* %45, i32 0, i32 0
  store i32 6, i32* %k23, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @nilK(%struct.FuncState* %fs) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %k = alloca %struct.lua_TValue.13, align 8
  %v = alloca %struct.lua_TValue.13, align 8
  %io = alloca %struct.lua_TValue.13*, align 8
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue.13* %v, i32 0, i32 1
  store i32 0, i32* %tt_, align 4
  store %struct.lua_TValue.13* %k, %struct.lua_TValue.13** %io, align 8
  %0 = load %struct.FuncState** %fs.addr, align 8
  %h = getelementptr inbounds %struct.FuncState* %0, i32 0, i32 1
  %1 = load %struct.Table.23** %h, align 8
  %2 = bitcast %struct.Table.23* %1 to %union.GCObject.31*
  %3 = load %struct.lua_TValue.13** %io, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue.13* %3, i32 0, i32 0
  %gc = bitcast %union.Value.12* %value_ to %union.GCObject.31**
  store %union.GCObject.31* %2, %union.GCObject.31** %gc, align 8
  %4 = load %struct.lua_TValue.13** %io, align 8
  %tt_1 = getelementptr inbounds %struct.lua_TValue.13* %4, i32 0, i32 1
  store i32 69, i32* %tt_1, align 4
  %5 = load %struct.FuncState** %fs.addr, align 8
  %call = call i32 @addk(%struct.FuncState* %5, %struct.lua_TValue.13* %k, %struct.lua_TValue.13* %v)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @boolK(%struct.FuncState* %fs, i32 %b) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %b.addr = alloca i32, align 4
  %o = alloca %struct.lua_TValue.13, align 8
  %io = alloca %struct.lua_TValue.13*, align 8
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store i32 %b, i32* %b.addr, align 4
  store %struct.lua_TValue.13* %o, %struct.lua_TValue.13** %io, align 8
  %0 = load i32* %b.addr, align 4
  %1 = load %struct.lua_TValue.13** %io, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue.13* %1, i32 0, i32 0
  %b1 = bitcast %union.Value.12* %value_ to i32*
  store i32 %0, i32* %b1, align 4
  %2 = load %struct.lua_TValue.13** %io, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue.13* %2, i32 0, i32 1
  store i32 1, i32* %tt_, align 4
  %3 = load %struct.FuncState** %fs.addr, align 8
  %call = call i32 @addk(%struct.FuncState* %3, %struct.lua_TValue.13* %o, %struct.lua_TValue.13* %o)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal void @invertjump(%struct.FuncState* %fs, %struct.expdesc* %e) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %e.addr = alloca %struct.expdesc*, align 8
  %pc = alloca i32*, align 8
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store %struct.expdesc* %e, %struct.expdesc** %e.addr, align 8
  %0 = load %struct.FuncState** %fs.addr, align 8
  %1 = load %struct.expdesc** %e.addr, align 8
  %u = getelementptr inbounds %struct.expdesc* %1, i32 0, i32 1
  %info = bitcast %union.anon.7* %u to i32*
  %2 = load i32* %info, align 4
  %call = call i32* @getjumpcontrol(%struct.FuncState* %0, i32 %2)
  store i32* %call, i32** %pc, align 8
  %3 = load i32** %pc, align 8
  %4 = load i32* %3, align 4
  %and = and i32 %4, -16321
  %5 = load i32** %pc, align 8
  %6 = load i32* %5, align 4
  %shr = lshr i32 %6, 6
  %and1 = and i32 %shr, 255
  %tobool = icmp ne i32 %and1, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  %shl = shl i32 %lnot.ext, 6
  %and2 = and i32 %shl, 16320
  %or = or i32 %and, %and2
  %7 = load i32** %pc, align 8
  store i32 %or, i32* %7, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @jumponcond(%struct.FuncState* %fs, %struct.expdesc* %e, i32 %cond) #0 {
entry:
  %retval = alloca i32, align 4
  %fs.addr = alloca %struct.FuncState*, align 8
  %e.addr = alloca %struct.expdesc*, align 8
  %cond.addr = alloca i32, align 4
  %ie = alloca i32, align 4
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store %struct.expdesc* %e, %struct.expdesc** %e.addr, align 8
  store i32 %cond, i32* %cond.addr, align 4
  %0 = load %struct.expdesc** %e.addr, align 8
  %k = getelementptr inbounds %struct.expdesc* %0, i32 0, i32 0
  %1 = load i32* %k, align 4
  %cmp = icmp eq i32 %1, 11
  br i1 %cmp, label %if.then, label %if.end5

if.then:                                          ; preds = %entry
  %2 = load %struct.expdesc** %e.addr, align 8
  %u = getelementptr inbounds %struct.expdesc* %2, i32 0, i32 1
  %info = bitcast %union.anon.7* %u to i32*
  %3 = load i32* %info, align 4
  %idxprom = sext i32 %3 to i64
  %4 = load %struct.FuncState** %fs.addr, align 8
  %f = getelementptr inbounds %struct.FuncState* %4, i32 0, i32 0
  %5 = load %struct.Proto.36** %f, align 8
  %code = getelementptr inbounds %struct.Proto.36* %5, i32 0, i32 4
  %6 = load i32** %code, align 8
  %arrayidx = getelementptr inbounds i32* %6, i64 %idxprom
  %7 = load i32* %arrayidx, align 4
  store i32 %7, i32* %ie, align 4
  %8 = load i32* %ie, align 4
  %shr = lshr i32 %8, 0
  %and = and i32 %shr, 63
  %cmp1 = icmp eq i32 %and, 20
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %9 = load %struct.FuncState** %fs.addr, align 8
  %pc = getelementptr inbounds %struct.FuncState* %9, i32 0, i32 5
  %10 = load i32* %pc, align 4
  %dec = add nsw i32 %10, -1
  store i32 %dec, i32* %pc, align 4
  %11 = load %struct.FuncState** %fs.addr, align 8
  %12 = load i32* %ie, align 4
  %shr3 = lshr i32 %12, 23
  %and4 = and i32 %shr3, 511
  %13 = load i32* %cond.addr, align 4
  %tobool = icmp ne i32 %13, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  %call = call i32 @condjump(%struct.FuncState* %11, i32 27, i32 %and4, i32 0, i32 %lnot.ext)
  store i32 %call, i32* %retval
  br label %return

if.end:                                           ; preds = %if.then
  br label %if.end5

if.end5:                                          ; preds = %if.end, %entry
  %14 = load %struct.FuncState** %fs.addr, align 8
  %15 = load %struct.expdesc** %e.addr, align 8
  call void @discharge2anyreg(%struct.FuncState* %14, %struct.expdesc* %15)
  %16 = load %struct.FuncState** %fs.addr, align 8
  %17 = load %struct.expdesc** %e.addr, align 8
  call void @freeexp(%struct.FuncState* %16, %struct.expdesc* %17)
  %18 = load %struct.FuncState** %fs.addr, align 8
  %19 = load %struct.expdesc** %e.addr, align 8
  %u6 = getelementptr inbounds %struct.expdesc* %19, i32 0, i32 1
  %info7 = bitcast %union.anon.7* %u6 to i32*
  %20 = load i32* %info7, align 4
  %21 = load i32* %cond.addr, align 4
  %call8 = call i32 @condjump(%struct.FuncState* %18, i32 28, i32 255, i32 %20, i32 %21)
  store i32 %call8, i32* %retval
  br label %return

return:                                           ; preds = %if.end5, %if.then2
  %22 = load i32* %retval
  ret i32 %22
}

; Function Attrs: nounwind uwtable
define internal i32 @isnumeral(%struct.expdesc* %e) #0 {
entry:
  %e.addr = alloca %struct.expdesc*, align 8
  store %struct.expdesc* %e, %struct.expdesc** %e.addr, align 8
  %0 = load %struct.expdesc** %e.addr, align 8
  %k = getelementptr inbounds %struct.expdesc* %0, i32 0, i32 0
  %1 = load i32* %k, align 4
  %cmp = icmp eq i32 %1, 5
  br i1 %cmp, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %2 = load %struct.expdesc** %e.addr, align 8
  %t = getelementptr inbounds %struct.expdesc* %2, i32 0, i32 2
  %3 = load i32* %t, align 4
  %cmp1 = icmp eq i32 %3, -1
  br i1 %cmp1, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %4 = load %struct.expdesc** %e.addr, align 8
  %f = getelementptr inbounds %struct.expdesc* %4, i32 0, i32 3
  %5 = load i32* %f, align 4
  %cmp2 = icmp eq i32 %5, -1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %entry
  %6 = phi i1 [ false, %land.lhs.true ], [ false, %entry ], [ %cmp2, %land.rhs ]
  %land.ext = zext i1 %6 to i32
  ret i32 %land.ext
}

; Function Attrs: nounwind uwtable
define internal void @codearith(%struct.FuncState* %fs, i32 %op, %struct.expdesc* %e1, %struct.expdesc* %e2, i32 %line) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %op.addr = alloca i32, align 4
  %e1.addr = alloca %struct.expdesc*, align 8
  %e2.addr = alloca %struct.expdesc*, align 8
  %line.addr = alloca i32, align 4
  %o2 = alloca i32, align 4
  %o1 = alloca i32, align 4
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store i32 %op, i32* %op.addr, align 4
  store %struct.expdesc* %e1, %struct.expdesc** %e1.addr, align 8
  store %struct.expdesc* %e2, %struct.expdesc** %e2.addr, align 8
  store i32 %line, i32* %line.addr, align 4
  %0 = load i32* %op.addr, align 4
  %1 = load %struct.expdesc** %e1.addr, align 8
  %2 = load %struct.expdesc** %e2.addr, align 8
  %call = call i32 @constfolding(i32 %0, %struct.expdesc* %1, %struct.expdesc* %2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end8

if.else:                                          ; preds = %entry
  %3 = load i32* %op.addr, align 4
  %cmp = icmp ne i32 %3, 19
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %if.else
  %4 = load i32* %op.addr, align 4
  %cmp1 = icmp ne i32 %4, 21
  br i1 %cmp1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  %5 = load %struct.FuncState** %fs.addr, align 8
  %6 = load %struct.expdesc** %e2.addr, align 8
  %call2 = call i32 @luaK_exp2RK(%struct.FuncState* %5, %struct.expdesc* %6)
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %if.else
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %call2, %cond.true ], [ 0, %cond.false ]
  store i32 %cond, i32* %o2, align 4
  %7 = load %struct.FuncState** %fs.addr, align 8
  %8 = load %struct.expdesc** %e1.addr, align 8
  %call3 = call i32 @luaK_exp2RK(%struct.FuncState* %7, %struct.expdesc* %8)
  store i32 %call3, i32* %o1, align 4
  %9 = load i32* %o1, align 4
  %10 = load i32* %o2, align 4
  %cmp4 = icmp sgt i32 %9, %10
  br i1 %cmp4, label %if.then5, label %if.else6

if.then5:                                         ; preds = %cond.end
  %11 = load %struct.FuncState** %fs.addr, align 8
  %12 = load %struct.expdesc** %e1.addr, align 8
  call void @freeexp(%struct.FuncState* %11, %struct.expdesc* %12)
  %13 = load %struct.FuncState** %fs.addr, align 8
  %14 = load %struct.expdesc** %e2.addr, align 8
  call void @freeexp(%struct.FuncState* %13, %struct.expdesc* %14)
  br label %if.end

if.else6:                                         ; preds = %cond.end
  %15 = load %struct.FuncState** %fs.addr, align 8
  %16 = load %struct.expdesc** %e2.addr, align 8
  call void @freeexp(%struct.FuncState* %15, %struct.expdesc* %16)
  %17 = load %struct.FuncState** %fs.addr, align 8
  %18 = load %struct.expdesc** %e1.addr, align 8
  call void @freeexp(%struct.FuncState* %17, %struct.expdesc* %18)
  br label %if.end

if.end:                                           ; preds = %if.else6, %if.then5
  %19 = load %struct.FuncState** %fs.addr, align 8
  %20 = load i32* %op.addr, align 4
  %21 = load i32* %o1, align 4
  %22 = load i32* %o2, align 4
  %call7 = call i32 @luaK_codeABC(%struct.FuncState* %19, i32 %20, i32 0, i32 %21, i32 %22)
  %23 = load %struct.expdesc** %e1.addr, align 8
  %u = getelementptr inbounds %struct.expdesc* %23, i32 0, i32 1
  %info = bitcast %union.anon.7* %u to i32*
  store i32 %call7, i32* %info, align 4
  %24 = load %struct.expdesc** %e1.addr, align 8
  %k = getelementptr inbounds %struct.expdesc* %24, i32 0, i32 0
  store i32 11, i32* %k, align 4
  %25 = load %struct.FuncState** %fs.addr, align 8
  %26 = load i32* %line.addr, align 4
  call void @luaK_fixline(%struct.FuncState* %25, i32 %26)
  br label %if.end8

if.end8:                                          ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @codenot(%struct.FuncState* %fs, %struct.expdesc* %e) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %e.addr = alloca %struct.expdesc*, align 8
  %temp = alloca i32, align 4
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store %struct.expdesc* %e, %struct.expdesc** %e.addr, align 8
  %0 = load %struct.FuncState** %fs.addr, align 8
  %1 = load %struct.expdesc** %e.addr, align 8
  call void @luaK_dischargevars(%struct.FuncState* %0, %struct.expdesc* %1)
  %2 = load %struct.expdesc** %e.addr, align 8
  %k = getelementptr inbounds %struct.expdesc* %2, i32 0, i32 0
  %3 = load i32* %k, align 4
  switch i32 %3, label %sw.default [
    i32 1, label %sw.bb
    i32 3, label %sw.bb
    i32 4, label %sw.bb2
    i32 5, label %sw.bb2
    i32 2, label %sw.bb2
    i32 10, label %sw.bb4
    i32 11, label %sw.bb5
    i32 6, label %sw.bb5
  ]

sw.bb:                                            ; preds = %entry, %entry
  %4 = load %struct.expdesc** %e.addr, align 8
  %k1 = getelementptr inbounds %struct.expdesc* %4, i32 0, i32 0
  store i32 2, i32* %k1, align 4
  br label %sw.epilog

sw.bb2:                                           ; preds = %entry, %entry, %entry
  %5 = load %struct.expdesc** %e.addr, align 8
  %k3 = getelementptr inbounds %struct.expdesc* %5, i32 0, i32 0
  store i32 3, i32* %k3, align 4
  br label %sw.epilog

sw.bb4:                                           ; preds = %entry
  %6 = load %struct.FuncState** %fs.addr, align 8
  %7 = load %struct.expdesc** %e.addr, align 8
  call void @invertjump(%struct.FuncState* %6, %struct.expdesc* %7)
  br label %sw.epilog

sw.bb5:                                           ; preds = %entry, %entry
  %8 = load %struct.FuncState** %fs.addr, align 8
  %9 = load %struct.expdesc** %e.addr, align 8
  call void @discharge2anyreg(%struct.FuncState* %8, %struct.expdesc* %9)
  %10 = load %struct.FuncState** %fs.addr, align 8
  %11 = load %struct.expdesc** %e.addr, align 8
  call void @freeexp(%struct.FuncState* %10, %struct.expdesc* %11)
  %12 = load %struct.FuncState** %fs.addr, align 8
  %13 = load %struct.expdesc** %e.addr, align 8
  %u = getelementptr inbounds %struct.expdesc* %13, i32 0, i32 1
  %info = bitcast %union.anon.7* %u to i32*
  %14 = load i32* %info, align 4
  %call = call i32 @luaK_codeABC(%struct.FuncState* %12, i32 20, i32 0, i32 %14, i32 0)
  %15 = load %struct.expdesc** %e.addr, align 8
  %u6 = getelementptr inbounds %struct.expdesc* %15, i32 0, i32 1
  %info7 = bitcast %union.anon.7* %u6 to i32*
  store i32 %call, i32* %info7, align 4
  %16 = load %struct.expdesc** %e.addr, align 8
  %k8 = getelementptr inbounds %struct.expdesc* %16, i32 0, i32 0
  store i32 11, i32* %k8, align 4
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb5, %sw.bb4, %sw.bb2, %sw.bb
  %17 = load %struct.expdesc** %e.addr, align 8
  %f = getelementptr inbounds %struct.expdesc* %17, i32 0, i32 3
  %18 = load i32* %f, align 4
  store i32 %18, i32* %temp, align 4
  %19 = load %struct.expdesc** %e.addr, align 8
  %t = getelementptr inbounds %struct.expdesc* %19, i32 0, i32 2
  %20 = load i32* %t, align 4
  %21 = load %struct.expdesc** %e.addr, align 8
  %f9 = getelementptr inbounds %struct.expdesc* %21, i32 0, i32 3
  store i32 %20, i32* %f9, align 4
  %22 = load i32* %temp, align 4
  %23 = load %struct.expdesc** %e.addr, align 8
  %t10 = getelementptr inbounds %struct.expdesc* %23, i32 0, i32 2
  store i32 %22, i32* %t10, align 4
  %24 = load %struct.FuncState** %fs.addr, align 8
  %25 = load %struct.expdesc** %e.addr, align 8
  %f11 = getelementptr inbounds %struct.expdesc* %25, i32 0, i32 3
  %26 = load i32* %f11, align 4
  call void @removevalues(%struct.FuncState* %24, i32 %26)
  %27 = load %struct.FuncState** %fs.addr, align 8
  %28 = load %struct.expdesc** %e.addr, align 8
  %t12 = getelementptr inbounds %struct.expdesc* %28, i32 0, i32 2
  %29 = load i32* %t12, align 4
  call void @removevalues(%struct.FuncState* %27, i32 %29)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @codecomp(%struct.FuncState* %fs, i32 %op, i32 %cond, %struct.expdesc* %e1, %struct.expdesc* %e2) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %op.addr = alloca i32, align 4
  %cond.addr = alloca i32, align 4
  %e1.addr = alloca %struct.expdesc*, align 8
  %e2.addr = alloca %struct.expdesc*, align 8
  %o1 = alloca i32, align 4
  %o2 = alloca i32, align 4
  %temp = alloca i32, align 4
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store i32 %op, i32* %op.addr, align 4
  store i32 %cond, i32* %cond.addr, align 4
  store %struct.expdesc* %e1, %struct.expdesc** %e1.addr, align 8
  store %struct.expdesc* %e2, %struct.expdesc** %e2.addr, align 8
  %0 = load %struct.FuncState** %fs.addr, align 8
  %1 = load %struct.expdesc** %e1.addr, align 8
  %call = call i32 @luaK_exp2RK(%struct.FuncState* %0, %struct.expdesc* %1)
  store i32 %call, i32* %o1, align 4
  %2 = load %struct.FuncState** %fs.addr, align 8
  %3 = load %struct.expdesc** %e2.addr, align 8
  %call1 = call i32 @luaK_exp2RK(%struct.FuncState* %2, %struct.expdesc* %3)
  store i32 %call1, i32* %o2, align 4
  %4 = load %struct.FuncState** %fs.addr, align 8
  %5 = load %struct.expdesc** %e2.addr, align 8
  call void @freeexp(%struct.FuncState* %4, %struct.expdesc* %5)
  %6 = load %struct.FuncState** %fs.addr, align 8
  %7 = load %struct.expdesc** %e1.addr, align 8
  call void @freeexp(%struct.FuncState* %6, %struct.expdesc* %7)
  %8 = load i32* %cond.addr, align 4
  %cmp = icmp eq i32 %8, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %9 = load i32* %op.addr, align 4
  %cmp2 = icmp ne i32 %9, 24
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %10 = load i32* %o1, align 4
  store i32 %10, i32* %temp, align 4
  %11 = load i32* %o2, align 4
  store i32 %11, i32* %o1, align 4
  %12 = load i32* %temp, align 4
  store i32 %12, i32* %o2, align 4
  store i32 1, i32* %cond.addr, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %13 = load %struct.FuncState** %fs.addr, align 8
  %14 = load i32* %op.addr, align 4
  %15 = load i32* %cond.addr, align 4
  %16 = load i32* %o1, align 4
  %17 = load i32* %o2, align 4
  %call3 = call i32 @condjump(%struct.FuncState* %13, i32 %14, i32 %15, i32 %16, i32 %17)
  %18 = load %struct.expdesc** %e1.addr, align 8
  %u = getelementptr inbounds %struct.expdesc* %18, i32 0, i32 1
  %info = bitcast %union.anon.7* %u to i32*
  store i32 %call3, i32* %info, align 4
  %19 = load %struct.expdesc** %e1.addr, align 8
  %k = getelementptr inbounds %struct.expdesc* %19, i32 0, i32 0
  store i32 10, i32* %k, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @dischargejpc(%struct.FuncState* %fs) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  %0 = load %struct.FuncState** %fs.addr, align 8
  %1 = load %struct.FuncState** %fs.addr, align 8
  %jpc = getelementptr inbounds %struct.FuncState* %1, i32 0, i32 7
  %2 = load i32* %jpc, align 4
  %3 = load %struct.FuncState** %fs.addr, align 8
  %pc = getelementptr inbounds %struct.FuncState* %3, i32 0, i32 5
  %4 = load i32* %pc, align 4
  %5 = load %struct.FuncState** %fs.addr, align 8
  %pc1 = getelementptr inbounds %struct.FuncState* %5, i32 0, i32 5
  %6 = load i32* %pc1, align 4
  call void @patchlistaux(%struct.FuncState* %0, i32 %2, i32 %4, i32 255, i32 %6)
  %7 = load %struct.FuncState** %fs.addr, align 8
  %jpc2 = getelementptr inbounds %struct.FuncState* %7, i32 0, i32 7
  store i32 -1, i32* %jpc2, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @patchtestreg(%struct.FuncState* %fs, i32 %node, i32 %reg) #0 {
entry:
  %retval = alloca i32, align 4
  %fs.addr = alloca %struct.FuncState*, align 8
  %node.addr = alloca i32, align 4
  %reg.addr = alloca i32, align 4
  %i = alloca i32*, align 8
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store i32 %node, i32* %node.addr, align 4
  store i32 %reg, i32* %reg.addr, align 4
  %0 = load %struct.FuncState** %fs.addr, align 8
  %1 = load i32* %node.addr, align 4
  %call = call i32* @getjumpcontrol(%struct.FuncState* %0, i32 %1)
  store i32* %call, i32** %i, align 8
  %2 = load i32** %i, align 8
  %3 = load i32* %2, align 4
  %shr = lshr i32 %3, 0
  %and = and i32 %shr, 63
  %cmp = icmp ne i32 %and, 28
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %4 = load i32* %reg.addr, align 4
  %cmp1 = icmp ne i32 %4, 255
  br i1 %cmp1, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.end
  %5 = load i32* %reg.addr, align 4
  %6 = load i32** %i, align 8
  %7 = load i32* %6, align 4
  %shr2 = lshr i32 %7, 23
  %and3 = and i32 %shr2, 511
  %cmp4 = icmp ne i32 %5, %and3
  br i1 %cmp4, label %if.then5, label %if.else

if.then5:                                         ; preds = %land.lhs.true
  %8 = load i32** %i, align 8
  %9 = load i32* %8, align 4
  %and6 = and i32 %9, -16321
  %10 = load i32* %reg.addr, align 4
  %shl = shl i32 %10, 6
  %and7 = and i32 %shl, 16320
  %or = or i32 %and6, %and7
  %11 = load i32** %i, align 8
  store i32 %or, i32* %11, align 4
  br label %if.end16

if.else:                                          ; preds = %land.lhs.true, %if.end
  %12 = load i32** %i, align 8
  %13 = load i32* %12, align 4
  %shr8 = lshr i32 %13, 23
  %and9 = and i32 %shr8, 511
  %shl10 = shl i32 %and9, 6
  %or11 = or i32 27, %shl10
  %14 = load i32** %i, align 8
  %15 = load i32* %14, align 4
  %shr12 = lshr i32 %15, 14
  %and13 = and i32 %shr12, 511
  %shl14 = shl i32 %and13, 14
  %or15 = or i32 %or11, %shl14
  %16 = load i32** %i, align 8
  store i32 %or15, i32* %16, align 4
  br label %if.end16

if.end16:                                         ; preds = %if.else, %if.then5
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %if.end16, %if.then
  %17 = load i32* %retval
  ret i32 %17
}

; Function Attrs: nounwind uwtable
define internal void @discharge2reg(%struct.FuncState* %fs, %struct.expdesc* %e, i32 %reg) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %e.addr = alloca %struct.expdesc*, align 8
  %reg.addr = alloca i32, align 4
  %pc = alloca i32*, align 8
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store %struct.expdesc* %e, %struct.expdesc** %e.addr, align 8
  store i32 %reg, i32* %reg.addr, align 4
  %0 = load %struct.FuncState** %fs.addr, align 8
  %1 = load %struct.expdesc** %e.addr, align 8
  call void @luaK_dischargevars(%struct.FuncState* %0, %struct.expdesc* %1)
  %2 = load %struct.expdesc** %e.addr, align 8
  %k = getelementptr inbounds %struct.expdesc* %2, i32 0, i32 0
  %3 = load i32* %k, align 4
  switch i32 %3, label %sw.default [
    i32 1, label %sw.bb
    i32 3, label %sw.bb1
    i32 2, label %sw.bb1
    i32 4, label %sw.bb3
    i32 5, label %sw.bb5
    i32 11, label %sw.bb9
    i32 6, label %sw.bb13
  ]

sw.bb:                                            ; preds = %entry
  %4 = load %struct.FuncState** %fs.addr, align 8
  %5 = load i32* %reg.addr, align 4
  call void @luaK_nil(%struct.FuncState* %4, i32 %5, i32 1)
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry, %entry
  %6 = load %struct.FuncState** %fs.addr, align 8
  %7 = load i32* %reg.addr, align 4
  %8 = load %struct.expdesc** %e.addr, align 8
  %k2 = getelementptr inbounds %struct.expdesc* %8, i32 0, i32 0
  %9 = load i32* %k2, align 4
  %cmp = icmp eq i32 %9, 2
  %conv = zext i1 %cmp to i32
  %call = call i32 @luaK_codeABC(%struct.FuncState* %6, i32 3, i32 %7, i32 %conv, i32 0)
  br label %sw.epilog

sw.bb3:                                           ; preds = %entry
  %10 = load %struct.FuncState** %fs.addr, align 8
  %11 = load i32* %reg.addr, align 4
  %12 = load %struct.expdesc** %e.addr, align 8
  %u = getelementptr inbounds %struct.expdesc* %12, i32 0, i32 1
  %info = bitcast %union.anon.7* %u to i32*
  %13 = load i32* %info, align 4
  %call4 = call i32 @luaK_codek(%struct.FuncState* %10, i32 %11, i32 %13)
  br label %sw.epilog

sw.bb5:                                           ; preds = %entry
  %14 = load %struct.FuncState** %fs.addr, align 8
  %15 = load i32* %reg.addr, align 4
  %16 = load %struct.FuncState** %fs.addr, align 8
  %17 = load %struct.expdesc** %e.addr, align 8
  %u6 = getelementptr inbounds %struct.expdesc* %17, i32 0, i32 1
  %nval = bitcast %union.anon.7* %u6 to double*
  %18 = load double* %nval, align 8
  %call7 = call i32 @luaK_numberK(%struct.FuncState* %16, double %18)
  %call8 = call i32 @luaK_codek(%struct.FuncState* %14, i32 %15, i32 %call7)
  br label %sw.epilog

sw.bb9:                                           ; preds = %entry
  %19 = load %struct.expdesc** %e.addr, align 8
  %u10 = getelementptr inbounds %struct.expdesc* %19, i32 0, i32 1
  %info11 = bitcast %union.anon.7* %u10 to i32*
  %20 = load i32* %info11, align 4
  %idxprom = sext i32 %20 to i64
  %21 = load %struct.FuncState** %fs.addr, align 8
  %f = getelementptr inbounds %struct.FuncState* %21, i32 0, i32 0
  %22 = load %struct.Proto.36** %f, align 8
  %code = getelementptr inbounds %struct.Proto.36* %22, i32 0, i32 4
  %23 = load i32** %code, align 8
  %arrayidx = getelementptr inbounds i32* %23, i64 %idxprom
  store i32* %arrayidx, i32** %pc, align 8
  %24 = load i32** %pc, align 8
  %25 = load i32* %24, align 4
  %and = and i32 %25, -16321
  %26 = load i32* %reg.addr, align 4
  %shl = shl i32 %26, 6
  %and12 = and i32 %shl, 16320
  %or = or i32 %and, %and12
  %27 = load i32** %pc, align 8
  store i32 %or, i32* %27, align 4
  br label %sw.epilog

sw.bb13:                                          ; preds = %entry
  %28 = load i32* %reg.addr, align 4
  %29 = load %struct.expdesc** %e.addr, align 8
  %u14 = getelementptr inbounds %struct.expdesc* %29, i32 0, i32 1
  %info15 = bitcast %union.anon.7* %u14 to i32*
  %30 = load i32* %info15, align 4
  %cmp16 = icmp ne i32 %28, %30
  br i1 %cmp16, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb13
  %31 = load %struct.FuncState** %fs.addr, align 8
  %32 = load i32* %reg.addr, align 4
  %33 = load %struct.expdesc** %e.addr, align 8
  %u18 = getelementptr inbounds %struct.expdesc* %33, i32 0, i32 1
  %info19 = bitcast %union.anon.7* %u18 to i32*
  %34 = load i32* %info19, align 4
  %call20 = call i32 @luaK_codeABC(%struct.FuncState* %31, i32 0, i32 %32, i32 %34, i32 0)
  br label %if.end

if.end:                                           ; preds = %if.then, %sw.bb13
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  br label %return

sw.epilog:                                        ; preds = %if.end, %sw.bb9, %sw.bb5, %sw.bb3, %sw.bb1, %sw.bb
  %35 = load i32* %reg.addr, align 4
  %36 = load %struct.expdesc** %e.addr, align 8
  %u21 = getelementptr inbounds %struct.expdesc* %36, i32 0, i32 1
  %info22 = bitcast %union.anon.7* %u21 to i32*
  store i32 %35, i32* %info22, align 4
  %37 = load %struct.expdesc** %e.addr, align 8
  %k23 = getelementptr inbounds %struct.expdesc* %37, i32 0, i32 0
  store i32 6, i32* %k23, align 4
  br label %return

return:                                           ; preds = %sw.epilog, %sw.default
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @need_value(%struct.FuncState* %fs, i32 %list) #0 {
entry:
  %retval = alloca i32, align 4
  %fs.addr = alloca %struct.FuncState*, align 8
  %list.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store i32 %list, i32* %list.addr, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32* %list.addr, align 4
  %cmp = icmp ne i32 %0, -1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load %struct.FuncState** %fs.addr, align 8
  %2 = load i32* %list.addr, align 4
  %call = call i32* @getjumpcontrol(%struct.FuncState* %1, i32 %2)
  %3 = load i32* %call, align 4
  store i32 %3, i32* %i, align 4
  %4 = load i32* %i, align 4
  %shr = lshr i32 %4, 0
  %and = and i32 %shr, 63
  %cmp1 = icmp ne i32 %and, 28
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  store i32 1, i32* %retval
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %5 = load %struct.FuncState** %fs.addr, align 8
  %6 = load i32* %list.addr, align 4
  %call2 = call i32 @getjump(%struct.FuncState* %5, i32 %6)
  store i32 %call2, i32* %list.addr, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %for.end, %if.then
  %7 = load i32* %retval
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal i32 @code_label(%struct.FuncState* %fs, i32 %A, i32 %b, i32 %jump) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %A.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %jump.addr = alloca i32, align 4
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store i32 %A, i32* %A.addr, align 4
  store i32 %b, i32* %b.addr, align 4
  store i32 %jump, i32* %jump.addr, align 4
  %0 = load %struct.FuncState** %fs.addr, align 8
  %call = call i32 @luaK_getlabel(%struct.FuncState* %0)
  %1 = load %struct.FuncState** %fs.addr, align 8
  %2 = load i32* %A.addr, align 4
  %3 = load i32* %b.addr, align 4
  %4 = load i32* %jump.addr, align 4
  %call1 = call i32 @luaK_codeABC(%struct.FuncState* %1, i32 3, i32 %2, i32 %3, i32 %4)
  ret i32 %call1
}

; Function Attrs: nounwind uwtable
define internal i32* @getjumpcontrol(%struct.FuncState* %fs, i32 %pc) #0 {
entry:
  %retval = alloca i32*, align 8
  %fs.addr = alloca %struct.FuncState*, align 8
  %pc.addr = alloca i32, align 4
  %pi = alloca i32*, align 8
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store i32 %pc, i32* %pc.addr, align 4
  %0 = load i32* %pc.addr, align 4
  %idxprom = sext i32 %0 to i64
  %1 = load %struct.FuncState** %fs.addr, align 8
  %f = getelementptr inbounds %struct.FuncState* %1, i32 0, i32 0
  %2 = load %struct.Proto.36** %f, align 8
  %code = getelementptr inbounds %struct.Proto.36* %2, i32 0, i32 4
  %3 = load i32** %code, align 8
  %arrayidx = getelementptr inbounds i32* %3, i64 %idxprom
  store i32* %arrayidx, i32** %pi, align 8
  %4 = load i32* %pc.addr, align 4
  %cmp = icmp sge i32 %4, 1
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %5 = load i32** %pi, align 8
  %add.ptr = getelementptr inbounds i32* %5, i64 -1
  %6 = load i32* %add.ptr, align 4
  %shr = lshr i32 %6, 0
  %and = and i32 %shr, 63
  %idxprom1 = zext i32 %and to i64
  %arrayidx2 = getelementptr inbounds [40 x i8]* @luaP_opmodes, i32 0, i64 %idxprom1
  %7 = load i8* %arrayidx2, align 1
  %conv = zext i8 %7 to i32
  %and3 = and i32 %conv, 128
  %tobool = icmp ne i32 %and3, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %8 = load i32** %pi, align 8
  %add.ptr4 = getelementptr inbounds i32* %8, i64 -1
  store i32* %add.ptr4, i32** %retval
  br label %return

if.else:                                          ; preds = %land.lhs.true, %entry
  %9 = load i32** %pi, align 8
  store i32* %9, i32** %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %10 = load i32** %retval
  ret i32* %10
}

; Function Attrs: nounwind uwtable
define internal i32 @condjump(%struct.FuncState* %fs, i32 %op, i32 %A, i32 %B, i32 %C) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %op.addr = alloca i32, align 4
  %A.addr = alloca i32, align 4
  %B.addr = alloca i32, align 4
  %C.addr = alloca i32, align 4
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store i32 %op, i32* %op.addr, align 4
  store i32 %A, i32* %A.addr, align 4
  store i32 %B, i32* %B.addr, align 4
  store i32 %C, i32* %C.addr, align 4
  %0 = load %struct.FuncState** %fs.addr, align 8
  %1 = load i32* %op.addr, align 4
  %2 = load i32* %A.addr, align 4
  %3 = load i32* %B.addr, align 4
  %4 = load i32* %C.addr, align 4
  %call = call i32 @luaK_codeABC(%struct.FuncState* %0, i32 %1, i32 %2, i32 %3, i32 %4)
  %5 = load %struct.FuncState** %fs.addr, align 8
  %call1 = call i32 @luaK_jump(%struct.FuncState* %5)
  ret i32 %call1
}

; Function Attrs: nounwind uwtable
define internal void @discharge2anyreg(%struct.FuncState* %fs, %struct.expdesc* %e) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %e.addr = alloca %struct.expdesc*, align 8
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store %struct.expdesc* %e, %struct.expdesc** %e.addr, align 8
  %0 = load %struct.expdesc** %e.addr, align 8
  %k = getelementptr inbounds %struct.expdesc* %0, i32 0, i32 0
  %1 = load i32* %k, align 4
  %cmp = icmp ne i32 %1, 6
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.FuncState** %fs.addr, align 8
  call void @luaK_reserveregs(%struct.FuncState* %2, i32 1)
  %3 = load %struct.FuncState** %fs.addr, align 8
  %4 = load %struct.expdesc** %e.addr, align 8
  %5 = load %struct.FuncState** %fs.addr, align 8
  %freereg = getelementptr inbounds %struct.FuncState* %5, i32 0, i32 14
  %6 = load i8* %freereg, align 1
  %conv = zext i8 %6 to i32
  %sub = sub nsw i32 %conv, 1
  call void @discharge2reg(%struct.FuncState* %3, %struct.expdesc* %4, i32 %sub)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @constfolding(i32 %op, %struct.expdesc* %e1, %struct.expdesc* %e2) #0 {
entry:
  %retval = alloca i32, align 4
  %op.addr = alloca i32, align 4
  %e1.addr = alloca %struct.expdesc*, align 8
  %e2.addr = alloca %struct.expdesc*, align 8
  %r = alloca double, align 8
  store i32 %op, i32* %op.addr, align 4
  store %struct.expdesc* %e1, %struct.expdesc** %e1.addr, align 8
  store %struct.expdesc* %e2, %struct.expdesc** %e2.addr, align 8
  %0 = load %struct.expdesc** %e1.addr, align 8
  %call = call i32 @isnumeral(%struct.expdesc* %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load %struct.expdesc** %e2.addr, align 8
  %call1 = call i32 @isnumeral(%struct.expdesc* %1)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 0, i32* %retval
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %2 = load i32* %op.addr, align 4
  %cmp = icmp eq i32 %2, 16
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false3

lor.lhs.false3:                                   ; preds = %if.end
  %3 = load i32* %op.addr, align 4
  %cmp4 = icmp eq i32 %3, 17
  br i1 %cmp4, label %land.lhs.true, label %if.end7

land.lhs.true:                                    ; preds = %lor.lhs.false3, %if.end
  %4 = load %struct.expdesc** %e2.addr, align 8
  %u = getelementptr inbounds %struct.expdesc* %4, i32 0, i32 1
  %nval = bitcast %union.anon.7* %u to double*
  %5 = load double* %nval, align 8
  %cmp5 = fcmp oeq double %5, 0.000000e+00
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %land.lhs.true
  store i32 0, i32* %retval
  br label %return

if.end7:                                          ; preds = %land.lhs.true, %lor.lhs.false3
  %6 = load i32* %op.addr, align 4
  %sub = sub i32 %6, 13
  %add = add i32 %sub, 0
  %7 = load %struct.expdesc** %e1.addr, align 8
  %u8 = getelementptr inbounds %struct.expdesc* %7, i32 0, i32 1
  %nval9 = bitcast %union.anon.7* %u8 to double*
  %8 = load double* %nval9, align 8
  %9 = load %struct.expdesc** %e2.addr, align 8
  %u10 = getelementptr inbounds %struct.expdesc* %9, i32 0, i32 1
  %nval11 = bitcast %union.anon.7* %u10 to double*
  %10 = load double* %nval11, align 8
  %call12 = call double @luaO_arith(i32 %add, double %8, double %10)
  store double %call12, double* %r, align 8
  %11 = load double* %r, align 8
  %12 = load %struct.expdesc** %e1.addr, align 8
  %u13 = getelementptr inbounds %struct.expdesc* %12, i32 0, i32 1
  %nval14 = bitcast %union.anon.7* %u13 to double*
  store double %11, double* %nval14, align 8
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %if.end7, %if.then6, %if.then
  %13 = load i32* %retval
  ret i32 %13
}

; Function Attrs: nounwind uwtable
define internal void @removevalues(%struct.FuncState* %fs, i32 %list) #0 {
entry:
  %fs.addr = alloca %struct.FuncState*, align 8
  %list.addr = alloca i32, align 4
  store %struct.FuncState* %fs, %struct.FuncState** %fs.addr, align 8
  store i32 %list, i32* %list.addr, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32* %list.addr, align 4
  %cmp = icmp ne i32 %0, -1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load %struct.FuncState** %fs.addr, align 8
  %2 = load i32* %list.addr, align 4
  %call = call i32 @patchtestreg(%struct.FuncState* %1, i32 %2, i32 255)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %3 = load %struct.FuncState** %fs.addr, align 8
  %4 = load i32* %list.addr, align 4
  %call1 = call i32 @getjump(%struct.FuncState* %3, i32 %4)
  store i32 %call1, i32* %list.addr, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @luaopen_coroutine(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 6)
  %1 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_setfuncs(%struct.lua_State* %1, %struct.luaL_Reg* getelementptr inbounds ([7 x %struct.luaL_Reg]* @co_funcs, i32 0, i32 0), i32 0)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_cocreate(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %NL = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_checktype(%struct.lua_State* %0, i32 1, i32 6)
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call %struct.lua_State* bitcast (%struct.lua_State.343* (%struct.lua_State.343*)* @lua_newthread to %struct.lua_State* (%struct.lua_State*)*)(%struct.lua_State* %1)
  store %struct.lua_State* %call, %struct.lua_State** %NL, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushvalue(%struct.lua_State* %2, i32 1)
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load %struct.lua_State** %NL, align 8
  call void @lua_xmove(%struct.lua_State* %3, %struct.lua_State* %4, i32 1)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_coresume(%struct.lua_State* %L) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %co = alloca %struct.lua_State*, align 8
  %r = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call %struct.lua_State* @lua_tothread(%struct.lua_State* %0, i32 1)
  store %struct.lua_State* %call, %struct.lua_State** %co, align 8
  %1 = load %struct.lua_State** %co, align 8
  %tobool = icmp ne %struct.lua_State* %1, null
  br i1 %tobool, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %2 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i32 @luaL_argerror(%struct.lua_State* %2, i32 1, i8* getelementptr inbounds ([19 x i8]* @.str9136, i32 0, i32 0))
  %tobool2 = icmp ne i32 %call1, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %3 = phi i1 [ true, %entry ], [ %tobool2, %lor.rhs ]
  %lor.ext = zext i1 %3 to i32
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load %struct.lua_State** %co, align 8
  %6 = load %struct.lua_State** %L.addr, align 8
  %call3 = call i32 @lua_gettop(%struct.lua_State* %6)
  %sub = sub nsw i32 %call3, 1
  %call4 = call i32 @auxresume(%struct.lua_State* %4, %struct.lua_State* %5, i32 %sub)
  store i32 %call4, i32* %r, align 4
  %7 = load i32* %r, align 4
  %cmp = icmp slt i32 %7, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %lor.end
  %8 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushboolean(%struct.lua_State* %8, i32 0)
  %9 = load %struct.lua_State** %L.addr, align 8
  call void @lua_insert(%struct.lua_State* %9, i32 -2)
  store i32 2, i32* %retval
  br label %return

if.else:                                          ; preds = %lor.end
  %10 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushboolean(%struct.lua_State* %10, i32 1)
  %11 = load %struct.lua_State** %L.addr, align 8
  %12 = load i32* %r, align 4
  %add = add nsw i32 %12, 1
  %sub5 = sub nsw i32 0, %add
  call void @lua_insert(%struct.lua_State* %11, i32 %sub5)
  %13 = load i32* %r, align 4
  %add6 = add nsw i32 %13, 1
  store i32 %add6, i32* %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %14 = load i32* %retval
  ret i32 %14
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_corunning(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %ismain = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_pushthread(%struct.lua_State* %0)
  store i32 %call, i32* %ismain, align 4
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load i32* %ismain, align 4
  call void @lua_pushboolean(%struct.lua_State* %1, i32 %2)
  ret i32 2
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_costatus(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %co = alloca %struct.lua_State*, align 8
  %ar = alloca %struct.lua_Debug, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call %struct.lua_State* @lua_tothread(%struct.lua_State* %0, i32 1)
  store %struct.lua_State* %call, %struct.lua_State** %co, align 8
  %1 = load %struct.lua_State** %co, align 8
  %tobool = icmp ne %struct.lua_State* %1, null
  br i1 %tobool, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %2 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i32 @luaL_argerror(%struct.lua_State* %2, i32 1, i8* getelementptr inbounds ([19 x i8]* @.str9136, i32 0, i32 0))
  %tobool2 = icmp ne i32 %call1, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %3 = phi i1 [ true, %entry ], [ %tobool2, %lor.rhs ]
  %lor.ext = zext i1 %3 to i32
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load %struct.lua_State** %co, align 8
  %cmp = icmp eq %struct.lua_State* %4, %5
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %lor.end
  %6 = load %struct.lua_State** %L.addr, align 8
  %call3 = call i8* @lua_pushlstring(%struct.lua_State* %6, i8* getelementptr inbounds ([8 x i8]* @.str2129, i32 0, i32 0), i64 7)
  br label %if.end20

if.else:                                          ; preds = %lor.end
  %7 = load %struct.lua_State** %co, align 8
  %call4 = call i32 @lua_status(%struct.lua_State* %7)
  switch i32 %call4, label %sw.default [
    i32 1, label %sw.bb
    i32 0, label %sw.bb6
  ]

sw.bb:                                            ; preds = %if.else
  %8 = load %struct.lua_State** %L.addr, align 8
  %call5 = call i8* @lua_pushlstring(%struct.lua_State* %8, i8* getelementptr inbounds ([10 x i8]* @.str10137, i32 0, i32 0), i64 9)
  br label %sw.epilog

sw.bb6:                                           ; preds = %if.else
  %9 = load %struct.lua_State** %co, align 8
  %call7 = call i32 @lua_getstack(%struct.lua_State* %9, i32 0, %struct.lua_Debug* %ar)
  %cmp8 = icmp sgt i32 %call7, 0
  br i1 %cmp8, label %if.then9, label %if.else11

if.then9:                                         ; preds = %sw.bb6
  %10 = load %struct.lua_State** %L.addr, align 8
  %call10 = call i8* @lua_pushlstring(%struct.lua_State* %10, i8* getelementptr inbounds ([7 x i8]* @.str11138, i32 0, i32 0), i64 6)
  br label %if.end18

if.else11:                                        ; preds = %sw.bb6
  %11 = load %struct.lua_State** %co, align 8
  %call12 = call i32 @lua_gettop(%struct.lua_State* %11)
  %cmp13 = icmp eq i32 %call12, 0
  br i1 %cmp13, label %if.then14, label %if.else16

if.then14:                                        ; preds = %if.else11
  %12 = load %struct.lua_State** %L.addr, align 8
  %call15 = call i8* @lua_pushlstring(%struct.lua_State* %12, i8* getelementptr inbounds ([5 x i8]* @.str12139, i32 0, i32 0), i64 4)
  br label %if.end

if.else16:                                        ; preds = %if.else11
  %13 = load %struct.lua_State** %L.addr, align 8
  %call17 = call i8* @lua_pushlstring(%struct.lua_State* %13, i8* getelementptr inbounds ([10 x i8]* @.str10137, i32 0, i32 0), i64 9)
  br label %if.end

if.end:                                           ; preds = %if.else16, %if.then14
  br label %if.end18

if.end18:                                         ; preds = %if.end, %if.then9
  br label %sw.epilog

sw.default:                                       ; preds = %if.else
  %14 = load %struct.lua_State** %L.addr, align 8
  %call19 = call i8* @lua_pushlstring(%struct.lua_State* %14, i8* getelementptr inbounds ([5 x i8]* @.str12139, i32 0, i32 0), i64 4)
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.end18, %sw.bb
  br label %if.end20

if.end20:                                         ; preds = %sw.epilog, %if.then
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_cowrap(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @luaB_cocreate(%struct.lua_State* %0)
  %1 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushcclosure(%struct.lua_State* %1, i32 (%struct.lua_State*)* @luaB_auxwrap, i32 1)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_yield(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_gettop(%struct.lua_State* %1)
  %call1 = call i32 @lua_yieldk(%struct.lua_State* %0, i32 %call, i32 0, i32 (%struct.lua_State*)* null)
  ret i32 %call1
}

; Function Attrs: nounwind uwtable
define internal i32 @auxresume(%struct.lua_State* %L, %struct.lua_State* %co, i32 %narg) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %co.addr = alloca %struct.lua_State*, align 8
  %narg.addr = alloca i32, align 4
  %status = alloca i32, align 4
  %nres = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.lua_State* %co, %struct.lua_State** %co.addr, align 8
  store i32 %narg, i32* %narg.addr, align 4
  %0 = load %struct.lua_State** %co.addr, align 8
  %1 = load i32* %narg.addr, align 4
  %call = call i32 @lua_checkstack(%struct.lua_State* %0, i32 %1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i8* @lua_pushlstring(%struct.lua_State* %2, i8* getelementptr inbounds ([29 x i8]* @.str6133, i32 0, i32 0), i64 28)
  store i32 -1, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %3 = load %struct.lua_State** %co.addr, align 8
  %call2 = call i32 @lua_status(%struct.lua_State* %3)
  %cmp = icmp eq i32 %call2, 0
  br i1 %cmp, label %land.lhs.true, label %if.end7

land.lhs.true:                                    ; preds = %if.end
  %4 = load %struct.lua_State** %co.addr, align 8
  %call3 = call i32 @lua_gettop(%struct.lua_State* %4)
  %cmp4 = icmp eq i32 %call3, 0
  br i1 %cmp4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %land.lhs.true
  %5 = load %struct.lua_State** %L.addr, align 8
  %call6 = call i8* @lua_pushlstring(%struct.lua_State* %5, i8* getelementptr inbounds ([29 x i8]* @.str7134, i32 0, i32 0), i64 28)
  store i32 -1, i32* %retval
  br label %return

if.end7:                                          ; preds = %land.lhs.true, %if.end
  %6 = load %struct.lua_State** %L.addr, align 8
  %7 = load %struct.lua_State** %co.addr, align 8
  %8 = load i32* %narg.addr, align 4
  call void @lua_xmove(%struct.lua_State* %6, %struct.lua_State* %7, i32 %8)
  %9 = load %struct.lua_State** %co.addr, align 8
  %10 = load %struct.lua_State** %L.addr, align 8
  %11 = load i32* %narg.addr, align 4
  %call8 = call i32 @lua_resume(%struct.lua_State* %9, %struct.lua_State* %10, i32 %11)
  store i32 %call8, i32* %status, align 4
  %12 = load i32* %status, align 4
  %cmp9 = icmp eq i32 %12, 0
  br i1 %cmp9, label %if.then11, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end7
  %13 = load i32* %status, align 4
  %cmp10 = icmp eq i32 %13, 1
  br i1 %cmp10, label %if.then11, label %if.else

if.then11:                                        ; preds = %lor.lhs.false, %if.end7
  %14 = load %struct.lua_State** %co.addr, align 8
  %call12 = call i32 @lua_gettop(%struct.lua_State* %14)
  store i32 %call12, i32* %nres, align 4
  %15 = load %struct.lua_State** %L.addr, align 8
  %16 = load i32* %nres, align 4
  %add = add nsw i32 %16, 1
  %call13 = call i32 @lua_checkstack(%struct.lua_State* %15, i32 %add)
  %tobool14 = icmp ne i32 %call13, 0
  br i1 %tobool14, label %if.end18, label %if.then15

if.then15:                                        ; preds = %if.then11
  %17 = load %struct.lua_State** %co.addr, align 8
  %18 = load i32* %nres, align 4
  %sub = sub nsw i32 0, %18
  %sub16 = sub nsw i32 %sub, 1
  call void @lua_settop(%struct.lua_State* %17, i32 %sub16)
  %19 = load %struct.lua_State** %L.addr, align 8
  %call17 = call i8* @lua_pushlstring(%struct.lua_State* %19, i8* getelementptr inbounds ([27 x i8]* @.str8135, i32 0, i32 0), i64 26)
  store i32 -1, i32* %retval
  br label %return

if.end18:                                         ; preds = %if.then11
  %20 = load %struct.lua_State** %co.addr, align 8
  %21 = load %struct.lua_State** %L.addr, align 8
  %22 = load i32* %nres, align 4
  call void @lua_xmove(%struct.lua_State* %20, %struct.lua_State* %21, i32 %22)
  %23 = load i32* %nres, align 4
  store i32 %23, i32* %retval
  br label %return

if.else:                                          ; preds = %lor.lhs.false
  %24 = load %struct.lua_State** %co.addr, align 8
  %25 = load %struct.lua_State** %L.addr, align 8
  call void @lua_xmove(%struct.lua_State* %24, %struct.lua_State* %25, i32 1)
  store i32 -1, i32* %retval
  br label %return

return:                                           ; preds = %if.else, %if.end18, %if.then15, %if.then5, %if.then
  %26 = load i32* %retval
  ret i32 %26
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_auxwrap(%struct.lua_State* %L) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %co = alloca %struct.lua_State*, align 8
  %r = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call %struct.lua_State* @lua_tothread(%struct.lua_State* %0, i32 -1001001)
  store %struct.lua_State* %call, %struct.lua_State** %co, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load %struct.lua_State** %co, align 8
  %3 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i32 @lua_gettop(%struct.lua_State* %3)
  %call2 = call i32 @auxresume(%struct.lua_State* %1, %struct.lua_State* %2, i32 %call1)
  store i32 %call2, i32* %r, align 4
  %4 = load i32* %r, align 4
  %cmp = icmp slt i32 %4, 0
  br i1 %cmp, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %5 = load %struct.lua_State** %L.addr, align 8
  %call3 = call i32 @lua_isstring(%struct.lua_State* %5, i32 -1)
  %tobool = icmp ne i32 %call3, 0
  br i1 %tobool, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  %6 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_where(%struct.lua_State* %6, i32 1)
  %7 = load %struct.lua_State** %L.addr, align 8
  call void @lua_insert(%struct.lua_State* %7, i32 -2)
  %8 = load %struct.lua_State** %L.addr, align 8
  call void @lua_concat(%struct.lua_State* %8, i32 2)
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then
  %9 = load %struct.lua_State** %L.addr, align 8
  %call5 = call i32 @lua_error(%struct.lua_State* %9)
  store i32 %call5, i32* %retval
  br label %return

if.end6:                                          ; preds = %entry
  %10 = load i32* %r, align 4
  store i32 %10, i32* %retval
  br label %return

return:                                           ; preds = %if.end6, %if.end
  %11 = load i32* %retval
  ret i32 %11
}

; Function Attrs: nounwind uwtable
define i32 @luaopen_debug(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 16)
  %1 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_setfuncs(%struct.lua_State* %1, %struct.luaL_Reg* getelementptr inbounds ([17 x %struct.luaL_Reg]* @dblib, i32 0, i32 0), i32 0)
  ret i32 1
}

; Function Attrs: nounwind readonly
declare i8* @strchr(i8*, i32) #2

declare i8* @fgets(i8*, i32, %struct._IO_FILE*) #5

; Function Attrs: nounwind uwtable
define internal i32 @db_debug(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %buffer = alloca [250 x i8], align 16
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  br label %for.cond

for.cond:                                         ; preds = %if.end17, %entry
  %0 = load %struct._IO_FILE** @stderr, align 8
  %call = call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %0, i8* getelementptr inbounds ([3 x i8]* @.str49189, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8]* @.str50190, i32 0, i32 0))
  %1 = load %struct._IO_FILE** @stderr, align 8
  %call1 = call i32 @fflush(%struct._IO_FILE* %1)
  %arraydecay = getelementptr inbounds [250 x i8]* %buffer, i32 0, i32 0
  %2 = load %struct._IO_FILE** @stdin, align 8
  %call2 = call i8* @fgets(i8* %arraydecay, i32 250, %struct._IO_FILE* %2)
  %cmp = icmp eq i8* %call2, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.cond
  %arraydecay3 = getelementptr inbounds [250 x i8]* %buffer, i32 0, i32 0
  %call4 = call i32 @strcmp(i8* %arraydecay3, i8* getelementptr inbounds ([6 x i8]* @.str51191, i32 0, i32 0)) #10
  %cmp5 = icmp eq i32 %call4, 0
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %for.cond
  ret i32 0

if.end:                                           ; preds = %lor.lhs.false
  %3 = load %struct.lua_State** %L.addr, align 8
  %arraydecay6 = getelementptr inbounds [250 x i8]* %buffer, i32 0, i32 0
  %arraydecay7 = getelementptr inbounds [250 x i8]* %buffer, i32 0, i32 0
  %call8 = call i64 @strlen(i8* %arraydecay7) #10
  %call9 = call i32 @luaL_loadbufferx(%struct.lua_State* %3, i8* %arraydecay6, i64 %call8, i8* getelementptr inbounds ([17 x i8]* @.str52192, i32 0, i32 0), i8* null)
  %tobool = icmp ne i32 %call9, 0
  br i1 %tobool, label %if.then13, label %lor.lhs.false10

lor.lhs.false10:                                  ; preds = %if.end
  %4 = load %struct.lua_State** %L.addr, align 8
  %call11 = call i32 @lua_pcallk(%struct.lua_State* %4, i32 0, i32 0, i32 0, i32 0, i32 (%struct.lua_State*)* null)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %if.then13, label %if.end17

if.then13:                                        ; preds = %lor.lhs.false10, %if.end
  %5 = load %struct._IO_FILE** @stderr, align 8
  %6 = load %struct.lua_State** %L.addr, align 8
  %call14 = call i8* @lua_tolstring(%struct.lua_State* %6, i32 -1, i64* null)
  %call15 = call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %5, i8* getelementptr inbounds ([4 x i8]* @.str53193, i32 0, i32 0), i8* %call14)
  %7 = load %struct._IO_FILE** @stderr, align 8
  %call16 = call i32 @fflush(%struct._IO_FILE* %7)
  br label %if.end17

if.end17:                                         ; preds = %if.then13, %lor.lhs.false10
  %8 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %8, i32 0)
  br label %for.cond
}

; Function Attrs: nounwind uwtable
define internal i32 @db_getuservalue(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_type(%struct.lua_State* %0, i32 1)
  %cmp = icmp ne i32 %call, 7
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushnil(%struct.lua_State* %1)
  br label %if.end

if.else:                                          ; preds = %entry
  %2 = load %struct.lua_State** %L.addr, align 8
  call void @lua_getuservalue(%struct.lua_State* %2, i32 1)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @db_gethook(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %arg = alloca i32, align 4
  %L1 = alloca %struct.lua_State*, align 8
  %buff = alloca [5 x i8], align 1
  %mask = alloca i32, align 4
  %hook = alloca void (%struct.lua_State*, %struct.lua_Debug*)*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call %struct.lua_State* @getthread(%struct.lua_State* %0, i32* %arg)
  store %struct.lua_State* %call, %struct.lua_State** %L1, align 8
  %1 = load %struct.lua_State** %L1, align 8
  %call1 = call i32 @lua_gethookmask(%struct.lua_State* %1)
  store i32 %call1, i32* %mask, align 4
  %2 = load %struct.lua_State** %L1, align 8
  %call2 = call void (%struct.lua_State*, %struct.lua_Debug*)* (%struct.lua_State*)* @lua_gethook(%struct.lua_State* %2)
  store void (%struct.lua_State*, %struct.lua_Debug*)* %call2, void (%struct.lua_State*, %struct.lua_Debug*)** %hook, align 8
  %3 = load void (%struct.lua_State*, %struct.lua_Debug*)** %hook, align 8
  %cmp = icmp ne void (%struct.lua_State*, %struct.lua_Debug*)* %3, null
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %4 = load void (%struct.lua_State*, %struct.lua_Debug*)** %hook, align 8
  %cmp3 = icmp ne void (%struct.lua_State*, %struct.lua_Debug*)* %4, @hookf
  br i1 %cmp3, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %5 = load %struct.lua_State** %L.addr, align 8
  %call4 = call i8* @lua_pushlstring(%struct.lua_State* %5, i8* getelementptr inbounds ([14 x i8]* @.str48188, i32 0, i32 0), i64 13)
  br label %if.end

if.else:                                          ; preds = %land.lhs.true, %entry
  %6 = load %struct.lua_State** %L.addr, align 8
  %call5 = call i32 @luaL_getsubtable(%struct.lua_State* %6, i32 -1001000, i8* getelementptr inbounds ([6 x i8]* @.str18158, i32 0, i32 0))
  %7 = load %struct.lua_State** %L1, align 8
  %call6 = call i32 @lua_pushthread(%struct.lua_State* %7)
  %8 = load %struct.lua_State** %L1, align 8
  %9 = load %struct.lua_State** %L.addr, align 8
  call void @lua_xmove(%struct.lua_State* %8, %struct.lua_State* %9, i32 1)
  %10 = load %struct.lua_State** %L.addr, align 8
  call void @lua_rawget(%struct.lua_State* %10, i32 -2)
  %11 = load %struct.lua_State** %L.addr, align 8
  call void @lua_remove(%struct.lua_State* %11, i32 -2)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %12 = load %struct.lua_State** %L.addr, align 8
  %13 = load i32* %mask, align 4
  %arraydecay = getelementptr inbounds [5 x i8]* %buff, i32 0, i32 0
  %call7 = call i8* @unmakemask(i32 %13, i8* %arraydecay)
  %call8 = call i8* @lua_pushstring(%struct.lua_State* %12, i8* %call7)
  %14 = load %struct.lua_State** %L.addr, align 8
  %15 = load %struct.lua_State** %L1, align 8
  %call9 = call i32 @lua_gethookcount(%struct.lua_State* %15)
  %conv = sext i32 %call9 to i64
  call void @lua_pushinteger(%struct.lua_State* %14, i64 %conv)
  ret i32 3
}

; Function Attrs: nounwind uwtable
define internal i32 @db_getinfo(%struct.lua_State* %L) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %ar = alloca %struct.lua_Debug, align 8
  %arg = alloca i32, align 4
  %L1 = alloca %struct.lua_State*, align 8
  %options = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call %struct.lua_State* @getthread(%struct.lua_State* %0, i32* %arg)
  store %struct.lua_State* %call, %struct.lua_State** %L1, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load i32* %arg, align 4
  %add = add nsw i32 %2, 2
  %call1 = call i8* @luaL_optlstring(%struct.lua_State* %1, i32 %add, i8* getelementptr inbounds ([7 x i8]* @.str30170, i32 0, i32 0), i64* null)
  store i8* %call1, i8** %options, align 8
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load i32* %arg, align 4
  %add2 = add nsw i32 %4, 1
  %call3 = call i32 @lua_isnumber(%struct.lua_State* %3, i32 %add2)
  %tobool = icmp ne i32 %call3, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %5 = load %struct.lua_State** %L1, align 8
  %6 = load %struct.lua_State** %L.addr, align 8
  %7 = load i32* %arg, align 4
  %add4 = add nsw i32 %7, 1
  %call5 = call i64 @lua_tointegerx(%struct.lua_State* %6, i32 %add4, i32* null)
  %conv = trunc i64 %call5 to i32
  %call6 = call i32 @lua_getstack(%struct.lua_State* %5, i32 %conv, %struct.lua_Debug* %ar)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.end, label %if.then8

if.then8:                                         ; preds = %if.then
  %8 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushnil(%struct.lua_State* %8)
  store i32 1, i32* %retval
  br label %return

if.end:                                           ; preds = %if.then
  br label %if.end20

if.else:                                          ; preds = %entry
  %9 = load %struct.lua_State** %L.addr, align 8
  %10 = load i32* %arg, align 4
  %add9 = add nsw i32 %10, 1
  %call10 = call i32 @lua_type(%struct.lua_State* %9, i32 %add9)
  %cmp = icmp eq i32 %call10, 6
  br i1 %cmp, label %if.then12, label %if.else16

if.then12:                                        ; preds = %if.else
  %11 = load %struct.lua_State** %L.addr, align 8
  %12 = load i8** %options, align 8
  %call13 = call i8* (%struct.lua_State*, i8*, ...)* @lua_pushfstring(%struct.lua_State* %11, i8* getelementptr inbounds ([4 x i8]* @.str31171, i32 0, i32 0), i8* %12)
  %13 = load %struct.lua_State** %L.addr, align 8
  %call14 = call i8* @lua_tolstring(%struct.lua_State* %13, i32 -1, i64* null)
  store i8* %call14, i8** %options, align 8
  %14 = load %struct.lua_State** %L.addr, align 8
  %15 = load i32* %arg, align 4
  %add15 = add nsw i32 %15, 1
  call void @lua_pushvalue(%struct.lua_State* %14, i32 %add15)
  %16 = load %struct.lua_State** %L.addr, align 8
  %17 = load %struct.lua_State** %L1, align 8
  call void @lua_xmove(%struct.lua_State* %16, %struct.lua_State* %17, i32 1)
  br label %if.end19

if.else16:                                        ; preds = %if.else
  %18 = load %struct.lua_State** %L.addr, align 8
  %19 = load i32* %arg, align 4
  %add17 = add nsw i32 %19, 1
  %call18 = call i32 @luaL_argerror(%struct.lua_State* %18, i32 %add17, i8* getelementptr inbounds ([27 x i8]* @.str32172, i32 0, i32 0))
  store i32 %call18, i32* %retval
  br label %return

if.end19:                                         ; preds = %if.then12
  br label %if.end20

if.end20:                                         ; preds = %if.end19, %if.end
  %20 = load %struct.lua_State** %L1, align 8
  %21 = load i8** %options, align 8
  %call21 = call i32 @lua_getinfo(%struct.lua_State* %20, i8* %21, %struct.lua_Debug* %ar)
  %tobool22 = icmp ne i32 %call21, 0
  br i1 %tobool22, label %if.end26, label %if.then23

if.then23:                                        ; preds = %if.end20
  %22 = load %struct.lua_State** %L.addr, align 8
  %23 = load i32* %arg, align 4
  %add24 = add nsw i32 %23, 2
  %call25 = call i32 @luaL_argerror(%struct.lua_State* %22, i32 %add24, i8* getelementptr inbounds ([15 x i8]* @.str33173, i32 0, i32 0))
  store i32 %call25, i32* %retval
  br label %return

if.end26:                                         ; preds = %if.end20
  %24 = load %struct.lua_State** %L.addr, align 8
  call void @lua_createtable(%struct.lua_State* %24, i32 0, i32 2)
  %25 = load i8** %options, align 8
  %call27 = call i8* @strchr(i8* %25, i32 83) #10
  %tobool28 = icmp ne i8* %call27, null
  br i1 %tobool28, label %if.then29, label %if.end30

if.then29:                                        ; preds = %if.end26
  %26 = load %struct.lua_State** %L.addr, align 8
  %source = getelementptr inbounds %struct.lua_Debug* %ar, i32 0, i32 4
  %27 = load i8** %source, align 8
  call void @settabss(%struct.lua_State* %26, i8* getelementptr inbounds ([7 x i8]* @.str34174, i32 0, i32 0), i8* %27)
  %28 = load %struct.lua_State** %L.addr, align 8
  %short_src = getelementptr inbounds %struct.lua_Debug* %ar, i32 0, i32 12
  %arraydecay = getelementptr inbounds [60 x i8]* %short_src, i32 0, i32 0
  call void @settabss(%struct.lua_State* %28, i8* getelementptr inbounds ([10 x i8]* @.str35175, i32 0, i32 0), i8* %arraydecay)
  %29 = load %struct.lua_State** %L.addr, align 8
  %linedefined = getelementptr inbounds %struct.lua_Debug* %ar, i32 0, i32 6
  %30 = load i32* %linedefined, align 4
  call void @settabsi(%struct.lua_State* %29, i8* getelementptr inbounds ([12 x i8]* @.str36176, i32 0, i32 0), i32 %30)
  %31 = load %struct.lua_State** %L.addr, align 8
  %lastlinedefined = getelementptr inbounds %struct.lua_Debug* %ar, i32 0, i32 7
  %32 = load i32* %lastlinedefined, align 4
  call void @settabsi(%struct.lua_State* %31, i8* getelementptr inbounds ([16 x i8]* @.str37177, i32 0, i32 0), i32 %32)
  %33 = load %struct.lua_State** %L.addr, align 8
  %what = getelementptr inbounds %struct.lua_Debug* %ar, i32 0, i32 3
  %34 = load i8** %what, align 8
  call void @settabss(%struct.lua_State* %33, i8* getelementptr inbounds ([5 x i8]* @.str38178, i32 0, i32 0), i8* %34)
  br label %if.end30

if.end30:                                         ; preds = %if.then29, %if.end26
  %35 = load i8** %options, align 8
  %call31 = call i8* @strchr(i8* %35, i32 108) #10
  %tobool32 = icmp ne i8* %call31, null
  br i1 %tobool32, label %if.then33, label %if.end34

if.then33:                                        ; preds = %if.end30
  %36 = load %struct.lua_State** %L.addr, align 8
  %currentline = getelementptr inbounds %struct.lua_Debug* %ar, i32 0, i32 5
  %37 = load i32* %currentline, align 4
  call void @settabsi(%struct.lua_State* %36, i8* getelementptr inbounds ([12 x i8]* @.str39179, i32 0, i32 0), i32 %37)
  br label %if.end34

if.end34:                                         ; preds = %if.then33, %if.end30
  %38 = load i8** %options, align 8
  %call35 = call i8* @strchr(i8* %38, i32 117) #10
  %tobool36 = icmp ne i8* %call35, null
  br i1 %tobool36, label %if.then37, label %if.end41

if.then37:                                        ; preds = %if.end34
  %39 = load %struct.lua_State** %L.addr, align 8
  %nups = getelementptr inbounds %struct.lua_Debug* %ar, i32 0, i32 8
  %40 = load i8* %nups, align 1
  %conv38 = zext i8 %40 to i32
  call void @settabsi(%struct.lua_State* %39, i8* getelementptr inbounds ([5 x i8]* @.str40180, i32 0, i32 0), i32 %conv38)
  %41 = load %struct.lua_State** %L.addr, align 8
  %nparams = getelementptr inbounds %struct.lua_Debug* %ar, i32 0, i32 9
  %42 = load i8* %nparams, align 1
  %conv39 = zext i8 %42 to i32
  call void @settabsi(%struct.lua_State* %41, i8* getelementptr inbounds ([8 x i8]* @.str41181, i32 0, i32 0), i32 %conv39)
  %43 = load %struct.lua_State** %L.addr, align 8
  %isvararg = getelementptr inbounds %struct.lua_Debug* %ar, i32 0, i32 10
  %44 = load i8* %isvararg, align 1
  %conv40 = sext i8 %44 to i32
  call void @settabsb(%struct.lua_State* %43, i8* getelementptr inbounds ([9 x i8]* @.str42182, i32 0, i32 0), i32 %conv40)
  br label %if.end41

if.end41:                                         ; preds = %if.then37, %if.end34
  %45 = load i8** %options, align 8
  %call42 = call i8* @strchr(i8* %45, i32 110) #10
  %tobool43 = icmp ne i8* %call42, null
  br i1 %tobool43, label %if.then44, label %if.end45

if.then44:                                        ; preds = %if.end41
  %46 = load %struct.lua_State** %L.addr, align 8
  %name = getelementptr inbounds %struct.lua_Debug* %ar, i32 0, i32 1
  %47 = load i8** %name, align 8
  call void @settabss(%struct.lua_State* %46, i8* getelementptr inbounds ([5 x i8]* @.str43183, i32 0, i32 0), i8* %47)
  %48 = load %struct.lua_State** %L.addr, align 8
  %namewhat = getelementptr inbounds %struct.lua_Debug* %ar, i32 0, i32 2
  %49 = load i8** %namewhat, align 8
  call void @settabss(%struct.lua_State* %48, i8* getelementptr inbounds ([9 x i8]* @.str44184, i32 0, i32 0), i8* %49)
  br label %if.end45

if.end45:                                         ; preds = %if.then44, %if.end41
  %50 = load i8** %options, align 8
  %call46 = call i8* @strchr(i8* %50, i32 116) #10
  %tobool47 = icmp ne i8* %call46, null
  br i1 %tobool47, label %if.then48, label %if.end50

if.then48:                                        ; preds = %if.end45
  %51 = load %struct.lua_State** %L.addr, align 8
  %istailcall = getelementptr inbounds %struct.lua_Debug* %ar, i32 0, i32 11
  %52 = load i8* %istailcall, align 1
  %conv49 = sext i8 %52 to i32
  call void @settabsb(%struct.lua_State* %51, i8* getelementptr inbounds ([11 x i8]* @.str45185, i32 0, i32 0), i32 %conv49)
  br label %if.end50

if.end50:                                         ; preds = %if.then48, %if.end45
  %53 = load i8** %options, align 8
  %call51 = call i8* @strchr(i8* %53, i32 76) #10
  %tobool52 = icmp ne i8* %call51, null
  br i1 %tobool52, label %if.then53, label %if.end54

if.then53:                                        ; preds = %if.end50
  %54 = load %struct.lua_State** %L.addr, align 8
  %55 = load %struct.lua_State** %L1, align 8
  call void @treatstackoption(%struct.lua_State* %54, %struct.lua_State* %55, i8* getelementptr inbounds ([12 x i8]* @.str46186, i32 0, i32 0))
  br label %if.end54

if.end54:                                         ; preds = %if.then53, %if.end50
  %56 = load i8** %options, align 8
  %call55 = call i8* @strchr(i8* %56, i32 102) #10
  %tobool56 = icmp ne i8* %call55, null
  br i1 %tobool56, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.end54
  %57 = load %struct.lua_State** %L.addr, align 8
  %58 = load %struct.lua_State** %L1, align 8
  call void @treatstackoption(%struct.lua_State* %57, %struct.lua_State* %58, i8* getelementptr inbounds ([5 x i8]* @.str47187, i32 0, i32 0))
  br label %if.end58

if.end58:                                         ; preds = %if.then57, %if.end54
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %if.end58, %if.then23, %if.else16, %if.then8
  %59 = load i32* %retval
  ret i32 %59
}

; Function Attrs: nounwind uwtable
define internal i32 @db_getlocal(%struct.lua_State* %L) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %arg = alloca i32, align 4
  %L1 = alloca %struct.lua_State*, align 8
  %ar = alloca %struct.lua_Debug, align 8
  %name = alloca i8*, align 8
  %nvar = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call %struct.lua_State* @getthread(%struct.lua_State* %0, i32* %arg)
  store %struct.lua_State* %call, %struct.lua_State** %L1, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load i32* %arg, align 4
  %add = add nsw i32 %2, 2
  %call1 = call i64 @luaL_checkinteger(%struct.lua_State* %1, i32 %add)
  %conv = trunc i64 %call1 to i32
  store i32 %conv, i32* %nvar, align 4
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load i32* %arg, align 4
  %add2 = add nsw i32 %4, 1
  %call3 = call i32 @lua_type(%struct.lua_State* %3, i32 %add2)
  %cmp = icmp eq i32 %call3, 6
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %5 = load %struct.lua_State** %L.addr, align 8
  %6 = load i32* %arg, align 4
  %add5 = add nsw i32 %6, 1
  call void @lua_pushvalue(%struct.lua_State* %5, i32 %add5)
  %7 = load %struct.lua_State** %L.addr, align 8
  %8 = load %struct.lua_State** %L.addr, align 8
  %9 = load i32* %nvar, align 4
  %call6 = call i8* @lua_getlocal(%struct.lua_State* %8, %struct.lua_Debug* null, i32 %9)
  %call7 = call i8* @lua_pushstring(%struct.lua_State* %7, i8* %call6)
  store i32 1, i32* %retval
  br label %return

if.else:                                          ; preds = %entry
  %10 = load %struct.lua_State** %L1, align 8
  %11 = load %struct.lua_State** %L.addr, align 8
  %12 = load i32* %arg, align 4
  %add8 = add nsw i32 %12, 1
  %call9 = call i64 @luaL_checkinteger(%struct.lua_State* %11, i32 %add8)
  %conv10 = trunc i64 %call9 to i32
  %call11 = call i32 @lua_getstack(%struct.lua_State* %10, i32 %conv10, %struct.lua_Debug* %ar)
  %tobool = icmp ne i32 %call11, 0
  br i1 %tobool, label %if.end, label %if.then12

if.then12:                                        ; preds = %if.else
  %13 = load %struct.lua_State** %L.addr, align 8
  %14 = load i32* %arg, align 4
  %add13 = add nsw i32 %14, 1
  %call14 = call i32 @luaL_argerror(%struct.lua_State* %13, i32 %add13, i8* getelementptr inbounds ([19 x i8]* @.str17157, i32 0, i32 0))
  store i32 %call14, i32* %retval
  br label %return

if.end:                                           ; preds = %if.else
  %15 = load %struct.lua_State** %L1, align 8
  %16 = load i32* %nvar, align 4
  %call15 = call i8* @lua_getlocal(%struct.lua_State* %15, %struct.lua_Debug* %ar, i32 %16)
  store i8* %call15, i8** %name, align 8
  %17 = load i8** %name, align 8
  %tobool16 = icmp ne i8* %17, null
  br i1 %tobool16, label %if.then17, label %if.else19

if.then17:                                        ; preds = %if.end
  %18 = load %struct.lua_State** %L1, align 8
  %19 = load %struct.lua_State** %L.addr, align 8
  call void @lua_xmove(%struct.lua_State* %18, %struct.lua_State* %19, i32 1)
  %20 = load %struct.lua_State** %L.addr, align 8
  %21 = load i8** %name, align 8
  %call18 = call i8* @lua_pushstring(%struct.lua_State* %20, i8* %21)
  %22 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushvalue(%struct.lua_State* %22, i32 -2)
  store i32 2, i32* %retval
  br label %return

if.else19:                                        ; preds = %if.end
  %23 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushnil(%struct.lua_State* %23)
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %if.else19, %if.then17, %if.then12, %if.then
  %24 = load i32* %retval
  ret i32 %24
}

; Function Attrs: nounwind uwtable
define internal i32 @db_getregistry(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushvalue(%struct.lua_State* %0, i32 -1001000)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @db_getmetatable(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_checkany(%struct.lua_State* %0, i32 1)
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_getmetatable(%struct.lua_State* %1, i32 1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushnil(%struct.lua_State* %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @db_getupvalue(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @auxupvalue(%struct.lua_State* %0, i32 1)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @db_upvaluejoin(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %n1 = alloca i32, align 4
  %n2 = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @checkupval(%struct.lua_State* %0, i32 1, i32 2)
  store i32 %call, i32* %n1, align 4
  %1 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i32 @checkupval(%struct.lua_State* %1, i32 3, i32 4)
  store i32 %call1, i32* %n2, align 4
  %2 = load %struct.lua_State** %L.addr, align 8
  %call2 = call i32 @lua_iscfunction(%struct.lua_State* %2, i32 1)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %entry
  %3 = load %struct.lua_State** %L.addr, align 8
  %call3 = call i32 @luaL_argerror(%struct.lua_State* %3, i32 1, i8* getelementptr inbounds ([22 x i8]* @.str29169, i32 0, i32 0))
  %tobool4 = icmp ne i32 %call3, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %4 = phi i1 [ true, %entry ], [ %tobool4, %lor.rhs ]
  %lor.ext = zext i1 %4 to i32
  %5 = load %struct.lua_State** %L.addr, align 8
  %call5 = call i32 @lua_iscfunction(%struct.lua_State* %5, i32 3)
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %lor.rhs7, label %lor.end10

lor.rhs7:                                         ; preds = %lor.end
  %6 = load %struct.lua_State** %L.addr, align 8
  %call8 = call i32 @luaL_argerror(%struct.lua_State* %6, i32 3, i8* getelementptr inbounds ([22 x i8]* @.str29169, i32 0, i32 0))
  %tobool9 = icmp ne i32 %call8, 0
  br label %lor.end10

lor.end10:                                        ; preds = %lor.rhs7, %lor.end
  %7 = phi i1 [ true, %lor.end ], [ %tobool9, %lor.rhs7 ]
  %lor.ext11 = zext i1 %7 to i32
  %8 = load %struct.lua_State** %L.addr, align 8
  %9 = load i32* %n1, align 4
  %10 = load i32* %n2, align 4
  call void @lua_upvaluejoin(%struct.lua_State* %8, i32 1, i32 %9, i32 3, i32 %10)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @db_upvalueid(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %n = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @checkupval(%struct.lua_State* %0, i32 1, i32 2)
  store i32 %call, i32* %n, align 4
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load i32* %n, align 4
  %call1 = call i8* @lua_upvalueid(%struct.lua_State* %2, i32 1, i32 %3)
  call void @lua_pushlightuserdata(%struct.lua_State* %1, i8* %call1)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @db_setuservalue(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_type(%struct.lua_State* %0, i32 1)
  %cmp = icmp eq i32 %call, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i32 @luaL_argerror(%struct.lua_State* %1, i32 1, i8* getelementptr inbounds ([43 x i8]* @.str26166, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_checktype(%struct.lua_State* %2, i32 1, i32 7)
  %3 = load %struct.lua_State** %L.addr, align 8
  %call2 = call i32 @lua_type(%struct.lua_State* %3, i32 2)
  %cmp3 = icmp sle i32 %call2, 0
  br i1 %cmp3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end
  %4 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_checktype(%struct.lua_State* %4, i32 2, i32 5)
  br label %if.end5

if.end5:                                          ; preds = %if.then4, %if.end
  %5 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %5, i32 2)
  %6 = load %struct.lua_State** %L.addr, align 8
  call void @lua_setuservalue(%struct.lua_State* %6, i32 1)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @db_sethook(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %arg = alloca i32, align 4
  %mask = alloca i32, align 4
  %count = alloca i32, align 4
  %func = alloca void (%struct.lua_State*, %struct.lua_Debug*)*, align 8
  %L1 = alloca %struct.lua_State*, align 8
  %smask = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call %struct.lua_State* @getthread(%struct.lua_State* %0, i32* %arg)
  store %struct.lua_State* %call, %struct.lua_State** %L1, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load i32* %arg, align 4
  %add = add nsw i32 %2, 1
  %call1 = call i32 @lua_type(%struct.lua_State* %1, i32 %add)
  %cmp = icmp sle i32 %call1, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load i32* %arg, align 4
  %add2 = add nsw i32 %4, 1
  call void @lua_settop(%struct.lua_State* %3, i32 %add2)
  store void (%struct.lua_State*, %struct.lua_Debug*)* null, void (%struct.lua_State*, %struct.lua_Debug*)** %func, align 8
  store i32 0, i32* %mask, align 4
  store i32 0, i32* %count, align 4
  br label %if.end

if.else:                                          ; preds = %entry
  %5 = load %struct.lua_State** %L.addr, align 8
  %6 = load i32* %arg, align 4
  %add3 = add nsw i32 %6, 2
  %call4 = call i8* @luaL_checklstring(%struct.lua_State* %5, i32 %add3, i64* null)
  store i8* %call4, i8** %smask, align 8
  %7 = load %struct.lua_State** %L.addr, align 8
  %8 = load i32* %arg, align 4
  %add5 = add nsw i32 %8, 1
  call void @luaL_checktype(%struct.lua_State* %7, i32 %add5, i32 6)
  %9 = load %struct.lua_State** %L.addr, align 8
  %10 = load i32* %arg, align 4
  %add6 = add nsw i32 %10, 3
  %call7 = call i64 @luaL_optinteger(%struct.lua_State* %9, i32 %add6, i64 0)
  %conv = trunc i64 %call7 to i32
  store i32 %conv, i32* %count, align 4
  store void (%struct.lua_State*, %struct.lua_Debug*)* @hookf, void (%struct.lua_State*, %struct.lua_Debug*)** %func, align 8
  %11 = load i8** %smask, align 8
  %12 = load i32* %count, align 4
  %call8 = call i32 @makemask(i8* %11, i32 %12)
  store i32 %call8, i32* %mask, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %13 = load %struct.lua_State** %L.addr, align 8
  %call9 = call i32 @luaL_getsubtable(%struct.lua_State* %13, i32 -1001000, i8* getelementptr inbounds ([6 x i8]* @.str18158, i32 0, i32 0))
  %cmp10 = icmp eq i32 %call9, 0
  br i1 %cmp10, label %if.then12, label %if.end15

if.then12:                                        ; preds = %if.end
  %14 = load %struct.lua_State** %L.addr, align 8
  %call13 = call i8* @lua_pushstring(%struct.lua_State* %14, i8* getelementptr inbounds ([2 x i8]* @.str19159, i32 0, i32 0))
  %15 = load %struct.lua_State** %L.addr, align 8
  call void @lua_setfield(%struct.lua_State* %15, i32 -2, i8* getelementptr inbounds ([7 x i8]* @.str20160, i32 0, i32 0))
  %16 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushvalue(%struct.lua_State* %16, i32 -1)
  %17 = load %struct.lua_State** %L.addr, align 8
  %call14 = call i32 @lua_setmetatable(%struct.lua_State* %17, i32 -2)
  br label %if.end15

if.end15:                                         ; preds = %if.then12, %if.end
  %18 = load %struct.lua_State** %L1, align 8
  %call16 = call i32 @lua_pushthread(%struct.lua_State* %18)
  %19 = load %struct.lua_State** %L1, align 8
  %20 = load %struct.lua_State** %L.addr, align 8
  call void @lua_xmove(%struct.lua_State* %19, %struct.lua_State* %20, i32 1)
  %21 = load %struct.lua_State** %L.addr, align 8
  %22 = load i32* %arg, align 4
  %add17 = add nsw i32 %22, 1
  call void @lua_pushvalue(%struct.lua_State* %21, i32 %add17)
  %23 = load %struct.lua_State** %L.addr, align 8
  call void @lua_rawset(%struct.lua_State* %23, i32 -3)
  %24 = load %struct.lua_State** %L1, align 8
  %25 = load void (%struct.lua_State*, %struct.lua_Debug*)** %func, align 8
  %26 = load i32* %mask, align 4
  %27 = load i32* %count, align 4
  %call18 = call i32 @lua_sethook(%struct.lua_State* %24, void (%struct.lua_State*, %struct.lua_Debug*)* %25, i32 %26, i32 %27)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @db_setlocal(%struct.lua_State* %L) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %arg = alloca i32, align 4
  %L1 = alloca %struct.lua_State*, align 8
  %ar = alloca %struct.lua_Debug, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call %struct.lua_State* @getthread(%struct.lua_State* %0, i32* %arg)
  store %struct.lua_State* %call, %struct.lua_State** %L1, align 8
  %1 = load %struct.lua_State** %L1, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load i32* %arg, align 4
  %add = add nsw i32 %3, 1
  %call1 = call i64 @luaL_checkinteger(%struct.lua_State* %2, i32 %add)
  %conv = trunc i64 %call1 to i32
  %call2 = call i32 @lua_getstack(%struct.lua_State* %1, i32 %conv, %struct.lua_Debug* %ar)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load i32* %arg, align 4
  %add3 = add nsw i32 %5, 1
  %call4 = call i32 @luaL_argerror(%struct.lua_State* %4, i32 %add3, i8* getelementptr inbounds ([19 x i8]* @.str17157, i32 0, i32 0))
  store i32 %call4, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %6 = load %struct.lua_State** %L.addr, align 8
  %7 = load i32* %arg, align 4
  %add5 = add nsw i32 %7, 3
  call void @luaL_checkany(%struct.lua_State* %6, i32 %add5)
  %8 = load %struct.lua_State** %L.addr, align 8
  %9 = load i32* %arg, align 4
  %add6 = add nsw i32 %9, 3
  call void @lua_settop(%struct.lua_State* %8, i32 %add6)
  %10 = load %struct.lua_State** %L.addr, align 8
  %11 = load %struct.lua_State** %L1, align 8
  call void @lua_xmove(%struct.lua_State* %10, %struct.lua_State* %11, i32 1)
  %12 = load %struct.lua_State** %L.addr, align 8
  %13 = load %struct.lua_State** %L1, align 8
  %14 = load %struct.lua_State** %L.addr, align 8
  %15 = load i32* %arg, align 4
  %add7 = add nsw i32 %15, 2
  %call8 = call i64 @luaL_checkinteger(%struct.lua_State* %14, i32 %add7)
  %conv9 = trunc i64 %call8 to i32
  %call10 = call i8* @lua_setlocal(%struct.lua_State* %13, %struct.lua_Debug* %ar, i32 %conv9)
  %call11 = call i8* @lua_pushstring(%struct.lua_State* %12, i8* %call10)
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %16 = load i32* %retval
  ret i32 %16
}

; Function Attrs: nounwind uwtable
define internal i32 @db_setmetatable(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %t = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_type(%struct.lua_State* %0, i32 2)
  store i32 %call, i32* %t, align 4
  %1 = load i32* %t, align 4
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load i32* %t, align 4
  %cmp1 = icmp eq i32 %2, 5
  br i1 %cmp1, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false
  %3 = load %struct.lua_State** %L.addr, align 8
  %call2 = call i32 @luaL_argerror(%struct.lua_State* %3, i32 2, i8* getelementptr inbounds ([22 x i8]* @.str16156, i32 0, i32 0))
  %tobool = icmp ne i32 %call2, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false, %entry
  %4 = phi i1 [ true, %lor.lhs.false ], [ true, %entry ], [ %tobool, %lor.rhs ]
  %lor.ext = zext i1 %4 to i32
  %5 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %5, i32 2)
  %6 = load %struct.lua_State** %L.addr, align 8
  %call3 = call i32 @lua_setmetatable(%struct.lua_State* %6, i32 1)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @db_setupvalue(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_checkany(%struct.lua_State* %0, i32 3)
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @auxupvalue(%struct.lua_State* %1, i32 0)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @db_traceback(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %arg = alloca i32, align 4
  %L1 = alloca %struct.lua_State*, align 8
  %msg = alloca i8*, align 8
  %level = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call %struct.lua_State* @getthread(%struct.lua_State* %0, i32* %arg)
  store %struct.lua_State* %call, %struct.lua_State** %L1, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load i32* %arg, align 4
  %add = add nsw i32 %2, 1
  %call1 = call i8* @lua_tolstring(%struct.lua_State* %1, i32 %add, i64* null)
  store i8* %call1, i8** %msg, align 8
  %3 = load i8** %msg, align 8
  %cmp = icmp eq i8* %3, null
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load i32* %arg, align 4
  %add2 = add nsw i32 %5, 1
  %call3 = call i32 @lua_type(%struct.lua_State* %4, i32 %add2)
  %cmp4 = icmp sle i32 %call3, 0
  br i1 %cmp4, label %if.else, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %6 = load %struct.lua_State** %L.addr, align 8
  %7 = load i32* %arg, align 4
  %add5 = add nsw i32 %7, 1
  call void @lua_pushvalue(%struct.lua_State* %6, i32 %add5)
  br label %if.end

if.else:                                          ; preds = %land.lhs.true, %entry
  %8 = load %struct.lua_State** %L.addr, align 8
  %9 = load i32* %arg, align 4
  %add6 = add nsw i32 %9, 2
  %10 = load %struct.lua_State** %L.addr, align 8
  %11 = load %struct.lua_State** %L1, align 8
  %cmp7 = icmp eq %struct.lua_State* %10, %11
  %cond = select i1 %cmp7, i32 1, i32 0
  %conv = sext i32 %cond to i64
  %call8 = call i64 @luaL_optinteger(%struct.lua_State* %8, i32 %add6, i64 %conv)
  %conv9 = trunc i64 %call8 to i32
  store i32 %conv9, i32* %level, align 4
  %12 = load %struct.lua_State** %L.addr, align 8
  %13 = load %struct.lua_State** %L1, align 8
  %14 = load i8** %msg, align 8
  %15 = load i32* %level, align 4
  call void @luaL_traceback(%struct.lua_State* %12, %struct.lua_State* %13, i8* %14, i32 %15)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal %struct.lua_State* @getthread(%struct.lua_State* %L, i32* %arg) #0 {
entry:
  %retval = alloca %struct.lua_State*, align 8
  %L.addr = alloca %struct.lua_State*, align 8
  %arg.addr = alloca i32*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32* %arg, i32** %arg.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_type(%struct.lua_State* %0, i32 1)
  %cmp = icmp eq i32 %call, 8
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i32** %arg.addr, align 8
  store i32 1, i32* %1, align 4
  %2 = load %struct.lua_State** %L.addr, align 8
  %call1 = call %struct.lua_State* @lua_tothread(%struct.lua_State* %2, i32 1)
  store %struct.lua_State* %call1, %struct.lua_State** %retval
  br label %return

if.else:                                          ; preds = %entry
  %3 = load i32** %arg.addr, align 8
  store i32 0, i32* %3, align 4
  %4 = load %struct.lua_State** %L.addr, align 8
  store %struct.lua_State* %4, %struct.lua_State** %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %5 = load %struct.lua_State** %retval
  ret %struct.lua_State* %5
}

; Function Attrs: nounwind uwtable
define internal void @hookf(%struct.lua_State* %L, %struct.lua_Debug* %ar) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %ar.addr = alloca %struct.lua_Debug*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.lua_Debug* %ar, %struct.lua_Debug** %ar.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @luaL_getsubtable(%struct.lua_State* %0, i32 -1001000, i8* getelementptr inbounds ([6 x i8]* @.str18158, i32 0, i32 0))
  %1 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i32 @lua_pushthread(%struct.lua_State* %1)
  %2 = load %struct.lua_State** %L.addr, align 8
  call void @lua_rawget(%struct.lua_State* %2, i32 -2)
  %3 = load %struct.lua_State** %L.addr, align 8
  %call2 = call i32 @lua_type(%struct.lua_State* %3, i32 -1)
  %cmp = icmp eq i32 %call2, 6
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load %struct.lua_Debug** %ar.addr, align 8
  %event = getelementptr inbounds %struct.lua_Debug* %5, i32 0, i32 0
  %6 = load i32* %event, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr inbounds [5 x i8*]* @hookf.hooknames, i32 0, i64 %idxprom
  %7 = load i8** %arrayidx, align 8
  %call3 = call i8* @lua_pushstring(%struct.lua_State* %4, i8* %7)
  %8 = load %struct.lua_Debug** %ar.addr, align 8
  %currentline = getelementptr inbounds %struct.lua_Debug* %8, i32 0, i32 5
  %9 = load i32* %currentline, align 4
  %cmp4 = icmp sge i32 %9, 0
  br i1 %cmp4, label %if.then5, label %if.else

if.then5:                                         ; preds = %if.then
  %10 = load %struct.lua_State** %L.addr, align 8
  %11 = load %struct.lua_Debug** %ar.addr, align 8
  %currentline6 = getelementptr inbounds %struct.lua_Debug* %11, i32 0, i32 5
  %12 = load i32* %currentline6, align 4
  %conv = sext i32 %12 to i64
  call void @lua_pushinteger(%struct.lua_State* %10, i64 %conv)
  br label %if.end

if.else:                                          ; preds = %if.then
  %13 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushnil(%struct.lua_State* %13)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then5
  %14 = load %struct.lua_State** %L.addr, align 8
  call void @lua_callk(%struct.lua_State* %14, i32 2, i32 0, i32 0, i32 (%struct.lua_State*)* null)
  br label %if.end7

if.end7:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i8* @unmakemask(i32 %mask, i8* %smask) #0 {
entry:
  %mask.addr = alloca i32, align 4
  %smask.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  store i32 %mask, i32* %mask.addr, align 4
  store i8* %smask, i8** %smask.addr, align 8
  store i32 0, i32* %i, align 4
  %0 = load i32* %mask.addr, align 4
  %and = and i32 %0, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i32* %i, align 4
  %inc = add nsw i32 %1, 1
  store i32 %inc, i32* %i, align 4
  %idxprom = sext i32 %1 to i64
  %2 = load i8** %smask.addr, align 8
  %arrayidx = getelementptr inbounds i8* %2, i64 %idxprom
  store i8 99, i8* %arrayidx, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32* %mask.addr, align 4
  %and1 = and i32 %3, 2
  %tobool2 = icmp ne i32 %and1, 0
  br i1 %tobool2, label %if.then3, label %if.end7

if.then3:                                         ; preds = %if.end
  %4 = load i32* %i, align 4
  %inc4 = add nsw i32 %4, 1
  store i32 %inc4, i32* %i, align 4
  %idxprom5 = sext i32 %4 to i64
  %5 = load i8** %smask.addr, align 8
  %arrayidx6 = getelementptr inbounds i8* %5, i64 %idxprom5
  store i8 114, i8* %arrayidx6, align 1
  br label %if.end7

if.end7:                                          ; preds = %if.then3, %if.end
  %6 = load i32* %mask.addr, align 4
  %and8 = and i32 %6, 4
  %tobool9 = icmp ne i32 %and8, 0
  br i1 %tobool9, label %if.then10, label %if.end14

if.then10:                                        ; preds = %if.end7
  %7 = load i32* %i, align 4
  %inc11 = add nsw i32 %7, 1
  store i32 %inc11, i32* %i, align 4
  %idxprom12 = sext i32 %7 to i64
  %8 = load i8** %smask.addr, align 8
  %arrayidx13 = getelementptr inbounds i8* %8, i64 %idxprom12
  store i8 108, i8* %arrayidx13, align 1
  br label %if.end14

if.end14:                                         ; preds = %if.then10, %if.end7
  %9 = load i32* %i, align 4
  %idxprom15 = sext i32 %9 to i64
  %10 = load i8** %smask.addr, align 8
  %arrayidx16 = getelementptr inbounds i8* %10, i64 %idxprom15
  store i8 0, i8* %arrayidx16, align 1
  %11 = load i8** %smask.addr, align 8
  ret i8* %11
}

; Function Attrs: nounwind uwtable
define internal void @settabss(%struct.lua_State* %L, i8* %i, i8* %v) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %i.addr = alloca i8*, align 8
  %v.addr = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %i, i8** %i.addr, align 8
  store i8* %v, i8** %v.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i8** %v.addr, align 8
  %call = call i8* @lua_pushstring(%struct.lua_State* %0, i8* %1)
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load i8** %i.addr, align 8
  call void @lua_setfield(%struct.lua_State* %2, i32 -2, i8* %3)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @settabsi(%struct.lua_State* %L, i8* %i, i32 %v) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %i.addr = alloca i8*, align 8
  %v.addr = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %i, i8** %i.addr, align 8
  store i32 %v, i32* %v.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %v.addr, align 4
  %conv = sext i32 %1 to i64
  call void @lua_pushinteger(%struct.lua_State* %0, i64 %conv)
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load i8** %i.addr, align 8
  call void @lua_setfield(%struct.lua_State* %2, i32 -2, i8* %3)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @settabsb(%struct.lua_State* %L, i8* %i, i32 %v) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %i.addr = alloca i8*, align 8
  %v.addr = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %i, i8** %i.addr, align 8
  store i32 %v, i32* %v.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %v.addr, align 4
  call void @lua_pushboolean(%struct.lua_State* %0, i32 %1)
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load i8** %i.addr, align 8
  call void @lua_setfield(%struct.lua_State* %2, i32 -2, i8* %3)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @treatstackoption(%struct.lua_State* %L, %struct.lua_State* %L1, i8* %fname) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %L1.addr = alloca %struct.lua_State*, align 8
  %fname.addr = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.lua_State* %L1, %struct.lua_State** %L1.addr, align 8
  store i8* %fname, i8** %fname.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load %struct.lua_State** %L1.addr, align 8
  %cmp = icmp eq %struct.lua_State* %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushvalue(%struct.lua_State* %2, i32 -2)
  %3 = load %struct.lua_State** %L.addr, align 8
  call void @lua_remove(%struct.lua_State* %3, i32 -3)
  br label %if.end

if.else:                                          ; preds = %entry
  %4 = load %struct.lua_State** %L1.addr, align 8
  %5 = load %struct.lua_State** %L.addr, align 8
  call void @lua_xmove(%struct.lua_State* %4, %struct.lua_State* %5, i32 1)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %6 = load %struct.lua_State** %L.addr, align 8
  %7 = load i8** %fname.addr, align 8
  call void @lua_setfield(%struct.lua_State* %6, i32 -2, i8* %7)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @auxupvalue(%struct.lua_State* %L, i32 %get) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %get.addr = alloca i32, align 4
  %name = alloca i8*, align 8
  %n = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %get, i32* %get.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 2)
  %conv = trunc i64 %call to i32
  store i32 %conv, i32* %n, align 4
  %1 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_checktype(%struct.lua_State* %1, i32 1, i32 6)
  %2 = load i32* %get.addr, align 4
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load i32* %n, align 4
  %call1 = call i8* @lua_getupvalue(%struct.lua_State* %3, i32 1, i32 %4)
  br label %cond.end

cond.false:                                       ; preds = %entry
  %5 = load %struct.lua_State** %L.addr, align 8
  %6 = load i32* %n, align 4
  %call2 = call i8* @lua_setupvalue(%struct.lua_State* %5, i32 1, i32 %6)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %call1, %cond.true ], [ %call2, %cond.false ]
  store i8* %cond, i8** %name, align 8
  %7 = load i8** %name, align 8
  %cmp = icmp eq i8* %7, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  store i32 0, i32* %retval
  br label %return

if.end:                                           ; preds = %cond.end
  %8 = load %struct.lua_State** %L.addr, align 8
  %9 = load i8** %name, align 8
  %call4 = call i8* @lua_pushstring(%struct.lua_State* %8, i8* %9)
  %10 = load %struct.lua_State** %L.addr, align 8
  %11 = load i32* %get.addr, align 4
  %add = add nsw i32 %11, 1
  %sub = sub nsw i32 0, %add
  call void @lua_insert(%struct.lua_State* %10, i32 %sub)
  %12 = load i32* %get.addr, align 4
  %add5 = add nsw i32 %12, 1
  store i32 %add5, i32* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %13 = load i32* %retval
  ret i32 %13
}

; Function Attrs: nounwind uwtable
define internal i32 @checkupval(%struct.lua_State* %L, i32 %argf, i32 %argnup) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %argf.addr = alloca i32, align 4
  %argnup.addr = alloca i32, align 4
  %ar = alloca %struct.lua_Debug, align 8
  %nup = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %argf, i32* %argf.addr, align 4
  store i32 %argnup, i32* %argnup.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %argnup.addr, align 4
  %call = call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 %1)
  %conv = trunc i64 %call to i32
  store i32 %conv, i32* %nup, align 4
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load i32* %argf.addr, align 4
  call void @luaL_checktype(%struct.lua_State* %2, i32 %3, i32 6)
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load i32* %argf.addr, align 4
  call void @lua_pushvalue(%struct.lua_State* %4, i32 %5)
  %6 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i32 @lua_getinfo(%struct.lua_State* %6, i8* getelementptr inbounds ([3 x i8]* @.str27167, i32 0, i32 0), %struct.lua_Debug* %ar)
  %7 = load i32* %nup, align 4
  %cmp = icmp sle i32 1, %7
  br i1 %cmp, label %land.lhs.true, label %lor.rhs

land.lhs.true:                                    ; preds = %entry
  %8 = load i32* %nup, align 4
  %nups = getelementptr inbounds %struct.lua_Debug* %ar, i32 0, i32 8
  %9 = load i8* %nups, align 1
  %conv3 = zext i8 %9 to i32
  %cmp4 = icmp sle i32 %8, %conv3
  br i1 %cmp4, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.lhs.true, %entry
  %10 = load %struct.lua_State** %L.addr, align 8
  %11 = load i32* %argnup.addr, align 4
  %call6 = call i32 @luaL_argerror(%struct.lua_State* %10, i32 %11, i8* getelementptr inbounds ([22 x i8]* @.str28168, i32 0, i32 0))
  %tobool = icmp ne i32 %call6, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.lhs.true
  %12 = phi i1 [ true, %land.lhs.true ], [ %tobool, %lor.rhs ]
  %lor.ext = zext i1 %12 to i32
  %13 = load i32* %nup, align 4
  ret i32 %13
}

; Function Attrs: nounwind uwtable
define internal i32 @makemask(i8* %smask, i32 %count) #0 {
entry:
  %smask.addr = alloca i8*, align 8
  %count.addr = alloca i32, align 4
  %mask = alloca i32, align 4
  store i8* %smask, i8** %smask.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i32 0, i32* %mask, align 4
  %0 = load i8** %smask.addr, align 8
  %call = call i8* @strchr(i8* %0, i32 99) #10
  %tobool = icmp ne i8* %call, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i32* %mask, align 4
  %or = or i32 %1, 1
  store i32 %or, i32* %mask, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i8** %smask.addr, align 8
  %call1 = call i8* @strchr(i8* %2, i32 114) #10
  %tobool2 = icmp ne i8* %call1, null
  br i1 %tobool2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %3 = load i32* %mask, align 4
  %or4 = or i32 %3, 2
  store i32 %or4, i32* %mask, align 4
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end
  %4 = load i8** %smask.addr, align 8
  %call6 = call i8* @strchr(i8* %4, i32 108) #10
  %tobool7 = icmp ne i8* %call6, null
  br i1 %tobool7, label %if.then8, label %if.end10

if.then8:                                         ; preds = %if.end5
  %5 = load i32* %mask, align 4
  %or9 = or i32 %5, 4
  store i32 %or9, i32* %mask, align 4
  br label %if.end10

if.end10:                                         ; preds = %if.then8, %if.end5
  %6 = load i32* %count.addr, align 4
  %cmp = icmp sgt i32 %6, 0
  br i1 %cmp, label %if.then11, label %if.end13

if.then11:                                        ; preds = %if.end10
  %7 = load i32* %mask, align 4
  %or12 = or i32 %7, 8
  store i32 %or12, i32* %mask, align 4
  br label %if.end13

if.end13:                                         ; preds = %if.then11, %if.end10
  %8 = load i32* %mask, align 4
  ret i32 %8
}

; Function Attrs: nounwind uwtable
define i32 @lua_sethook(%struct.lua_State* %L, void (%struct.lua_State*, %struct.lua_Debug*)* %func, i32 %mask, i32 %count) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %func.addr = alloca void (%struct.lua_State*, %struct.lua_Debug*)*, align 8
  %mask.addr = alloca i32, align 4
  %count.addr = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store void (%struct.lua_State*, %struct.lua_Debug*)* %func, void (%struct.lua_State*, %struct.lua_Debug*)** %func.addr, align 8
  store i32 %mask, i32* %mask.addr, align 4
  store i32 %count, i32* %count.addr, align 4
  %0 = load void (%struct.lua_State*, %struct.lua_Debug*)** %func.addr, align 8
  %cmp = icmp eq void (%struct.lua_State*, %struct.lua_Debug*)* %0, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32* %mask.addr, align 4
  %cmp1 = icmp eq i32 %1, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 0, i32* %mask.addr, align 4
  store void (%struct.lua_State*, %struct.lua_Debug*)* null, void (%struct.lua_State*, %struct.lua_Debug*)** %func.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  %2 = load %struct.lua_State** %L.addr, align 8
  %ci = getelementptr inbounds %struct.lua_State* %2, i32 0, i32 6
  %3 = load %struct.CallInfo** %ci, align 8
  %callstatus = getelementptr inbounds %struct.CallInfo* %3, i32 0, i32 5
  %4 = load i8* %callstatus, align 1
  %conv = zext i8 %4 to i32
  %and = and i32 %conv, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %5 = load %struct.lua_State** %L.addr, align 8
  %ci3 = getelementptr inbounds %struct.lua_State* %5, i32 0, i32 6
  %6 = load %struct.CallInfo** %ci3, align 8
  %u = getelementptr inbounds %struct.CallInfo* %6, i32 0, i32 7
  %l = bitcast %union.anon.2* %u to %struct.anon.3*
  %savedpc = getelementptr inbounds %struct.anon.3* %l, i32 0, i32 1
  %7 = load i32** %savedpc, align 8
  %8 = load %struct.lua_State** %L.addr, align 8
  %oldpc = getelementptr inbounds %struct.lua_State* %8, i32 0, i32 7
  store i32* %7, i32** %oldpc, align 8
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.end
  %9 = load void (%struct.lua_State*, %struct.lua_Debug*)** %func.addr, align 8
  %10 = load %struct.lua_State** %L.addr, align 8
  %hook = getelementptr inbounds %struct.lua_State* %10, i32 0, i32 17
  store void (%struct.lua_State*, %struct.lua_Debug*)* %9, void (%struct.lua_State*, %struct.lua_Debug*)** %hook, align 8
  %11 = load i32* %count.addr, align 4
  %12 = load %struct.lua_State** %L.addr, align 8
  %basehookcount = getelementptr inbounds %struct.lua_State* %12, i32 0, i32 15
  store i32 %11, i32* %basehookcount, align 4
  %13 = load %struct.lua_State** %L.addr, align 8
  %basehookcount5 = getelementptr inbounds %struct.lua_State* %13, i32 0, i32 15
  %14 = load i32* %basehookcount5, align 4
  %15 = load %struct.lua_State** %L.addr, align 8
  %hookcount = getelementptr inbounds %struct.lua_State* %15, i32 0, i32 16
  store i32 %14, i32* %hookcount, align 4
  %16 = load i32* %mask.addr, align 4
  %conv6 = trunc i32 %16 to i8
  %17 = load %struct.lua_State** %L.addr, align 8
  %hookmask = getelementptr inbounds %struct.lua_State* %17, i32 0, i32 13
  store i8 %conv6, i8* %hookmask, align 1
  ret i32 1
}

; Function Attrs: nounwind uwtable
define void (%struct.lua_State*, %struct.lua_Debug*)* @lua_gethook(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %hook = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 17
  %1 = load void (%struct.lua_State*, %struct.lua_Debug*)** %hook, align 8
  ret void (%struct.lua_State*, %struct.lua_Debug*)* %1
}

; Function Attrs: nounwind uwtable
define i32 @lua_gethookmask(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %hookmask = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 13
  %1 = load i8* %hookmask, align 1
  %conv = zext i8 %1 to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define i32 @lua_gethookcount(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %basehookcount = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 15
  %1 = load i32* %basehookcount, align 4
  ret i32 %1
}

; Function Attrs: nounwind uwtable
define i32 @lua_getstack(%struct.lua_State* %L, i32 %level, %struct.lua_Debug* %ar) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %level.addr = alloca i32, align 4
  %ar.addr = alloca %struct.lua_Debug*, align 8
  %status = alloca i32, align 4
  %ci = alloca %struct.CallInfo*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %level, i32* %level.addr, align 4
  store %struct.lua_Debug* %ar, %struct.lua_Debug** %ar.addr, align 8
  %0 = load i32* %level.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.lua_State** %L.addr, align 8
  %ci1 = getelementptr inbounds %struct.lua_State* %1, i32 0, i32 6
  %2 = load %struct.CallInfo** %ci1, align 8
  store %struct.CallInfo* %2, %struct.CallInfo** %ci, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %3 = load i32* %level.addr, align 4
  %cmp2 = icmp sgt i32 %3, 0
  br i1 %cmp2, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %4 = load %struct.CallInfo** %ci, align 8
  %5 = load %struct.lua_State** %L.addr, align 8
  %base_ci = getelementptr inbounds %struct.lua_State* %5, i32 0, i32 22
  %cmp3 = icmp ne %struct.CallInfo* %4, %base_ci
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %6 = phi i1 [ false, %for.cond ], [ %cmp3, %land.rhs ]
  br i1 %6, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %7 = load i32* %level.addr, align 4
  %dec = add nsw i32 %7, -1
  store i32 %dec, i32* %level.addr, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %8 = load %struct.CallInfo** %ci, align 8
  %previous = getelementptr inbounds %struct.CallInfo* %8, i32 0, i32 2
  %9 = load %struct.CallInfo** %previous, align 8
  store %struct.CallInfo* %9, %struct.CallInfo** %ci, align 8
  br label %for.cond

for.end:                                          ; preds = %land.end
  %10 = load i32* %level.addr, align 4
  %cmp4 = icmp eq i32 %10, 0
  br i1 %cmp4, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %for.end
  %11 = load %struct.CallInfo** %ci, align 8
  %12 = load %struct.lua_State** %L.addr, align 8
  %base_ci5 = getelementptr inbounds %struct.lua_State* %12, i32 0, i32 22
  %cmp6 = icmp ne %struct.CallInfo* %11, %base_ci5
  br i1 %cmp6, label %if.then7, label %if.else

if.then7:                                         ; preds = %land.lhs.true
  store i32 1, i32* %status, align 4
  %13 = load %struct.CallInfo** %ci, align 8
  %14 = load %struct.lua_Debug** %ar.addr, align 8
  %i_ci = getelementptr inbounds %struct.lua_Debug* %14, i32 0, i32 13
  store %struct.CallInfo* %13, %struct.CallInfo** %i_ci, align 8
  br label %if.end8

if.else:                                          ; preds = %land.lhs.true, %for.end
  store i32 0, i32* %status, align 4
  br label %if.end8

if.end8:                                          ; preds = %if.else, %if.then7
  %15 = load i32* %status, align 4
  store i32 %15, i32* %retval
  br label %return

return:                                           ; preds = %if.end8, %if.then
  %16 = load i32* %retval
  ret i32 %16
}

; Function Attrs: nounwind uwtable
define i8* @lua_getlocal(%struct.lua_State* %L, %struct.lua_Debug* %ar, i32 %n) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %ar.addr = alloca %struct.lua_Debug*, align 8
  %n.addr = alloca i32, align 4
  %name = alloca i8*, align 8
  %pos = alloca %struct.lua_TValue*, align 8
  %io2 = alloca %struct.lua_TValue*, align 8
  %io1 = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.lua_Debug* %ar, %struct.lua_Debug** %ar.addr, align 8
  store i32 %n, i32* %n.addr, align 4
  %0 = load %struct.lua_Debug** %ar.addr, align 8
  %cmp = icmp eq %struct.lua_Debug* %0, null
  br i1 %cmp, label %if.then, label %if.else5

if.then:                                          ; preds = %entry
  %1 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %1, i32 0, i32 4
  %2 = load %struct.lua_TValue** %top, align 8
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %2, i64 -1
  %tt_ = getelementptr inbounds %struct.lua_TValue* %add.ptr, i32 0, i32 1
  %3 = load i32* %tt_, align 4
  %cmp1 = icmp eq i32 %3, 70
  br i1 %cmp1, label %if.else, label %if.then2

if.then2:                                         ; preds = %if.then
  store i8* null, i8** %name, align 8
  br label %if.end

if.else:                                          ; preds = %if.then
  %4 = load %struct.lua_State** %L.addr, align 8
  %top3 = getelementptr inbounds %struct.lua_State* %4, i32 0, i32 4
  %5 = load %struct.lua_TValue** %top3, align 8
  %add.ptr4 = getelementptr inbounds %struct.lua_TValue* %5, i64 -1
  %value_ = getelementptr inbounds %struct.lua_TValue* %add.ptr4, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %6 = load %union.GCObject** %gc, align 8
  %cl = bitcast %union.GCObject* %6 to %union.Closure*
  %l = bitcast %union.Closure* %cl to %struct.LClosure*
  %p = getelementptr inbounds %struct.LClosure* %l, i32 0, i32 5
  %7 = load %struct.Proto** %p, align 8
  %8 = load i32* %n.addr, align 4
  %call = call i8* bitcast (i8* (%struct.Proto.160*, i32, i32)* @luaF_getlocalname to i8* (%struct.Proto*, i32, i32)*)(%struct.Proto* %7, i32 %8, i32 0)
  store i8* %call, i8** %name, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then2
  br label %if.end15

if.else5:                                         ; preds = %entry
  store %struct.lua_TValue* null, %struct.lua_TValue** %pos, align 8
  %9 = load %struct.lua_State** %L.addr, align 8
  %10 = load %struct.lua_Debug** %ar.addr, align 8
  %i_ci = getelementptr inbounds %struct.lua_Debug* %10, i32 0, i32 13
  %11 = load %struct.CallInfo** %i_ci, align 8
  %12 = load i32* %n.addr, align 4
  %call6 = call i8* @findlocal(%struct.lua_State* %9, %struct.CallInfo* %11, i32 %12, %struct.lua_TValue** %pos)
  store i8* %call6, i8** %name, align 8
  %13 = load i8** %name, align 8
  %tobool = icmp ne i8* %13, null
  br i1 %tobool, label %if.then7, label %if.end14

if.then7:                                         ; preds = %if.else5
  %14 = load %struct.lua_TValue** %pos, align 8
  store %struct.lua_TValue* %14, %struct.lua_TValue** %io2, align 8
  %15 = load %struct.lua_State** %L.addr, align 8
  %top8 = getelementptr inbounds %struct.lua_State* %15, i32 0, i32 4
  %16 = load %struct.lua_TValue** %top8, align 8
  store %struct.lua_TValue* %16, %struct.lua_TValue** %io1, align 8
  %17 = load %struct.lua_TValue** %io1, align 8
  %value_9 = getelementptr inbounds %struct.lua_TValue* %17, i32 0, i32 0
  %18 = load %struct.lua_TValue** %io2, align 8
  %value_10 = getelementptr inbounds %struct.lua_TValue* %18, i32 0, i32 0
  %19 = bitcast %union.Value* %value_9 to i8*
  %20 = bitcast %union.Value* %value_10 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %19, i8* %20, i64 8, i32 8, i1 false)
  %21 = load %struct.lua_TValue** %io2, align 8
  %tt_11 = getelementptr inbounds %struct.lua_TValue* %21, i32 0, i32 1
  %22 = load i32* %tt_11, align 4
  %23 = load %struct.lua_TValue** %io1, align 8
  %tt_12 = getelementptr inbounds %struct.lua_TValue* %23, i32 0, i32 1
  store i32 %22, i32* %tt_12, align 4
  %24 = load %struct.lua_State** %L.addr, align 8
  %top13 = getelementptr inbounds %struct.lua_State* %24, i32 0, i32 4
  %25 = load %struct.lua_TValue** %top13, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %25, i32 1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %top13, align 8
  br label %if.end14

if.end14:                                         ; preds = %if.then7, %if.else5
  br label %if.end15

if.end15:                                         ; preds = %if.end14, %if.end
  %26 = load i8** %name, align 8
  ret i8* %26
}

; Function Attrs: nounwind uwtable
define i8* @lua_setlocal(%struct.lua_State* %L, %struct.lua_Debug* %ar, i32 %n) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %ar.addr = alloca %struct.lua_Debug*, align 8
  %n.addr = alloca i32, align 4
  %pos = alloca %struct.lua_TValue*, align 8
  %name = alloca i8*, align 8
  %io2 = alloca %struct.lua_TValue*, align 8
  %io1 = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.lua_Debug* %ar, %struct.lua_Debug** %ar.addr, align 8
  store i32 %n, i32* %n.addr, align 4
  store %struct.lua_TValue* null, %struct.lua_TValue** %pos, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load %struct.lua_Debug** %ar.addr, align 8
  %i_ci = getelementptr inbounds %struct.lua_Debug* %1, i32 0, i32 13
  %2 = load %struct.CallInfo** %i_ci, align 8
  %3 = load i32* %n.addr, align 4
  %call = call i8* @findlocal(%struct.lua_State* %0, %struct.CallInfo* %2, i32 %3, %struct.lua_TValue** %pos)
  store i8* %call, i8** %name, align 8
  %4 = load i8** %name, align 8
  %tobool = icmp ne i8* %4, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %5, i32 0, i32 4
  %6 = load %struct.lua_TValue** %top, align 8
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %6, i64 -1
  store %struct.lua_TValue* %add.ptr, %struct.lua_TValue** %io2, align 8
  %7 = load %struct.lua_TValue** %pos, align 8
  store %struct.lua_TValue* %7, %struct.lua_TValue** %io1, align 8
  %8 = load %struct.lua_TValue** %io1, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %8, i32 0, i32 0
  %9 = load %struct.lua_TValue** %io2, align 8
  %value_1 = getelementptr inbounds %struct.lua_TValue* %9, i32 0, i32 0
  %10 = bitcast %union.Value* %value_ to i8*
  %11 = bitcast %union.Value* %value_1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %10, i8* %11, i64 8, i32 8, i1 false)
  %12 = load %struct.lua_TValue** %io2, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %12, i32 0, i32 1
  %13 = load i32* %tt_, align 4
  %14 = load %struct.lua_TValue** %io1, align 8
  %tt_2 = getelementptr inbounds %struct.lua_TValue* %14, i32 0, i32 1
  store i32 %13, i32* %tt_2, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %15 = load %struct.lua_State** %L.addr, align 8
  %top3 = getelementptr inbounds %struct.lua_State* %15, i32 0, i32 4
  %16 = load %struct.lua_TValue** %top3, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %16, i32 -1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %top3, align 8
  %17 = load i8** %name, align 8
  ret i8* %17
}

; Function Attrs: nounwind uwtable
define i32 @lua_getinfo(%struct.lua_State* %L, i8* %what, %struct.lua_Debug* %ar) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %what.addr = alloca i8*, align 8
  %ar.addr = alloca %struct.lua_Debug*, align 8
  %status = alloca i32, align 4
  %cl = alloca %union.Closure*, align 8
  %ci = alloca %struct.CallInfo*, align 8
  %func = alloca %struct.lua_TValue*, align 8
  %io2 = alloca %struct.lua_TValue*, align 8
  %io1 = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %what, i8** %what.addr, align 8
  store %struct.lua_Debug* %ar, %struct.lua_Debug** %ar.addr, align 8
  %0 = load i8** %what.addr, align 8
  %1 = load i8* %0, align 1
  %conv = sext i8 %1 to i32
  %cmp = icmp eq i32 %conv, 62
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store %struct.CallInfo* null, %struct.CallInfo** %ci, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %2, i32 0, i32 4
  %3 = load %struct.lua_TValue** %top, align 8
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %3, i64 -1
  store %struct.lua_TValue* %add.ptr, %struct.lua_TValue** %func, align 8
  %4 = load i8** %what.addr, align 8
  %incdec.ptr = getelementptr inbounds i8* %4, i32 1
  store i8* %incdec.ptr, i8** %what.addr, align 8
  %5 = load %struct.lua_State** %L.addr, align 8
  %top2 = getelementptr inbounds %struct.lua_State* %5, i32 0, i32 4
  %6 = load %struct.lua_TValue** %top2, align 8
  %incdec.ptr3 = getelementptr inbounds %struct.lua_TValue* %6, i32 -1
  store %struct.lua_TValue* %incdec.ptr3, %struct.lua_TValue** %top2, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %7 = load %struct.lua_Debug** %ar.addr, align 8
  %i_ci = getelementptr inbounds %struct.lua_Debug* %7, i32 0, i32 13
  %8 = load %struct.CallInfo** %i_ci, align 8
  store %struct.CallInfo* %8, %struct.CallInfo** %ci, align 8
  %9 = load %struct.CallInfo** %ci, align 8
  %func4 = getelementptr inbounds %struct.CallInfo* %9, i32 0, i32 0
  %10 = load %struct.lua_TValue** %func4, align 8
  store %struct.lua_TValue* %10, %struct.lua_TValue** %func, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %11 = load %struct.lua_TValue** %func, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %11, i32 0, i32 1
  %12 = load i32* %tt_, align 4
  %and = and i32 %12, 31
  %cmp5 = icmp eq i32 %and, 6
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %13 = load %struct.lua_TValue** %func, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %13, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %14 = load %union.GCObject** %gc, align 8
  %cl7 = bitcast %union.GCObject* %14 to %union.Closure*
  br label %cond.end

cond.false:                                       ; preds = %if.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %union.Closure* [ %cl7, %cond.true ], [ null, %cond.false ]
  store %union.Closure* %cond, %union.Closure** %cl, align 8
  %15 = load %struct.lua_State** %L.addr, align 8
  %16 = load i8** %what.addr, align 8
  %17 = load %struct.lua_Debug** %ar.addr, align 8
  %18 = load %union.Closure** %cl, align 8
  %19 = load %struct.CallInfo** %ci, align 8
  %call = call i32 @auxgetinfo(%struct.lua_State* %15, i8* %16, %struct.lua_Debug* %17, %union.Closure* %18, %struct.CallInfo* %19)
  store i32 %call, i32* %status, align 4
  %20 = load i8** %what.addr, align 8
  %call8 = call i8* @strchr(i8* %20, i32 102) #10
  %tobool = icmp ne i8* %call8, null
  br i1 %tobool, label %if.then9, label %if.end17

if.then9:                                         ; preds = %cond.end
  %21 = load %struct.lua_TValue** %func, align 8
  store %struct.lua_TValue* %21, %struct.lua_TValue** %io2, align 8
  %22 = load %struct.lua_State** %L.addr, align 8
  %top10 = getelementptr inbounds %struct.lua_State* %22, i32 0, i32 4
  %23 = load %struct.lua_TValue** %top10, align 8
  store %struct.lua_TValue* %23, %struct.lua_TValue** %io1, align 8
  %24 = load %struct.lua_TValue** %io1, align 8
  %value_11 = getelementptr inbounds %struct.lua_TValue* %24, i32 0, i32 0
  %25 = load %struct.lua_TValue** %io2, align 8
  %value_12 = getelementptr inbounds %struct.lua_TValue* %25, i32 0, i32 0
  %26 = bitcast %union.Value* %value_11 to i8*
  %27 = bitcast %union.Value* %value_12 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %26, i8* %27, i64 8, i32 8, i1 false)
  %28 = load %struct.lua_TValue** %io2, align 8
  %tt_13 = getelementptr inbounds %struct.lua_TValue* %28, i32 0, i32 1
  %29 = load i32* %tt_13, align 4
  %30 = load %struct.lua_TValue** %io1, align 8
  %tt_14 = getelementptr inbounds %struct.lua_TValue* %30, i32 0, i32 1
  store i32 %29, i32* %tt_14, align 4
  %31 = load %struct.lua_State** %L.addr, align 8
  %top15 = getelementptr inbounds %struct.lua_State* %31, i32 0, i32 4
  %32 = load %struct.lua_TValue** %top15, align 8
  %incdec.ptr16 = getelementptr inbounds %struct.lua_TValue* %32, i32 1
  store %struct.lua_TValue* %incdec.ptr16, %struct.lua_TValue** %top15, align 8
  br label %if.end17

if.end17:                                         ; preds = %if.then9, %cond.end
  %33 = load i8** %what.addr, align 8
  %call18 = call i8* @strchr(i8* %33, i32 76) #10
  %tobool19 = icmp ne i8* %call18, null
  br i1 %tobool19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %if.end17
  %34 = load %struct.lua_State** %L.addr, align 8
  %35 = load %union.Closure** %cl, align 8
  call void @collectvalidlines(%struct.lua_State* %34, %union.Closure* %35)
  br label %if.end21

if.end21:                                         ; preds = %if.then20, %if.end17
  %36 = load i32* %status, align 4
  ret i32 %36
}

; Function Attrs: noreturn nounwind uwtable
define hidden void @luaG_typeerror(%struct.lua_State* %L, %struct.lua_TValue* %o, i8* %op) #6 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %o.addr = alloca %struct.lua_TValue*, align 8
  %op.addr = alloca i8*, align 8
  %ci = alloca %struct.CallInfo*, align 8
  %name = alloca i8*, align 8
  %t = alloca i8*, align 8
  %kind = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.lua_TValue* %o, %struct.lua_TValue** %o.addr, align 8
  store i8* %op, i8** %op.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %ci1 = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 6
  %1 = load %struct.CallInfo** %ci1, align 8
  store %struct.CallInfo* %1, %struct.CallInfo** %ci, align 8
  store i8* null, i8** %name, align 8
  %2 = load %struct.lua_TValue** %o.addr, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %2, i32 0, i32 1
  %3 = load i32* %tt_, align 4
  %and = and i32 %3, 15
  %add = add nsw i32 %and, 1
  %idxprom = sext i32 %add to i64
  %arrayidx = getelementptr inbounds [12 x i8*]* @luaT_typenames_, i32 0, i64 %idxprom
  %4 = load i8** %arrayidx, align 8
  store i8* %4, i8** %t, align 8
  store i8* null, i8** %kind, align 8
  %5 = load %struct.CallInfo** %ci, align 8
  %callstatus = getelementptr inbounds %struct.CallInfo* %5, i32 0, i32 5
  %6 = load i8* %callstatus, align 1
  %conv = zext i8 %6 to i32
  %and2 = and i32 %conv, 1
  %tobool = icmp ne i32 %and2, 0
  br i1 %tobool, label %if.then, label %if.end11

if.then:                                          ; preds = %entry
  %7 = load %struct.CallInfo** %ci, align 8
  %8 = load %struct.lua_TValue** %o.addr, align 8
  %call = call i8* @getupvalname(%struct.CallInfo* %7, %struct.lua_TValue* %8, i8** %name)
  store i8* %call, i8** %kind, align 8
  %9 = load i8** %kind, align 8
  %tobool3 = icmp ne i8* %9, null
  br i1 %tobool3, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then
  %10 = load %struct.CallInfo** %ci, align 8
  %11 = load %struct.lua_TValue** %o.addr, align 8
  %call4 = call i32 @isinstack(%struct.CallInfo* %10, %struct.lua_TValue* %11)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.then6, label %if.end

if.then6:                                         ; preds = %land.lhs.true
  %12 = load %struct.CallInfo** %ci, align 8
  %func = getelementptr inbounds %struct.CallInfo* %12, i32 0, i32 0
  %13 = load %struct.lua_TValue** %func, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %13, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %14 = load %union.GCObject** %gc, align 8
  %cl = bitcast %union.GCObject* %14 to %union.Closure*
  %l = bitcast %union.Closure* %cl to %struct.LClosure*
  %p = getelementptr inbounds %struct.LClosure* %l, i32 0, i32 5
  %15 = load %struct.Proto** %p, align 8
  %16 = load %struct.CallInfo** %ci, align 8
  %call7 = call i32 @currentpc(%struct.CallInfo* %16)
  %17 = load %struct.lua_TValue** %o.addr, align 8
  %18 = load %struct.CallInfo** %ci, align 8
  %u = getelementptr inbounds %struct.CallInfo* %18, i32 0, i32 7
  %l8 = bitcast %union.anon.2* %u to %struct.anon.3*
  %base = getelementptr inbounds %struct.anon.3* %l8, i32 0, i32 0
  %19 = load %struct.lua_TValue** %base, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.lua_TValue* %17 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.lua_TValue* %19 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 16
  %conv9 = trunc i64 %sub.ptr.div to i32
  %call10 = call i8* @getobjname(%struct.Proto* %15, i32 %call7, i32 %conv9, i8** %name)
  store i8* %call10, i8** %kind, align 8
  br label %if.end

if.end:                                           ; preds = %if.then6, %land.lhs.true, %if.then
  br label %if.end11

if.end11:                                         ; preds = %if.end, %entry
  %20 = load i8** %kind, align 8
  %tobool12 = icmp ne i8* %20, null
  br i1 %tobool12, label %if.then13, label %if.else

if.then13:                                        ; preds = %if.end11
  %21 = load %struct.lua_State** %L.addr, align 8
  %22 = load i8** %op.addr, align 8
  %23 = load i8** %kind, align 8
  %24 = load i8** %name, align 8
  %25 = load i8** %t, align 8
  call void (%struct.lua_State*, i8*, ...)* @luaG_runerror(%struct.lua_State* %21, i8* getelementptr inbounds ([35 x i8]* @.str194, i32 0, i32 0), i8* %22, i8* %23, i8* %24, i8* %25) #9
  unreachable

if.else:                                          ; preds = %if.end11
  %26 = load %struct.lua_State** %L.addr, align 8
  %27 = load i8** %op.addr, align 8
  %28 = load i8** %t, align 8
  call void (%struct.lua_State*, i8*, ...)* @luaG_runerror(%struct.lua_State* %26, i8* getelementptr inbounds ([25 x i8]* @.str1195, i32 0, i32 0), i8* %27, i8* %28) #9
  unreachable

return:                                           ; No predecessors!
  ret void
}

; Function Attrs: noreturn nounwind uwtable
define hidden void @luaG_runerror(%struct.lua_State* %L, i8* %fmt, ...) #6 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %fmt.addr = alloca i8*, align 8
  %argp = alloca [1 x %struct.__va_list_tag], align 16
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %fmt, i8** %fmt.addr, align 8
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag]* %argp, i32 0, i32 0
  %arraydecay1 = bitcast %struct.__va_list_tag* %arraydecay to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load i8** %fmt.addr, align 8
  %arraydecay2 = getelementptr inbounds [1 x %struct.__va_list_tag]* %argp, i32 0, i32 0
  %call = call i8* bitcast (i8* (%struct.lua_State.279*, i8*, %struct.__va_list_tag*)* @luaO_pushvfstring to i8* (%struct.lua_State*, i8*, %struct.__va_list_tag*)*)(%struct.lua_State* %1, i8* %2, %struct.__va_list_tag* %arraydecay2)
  call void @addinfo(%struct.lua_State* %0, i8* %call)
  %arraydecay3 = getelementptr inbounds [1 x %struct.__va_list_tag]* %argp, i32 0, i32 0
  %arraydecay34 = bitcast %struct.__va_list_tag* %arraydecay3 to i8*
  call void @llvm.va_end(i8* %arraydecay34)
  %3 = load %struct.lua_State** %L.addr, align 8
  call void @luaG_errormsg(%struct.lua_State* %3) #9
  unreachable

return:                                           ; No predecessors!
  ret void
}

; Function Attrs: noreturn nounwind uwtable
define hidden void @luaG_concaterror(%struct.lua_State* %L, %struct.lua_TValue* %p1, %struct.lua_TValue* %p2) #6 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %p1.addr = alloca %struct.lua_TValue*, align 8
  %p2.addr = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.lua_TValue* %p1, %struct.lua_TValue** %p1.addr, align 8
  store %struct.lua_TValue* %p2, %struct.lua_TValue** %p2.addr, align 8
  %0 = load %struct.lua_TValue** %p1.addr, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %0, i32 0, i32 1
  %1 = load i32* %tt_, align 4
  %and = and i32 %1, 15
  %cmp = icmp eq i32 %and, 4
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load %struct.lua_TValue** %p1.addr, align 8
  %tt_1 = getelementptr inbounds %struct.lua_TValue* %2, i32 0, i32 1
  %3 = load i32* %tt_1, align 4
  %cmp2 = icmp eq i32 %3, 3
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %4 = load %struct.lua_TValue** %p2.addr, align 8
  store %struct.lua_TValue* %4, %struct.lua_TValue** %p1.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  %5 = load %struct.lua_State** %L.addr, align 8
  %6 = load %struct.lua_TValue** %p1.addr, align 8
  call void @luaG_typeerror(%struct.lua_State* %5, %struct.lua_TValue* %6, i8* getelementptr inbounds ([12 x i8]* @.str2196, i32 0, i32 0)) #9
  unreachable

return:                                           ; No predecessors!
  ret void
}

; Function Attrs: noreturn nounwind uwtable
define hidden void @luaG_aritherror(%struct.lua_State* %L, %struct.lua_TValue* %p1, %struct.lua_TValue* %p2) #6 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %p1.addr = alloca %struct.lua_TValue*, align 8
  %p2.addr = alloca %struct.lua_TValue*, align 8
  %temp = alloca %struct.lua_TValue, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.lua_TValue* %p1, %struct.lua_TValue** %p1.addr, align 8
  store %struct.lua_TValue* %p2, %struct.lua_TValue** %p2.addr, align 8
  %0 = load %struct.lua_TValue** %p1.addr, align 8
  %call = call %struct.lua_TValue* bitcast (%struct.lua_TValue.349* (%struct.lua_TValue.349*, %struct.lua_TValue.349*)* @luaV_tonumber to %struct.lua_TValue* (%struct.lua_TValue*, %struct.lua_TValue*)*)(%struct.lua_TValue* %0, %struct.lua_TValue* %temp)
  %cmp = icmp eq %struct.lua_TValue* %call, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.lua_TValue** %p1.addr, align 8
  store %struct.lua_TValue* %1, %struct.lua_TValue** %p2.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load %struct.lua_TValue** %p2.addr, align 8
  call void @luaG_typeerror(%struct.lua_State* %2, %struct.lua_TValue* %3, i8* getelementptr inbounds ([22 x i8]* @.str3197, i32 0, i32 0)) #9
  unreachable

return:                                           ; No predecessors!
  ret void
}

; Function Attrs: noreturn nounwind uwtable
define hidden void @luaG_ordererror(%struct.lua_State* %L, %struct.lua_TValue* %p1, %struct.lua_TValue* %p2) #6 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %p1.addr = alloca %struct.lua_TValue*, align 8
  %p2.addr = alloca %struct.lua_TValue*, align 8
  %t1 = alloca i8*, align 8
  %t2 = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.lua_TValue* %p1, %struct.lua_TValue** %p1.addr, align 8
  store %struct.lua_TValue* %p2, %struct.lua_TValue** %p2.addr, align 8
  %0 = load %struct.lua_TValue** %p1.addr, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %0, i32 0, i32 1
  %1 = load i32* %tt_, align 4
  %and = and i32 %1, 15
  %add = add nsw i32 %and, 1
  %idxprom = sext i32 %add to i64
  %arrayidx = getelementptr inbounds [12 x i8*]* @luaT_typenames_, i32 0, i64 %idxprom
  %2 = load i8** %arrayidx, align 8
  store i8* %2, i8** %t1, align 8
  %3 = load %struct.lua_TValue** %p2.addr, align 8
  %tt_1 = getelementptr inbounds %struct.lua_TValue* %3, i32 0, i32 1
  %4 = load i32* %tt_1, align 4
  %and2 = and i32 %4, 15
  %add3 = add nsw i32 %and2, 1
  %idxprom4 = sext i32 %add3 to i64
  %arrayidx5 = getelementptr inbounds [12 x i8*]* @luaT_typenames_, i32 0, i64 %idxprom4
  %5 = load i8** %arrayidx5, align 8
  store i8* %5, i8** %t2, align 8
  %6 = load i8** %t1, align 8
  %7 = load i8** %t2, align 8
  %cmp = icmp eq i8* %6, %7
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %8 = load %struct.lua_State** %L.addr, align 8
  %9 = load i8** %t1, align 8
  call void (%struct.lua_State*, i8*, ...)* @luaG_runerror(%struct.lua_State* %8, i8* getelementptr inbounds ([33 x i8]* @.str4198, i32 0, i32 0), i8* %9) #9
  unreachable

if.else:                                          ; preds = %entry
  %10 = load %struct.lua_State** %L.addr, align 8
  %11 = load i8** %t1, align 8
  %12 = load i8** %t2, align 8
  call void (%struct.lua_State*, i8*, ...)* @luaG_runerror(%struct.lua_State* %10, i8* getelementptr inbounds ([30 x i8]* @.str5199, i32 0, i32 0), i8* %11, i8* %12) #9
  unreachable

return:                                           ; No predecessors!
  ret void
}

; Function Attrs: noreturn nounwind uwtable
define hidden void @luaG_errormsg(%struct.lua_State* %L) #6 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %errfunc1 = alloca %struct.lua_TValue*, align 8
  %io2 = alloca %struct.lua_TValue*, align 8
  %io1 = alloca %struct.lua_TValue*, align 8
  %io210 = alloca %struct.lua_TValue*, align 8
  %io111 = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %errfunc = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 21
  %1 = load i64* %errfunc, align 8
  %cmp = icmp ne i64 %1, 0
  br i1 %cmp, label %if.then, label %if.end21

if.then:                                          ; preds = %entry
  %2 = load %struct.lua_State** %L.addr, align 8
  %stack = getelementptr inbounds %struct.lua_State* %2, i32 0, i32 9
  %3 = load %struct.lua_TValue** %stack, align 8
  %4 = bitcast %struct.lua_TValue* %3 to i8*
  %5 = load %struct.lua_State** %L.addr, align 8
  %errfunc2 = getelementptr inbounds %struct.lua_State* %5, i32 0, i32 21
  %6 = load i64* %errfunc2, align 8
  %add.ptr = getelementptr inbounds i8* %4, i64 %6
  %7 = bitcast i8* %add.ptr to %struct.lua_TValue*
  store %struct.lua_TValue* %7, %struct.lua_TValue** %errfunc1, align 8
  %8 = load %struct.lua_TValue** %errfunc1, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %8, i32 0, i32 1
  %9 = load i32* %tt_, align 4
  %and = and i32 %9, 15
  %cmp3 = icmp eq i32 %and, 6
  br i1 %cmp3, label %if.end, label %if.then4

if.then4:                                         ; preds = %if.then
  %10 = load %struct.lua_State** %L.addr, align 8
  call void @luaD_throw(%struct.lua_State* %10, i32 6) #9
  unreachable

if.end:                                           ; preds = %if.then
  %11 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %11, i32 0, i32 4
  %12 = load %struct.lua_TValue** %top, align 8
  %add.ptr5 = getelementptr inbounds %struct.lua_TValue* %12, i64 -1
  store %struct.lua_TValue* %add.ptr5, %struct.lua_TValue** %io2, align 8
  %13 = load %struct.lua_State** %L.addr, align 8
  %top6 = getelementptr inbounds %struct.lua_State* %13, i32 0, i32 4
  %14 = load %struct.lua_TValue** %top6, align 8
  store %struct.lua_TValue* %14, %struct.lua_TValue** %io1, align 8
  %15 = load %struct.lua_TValue** %io1, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %15, i32 0, i32 0
  %16 = load %struct.lua_TValue** %io2, align 8
  %value_7 = getelementptr inbounds %struct.lua_TValue* %16, i32 0, i32 0
  %17 = bitcast %union.Value* %value_ to i8*
  %18 = bitcast %union.Value* %value_7 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %17, i8* %18, i64 8, i32 8, i1 false)
  %19 = load %struct.lua_TValue** %io2, align 8
  %tt_8 = getelementptr inbounds %struct.lua_TValue* %19, i32 0, i32 1
  %20 = load i32* %tt_8, align 4
  %21 = load %struct.lua_TValue** %io1, align 8
  %tt_9 = getelementptr inbounds %struct.lua_TValue* %21, i32 0, i32 1
  store i32 %20, i32* %tt_9, align 4
  %22 = load %struct.lua_TValue** %errfunc1, align 8
  store %struct.lua_TValue* %22, %struct.lua_TValue** %io210, align 8
  %23 = load %struct.lua_State** %L.addr, align 8
  %top12 = getelementptr inbounds %struct.lua_State* %23, i32 0, i32 4
  %24 = load %struct.lua_TValue** %top12, align 8
  %add.ptr13 = getelementptr inbounds %struct.lua_TValue* %24, i64 -1
  store %struct.lua_TValue* %add.ptr13, %struct.lua_TValue** %io111, align 8
  %25 = load %struct.lua_TValue** %io111, align 8
  %value_14 = getelementptr inbounds %struct.lua_TValue* %25, i32 0, i32 0
  %26 = load %struct.lua_TValue** %io210, align 8
  %value_15 = getelementptr inbounds %struct.lua_TValue* %26, i32 0, i32 0
  %27 = bitcast %union.Value* %value_14 to i8*
  %28 = bitcast %union.Value* %value_15 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %27, i8* %28, i64 8, i32 8, i1 false)
  %29 = load %struct.lua_TValue** %io210, align 8
  %tt_16 = getelementptr inbounds %struct.lua_TValue* %29, i32 0, i32 1
  %30 = load i32* %tt_16, align 4
  %31 = load %struct.lua_TValue** %io111, align 8
  %tt_17 = getelementptr inbounds %struct.lua_TValue* %31, i32 0, i32 1
  store i32 %30, i32* %tt_17, align 4
  %32 = load %struct.lua_State** %L.addr, align 8
  %top18 = getelementptr inbounds %struct.lua_State* %32, i32 0, i32 4
  %33 = load %struct.lua_TValue** %top18, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %33, i32 1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %top18, align 8
  %34 = load %struct.lua_State** %L.addr, align 8
  %35 = load %struct.lua_State** %L.addr, align 8
  %top19 = getelementptr inbounds %struct.lua_State* %35, i32 0, i32 4
  %36 = load %struct.lua_TValue** %top19, align 8
  %add.ptr20 = getelementptr inbounds %struct.lua_TValue* %36, i64 -2
  call void @luaD_call(%struct.lua_State* %34, %struct.lua_TValue* %add.ptr20, i32 1, i32 0)
  br label %if.end21

if.end21:                                         ; preds = %if.end, %entry
  %37 = load %struct.lua_State** %L.addr, align 8
  call void @luaD_throw(%struct.lua_State* %37, i32 2) #9
  unreachable

return:                                           ; No predecessors!
  ret void
}

; Function Attrs: nounwind uwtable
define internal i8* @findlocal(%struct.lua_State* %L, %struct.CallInfo* %ci, i32 %n, %struct.lua_TValue** %pos) #0 {
entry:
  %retval = alloca i8*, align 8
  %L.addr = alloca %struct.lua_State*, align 8
  %ci.addr = alloca %struct.CallInfo*, align 8
  %n.addr = alloca i32, align 4
  %pos.addr = alloca %struct.lua_TValue**, align 8
  %name = alloca i8*, align 8
  %base = alloca %struct.lua_TValue*, align 8
  %limit = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.CallInfo* %ci, %struct.CallInfo** %ci.addr, align 8
  store i32 %n, i32* %n.addr, align 4
  store %struct.lua_TValue** %pos, %struct.lua_TValue*** %pos.addr, align 8
  store i8* null, i8** %name, align 8
  %0 = load %struct.CallInfo** %ci.addr, align 8
  %callstatus = getelementptr inbounds %struct.CallInfo* %0, i32 0, i32 5
  %1 = load i8* %callstatus, align 1
  %conv = zext i8 %1 to i32
  %and = and i32 %conv, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else7

if.then:                                          ; preds = %entry
  %2 = load i32* %n.addr, align 4
  %cmp = icmp slt i32 %2, 0
  br i1 %cmp, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  %3 = load %struct.CallInfo** %ci.addr, align 8
  %4 = load i32* %n.addr, align 4
  %sub = sub nsw i32 0, %4
  %5 = load %struct.lua_TValue*** %pos.addr, align 8
  %call = call i8* @findvararg(%struct.CallInfo* %3, i32 %sub, %struct.lua_TValue** %5)
  store i8* %call, i8** %retval
  br label %return

if.else:                                          ; preds = %if.then
  %6 = load %struct.CallInfo** %ci.addr, align 8
  %u = getelementptr inbounds %struct.CallInfo* %6, i32 0, i32 7
  %l = bitcast %union.anon.2* %u to %struct.anon.3*
  %base3 = getelementptr inbounds %struct.anon.3* %l, i32 0, i32 0
  %7 = load %struct.lua_TValue** %base3, align 8
  store %struct.lua_TValue* %7, %struct.lua_TValue** %base, align 8
  %8 = load %struct.CallInfo** %ci.addr, align 8
  %func = getelementptr inbounds %struct.CallInfo* %8, i32 0, i32 0
  %9 = load %struct.lua_TValue** %func, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %9, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %10 = load %union.GCObject** %gc, align 8
  %cl = bitcast %union.GCObject* %10 to %union.Closure*
  %l4 = bitcast %union.Closure* %cl to %struct.LClosure*
  %p = getelementptr inbounds %struct.LClosure* %l4, i32 0, i32 5
  %11 = load %struct.Proto** %p, align 8
  %12 = load i32* %n.addr, align 4
  %13 = load %struct.CallInfo** %ci.addr, align 8
  %call5 = call i32 @currentpc(%struct.CallInfo* %13)
  %call6 = call i8* bitcast (i8* (%struct.Proto.160*, i32, i32)* @luaF_getlocalname to i8* (%struct.Proto*, i32, i32)*)(%struct.Proto* %11, i32 %12, i32 %call5)
  store i8* %call6, i8** %name, align 8
  br label %if.end

if.end:                                           ; preds = %if.else
  br label %if.end9

if.else7:                                         ; preds = %entry
  %14 = load %struct.CallInfo** %ci.addr, align 8
  %func8 = getelementptr inbounds %struct.CallInfo* %14, i32 0, i32 0
  %15 = load %struct.lua_TValue** %func8, align 8
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %15, i64 1
  store %struct.lua_TValue* %add.ptr, %struct.lua_TValue** %base, align 8
  br label %if.end9

if.end9:                                          ; preds = %if.else7, %if.end
  %16 = load i8** %name, align 8
  %cmp10 = icmp eq i8* %16, null
  br i1 %cmp10, label %if.then12, label %if.end25

if.then12:                                        ; preds = %if.end9
  %17 = load %struct.CallInfo** %ci.addr, align 8
  %18 = load %struct.lua_State** %L.addr, align 8
  %ci13 = getelementptr inbounds %struct.lua_State* %18, i32 0, i32 6
  %19 = load %struct.CallInfo** %ci13, align 8
  %cmp14 = icmp eq %struct.CallInfo* %17, %19
  br i1 %cmp14, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then12
  %20 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %20, i32 0, i32 4
  %21 = load %struct.lua_TValue** %top, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then12
  %22 = load %struct.CallInfo** %ci.addr, align 8
  %next = getelementptr inbounds %struct.CallInfo* %22, i32 0, i32 3
  %23 = load %struct.CallInfo** %next, align 8
  %func16 = getelementptr inbounds %struct.CallInfo* %23, i32 0, i32 0
  %24 = load %struct.lua_TValue** %func16, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.lua_TValue* [ %21, %cond.true ], [ %24, %cond.false ]
  store %struct.lua_TValue* %cond, %struct.lua_TValue** %limit, align 8
  %25 = load %struct.lua_TValue** %limit, align 8
  %26 = load %struct.lua_TValue** %base, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.lua_TValue* %25 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.lua_TValue* %26 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 16
  %27 = load i32* %n.addr, align 4
  %conv17 = sext i32 %27 to i64
  %cmp18 = icmp sge i64 %sub.ptr.div, %conv17
  br i1 %cmp18, label %land.lhs.true, label %if.else23

land.lhs.true:                                    ; preds = %cond.end
  %28 = load i32* %n.addr, align 4
  %cmp20 = icmp sgt i32 %28, 0
  br i1 %cmp20, label %if.then22, label %if.else23

if.then22:                                        ; preds = %land.lhs.true
  store i8* getelementptr inbounds ([13 x i8]* @.str23217, i32 0, i32 0), i8** %name, align 8
  br label %if.end24

if.else23:                                        ; preds = %land.lhs.true, %cond.end
  store i8* null, i8** %retval
  br label %return

if.end24:                                         ; preds = %if.then22
  br label %if.end25

if.end25:                                         ; preds = %if.end24, %if.end9
  %29 = load %struct.lua_TValue** %base, align 8
  %30 = load i32* %n.addr, align 4
  %sub26 = sub nsw i32 %30, 1
  %idx.ext = sext i32 %sub26 to i64
  %add.ptr27 = getelementptr inbounds %struct.lua_TValue* %29, i64 %idx.ext
  %31 = load %struct.lua_TValue*** %pos.addr, align 8
  store %struct.lua_TValue* %add.ptr27, %struct.lua_TValue** %31, align 8
  %32 = load i8** %name, align 8
  store i8* %32, i8** %retval
  br label %return

return:                                           ; preds = %if.end25, %if.else23, %if.then2
  %33 = load i8** %retval
  ret i8* %33
}

; Function Attrs: nounwind uwtable
define internal i32 @auxgetinfo(%struct.lua_State* %L, i8* %what, %struct.lua_Debug* %ar, %union.Closure* %f, %struct.CallInfo* %ci) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %what.addr = alloca i8*, align 8
  %ar.addr = alloca %struct.lua_Debug*, align 8
  %f.addr = alloca %union.Closure*, align 8
  %ci.addr = alloca %struct.CallInfo*, align 8
  %status = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %what, i8** %what.addr, align 8
  store %struct.lua_Debug* %ar, %struct.lua_Debug** %ar.addr, align 8
  store %union.Closure* %f, %union.Closure** %f.addr, align 8
  store %struct.CallInfo* %ci, %struct.CallInfo** %ci.addr, align 8
  store i32 1, i32* %status, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i8** %what.addr, align 8
  %1 = load i8* %0, align 1
  %tobool = icmp ne i8 %1, 0
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i8** %what.addr, align 8
  %3 = load i8* %2, align 1
  %conv = sext i8 %3 to i32
  switch i32 %conv, label %sw.default [
    i32 83, label %sw.bb
    i32 108, label %sw.bb1
    i32 117, label %sw.bb5
    i32 116, label %sw.bb23
    i32 110, label %sw.bb33
    i32 76, label %sw.bb58
    i32 102, label %sw.bb58
  ]

sw.bb:                                            ; preds = %for.body
  %4 = load %struct.lua_Debug** %ar.addr, align 8
  %5 = load %union.Closure** %f.addr, align 8
  call void @funcinfo(%struct.lua_Debug* %4, %union.Closure* %5)
  br label %sw.epilog

sw.bb1:                                           ; preds = %for.body
  %6 = load %struct.CallInfo** %ci.addr, align 8
  %tobool2 = icmp ne %struct.CallInfo* %6, null
  br i1 %tobool2, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %sw.bb1
  %7 = load %struct.CallInfo** %ci.addr, align 8
  %callstatus = getelementptr inbounds %struct.CallInfo* %7, i32 0, i32 5
  %8 = load i8* %callstatus, align 1
  %conv3 = zext i8 %8 to i32
  %and = and i32 %conv3, 1
  %tobool4 = icmp ne i32 %and, 0
  br i1 %tobool4, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  %9 = load %struct.CallInfo** %ci.addr, align 8
  %call = call i32 @currentline(%struct.CallInfo* %9)
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %sw.bb1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %call, %cond.true ], [ -1, %cond.false ]
  %10 = load %struct.lua_Debug** %ar.addr, align 8
  %currentline = getelementptr inbounds %struct.lua_Debug* %10, i32 0, i32 5
  store i32 %cond, i32* %currentline, align 4
  br label %sw.epilog

sw.bb5:                                           ; preds = %for.body
  %11 = load %union.Closure** %f.addr, align 8
  %cmp = icmp eq %union.Closure* %11, null
  br i1 %cmp, label %cond.true7, label %cond.false8

cond.true7:                                       ; preds = %sw.bb5
  br label %cond.end10

cond.false8:                                      ; preds = %sw.bb5
  %12 = load %union.Closure** %f.addr, align 8
  %c = bitcast %union.Closure* %12 to %struct.CClosure*
  %nupvalues = getelementptr inbounds %struct.CClosure* %c, i32 0, i32 3
  %13 = load i8* %nupvalues, align 1
  %conv9 = zext i8 %13 to i32
  br label %cond.end10

cond.end10:                                       ; preds = %cond.false8, %cond.true7
  %cond11 = phi i32 [ 0, %cond.true7 ], [ %conv9, %cond.false8 ]
  %conv12 = trunc i32 %cond11 to i8
  %14 = load %struct.lua_Debug** %ar.addr, align 8
  %nups = getelementptr inbounds %struct.lua_Debug* %14, i32 0, i32 8
  store i8 %conv12, i8* %nups, align 1
  %15 = load %union.Closure** %f.addr, align 8
  %cmp13 = icmp eq %union.Closure* %15, null
  br i1 %cmp13, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end10
  %16 = load %union.Closure** %f.addr, align 8
  %c15 = bitcast %union.Closure* %16 to %struct.CClosure*
  %tt = getelementptr inbounds %struct.CClosure* %c15, i32 0, i32 1
  %17 = load i8* %tt, align 1
  %conv16 = zext i8 %17 to i32
  %cmp17 = icmp eq i32 %conv16, 38
  br i1 %cmp17, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %cond.end10
  %18 = load %struct.lua_Debug** %ar.addr, align 8
  %isvararg = getelementptr inbounds %struct.lua_Debug* %18, i32 0, i32 10
  store i8 1, i8* %isvararg, align 1
  %19 = load %struct.lua_Debug** %ar.addr, align 8
  %nparams = getelementptr inbounds %struct.lua_Debug* %19, i32 0, i32 9
  store i8 0, i8* %nparams, align 1
  br label %if.end

if.else:                                          ; preds = %lor.lhs.false
  %20 = load %union.Closure** %f.addr, align 8
  %l = bitcast %union.Closure* %20 to %struct.LClosure*
  %p = getelementptr inbounds %struct.LClosure* %l, i32 0, i32 5
  %21 = load %struct.Proto** %p, align 8
  %is_vararg = getelementptr inbounds %struct.Proto* %21, i32 0, i32 21
  %22 = load i8* %is_vararg, align 1
  %23 = load %struct.lua_Debug** %ar.addr, align 8
  %isvararg19 = getelementptr inbounds %struct.lua_Debug* %23, i32 0, i32 10
  store i8 %22, i8* %isvararg19, align 1
  %24 = load %union.Closure** %f.addr, align 8
  %l20 = bitcast %union.Closure* %24 to %struct.LClosure*
  %p21 = getelementptr inbounds %struct.LClosure* %l20, i32 0, i32 5
  %25 = load %struct.Proto** %p21, align 8
  %numparams = getelementptr inbounds %struct.Proto* %25, i32 0, i32 20
  %26 = load i8* %numparams, align 1
  %27 = load %struct.lua_Debug** %ar.addr, align 8
  %nparams22 = getelementptr inbounds %struct.lua_Debug* %27, i32 0, i32 9
  store i8 %26, i8* %nparams22, align 1
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  br label %sw.epilog

sw.bb23:                                          ; preds = %for.body
  %28 = load %struct.CallInfo** %ci.addr, align 8
  %tobool24 = icmp ne %struct.CallInfo* %28, null
  br i1 %tobool24, label %cond.true25, label %cond.false29

cond.true25:                                      ; preds = %sw.bb23
  %29 = load %struct.CallInfo** %ci.addr, align 8
  %callstatus26 = getelementptr inbounds %struct.CallInfo* %29, i32 0, i32 5
  %30 = load i8* %callstatus26, align 1
  %conv27 = zext i8 %30 to i32
  %and28 = and i32 %conv27, 64
  br label %cond.end30

cond.false29:                                     ; preds = %sw.bb23
  br label %cond.end30

cond.end30:                                       ; preds = %cond.false29, %cond.true25
  %cond31 = phi i32 [ %and28, %cond.true25 ], [ 0, %cond.false29 ]
  %conv32 = trunc i32 %cond31 to i8
  %31 = load %struct.lua_Debug** %ar.addr, align 8
  %istailcall = getelementptr inbounds %struct.lua_Debug* %31, i32 0, i32 11
  store i8 %conv32, i8* %istailcall, align 1
  br label %sw.epilog

sw.bb33:                                          ; preds = %for.body
  %32 = load %struct.CallInfo** %ci.addr, align 8
  %tobool34 = icmp ne %struct.CallInfo* %32, null
  br i1 %tobool34, label %land.lhs.true35, label %if.else48

land.lhs.true35:                                  ; preds = %sw.bb33
  %33 = load %struct.CallInfo** %ci.addr, align 8
  %callstatus36 = getelementptr inbounds %struct.CallInfo* %33, i32 0, i32 5
  %34 = load i8* %callstatus36, align 1
  %conv37 = zext i8 %34 to i32
  %and38 = and i32 %conv37, 64
  %tobool39 = icmp ne i32 %and38, 0
  br i1 %tobool39, label %if.else48, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true35
  %35 = load %struct.CallInfo** %ci.addr, align 8
  %previous = getelementptr inbounds %struct.CallInfo* %35, i32 0, i32 2
  %36 = load %struct.CallInfo** %previous, align 8
  %callstatus41 = getelementptr inbounds %struct.CallInfo* %36, i32 0, i32 5
  %37 = load i8* %callstatus41, align 1
  %conv42 = zext i8 %37 to i32
  %and43 = and i32 %conv42, 1
  %tobool44 = icmp ne i32 %and43, 0
  br i1 %tobool44, label %if.then45, label %if.else48

if.then45:                                        ; preds = %land.lhs.true40
  %38 = load %struct.lua_State** %L.addr, align 8
  %39 = load %struct.CallInfo** %ci.addr, align 8
  %previous46 = getelementptr inbounds %struct.CallInfo* %39, i32 0, i32 2
  %40 = load %struct.CallInfo** %previous46, align 8
  %41 = load %struct.lua_Debug** %ar.addr, align 8
  %name = getelementptr inbounds %struct.lua_Debug* %41, i32 0, i32 1
  %call47 = call i8* @getfuncname(%struct.lua_State* %38, %struct.CallInfo* %40, i8** %name)
  %42 = load %struct.lua_Debug** %ar.addr, align 8
  %namewhat = getelementptr inbounds %struct.lua_Debug* %42, i32 0, i32 2
  store i8* %call47, i8** %namewhat, align 8
  br label %if.end50

if.else48:                                        ; preds = %land.lhs.true40, %land.lhs.true35, %sw.bb33
  %43 = load %struct.lua_Debug** %ar.addr, align 8
  %namewhat49 = getelementptr inbounds %struct.lua_Debug* %43, i32 0, i32 2
  store i8* null, i8** %namewhat49, align 8
  br label %if.end50

if.end50:                                         ; preds = %if.else48, %if.then45
  %44 = load %struct.lua_Debug** %ar.addr, align 8
  %namewhat51 = getelementptr inbounds %struct.lua_Debug* %44, i32 0, i32 2
  %45 = load i8** %namewhat51, align 8
  %cmp52 = icmp eq i8* %45, null
  br i1 %cmp52, label %if.then54, label %if.end57

if.then54:                                        ; preds = %if.end50
  %46 = load %struct.lua_Debug** %ar.addr, align 8
  %namewhat55 = getelementptr inbounds %struct.lua_Debug* %46, i32 0, i32 2
  store i8* getelementptr inbounds ([1 x i8]* @.str15209, i32 0, i32 0), i8** %namewhat55, align 8
  %47 = load %struct.lua_Debug** %ar.addr, align 8
  %name56 = getelementptr inbounds %struct.lua_Debug* %47, i32 0, i32 1
  store i8* null, i8** %name56, align 8
  br label %if.end57

if.end57:                                         ; preds = %if.then54, %if.end50
  br label %sw.epilog

sw.bb58:                                          ; preds = %for.body, %for.body
  br label %sw.epilog

sw.default:                                       ; preds = %for.body
  store i32 0, i32* %status, align 4
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb58, %if.end57, %cond.end30, %if.end, %cond.end, %sw.bb
  br label %for.inc

for.inc:                                          ; preds = %sw.epilog
  %48 = load i8** %what.addr, align 8
  %incdec.ptr = getelementptr inbounds i8* %48, i32 1
  store i8* %incdec.ptr, i8** %what.addr, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %49 = load i32* %status, align 4
  ret i32 %49
}

; Function Attrs: nounwind uwtable
define internal void @collectvalidlines(%struct.lua_State* %L, %union.Closure* %f) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %f.addr = alloca %union.Closure*, align 8
  %i = alloca i32, align 4
  %v = alloca %struct.lua_TValue, align 8
  %lineinfo = alloca i32*, align 8
  %t = alloca %struct.Table*, align 8
  %io = alloca %struct.lua_TValue*, align 8
  %io9 = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %union.Closure* %f, %union.Closure** %f.addr, align 8
  %0 = load %union.Closure** %f.addr, align 8
  %cmp = icmp eq %union.Closure* %0, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load %union.Closure** %f.addr, align 8
  %c = bitcast %union.Closure* %1 to %struct.CClosure*
  %tt = getelementptr inbounds %struct.CClosure* %c, i32 0, i32 1
  %2 = load i8* %tt, align 1
  %conv = zext i8 %2 to i32
  %cmp1 = icmp eq i32 %conv, 38
  br i1 %cmp1, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  %3 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %3, i32 0, i32 4
  %4 = load %struct.lua_TValue** %top, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %4, i32 0, i32 1
  store i32 0, i32* %tt_, align 4
  %5 = load %struct.lua_State** %L.addr, align 8
  %top3 = getelementptr inbounds %struct.lua_State* %5, i32 0, i32 4
  %6 = load %struct.lua_TValue** %top3, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %6, i32 1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %top3, align 8
  br label %if.end

if.else:                                          ; preds = %lor.lhs.false
  %7 = load %union.Closure** %f.addr, align 8
  %l = bitcast %union.Closure* %7 to %struct.LClosure*
  %p = getelementptr inbounds %struct.LClosure* %l, i32 0, i32 5
  %8 = load %struct.Proto** %p, align 8
  %lineinfo4 = getelementptr inbounds %struct.Proto* %8, i32 0, i32 6
  %9 = load i32** %lineinfo4, align 8
  store i32* %9, i32** %lineinfo, align 8
  %10 = load %struct.lua_State** %L.addr, align 8
  %call = call %struct.Table* @luaH_new(%struct.lua_State* %10)
  store %struct.Table* %call, %struct.Table** %t, align 8
  %11 = load %struct.lua_State** %L.addr, align 8
  %top5 = getelementptr inbounds %struct.lua_State* %11, i32 0, i32 4
  %12 = load %struct.lua_TValue** %top5, align 8
  store %struct.lua_TValue* %12, %struct.lua_TValue** %io, align 8
  %13 = load %struct.Table** %t, align 8
  %14 = bitcast %struct.Table* %13 to %union.GCObject*
  %15 = load %struct.lua_TValue** %io, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %15, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  store %union.GCObject* %14, %union.GCObject** %gc, align 8
  %16 = load %struct.lua_TValue** %io, align 8
  %tt_6 = getelementptr inbounds %struct.lua_TValue* %16, i32 0, i32 1
  store i32 69, i32* %tt_6, align 4
  %17 = load %struct.lua_State** %L.addr, align 8
  %top7 = getelementptr inbounds %struct.lua_State* %17, i32 0, i32 4
  %18 = load %struct.lua_TValue** %top7, align 8
  %incdec.ptr8 = getelementptr inbounds %struct.lua_TValue* %18, i32 1
  store %struct.lua_TValue* %incdec.ptr8, %struct.lua_TValue** %top7, align 8
  store %struct.lua_TValue* %v, %struct.lua_TValue** %io9, align 8
  %19 = load %struct.lua_TValue** %io9, align 8
  %value_10 = getelementptr inbounds %struct.lua_TValue* %19, i32 0, i32 0
  %b = bitcast %union.Value* %value_10 to i32*
  store i32 1, i32* %b, align 4
  %20 = load %struct.lua_TValue** %io9, align 8
  %tt_11 = getelementptr inbounds %struct.lua_TValue* %20, i32 0, i32 1
  store i32 1, i32* %tt_11, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.else
  %21 = load i32* %i, align 4
  %22 = load %union.Closure** %f.addr, align 8
  %l12 = bitcast %union.Closure* %22 to %struct.LClosure*
  %p13 = getelementptr inbounds %struct.LClosure* %l12, i32 0, i32 5
  %23 = load %struct.Proto** %p13, align 8
  %sizelineinfo = getelementptr inbounds %struct.Proto* %23, i32 0, i32 14
  %24 = load i32* %sizelineinfo, align 4
  %cmp14 = icmp slt i32 %21, %24
  br i1 %cmp14, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %25 = load %struct.lua_State** %L.addr, align 8
  %26 = load %struct.Table** %t, align 8
  %27 = load i32* %i, align 4
  %idxprom = sext i32 %27 to i64
  %28 = load i32** %lineinfo, align 8
  %arrayidx = getelementptr inbounds i32* %28, i64 %idxprom
  %29 = load i32* %arrayidx, align 4
  call void @luaH_setint(%struct.lua_State* %25, %struct.Table* %26, i32 %29, %struct.lua_TValue* %v)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %30 = load i32* %i, align 4
  %inc = add nsw i32 %30, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end

if.end:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal i8* @getupvalname(%struct.CallInfo* %ci, %struct.lua_TValue* %o, i8** %name) #0 {
entry:
  %retval = alloca i8*, align 8
  %ci.addr = alloca %struct.CallInfo*, align 8
  %o.addr = alloca %struct.lua_TValue*, align 8
  %name.addr = alloca i8**, align 8
  %c = alloca %struct.LClosure*, align 8
  %i = alloca i32, align 4
  store %struct.CallInfo* %ci, %struct.CallInfo** %ci.addr, align 8
  store %struct.lua_TValue* %o, %struct.lua_TValue** %o.addr, align 8
  store i8** %name, i8*** %name.addr, align 8
  %0 = load %struct.CallInfo** %ci.addr, align 8
  %func = getelementptr inbounds %struct.CallInfo* %0, i32 0, i32 0
  %1 = load %struct.lua_TValue** %func, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %1, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %2 = load %union.GCObject** %gc, align 8
  %cl = bitcast %union.GCObject* %2 to %union.Closure*
  %l = bitcast %union.Closure* %cl to %struct.LClosure*
  store %struct.LClosure* %l, %struct.LClosure** %c, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %3 = load i32* %i, align 4
  %4 = load %struct.LClosure** %c, align 8
  %nupvalues = getelementptr inbounds %struct.LClosure* %4, i32 0, i32 3
  %5 = load i8* %nupvalues, align 1
  %conv = zext i8 %5 to i32
  %cmp = icmp slt i32 %3, %conv
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load i32* %i, align 4
  %idxprom = sext i32 %6 to i64
  %7 = load %struct.LClosure** %c, align 8
  %upvals = getelementptr inbounds %struct.LClosure* %7, i32 0, i32 6
  %arrayidx = getelementptr inbounds [1 x %struct.UpVal*]* %upvals, i32 0, i64 %idxprom
  %8 = load %struct.UpVal** %arrayidx, align 8
  %v = getelementptr inbounds %struct.UpVal* %8, i32 0, i32 3
  %9 = load %struct.lua_TValue** %v, align 8
  %10 = load %struct.lua_TValue** %o.addr, align 8
  %cmp2 = icmp eq %struct.lua_TValue* %9, %10
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %11 = load %struct.LClosure** %c, align 8
  %p = getelementptr inbounds %struct.LClosure* %11, i32 0, i32 5
  %12 = load %struct.Proto** %p, align 8
  %13 = load i32* %i, align 4
  %call = call i8* @upvalname(%struct.Proto* %12, i32 %13)
  %14 = load i8*** %name.addr, align 8
  store i8* %call, i8** %14, align 8
  store i8* getelementptr inbounds ([8 x i8]* @.str11205, i32 0, i32 0), i8** %retval
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %15 = load i32* %i, align 4
  %inc = add nsw i32 %15, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i8* null, i8** %retval
  br label %return

return:                                           ; preds = %for.end, %if.then
  %16 = load i8** %retval
  ret i8* %16
}

; Function Attrs: nounwind uwtable
define internal i32 @isinstack(%struct.CallInfo* %ci, %struct.lua_TValue* %o) #0 {
entry:
  %retval = alloca i32, align 4
  %ci.addr = alloca %struct.CallInfo*, align 8
  %o.addr = alloca %struct.lua_TValue*, align 8
  %p = alloca %struct.lua_TValue*, align 8
  store %struct.CallInfo* %ci, %struct.CallInfo** %ci.addr, align 8
  store %struct.lua_TValue* %o, %struct.lua_TValue** %o.addr, align 8
  %0 = load %struct.CallInfo** %ci.addr, align 8
  %u = getelementptr inbounds %struct.CallInfo* %0, i32 0, i32 7
  %l = bitcast %union.anon.2* %u to %struct.anon.3*
  %base = getelementptr inbounds %struct.anon.3* %l, i32 0, i32 0
  %1 = load %struct.lua_TValue** %base, align 8
  store %struct.lua_TValue* %1, %struct.lua_TValue** %p, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load %struct.lua_TValue** %p, align 8
  %3 = load %struct.CallInfo** %ci.addr, align 8
  %top = getelementptr inbounds %struct.CallInfo* %3, i32 0, i32 1
  %4 = load %struct.lua_TValue** %top, align 8
  %cmp = icmp ult %struct.lua_TValue* %2, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load %struct.lua_TValue** %o.addr, align 8
  %6 = load %struct.lua_TValue** %p, align 8
  %cmp1 = icmp eq %struct.lua_TValue* %5, %6
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  store i32 1, i32* %retval
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %7 = load %struct.lua_TValue** %p, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %7, i32 1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %p, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %for.end, %if.then
  %8 = load i32* %retval
  ret i32 %8
}

; Function Attrs: nounwind uwtable
define internal i32 @currentpc(%struct.CallInfo* %ci) #0 {
entry:
  %ci.addr = alloca %struct.CallInfo*, align 8
  store %struct.CallInfo* %ci, %struct.CallInfo** %ci.addr, align 8
  %0 = load %struct.CallInfo** %ci.addr, align 8
  %u = getelementptr inbounds %struct.CallInfo* %0, i32 0, i32 7
  %l = bitcast %union.anon.2* %u to %struct.anon.3*
  %savedpc = getelementptr inbounds %struct.anon.3* %l, i32 0, i32 1
  %1 = load i32** %savedpc, align 8
  %2 = load %struct.CallInfo** %ci.addr, align 8
  %func = getelementptr inbounds %struct.CallInfo* %2, i32 0, i32 0
  %3 = load %struct.lua_TValue** %func, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %3, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %4 = load %union.GCObject** %gc, align 8
  %cl = bitcast %union.GCObject* %4 to %union.Closure*
  %l1 = bitcast %union.Closure* %cl to %struct.LClosure*
  %p = getelementptr inbounds %struct.LClosure* %l1, i32 0, i32 5
  %5 = load %struct.Proto** %p, align 8
  %code = getelementptr inbounds %struct.Proto* %5, i32 0, i32 4
  %6 = load i32** %code, align 8
  %sub.ptr.lhs.cast = ptrtoint i32* %1 to i64
  %sub.ptr.rhs.cast = ptrtoint i32* %6 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 4
  %conv = trunc i64 %sub.ptr.div to i32
  %sub = sub nsw i32 %conv, 1
  ret i32 %sub
}

; Function Attrs: nounwind uwtable
define internal i8* @getobjname(%struct.Proto* %p, i32 %lastpc, i32 %reg, i8** %name) #0 {
entry:
  %retval = alloca i8*, align 8
  %p.addr = alloca %struct.Proto*, align 8
  %lastpc.addr = alloca i32, align 4
  %reg.addr = alloca i32, align 4
  %name.addr = alloca i8**, align 8
  %pc = alloca i32, align 4
  %i = alloca i32, align 4
  %op = alloca i32, align 4
  %b = alloca i32, align 4
  %k = alloca i32, align 4
  %t = alloca i32, align 4
  %vn = alloca i8*, align 8
  %b29 = alloca i32, align 4
  %k54 = alloca i32, align 4
  store %struct.Proto* %p, %struct.Proto** %p.addr, align 8
  store i32 %lastpc, i32* %lastpc.addr, align 4
  store i32 %reg, i32* %reg.addr, align 4
  store i8** %name, i8*** %name.addr, align 8
  %0 = load %struct.Proto** %p.addr, align 8
  %1 = load i32* %reg.addr, align 4
  %add = add nsw i32 %1, 1
  %2 = load i32* %lastpc.addr, align 4
  %call = call i8* bitcast (i8* (%struct.Proto.160*, i32, i32)* @luaF_getlocalname to i8* (%struct.Proto*, i32, i32)*)(%struct.Proto* %0, i32 %add, i32 %2)
  %3 = load i8*** %name.addr, align 8
  store i8* %call, i8** %3, align 8
  %4 = load i8*** %name.addr, align 8
  %5 = load i8** %4, align 8
  %tobool = icmp ne i8* %5, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i8* getelementptr inbounds ([6 x i8]* @.str7201, i32 0, i32 0), i8** %retval
  br label %return

if.end:                                           ; preds = %entry
  %6 = load %struct.Proto** %p.addr, align 8
  %7 = load i32* %lastpc.addr, align 4
  %8 = load i32* %reg.addr, align 4
  %call1 = call i32 @findsetreg(%struct.Proto* %6, i32 %7, i32 %8)
  store i32 %call1, i32* %pc, align 4
  %9 = load i32* %pc, align 4
  %cmp = icmp ne i32 %9, -1
  br i1 %cmp, label %if.then2, label %if.end57

if.then2:                                         ; preds = %if.end
  %10 = load i32* %pc, align 4
  %idxprom = sext i32 %10 to i64
  %11 = load %struct.Proto** %p.addr, align 8
  %code = getelementptr inbounds %struct.Proto* %11, i32 0, i32 4
  %12 = load i32** %code, align 8
  %arrayidx = getelementptr inbounds i32* %12, i64 %idxprom
  %13 = load i32* %arrayidx, align 4
  store i32 %13, i32* %i, align 4
  %14 = load i32* %i, align 4
  %shr = lshr i32 %14, 0
  %and = and i32 %shr, 63
  store i32 %and, i32* %op, align 4
  %15 = load i32* %op, align 4
  switch i32 %15, label %sw.default [
    i32 0, label %sw.bb
    i32 6, label %sw.bb11
    i32 7, label %sw.bb11
    i32 5, label %sw.bb24
    i32 1, label %sw.bb28
    i32 2, label %sw.bb28
    i32 12, label %sw.bb53
  ]

sw.bb:                                            ; preds = %if.then2
  %16 = load i32* %i, align 4
  %shr3 = lshr i32 %16, 23
  %and4 = and i32 %shr3, 511
  store i32 %and4, i32* %b, align 4
  %17 = load i32* %b, align 4
  %18 = load i32* %i, align 4
  %shr5 = lshr i32 %18, 6
  %and6 = and i32 %shr5, 255
  %cmp7 = icmp slt i32 %17, %and6
  br i1 %cmp7, label %if.then8, label %if.end10

if.then8:                                         ; preds = %sw.bb
  %19 = load %struct.Proto** %p.addr, align 8
  %20 = load i32* %pc, align 4
  %21 = load i32* %b, align 4
  %22 = load i8*** %name.addr, align 8
  %call9 = call i8* @getobjname(%struct.Proto* %19, i32 %20, i32 %21, i8** %22)
  store i8* %call9, i8** %retval
  br label %return

if.end10:                                         ; preds = %sw.bb
  br label %sw.epilog

sw.bb11:                                          ; preds = %if.then2, %if.then2
  %23 = load i32* %i, align 4
  %shr12 = lshr i32 %23, 14
  %and13 = and i32 %shr12, 511
  store i32 %and13, i32* %k, align 4
  %24 = load i32* %i, align 4
  %shr14 = lshr i32 %24, 23
  %and15 = and i32 %shr14, 511
  store i32 %and15, i32* %t, align 4
  %25 = load i32* %op, align 4
  %cmp16 = icmp eq i32 %25, 7
  br i1 %cmp16, label %cond.true, label %cond.false

cond.true:                                        ; preds = %sw.bb11
  %26 = load %struct.Proto** %p.addr, align 8
  %27 = load i32* %t, align 4
  %add17 = add nsw i32 %27, 1
  %28 = load i32* %pc, align 4
  %call18 = call i8* bitcast (i8* (%struct.Proto.160*, i32, i32)* @luaF_getlocalname to i8* (%struct.Proto*, i32, i32)*)(%struct.Proto* %26, i32 %add17, i32 %28)
  br label %cond.end

cond.false:                                       ; preds = %sw.bb11
  %29 = load %struct.Proto** %p.addr, align 8
  %30 = load i32* %t, align 4
  %call19 = call i8* @upvalname(%struct.Proto* %29, i32 %30)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %call18, %cond.true ], [ %call19, %cond.false ]
  store i8* %cond, i8** %vn, align 8
  %31 = load %struct.Proto** %p.addr, align 8
  %32 = load i32* %pc, align 4
  %33 = load i32* %k, align 4
  %34 = load i8*** %name.addr, align 8
  call void @kname(%struct.Proto* %31, i32 %32, i32 %33, i8** %34)
  %35 = load i8** %vn, align 8
  %tobool20 = icmp ne i8* %35, null
  br i1 %tobool20, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %cond.end
  %36 = load i8** %vn, align 8
  %call21 = call i32 @strcmp(i8* %36, i8* getelementptr inbounds ([5 x i8]* @.str8202, i32 0, i32 0)) #10
  %cmp22 = icmp eq i32 %call21, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %cond.end
  %37 = phi i1 [ false, %cond.end ], [ %cmp22, %land.rhs ]
  %cond23 = select i1 %37, i8* getelementptr inbounds ([7 x i8]* @.str9203, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8]* @.str10204, i32 0, i32 0)
  store i8* %cond23, i8** %retval
  br label %return

sw.bb24:                                          ; preds = %if.then2
  %38 = load %struct.Proto** %p.addr, align 8
  %39 = load i32* %i, align 4
  %shr25 = lshr i32 %39, 23
  %and26 = and i32 %shr25, 511
  %call27 = call i8* @upvalname(%struct.Proto* %38, i32 %and26)
  %40 = load i8*** %name.addr, align 8
  store i8* %call27, i8** %40, align 8
  store i8* getelementptr inbounds ([8 x i8]* @.str11205, i32 0, i32 0), i8** %retval
  br label %return

sw.bb28:                                          ; preds = %if.then2, %if.then2
  %41 = load i32* %op, align 4
  %cmp30 = icmp eq i32 %41, 1
  br i1 %cmp30, label %cond.true31, label %cond.false34

cond.true31:                                      ; preds = %sw.bb28
  %42 = load i32* %i, align 4
  %shr32 = lshr i32 %42, 14
  %and33 = and i32 %shr32, 262143
  br label %cond.end41

cond.false34:                                     ; preds = %sw.bb28
  %43 = load i32* %pc, align 4
  %add35 = add nsw i32 %43, 1
  %idxprom36 = sext i32 %add35 to i64
  %44 = load %struct.Proto** %p.addr, align 8
  %code37 = getelementptr inbounds %struct.Proto* %44, i32 0, i32 4
  %45 = load i32** %code37, align 8
  %arrayidx38 = getelementptr inbounds i32* %45, i64 %idxprom36
  %46 = load i32* %arrayidx38, align 4
  %shr39 = lshr i32 %46, 6
  %and40 = and i32 %shr39, 67108863
  br label %cond.end41

cond.end41:                                       ; preds = %cond.false34, %cond.true31
  %cond42 = phi i32 [ %and33, %cond.true31 ], [ %and40, %cond.false34 ]
  store i32 %cond42, i32* %b29, align 4
  %47 = load i32* %b29, align 4
  %idxprom43 = sext i32 %47 to i64
  %48 = load %struct.Proto** %p.addr, align 8
  %k44 = getelementptr inbounds %struct.Proto* %48, i32 0, i32 3
  %49 = load %struct.lua_TValue** %k44, align 8
  %arrayidx45 = getelementptr inbounds %struct.lua_TValue* %49, i64 %idxprom43
  %tt_ = getelementptr inbounds %struct.lua_TValue* %arrayidx45, i32 0, i32 1
  %50 = load i32* %tt_, align 4
  %and46 = and i32 %50, 15
  %cmp47 = icmp eq i32 %and46, 4
  br i1 %cmp47, label %if.then48, label %if.end52

if.then48:                                        ; preds = %cond.end41
  %51 = load i32* %b29, align 4
  %idxprom49 = sext i32 %51 to i64
  %52 = load %struct.Proto** %p.addr, align 8
  %k50 = getelementptr inbounds %struct.Proto* %52, i32 0, i32 3
  %53 = load %struct.lua_TValue** %k50, align 8
  %arrayidx51 = getelementptr inbounds %struct.lua_TValue* %53, i64 %idxprom49
  %value_ = getelementptr inbounds %struct.lua_TValue* %arrayidx51, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %54 = load %union.GCObject** %gc, align 8
  %ts = bitcast %union.GCObject* %54 to %union.TString*
  %add.ptr = getelementptr inbounds %union.TString* %ts, i64 1
  %55 = bitcast %union.TString* %add.ptr to i8*
  %56 = load i8*** %name.addr, align 8
  store i8* %55, i8** %56, align 8
  store i8* getelementptr inbounds ([9 x i8]* @.str12206, i32 0, i32 0), i8** %retval
  br label %return

if.end52:                                         ; preds = %cond.end41
  br label %sw.epilog

sw.bb53:                                          ; preds = %if.then2
  %57 = load i32* %i, align 4
  %shr55 = lshr i32 %57, 14
  %and56 = and i32 %shr55, 511
  store i32 %and56, i32* %k54, align 4
  %58 = load %struct.Proto** %p.addr, align 8
  %59 = load i32* %pc, align 4
  %60 = load i32* %k54, align 4
  %61 = load i8*** %name.addr, align 8
  call void @kname(%struct.Proto* %58, i32 %59, i32 %60, i8** %61)
  store i8* getelementptr inbounds ([7 x i8]* @.str13207, i32 0, i32 0), i8** %retval
  br label %return

sw.default:                                       ; preds = %if.then2
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.end52, %if.end10
  br label %if.end57

if.end57:                                         ; preds = %sw.epilog, %if.end
  store i8* null, i8** %retval
  br label %return

return:                                           ; preds = %if.end57, %sw.bb53, %if.then48, %sw.bb24, %land.end, %if.then8, %if.then
  %62 = load i8** %retval
  ret i8* %62
}

; Function Attrs: nounwind uwtable
define internal void @addinfo(%struct.lua_State* %L, i8* %msg) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %msg.addr = alloca i8*, align 8
  %ci = alloca %struct.CallInfo*, align 8
  %buff = alloca [60 x i8], align 16
  %line = alloca i32, align 4
  %src = alloca %union.TString*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %msg, i8** %msg.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %ci1 = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 6
  %1 = load %struct.CallInfo** %ci1, align 8
  store %struct.CallInfo* %1, %struct.CallInfo** %ci, align 8
  %2 = load %struct.CallInfo** %ci, align 8
  %callstatus = getelementptr inbounds %struct.CallInfo* %2, i32 0, i32 5
  %3 = load i8* %callstatus, align 1
  %conv = zext i8 %3 to i32
  %and = and i32 %conv, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %4 = load %struct.CallInfo** %ci, align 8
  %call = call i32 @currentline(%struct.CallInfo* %4)
  store i32 %call, i32* %line, align 4
  %5 = load %struct.CallInfo** %ci, align 8
  %func = getelementptr inbounds %struct.CallInfo* %5, i32 0, i32 0
  %6 = load %struct.lua_TValue** %func, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %6, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %7 = load %union.GCObject** %gc, align 8
  %cl = bitcast %union.GCObject* %7 to %union.Closure*
  %l = bitcast %union.Closure* %cl to %struct.LClosure*
  %p = getelementptr inbounds %struct.LClosure* %l, i32 0, i32 5
  %8 = load %struct.Proto** %p, align 8
  %source = getelementptr inbounds %struct.Proto* %8, i32 0, i32 10
  %9 = load %union.TString** %source, align 8
  store %union.TString* %9, %union.TString** %src, align 8
  %10 = load %union.TString** %src, align 8
  %tobool2 = icmp ne %union.TString* %10, null
  br i1 %tobool2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.then
  %arraydecay = getelementptr inbounds [60 x i8]* %buff, i32 0, i32 0
  %11 = load %union.TString** %src, align 8
  %add.ptr = getelementptr inbounds %union.TString* %11, i64 1
  %12 = bitcast %union.TString* %add.ptr to i8*
  call void @luaO_chunkid(i8* %arraydecay, i8* %12, i64 60)
  br label %if.end

if.else:                                          ; preds = %if.then
  %arrayidx = getelementptr inbounds [60 x i8]* %buff, i32 0, i64 0
  store i8 63, i8* %arrayidx, align 1
  %arrayidx4 = getelementptr inbounds [60 x i8]* %buff, i32 0, i64 1
  store i8 0, i8* %arrayidx4, align 1
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then3
  %13 = load %struct.lua_State** %L.addr, align 8
  %arraydecay5 = getelementptr inbounds [60 x i8]* %buff, i32 0, i32 0
  %14 = load i32* %line, align 4
  %15 = load i8** %msg.addr, align 8
  %call6 = call i8* (%struct.lua_State*, i8*, ...)* bitcast (i8* (%struct.lua_State.279*, i8*, ...)* @luaO_pushfstring to i8* (%struct.lua_State*, i8*, ...)*)(%struct.lua_State* %13, i8* getelementptr inbounds ([10 x i8]* @.str6200, i32 0, i32 0), i8* %arraydecay5, i32 %14, i8* %15)
  br label %if.end7

if.end7:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i8* @findvararg(%struct.CallInfo* %ci, i32 %n, %struct.lua_TValue** %pos) #0 {
entry:
  %retval = alloca i8*, align 8
  %ci.addr = alloca %struct.CallInfo*, align 8
  %n.addr = alloca i32, align 4
  %pos.addr = alloca %struct.lua_TValue**, align 8
  %nparams = alloca i32, align 4
  store %struct.CallInfo* %ci, %struct.CallInfo** %ci.addr, align 8
  store i32 %n, i32* %n.addr, align 4
  store %struct.lua_TValue** %pos, %struct.lua_TValue*** %pos.addr, align 8
  %0 = load %struct.CallInfo** %ci.addr, align 8
  %func = getelementptr inbounds %struct.CallInfo* %0, i32 0, i32 0
  %1 = load %struct.lua_TValue** %func, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %1, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %2 = load %union.GCObject** %gc, align 8
  %cl = bitcast %union.GCObject* %2 to %union.Closure*
  %l = bitcast %union.Closure* %cl to %struct.LClosure*
  %p = getelementptr inbounds %struct.LClosure* %l, i32 0, i32 5
  %3 = load %struct.Proto** %p, align 8
  %numparams = getelementptr inbounds %struct.Proto* %3, i32 0, i32 20
  %4 = load i8* %numparams, align 1
  %conv = zext i8 %4 to i32
  store i32 %conv, i32* %nparams, align 4
  %5 = load i32* %n.addr, align 4
  %conv1 = sext i32 %5 to i64
  %6 = load %struct.CallInfo** %ci.addr, align 8
  %u = getelementptr inbounds %struct.CallInfo* %6, i32 0, i32 7
  %l2 = bitcast %union.anon.2* %u to %struct.anon.3*
  %base = getelementptr inbounds %struct.anon.3* %l2, i32 0, i32 0
  %7 = load %struct.lua_TValue** %base, align 8
  %8 = load %struct.CallInfo** %ci.addr, align 8
  %func3 = getelementptr inbounds %struct.CallInfo* %8, i32 0, i32 0
  %9 = load %struct.lua_TValue** %func3, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.lua_TValue* %7 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.lua_TValue* %9 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 16
  %10 = load i32* %nparams, align 4
  %conv4 = sext i32 %10 to i64
  %sub = sub nsw i64 %sub.ptr.div, %conv4
  %cmp = icmp sge i64 %conv1, %sub
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i8* null, i8** %retval
  br label %return

if.else:                                          ; preds = %entry
  %11 = load %struct.CallInfo** %ci.addr, align 8
  %func6 = getelementptr inbounds %struct.CallInfo* %11, i32 0, i32 0
  %12 = load %struct.lua_TValue** %func6, align 8
  %13 = load i32* %nparams, align 4
  %idx.ext = sext i32 %13 to i64
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %12, i64 %idx.ext
  %14 = load i32* %n.addr, align 4
  %idx.ext7 = sext i32 %14 to i64
  %add.ptr8 = getelementptr inbounds %struct.lua_TValue* %add.ptr, i64 %idx.ext7
  %15 = load %struct.lua_TValue*** %pos.addr, align 8
  store %struct.lua_TValue* %add.ptr8, %struct.lua_TValue** %15, align 8
  store i8* getelementptr inbounds ([10 x i8]* @.str24218, i32 0, i32 0), i8** %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %16 = load i8** %retval
  ret i8* %16
}

; Function Attrs: nounwind uwtable
define internal void @funcinfo(%struct.lua_Debug* %ar, %union.Closure* %cl) #0 {
entry:
  %ar.addr = alloca %struct.lua_Debug*, align 8
  %cl.addr = alloca %union.Closure*, align 8
  %p = alloca %struct.Proto*, align 8
  store %struct.lua_Debug* %ar, %struct.lua_Debug** %ar.addr, align 8
  store %union.Closure* %cl, %union.Closure** %cl.addr, align 8
  %0 = load %union.Closure** %cl.addr, align 8
  %cmp = icmp eq %union.Closure* %0, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load %union.Closure** %cl.addr, align 8
  %c = bitcast %union.Closure* %1 to %struct.CClosure*
  %tt = getelementptr inbounds %struct.CClosure* %c, i32 0, i32 1
  %2 = load i8* %tt, align 1
  %conv = zext i8 %2 to i32
  %cmp1 = icmp eq i32 %conv, 38
  br i1 %cmp1, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  %3 = load %struct.lua_Debug** %ar.addr, align 8
  %source = getelementptr inbounds %struct.lua_Debug* %3, i32 0, i32 4
  store i8* getelementptr inbounds ([5 x i8]* @.str18212, i32 0, i32 0), i8** %source, align 8
  %4 = load %struct.lua_Debug** %ar.addr, align 8
  %linedefined = getelementptr inbounds %struct.lua_Debug* %4, i32 0, i32 6
  store i32 -1, i32* %linedefined, align 4
  %5 = load %struct.lua_Debug** %ar.addr, align 8
  %lastlinedefined = getelementptr inbounds %struct.lua_Debug* %5, i32 0, i32 7
  store i32 -1, i32* %lastlinedefined, align 4
  %6 = load %struct.lua_Debug** %ar.addr, align 8
  %what = getelementptr inbounds %struct.lua_Debug* %6, i32 0, i32 3
  store i8* getelementptr inbounds ([2 x i8]* @.str19213, i32 0, i32 0), i8** %what, align 8
  br label %if.end

if.else:                                          ; preds = %lor.lhs.false
  %7 = load %union.Closure** %cl.addr, align 8
  %l = bitcast %union.Closure* %7 to %struct.LClosure*
  %p3 = getelementptr inbounds %struct.LClosure* %l, i32 0, i32 5
  %8 = load %struct.Proto** %p3, align 8
  store %struct.Proto* %8, %struct.Proto** %p, align 8
  %9 = load %struct.Proto** %p, align 8
  %source4 = getelementptr inbounds %struct.Proto* %9, i32 0, i32 10
  %10 = load %union.TString** %source4, align 8
  %tobool = icmp ne %union.TString* %10, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.else
  %11 = load %struct.Proto** %p, align 8
  %source5 = getelementptr inbounds %struct.Proto* %11, i32 0, i32 10
  %12 = load %union.TString** %source5, align 8
  %add.ptr = getelementptr inbounds %union.TString* %12, i64 1
  %13 = bitcast %union.TString* %add.ptr to i8*
  br label %cond.end

cond.false:                                       ; preds = %if.else
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %13, %cond.true ], [ getelementptr inbounds ([3 x i8]* @.str20214, i32 0, i32 0), %cond.false ]
  %14 = load %struct.lua_Debug** %ar.addr, align 8
  %source6 = getelementptr inbounds %struct.lua_Debug* %14, i32 0, i32 4
  store i8* %cond, i8** %source6, align 8
  %15 = load %struct.Proto** %p, align 8
  %linedefined7 = getelementptr inbounds %struct.Proto* %15, i32 0, i32 17
  %16 = load i32* %linedefined7, align 4
  %17 = load %struct.lua_Debug** %ar.addr, align 8
  %linedefined8 = getelementptr inbounds %struct.lua_Debug* %17, i32 0, i32 6
  store i32 %16, i32* %linedefined8, align 4
  %18 = load %struct.Proto** %p, align 8
  %lastlinedefined9 = getelementptr inbounds %struct.Proto* %18, i32 0, i32 18
  %19 = load i32* %lastlinedefined9, align 4
  %20 = load %struct.lua_Debug** %ar.addr, align 8
  %lastlinedefined10 = getelementptr inbounds %struct.lua_Debug* %20, i32 0, i32 7
  store i32 %19, i32* %lastlinedefined10, align 4
  %21 = load %struct.lua_Debug** %ar.addr, align 8
  %linedefined11 = getelementptr inbounds %struct.lua_Debug* %21, i32 0, i32 6
  %22 = load i32* %linedefined11, align 4
  %cmp12 = icmp eq i32 %22, 0
  %cond14 = select i1 %cmp12, i8* getelementptr inbounds ([5 x i8]* @.str21215, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8]* @.str22216, i32 0, i32 0)
  %23 = load %struct.lua_Debug** %ar.addr, align 8
  %what15 = getelementptr inbounds %struct.lua_Debug* %23, i32 0, i32 3
  store i8* %cond14, i8** %what15, align 8
  br label %if.end

if.end:                                           ; preds = %cond.end, %if.then
  %24 = load %struct.lua_Debug** %ar.addr, align 8
  %short_src = getelementptr inbounds %struct.lua_Debug* %24, i32 0, i32 12
  %arraydecay = getelementptr inbounds [60 x i8]* %short_src, i32 0, i32 0
  %25 = load %struct.lua_Debug** %ar.addr, align 8
  %source16 = getelementptr inbounds %struct.lua_Debug* %25, i32 0, i32 4
  %26 = load i8** %source16, align 8
  call void @luaO_chunkid(i8* %arraydecay, i8* %26, i64 60)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @currentline(%struct.CallInfo* %ci) #0 {
entry:
  %ci.addr = alloca %struct.CallInfo*, align 8
  store %struct.CallInfo* %ci, %struct.CallInfo** %ci.addr, align 8
  %0 = load %struct.CallInfo** %ci.addr, align 8
  %func = getelementptr inbounds %struct.CallInfo* %0, i32 0, i32 0
  %1 = load %struct.lua_TValue** %func, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %1, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %2 = load %union.GCObject** %gc, align 8
  %cl = bitcast %union.GCObject* %2 to %union.Closure*
  %l = bitcast %union.Closure* %cl to %struct.LClosure*
  %p = getelementptr inbounds %struct.LClosure* %l, i32 0, i32 5
  %3 = load %struct.Proto** %p, align 8
  %lineinfo = getelementptr inbounds %struct.Proto* %3, i32 0, i32 6
  %4 = load i32** %lineinfo, align 8
  %tobool = icmp ne i32* %4, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %5 = load %struct.CallInfo** %ci.addr, align 8
  %call = call i32 @currentpc(%struct.CallInfo* %5)
  %idxprom = sext i32 %call to i64
  %6 = load %struct.CallInfo** %ci.addr, align 8
  %func1 = getelementptr inbounds %struct.CallInfo* %6, i32 0, i32 0
  %7 = load %struct.lua_TValue** %func1, align 8
  %value_2 = getelementptr inbounds %struct.lua_TValue* %7, i32 0, i32 0
  %gc3 = bitcast %union.Value* %value_2 to %union.GCObject**
  %8 = load %union.GCObject** %gc3, align 8
  %cl4 = bitcast %union.GCObject* %8 to %union.Closure*
  %l5 = bitcast %union.Closure* %cl4 to %struct.LClosure*
  %p6 = getelementptr inbounds %struct.LClosure* %l5, i32 0, i32 5
  %9 = load %struct.Proto** %p6, align 8
  %lineinfo7 = getelementptr inbounds %struct.Proto* %9, i32 0, i32 6
  %10 = load i32** %lineinfo7, align 8
  %arrayidx = getelementptr inbounds i32* %10, i64 %idxprom
  %11 = load i32* %arrayidx, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %11, %cond.true ], [ 0, %cond.false ]
  ret i32 %cond
}

; Function Attrs: nounwind uwtable
define internal i8* @getfuncname(%struct.lua_State* %L, %struct.CallInfo* %ci, i8** %name) #0 {
entry:
  %retval = alloca i8*, align 8
  %L.addr = alloca %struct.lua_State*, align 8
  %ci.addr = alloca %struct.CallInfo*, align 8
  %name.addr = alloca i8**, align 8
  %tm = alloca i32, align 4
  %p = alloca %struct.Proto*, align 8
  %pc = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.CallInfo* %ci, %struct.CallInfo** %ci.addr, align 8
  store i8** %name, i8*** %name.addr, align 8
  %0 = load %struct.CallInfo** %ci.addr, align 8
  %func = getelementptr inbounds %struct.CallInfo* %0, i32 0, i32 0
  %1 = load %struct.lua_TValue** %func, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %1, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %2 = load %union.GCObject** %gc, align 8
  %cl = bitcast %union.GCObject* %2 to %union.Closure*
  %l = bitcast %union.Closure* %cl to %struct.LClosure*
  %p1 = getelementptr inbounds %struct.LClosure* %l, i32 0, i32 5
  %3 = load %struct.Proto** %p1, align 8
  store %struct.Proto* %3, %struct.Proto** %p, align 8
  %4 = load %struct.CallInfo** %ci.addr, align 8
  %call = call i32 @currentpc(%struct.CallInfo* %4)
  store i32 %call, i32* %pc, align 4
  %5 = load i32* %pc, align 4
  %idxprom = sext i32 %5 to i64
  %6 = load %struct.Proto** %p, align 8
  %code = getelementptr inbounds %struct.Proto* %6, i32 0, i32 4
  %7 = load i32** %code, align 8
  %arrayidx = getelementptr inbounds i32* %7, i64 %idxprom
  %8 = load i32* %arrayidx, align 4
  store i32 %8, i32* %i, align 4
  %9 = load i32* %i, align 4
  %shr = lshr i32 %9, 0
  %and = and i32 %shr, 63
  switch i32 %and, label %sw.default [
    i32 29, label %sw.bb
    i32 30, label %sw.bb
    i32 34, label %sw.bb5
    i32 12, label %sw.bb6
    i32 6, label %sw.bb6
    i32 7, label %sw.bb6
    i32 8, label %sw.bb7
    i32 10, label %sw.bb7
    i32 24, label %sw.bb8
    i32 13, label %sw.bb9
    i32 14, label %sw.bb10
    i32 15, label %sw.bb11
    i32 16, label %sw.bb12
    i32 17, label %sw.bb13
    i32 18, label %sw.bb14
    i32 19, label %sw.bb15
    i32 21, label %sw.bb16
    i32 25, label %sw.bb17
    i32 26, label %sw.bb18
    i32 22, label %sw.bb19
  ]

sw.bb:                                            ; preds = %entry, %entry
  %10 = load %struct.Proto** %p, align 8
  %11 = load i32* %pc, align 4
  %12 = load i32* %i, align 4
  %shr2 = lshr i32 %12, 6
  %and3 = and i32 %shr2, 255
  %13 = load i8*** %name.addr, align 8
  %call4 = call i8* @getobjname(%struct.Proto* %10, i32 %11, i32 %and3, i8** %13)
  store i8* %call4, i8** %retval
  br label %return

sw.bb5:                                           ; preds = %entry
  %14 = load i8*** %name.addr, align 8
  store i8* getelementptr inbounds ([13 x i8]* @.str16210, i32 0, i32 0), i8** %14, align 8
  store i8* getelementptr inbounds ([13 x i8]* @.str16210, i32 0, i32 0), i8** %retval
  br label %return

sw.bb6:                                           ; preds = %entry, %entry, %entry
  store i32 0, i32* %tm, align 4
  br label %sw.epilog

sw.bb7:                                           ; preds = %entry, %entry
  store i32 1, i32* %tm, align 4
  br label %sw.epilog

sw.bb8:                                           ; preds = %entry
  store i32 5, i32* %tm, align 4
  br label %sw.epilog

sw.bb9:                                           ; preds = %entry
  store i32 6, i32* %tm, align 4
  br label %sw.epilog

sw.bb10:                                          ; preds = %entry
  store i32 7, i32* %tm, align 4
  br label %sw.epilog

sw.bb11:                                          ; preds = %entry
  store i32 8, i32* %tm, align 4
  br label %sw.epilog

sw.bb12:                                          ; preds = %entry
  store i32 9, i32* %tm, align 4
  br label %sw.epilog

sw.bb13:                                          ; preds = %entry
  store i32 10, i32* %tm, align 4
  br label %sw.epilog

sw.bb14:                                          ; preds = %entry
  store i32 11, i32* %tm, align 4
  br label %sw.epilog

sw.bb15:                                          ; preds = %entry
  store i32 12, i32* %tm, align 4
  br label %sw.epilog

sw.bb16:                                          ; preds = %entry
  store i32 4, i32* %tm, align 4
  br label %sw.epilog

sw.bb17:                                          ; preds = %entry
  store i32 13, i32* %tm, align 4
  br label %sw.epilog

sw.bb18:                                          ; preds = %entry
  store i32 14, i32* %tm, align 4
  br label %sw.epilog

sw.bb19:                                          ; preds = %entry
  store i32 15, i32* %tm, align 4
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  store i8* null, i8** %retval
  br label %return

sw.epilog:                                        ; preds = %sw.bb19, %sw.bb18, %sw.bb17, %sw.bb16, %sw.bb15, %sw.bb14, %sw.bb13, %sw.bb12, %sw.bb11, %sw.bb10, %sw.bb9, %sw.bb8, %sw.bb7, %sw.bb6
  %15 = load i32* %tm, align 4
  %idxprom20 = zext i32 %15 to i64
  %16 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %16, i32 0, i32 5
  %17 = load %struct.global_State** %l_G, align 8
  %tmname = getelementptr inbounds %struct.global_State* %17, i32 0, i32 33
  %arrayidx21 = getelementptr inbounds [17 x %union.TString*]* %tmname, i32 0, i64 %idxprom20
  %18 = load %union.TString** %arrayidx21, align 8
  %add.ptr = getelementptr inbounds %union.TString* %18, i64 1
  %19 = bitcast %union.TString* %add.ptr to i8*
  %20 = load i8*** %name.addr, align 8
  store i8* %19, i8** %20, align 8
  store i8* getelementptr inbounds ([11 x i8]* @.str17211, i32 0, i32 0), i8** %retval
  br label %return

return:                                           ; preds = %sw.epilog, %sw.default, %sw.bb5, %sw.bb
  %21 = load i8** %retval
  ret i8* %21
}

; Function Attrs: nounwind uwtable
define internal i8* @upvalname(%struct.Proto* %p, i32 %uv) #0 {
entry:
  %retval = alloca i8*, align 8
  %p.addr = alloca %struct.Proto*, align 8
  %uv.addr = alloca i32, align 4
  %s = alloca %union.TString*, align 8
  store %struct.Proto* %p, %struct.Proto** %p.addr, align 8
  store i32 %uv, i32* %uv.addr, align 4
  %0 = load i32* %uv.addr, align 4
  %idxprom = sext i32 %0 to i64
  %1 = load %struct.Proto** %p.addr, align 8
  %upvalues = getelementptr inbounds %struct.Proto* %1, i32 0, i32 8
  %2 = load %struct.Upvaldesc** %upvalues, align 8
  %arrayidx = getelementptr inbounds %struct.Upvaldesc* %2, i64 %idxprom
  %name = getelementptr inbounds %struct.Upvaldesc* %arrayidx, i32 0, i32 0
  %3 = load %union.TString** %name, align 8
  store %union.TString* %3, %union.TString** %s, align 8
  %4 = load %union.TString** %s, align 8
  %cmp = icmp eq %union.TString* %4, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i8* getelementptr inbounds ([2 x i8]* @.str14208, i32 0, i32 0), i8** %retval
  br label %return

if.else:                                          ; preds = %entry
  %5 = load %union.TString** %s, align 8
  %add.ptr = getelementptr inbounds %union.TString* %5, i64 1
  %6 = bitcast %union.TString* %add.ptr to i8*
  store i8* %6, i8** %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %7 = load i8** %retval
  ret i8* %7
}

; Function Attrs: nounwind uwtable
define internal i32 @findsetreg(%struct.Proto* %p, i32 %lastpc, i32 %reg) #0 {
entry:
  %p.addr = alloca %struct.Proto*, align 8
  %lastpc.addr = alloca i32, align 4
  %reg.addr = alloca i32, align 4
  %pc = alloca i32, align 4
  %setreg = alloca i32, align 4
  %i = alloca i32, align 4
  %op = alloca i32, align 4
  %a = alloca i32, align 4
  %b = alloca i32, align 4
  %b17 = alloca i32, align 4
  %dest = alloca i32, align 4
  store %struct.Proto* %p, %struct.Proto** %p.addr, align 8
  store i32 %lastpc, i32* %lastpc.addr, align 4
  store i32 %reg, i32* %reg.addr, align 4
  store i32 -1, i32* %setreg, align 4
  store i32 0, i32* %pc, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32* %pc, align 4
  %1 = load i32* %lastpc.addr, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i32* %pc, align 4
  %idxprom = sext i32 %2 to i64
  %3 = load %struct.Proto** %p.addr, align 8
  %code = getelementptr inbounds %struct.Proto* %3, i32 0, i32 4
  %4 = load i32** %code, align 8
  %arrayidx = getelementptr inbounds i32* %4, i64 %idxprom
  %5 = load i32* %arrayidx, align 4
  store i32 %5, i32* %i, align 4
  %6 = load i32* %i, align 4
  %shr = lshr i32 %6, 0
  %and = and i32 %shr, 63
  store i32 %and, i32* %op, align 4
  %7 = load i32* %i, align 4
  %shr1 = lshr i32 %7, 6
  %and2 = and i32 %shr1, 255
  store i32 %and2, i32* %a, align 4
  %8 = load i32* %op, align 4
  switch i32 %8, label %sw.default [
    i32 4, label %sw.bb
    i32 34, label %sw.bb7
    i32 29, label %sw.bb12
    i32 30, label %sw.bb12
    i32 23, label %sw.bb16
    i32 27, label %sw.bb28
  ]

sw.bb:                                            ; preds = %for.body
  %9 = load i32* %i, align 4
  %shr3 = lshr i32 %9, 23
  %and4 = and i32 %shr3, 511
  store i32 %and4, i32* %b, align 4
  %10 = load i32* %a, align 4
  %11 = load i32* %reg.addr, align 4
  %cmp5 = icmp sle i32 %10, %11
  br i1 %cmp5, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %sw.bb
  %12 = load i32* %reg.addr, align 4
  %13 = load i32* %a, align 4
  %14 = load i32* %b, align 4
  %add = add nsw i32 %13, %14
  %cmp6 = icmp sle i32 %12, %add
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %15 = load i32* %pc, align 4
  store i32 %15, i32* %setreg, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %sw.bb
  br label %sw.epilog

sw.bb7:                                           ; preds = %for.body
  %16 = load i32* %reg.addr, align 4
  %17 = load i32* %a, align 4
  %add8 = add nsw i32 %17, 2
  %cmp9 = icmp sge i32 %16, %add8
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %sw.bb7
  %18 = load i32* %pc, align 4
  store i32 %18, i32* %setreg, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %sw.bb7
  br label %sw.epilog

sw.bb12:                                          ; preds = %for.body, %for.body
  %19 = load i32* %reg.addr, align 4
  %20 = load i32* %a, align 4
  %cmp13 = icmp sge i32 %19, %20
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %sw.bb12
  %21 = load i32* %pc, align 4
  store i32 %21, i32* %setreg, align 4
  br label %if.end15

if.end15:                                         ; preds = %if.then14, %sw.bb12
  br label %sw.epilog

sw.bb16:                                          ; preds = %for.body
  %22 = load i32* %i, align 4
  %shr18 = lshr i32 %22, 14
  %and19 = and i32 %shr18, 262143
  %sub = sub nsw i32 %and19, 131071
  store i32 %sub, i32* %b17, align 4
  %23 = load i32* %pc, align 4
  %add20 = add nsw i32 %23, 1
  %24 = load i32* %b17, align 4
  %add21 = add nsw i32 %add20, %24
  store i32 %add21, i32* %dest, align 4
  %25 = load i32* %pc, align 4
  %26 = load i32* %dest, align 4
  %cmp22 = icmp slt i32 %25, %26
  br i1 %cmp22, label %land.lhs.true23, label %if.end27

land.lhs.true23:                                  ; preds = %sw.bb16
  %27 = load i32* %dest, align 4
  %28 = load i32* %lastpc.addr, align 4
  %cmp24 = icmp sle i32 %27, %28
  br i1 %cmp24, label %if.then25, label %if.end27

if.then25:                                        ; preds = %land.lhs.true23
  %29 = load i32* %b17, align 4
  %30 = load i32* %pc, align 4
  %add26 = add nsw i32 %30, %29
  store i32 %add26, i32* %pc, align 4
  br label %if.end27

if.end27:                                         ; preds = %if.then25, %land.lhs.true23, %sw.bb16
  br label %sw.epilog

sw.bb28:                                          ; preds = %for.body
  %31 = load i32* %reg.addr, align 4
  %32 = load i32* %a, align 4
  %cmp29 = icmp eq i32 %31, %32
  br i1 %cmp29, label %if.then30, label %if.end31

if.then30:                                        ; preds = %sw.bb28
  %33 = load i32* %pc, align 4
  store i32 %33, i32* %setreg, align 4
  br label %if.end31

if.end31:                                         ; preds = %if.then30, %sw.bb28
  br label %sw.epilog

sw.default:                                       ; preds = %for.body
  %34 = load i32* %op, align 4
  %idxprom32 = zext i32 %34 to i64
  %arrayidx33 = getelementptr inbounds [40 x i8]* @luaP_opmodes, i32 0, i64 %idxprom32
  %35 = load i8* %arrayidx33, align 1
  %conv = zext i8 %35 to i32
  %and34 = and i32 %conv, 64
  %tobool = icmp ne i32 %and34, 0
  br i1 %tobool, label %land.lhs.true35, label %if.end39

land.lhs.true35:                                  ; preds = %sw.default
  %36 = load i32* %reg.addr, align 4
  %37 = load i32* %a, align 4
  %cmp36 = icmp eq i32 %36, %37
  br i1 %cmp36, label %if.then38, label %if.end39

if.then38:                                        ; preds = %land.lhs.true35
  %38 = load i32* %pc, align 4
  store i32 %38, i32* %setreg, align 4
  br label %if.end39

if.end39:                                         ; preds = %if.then38, %land.lhs.true35, %sw.default
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end39, %if.end31, %if.end27, %if.end15, %if.end11, %if.end
  br label %for.inc

for.inc:                                          ; preds = %sw.epilog
  %39 = load i32* %pc, align 4
  %inc = add nsw i32 %39, 1
  store i32 %inc, i32* %pc, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %40 = load i32* %setreg, align 4
  ret i32 %40
}

; Function Attrs: nounwind uwtable
define internal void @kname(%struct.Proto* %p, i32 %pc, i32 %c, i8** %name) #0 {
entry:
  %p.addr = alloca %struct.Proto*, align 8
  %pc.addr = alloca i32, align 4
  %c.addr = alloca i32, align 4
  %name.addr = alloca i8**, align 8
  %kvalue = alloca %struct.lua_TValue*, align 8
  %what = alloca i8*, align 8
  store %struct.Proto* %p, %struct.Proto** %p.addr, align 8
  store i32 %pc, i32* %pc.addr, align 4
  store i32 %c, i32* %c.addr, align 4
  store i8** %name, i8*** %name.addr, align 8
  %0 = load i32* %c.addr, align 4
  %and = and i32 %0, 256
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i32* %c.addr, align 4
  %and1 = and i32 %1, -257
  %idxprom = sext i32 %and1 to i64
  %2 = load %struct.Proto** %p.addr, align 8
  %k = getelementptr inbounds %struct.Proto* %2, i32 0, i32 3
  %3 = load %struct.lua_TValue** %k, align 8
  %arrayidx = getelementptr inbounds %struct.lua_TValue* %3, i64 %idxprom
  store %struct.lua_TValue* %arrayidx, %struct.lua_TValue** %kvalue, align 8
  %4 = load %struct.lua_TValue** %kvalue, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %4, i32 0, i32 1
  %5 = load i32* %tt_, align 4
  %and2 = and i32 %5, 15
  %cmp = icmp eq i32 %and2, 4
  br i1 %cmp, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %6 = load %struct.lua_TValue** %kvalue, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %6, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %7 = load %union.GCObject** %gc, align 8
  %ts = bitcast %union.GCObject* %7 to %union.TString*
  %add.ptr = getelementptr inbounds %union.TString* %ts, i64 1
  %8 = bitcast %union.TString* %add.ptr to i8*
  %9 = load i8*** %name.addr, align 8
  store i8* %8, i8** %9, align 8
  br label %return

if.end:                                           ; preds = %if.then
  br label %if.end9

if.else:                                          ; preds = %entry
  %10 = load %struct.Proto** %p.addr, align 8
  %11 = load i32* %pc.addr, align 4
  %12 = load i32* %c.addr, align 4
  %13 = load i8*** %name.addr, align 8
  %call = call i8* @getobjname(%struct.Proto* %10, i32 %11, i32 %12, i8** %13)
  store i8* %call, i8** %what, align 8
  %14 = load i8** %what, align 8
  %tobool4 = icmp ne i8* %14, null
  br i1 %tobool4, label %land.lhs.true, label %if.end8

land.lhs.true:                                    ; preds = %if.else
  %15 = load i8** %what, align 8
  %16 = load i8* %15, align 1
  %conv = sext i8 %16 to i32
  %cmp5 = icmp eq i32 %conv, 99
  br i1 %cmp5, label %if.then7, label %if.end8

if.then7:                                         ; preds = %land.lhs.true
  br label %return

if.end8:                                          ; preds = %land.lhs.true, %if.else
  br label %if.end9

if.end9:                                          ; preds = %if.end8, %if.end
  %17 = load i8*** %name.addr, align 8
  store i8* getelementptr inbounds ([2 x i8]* @.str14208, i32 0, i32 0), i8** %17, align 8
  br label %return

return:                                           ; preds = %if.end9, %if.then7, %if.then3
  ret void
}

; Function Attrs: noreturn nounwind uwtable
define hidden void @luaD_throw(%struct.lua_State* %L, i32 %errcode) #6 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %errcode.addr = alloca i32, align 4
  %io2 = alloca %struct.lua_TValue*, align 8
  %io1 = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %errcode, i32* %errcode.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %errorJmp = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 20
  %1 = load %struct.lua_longjmp** %errorJmp, align 8
  %tobool = icmp ne %struct.lua_longjmp* %1, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load i32* %errcode.addr, align 4
  %3 = load %struct.lua_State** %L.addr, align 8
  %errorJmp1 = getelementptr inbounds %struct.lua_State* %3, i32 0, i32 20
  %4 = load %struct.lua_longjmp** %errorJmp1, align 8
  %status = getelementptr inbounds %struct.lua_longjmp* %4, i32 0, i32 2
  store volatile i32 %2, i32* %status, align 4
  %5 = load %struct.lua_State** %L.addr, align 8
  %errorJmp2 = getelementptr inbounds %struct.lua_State* %5, i32 0, i32 20
  %6 = load %struct.lua_longjmp** %errorJmp2, align 8
  %b = getelementptr inbounds %struct.lua_longjmp* %6, i32 0, i32 1
  %arraydecay = getelementptr inbounds [1 x %struct.__jmp_buf_tag]* %b, i32 0, i32 0
  call void @_longjmp(%struct.__jmp_buf_tag* %arraydecay, i32 1) #12
  unreachable

if.else:                                          ; preds = %entry
  %7 = load i32* %errcode.addr, align 4
  %conv = trunc i32 %7 to i8
  %8 = load %struct.lua_State** %L.addr, align 8
  %status3 = getelementptr inbounds %struct.lua_State* %8, i32 0, i32 3
  store i8 %conv, i8* %status3, align 1
  %9 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %9, i32 0, i32 5
  %10 = load %struct.global_State** %l_G, align 8
  %mainthread = getelementptr inbounds %struct.global_State* %10, i32 0, i32 30
  %11 = load %struct.lua_State** %mainthread, align 8
  %errorJmp4 = getelementptr inbounds %struct.lua_State* %11, i32 0, i32 20
  %12 = load %struct.lua_longjmp** %errorJmp4, align 8
  %tobool5 = icmp ne %struct.lua_longjmp* %12, null
  br i1 %tobool5, label %if.then6, label %if.else14

if.then6:                                         ; preds = %if.else
  %13 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %13, i32 0, i32 4
  %14 = load %struct.lua_TValue** %top, align 8
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %14, i64 -1
  store %struct.lua_TValue* %add.ptr, %struct.lua_TValue** %io2, align 8
  %15 = load %struct.lua_State** %L.addr, align 8
  %l_G7 = getelementptr inbounds %struct.lua_State* %15, i32 0, i32 5
  %16 = load %struct.global_State** %l_G7, align 8
  %mainthread8 = getelementptr inbounds %struct.global_State* %16, i32 0, i32 30
  %17 = load %struct.lua_State** %mainthread8, align 8
  %top9 = getelementptr inbounds %struct.lua_State* %17, i32 0, i32 4
  %18 = load %struct.lua_TValue** %top9, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %18, i32 1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %top9, align 8
  store %struct.lua_TValue* %18, %struct.lua_TValue** %io1, align 8
  %19 = load %struct.lua_TValue** %io1, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %19, i32 0, i32 0
  %20 = load %struct.lua_TValue** %io2, align 8
  %value_10 = getelementptr inbounds %struct.lua_TValue* %20, i32 0, i32 0
  %21 = bitcast %union.Value* %value_ to i8*
  %22 = bitcast %union.Value* %value_10 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %21, i8* %22, i64 8, i32 8, i1 false)
  %23 = load %struct.lua_TValue** %io2, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %23, i32 0, i32 1
  %24 = load i32* %tt_, align 4
  %25 = load %struct.lua_TValue** %io1, align 8
  %tt_11 = getelementptr inbounds %struct.lua_TValue* %25, i32 0, i32 1
  store i32 %24, i32* %tt_11, align 4
  %26 = load %struct.lua_State** %L.addr, align 8
  %l_G12 = getelementptr inbounds %struct.lua_State* %26, i32 0, i32 5
  %27 = load %struct.global_State** %l_G12, align 8
  %mainthread13 = getelementptr inbounds %struct.global_State* %27, i32 0, i32 30
  %28 = load %struct.lua_State** %mainthread13, align 8
  %29 = load i32* %errcode.addr, align 4
  call void @luaD_throw(%struct.lua_State* %28, i32 %29) #9
  unreachable

if.else14:                                        ; preds = %if.else
  %30 = load %struct.lua_State** %L.addr, align 8
  %l_G15 = getelementptr inbounds %struct.lua_State* %30, i32 0, i32 5
  %31 = load %struct.global_State** %l_G15, align 8
  %panic = getelementptr inbounds %struct.global_State* %31, i32 0, i32 29
  %32 = load i32 (%struct.lua_State*)** %panic, align 8
  %tobool16 = icmp ne i32 (%struct.lua_State*)* %32, null
  br i1 %tobool16, label %if.then17, label %if.end

if.then17:                                        ; preds = %if.else14
  %33 = load %struct.lua_State** %L.addr, align 8
  %l_G18 = getelementptr inbounds %struct.lua_State* %33, i32 0, i32 5
  %34 = load %struct.global_State** %l_G18, align 8
  %panic19 = getelementptr inbounds %struct.global_State* %34, i32 0, i32 29
  %35 = load i32 (%struct.lua_State*)** %panic19, align 8
  %36 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 %35(%struct.lua_State* %36)
  br label %if.end

if.end:                                           ; preds = %if.then17, %if.else14
  call void @abort() #12
  unreachable

return:                                           ; No predecessors!
  ret void
}

; Function Attrs: noreturn nounwind
declare void @_longjmp(%struct.__jmp_buf_tag*, i32) #7

; Function Attrs: noreturn nounwind
declare void @abort() #7

; Function Attrs: nounwind uwtable
define hidden i32 @luaD_rawrunprotected(%struct.lua_State* %L, void (%struct.lua_State*, i8*)* %f, i8* %ud) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %f.addr = alloca void (%struct.lua_State*, i8*)*, align 8
  %ud.addr = alloca i8*, align 8
  %oldnCcalls = alloca i16, align 2
  %lj = alloca %struct.lua_longjmp, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store void (%struct.lua_State*, i8*)* %f, void (%struct.lua_State*, i8*)** %f.addr, align 8
  store i8* %ud, i8** %ud.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %nCcalls = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 12
  %1 = load i16* %nCcalls, align 2
  store i16 %1, i16* %oldnCcalls, align 2
  %status = getelementptr inbounds %struct.lua_longjmp* %lj, i32 0, i32 2
  store volatile i32 0, i32* %status, align 4
  %2 = load %struct.lua_State** %L.addr, align 8
  %errorJmp = getelementptr inbounds %struct.lua_State* %2, i32 0, i32 20
  %3 = load %struct.lua_longjmp** %errorJmp, align 8
  %previous = getelementptr inbounds %struct.lua_longjmp* %lj, i32 0, i32 0
  store %struct.lua_longjmp* %3, %struct.lua_longjmp** %previous, align 8
  %4 = load %struct.lua_State** %L.addr, align 8
  %errorJmp1 = getelementptr inbounds %struct.lua_State* %4, i32 0, i32 20
  store %struct.lua_longjmp* %lj, %struct.lua_longjmp** %errorJmp1, align 8
  %b = getelementptr inbounds %struct.lua_longjmp* %lj, i32 0, i32 1
  %arraydecay = getelementptr inbounds [1 x %struct.__jmp_buf_tag]* %b, i32 0, i32 0
  %call = call i32 @_setjmp(%struct.__jmp_buf_tag* %arraydecay) #13
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load void (%struct.lua_State*, i8*)** %f.addr, align 8
  %6 = load %struct.lua_State** %L.addr, align 8
  %7 = load i8** %ud.addr, align 8
  call void %5(%struct.lua_State* %6, i8* %7)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %previous2 = getelementptr inbounds %struct.lua_longjmp* %lj, i32 0, i32 0
  %8 = load %struct.lua_longjmp** %previous2, align 8
  %9 = load %struct.lua_State** %L.addr, align 8
  %errorJmp3 = getelementptr inbounds %struct.lua_State* %9, i32 0, i32 20
  store %struct.lua_longjmp* %8, %struct.lua_longjmp** %errorJmp3, align 8
  %10 = load i16* %oldnCcalls, align 2
  %11 = load %struct.lua_State** %L.addr, align 8
  %nCcalls4 = getelementptr inbounds %struct.lua_State* %11, i32 0, i32 12
  store i16 %10, i16* %nCcalls4, align 2
  %status5 = getelementptr inbounds %struct.lua_longjmp* %lj, i32 0, i32 2
  %12 = load volatile i32* %status5, align 4
  ret i32 %12
}

; Function Attrs: nounwind returns_twice
declare i32 @_setjmp(%struct.__jmp_buf_tag*) #8

; Function Attrs: nounwind uwtable
define hidden void @luaD_reallocstack(%struct.lua_State* %L, i32 %newsize) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %newsize.addr = alloca i32, align 4
  %oldstack = alloca %struct.lua_TValue*, align 8
  %lim = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %newsize, i32* %newsize.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %stack = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 9
  %1 = load %struct.lua_TValue** %stack, align 8
  store %struct.lua_TValue* %1, %struct.lua_TValue** %oldstack, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %stacksize = getelementptr inbounds %struct.lua_State* %2, i32 0, i32 10
  %3 = load i32* %stacksize, align 4
  store i32 %3, i32* %lim, align 4
  %4 = load i32* %newsize.addr, align 4
  %add = add nsw i32 %4, 1
  %conv = sext i32 %add to i64
  %cmp = icmp ugt i64 %conv, 1152921504606846975
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %5 = load %struct.lua_State** %L.addr, align 8
  call void @luaM_toobig(%struct.lua_State* %5) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %6
  %cond = phi i32 [ 0, %6 ], [ 0, %cond.false ]
  %7 = load %struct.lua_State** %L.addr, align 8
  %8 = load %struct.lua_State** %L.addr, align 8
  %stack2 = getelementptr inbounds %struct.lua_State* %8, i32 0, i32 9
  %9 = load %struct.lua_TValue** %stack2, align 8
  %10 = bitcast %struct.lua_TValue* %9 to i8*
  %11 = load %struct.lua_State** %L.addr, align 8
  %stacksize3 = getelementptr inbounds %struct.lua_State* %11, i32 0, i32 10
  %12 = load i32* %stacksize3, align 4
  %conv4 = sext i32 %12 to i64
  %mul = mul i64 %conv4, 16
  %13 = load i32* %newsize.addr, align 4
  %conv5 = sext i32 %13 to i64
  %mul6 = mul i64 %conv5, 16
  %call = call i8* @luaM_realloc_(%struct.lua_State* %7, i8* %10, i64 %mul, i64 %mul6)
  %14 = bitcast i8* %call to %struct.lua_TValue*
  %15 = load %struct.lua_State** %L.addr, align 8
  %stack7 = getelementptr inbounds %struct.lua_State* %15, i32 0, i32 9
  store %struct.lua_TValue* %14, %struct.lua_TValue** %stack7, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %16 = load i32* %lim, align 4
  %17 = load i32* %newsize.addr, align 4
  %cmp8 = icmp slt i32 %16, %17
  br i1 %cmp8, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %18 = load %struct.lua_State** %L.addr, align 8
  %stack10 = getelementptr inbounds %struct.lua_State* %18, i32 0, i32 9
  %19 = load %struct.lua_TValue** %stack10, align 8
  %20 = load i32* %lim, align 4
  %idx.ext = sext i32 %20 to i64
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %19, i64 %idx.ext
  %tt_ = getelementptr inbounds %struct.lua_TValue* %add.ptr, i32 0, i32 1
  store i32 0, i32* %tt_, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %21 = load i32* %lim, align 4
  %inc = add nsw i32 %21, 1
  store i32 %inc, i32* %lim, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %22 = load i32* %newsize.addr, align 4
  %23 = load %struct.lua_State** %L.addr, align 8
  %stacksize11 = getelementptr inbounds %struct.lua_State* %23, i32 0, i32 10
  store i32 %22, i32* %stacksize11, align 4
  %24 = load %struct.lua_State** %L.addr, align 8
  %stack12 = getelementptr inbounds %struct.lua_State* %24, i32 0, i32 9
  %25 = load %struct.lua_TValue** %stack12, align 8
  %26 = load i32* %newsize.addr, align 4
  %idx.ext13 = sext i32 %26 to i64
  %add.ptr14 = getelementptr inbounds %struct.lua_TValue* %25, i64 %idx.ext13
  %add.ptr15 = getelementptr inbounds %struct.lua_TValue* %add.ptr14, i64 -5
  %27 = load %struct.lua_State** %L.addr, align 8
  %stack_last = getelementptr inbounds %struct.lua_State* %27, i32 0, i32 8
  store %struct.lua_TValue* %add.ptr15, %struct.lua_TValue** %stack_last, align 8
  %28 = load %struct.lua_State** %L.addr, align 8
  %29 = load %struct.lua_TValue** %oldstack, align 8
  call void @correctstack(%struct.lua_State* %28, %struct.lua_TValue* %29)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @luaD_growstack(%struct.lua_State* %L, i32 %n) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %n.addr = alloca i32, align 4
  %size = alloca i32, align 4
  %needed = alloca i32, align 4
  %newsize = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %n, i32* %n.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %stacksize = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 10
  %1 = load i32* %stacksize, align 4
  store i32 %1, i32* %size, align 4
  %2 = load i32* %size, align 4
  %cmp = icmp sgt i32 %2, 1000000
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load %struct.lua_State** %L.addr, align 8
  call void @luaD_throw(%struct.lua_State* %3, i32 6) #9
  unreachable

if.else:                                          ; preds = %entry
  %4 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %4, i32 0, i32 4
  %5 = load %struct.lua_TValue** %top, align 8
  %6 = load %struct.lua_State** %L.addr, align 8
  %stack = getelementptr inbounds %struct.lua_State* %6, i32 0, i32 9
  %7 = load %struct.lua_TValue** %stack, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.lua_TValue* %5 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.lua_TValue* %7 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 16
  %conv = trunc i64 %sub.ptr.div to i32
  %8 = load i32* %n.addr, align 4
  %add = add nsw i32 %conv, %8
  %add1 = add nsw i32 %add, 5
  store i32 %add1, i32* %needed, align 4
  %9 = load i32* %size, align 4
  %mul = mul nsw i32 2, %9
  store i32 %mul, i32* %newsize, align 4
  %10 = load i32* %newsize, align 4
  %cmp2 = icmp sgt i32 %10, 1000000
  br i1 %cmp2, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.else
  store i32 1000000, i32* %newsize, align 4
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.else
  %11 = load i32* %newsize, align 4
  %12 = load i32* %needed, align 4
  %cmp5 = icmp slt i32 %11, %12
  br i1 %cmp5, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end
  %13 = load i32* %needed, align 4
  store i32 %13, i32* %newsize, align 4
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %if.end
  %14 = load i32* %newsize, align 4
  %cmp9 = icmp sgt i32 %14, 1000000
  br i1 %cmp9, label %if.then11, label %if.else12

if.then11:                                        ; preds = %if.end8
  %15 = load %struct.lua_State** %L.addr, align 8
  call void @luaD_reallocstack(%struct.lua_State* %15, i32 1000200)
  %16 = load %struct.lua_State** %L.addr, align 8
  call void (%struct.lua_State*, i8*, ...)* @luaG_runerror(%struct.lua_State* %16, i8* getelementptr inbounds ([15 x i8]* @.str237, i32 0, i32 0)) #9
  unreachable

if.else12:                                        ; preds = %if.end8
  %17 = load %struct.lua_State** %L.addr, align 8
  %18 = load i32* %newsize, align 4
  call void @luaD_reallocstack(%struct.lua_State* %17, i32 %18)
  br label %if.end13

if.end13:                                         ; preds = %if.else12
  br label %if.end14

if.end14:                                         ; preds = %if.end13
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @luaD_shrinkstack(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %inuse = alloca i32, align 4
  %goodsize = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @stackinuse(%struct.lua_State* %0)
  store i32 %call, i32* %inuse, align 4
  %1 = load i32* %inuse, align 4
  %2 = load i32* %inuse, align 4
  %div = sdiv i32 %2, 8
  %add = add nsw i32 %1, %div
  %add1 = add nsw i32 %add, 10
  store i32 %add1, i32* %goodsize, align 4
  %3 = load i32* %goodsize, align 4
  %cmp = icmp sgt i32 %3, 1000000
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1000000, i32* %goodsize, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load i32* %inuse, align 4
  %cmp2 = icmp sgt i32 %4, 1000000
  br i1 %cmp2, label %if.then4, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %5 = load i32* %goodsize, align 4
  %6 = load %struct.lua_State** %L.addr, align 8
  %stacksize = getelementptr inbounds %struct.lua_State* %6, i32 0, i32 10
  %7 = load i32* %stacksize, align 4
  %cmp3 = icmp sge i32 %5, %7
  br i1 %cmp3, label %if.then4, label %if.else

if.then4:                                         ; preds = %lor.lhs.false, %if.end
  br label %if.end5

if.else:                                          ; preds = %lor.lhs.false
  %8 = load %struct.lua_State** %L.addr, align 8
  %9 = load i32* %goodsize, align 4
  call void @luaD_reallocstack(%struct.lua_State* %8, i32 %9)
  br label %if.end5

if.end5:                                          ; preds = %if.else, %if.then4
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @luaD_hook(%struct.lua_State* %L, i32 %event, i32 %line) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %event.addr = alloca i32, align 4
  %line.addr = alloca i32, align 4
  %hook = alloca void (%struct.lua_State*, %struct.lua_Debug*)*, align 8
  %ci = alloca %struct.CallInfo*, align 8
  %top = alloca i64, align 8
  %ci_top = alloca i64, align 8
  %ar = alloca %struct.lua_Debug, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %event, i32* %event.addr, align 4
  store i32 %line, i32* %line.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %hook1 = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 17
  %1 = load void (%struct.lua_State*, %struct.lua_Debug*)** %hook1, align 8
  store void (%struct.lua_State*, %struct.lua_Debug*)* %1, void (%struct.lua_State*, %struct.lua_Debug*)** %hook, align 8
  %2 = load void (%struct.lua_State*, %struct.lua_Debug*)** %hook, align 8
  %tobool = icmp ne void (%struct.lua_State*, %struct.lua_Debug*)* %2, null
  br i1 %tobool, label %land.lhs.true, label %if.end32

land.lhs.true:                                    ; preds = %entry
  %3 = load %struct.lua_State** %L.addr, align 8
  %allowhook = getelementptr inbounds %struct.lua_State* %3, i32 0, i32 14
  %4 = load i8* %allowhook, align 1
  %conv = zext i8 %4 to i32
  %tobool2 = icmp ne i32 %conv, 0
  br i1 %tobool2, label %if.then, label %if.end32

if.then:                                          ; preds = %land.lhs.true
  %5 = load %struct.lua_State** %L.addr, align 8
  %ci3 = getelementptr inbounds %struct.lua_State* %5, i32 0, i32 6
  %6 = load %struct.CallInfo** %ci3, align 8
  store %struct.CallInfo* %6, %struct.CallInfo** %ci, align 8
  %7 = load %struct.lua_State** %L.addr, align 8
  %top4 = getelementptr inbounds %struct.lua_State* %7, i32 0, i32 4
  %8 = load %struct.lua_TValue** %top4, align 8
  %9 = bitcast %struct.lua_TValue* %8 to i8*
  %10 = load %struct.lua_State** %L.addr, align 8
  %stack = getelementptr inbounds %struct.lua_State* %10, i32 0, i32 9
  %11 = load %struct.lua_TValue** %stack, align 8
  %12 = bitcast %struct.lua_TValue* %11 to i8*
  %sub.ptr.lhs.cast = ptrtoint i8* %9 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %12 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, i64* %top, align 8
  %13 = load %struct.CallInfo** %ci, align 8
  %top5 = getelementptr inbounds %struct.CallInfo* %13, i32 0, i32 1
  %14 = load %struct.lua_TValue** %top5, align 8
  %15 = bitcast %struct.lua_TValue* %14 to i8*
  %16 = load %struct.lua_State** %L.addr, align 8
  %stack6 = getelementptr inbounds %struct.lua_State* %16, i32 0, i32 9
  %17 = load %struct.lua_TValue** %stack6, align 8
  %18 = bitcast %struct.lua_TValue* %17 to i8*
  %sub.ptr.lhs.cast7 = ptrtoint i8* %15 to i64
  %sub.ptr.rhs.cast8 = ptrtoint i8* %18 to i64
  %sub.ptr.sub9 = sub i64 %sub.ptr.lhs.cast7, %sub.ptr.rhs.cast8
  store i64 %sub.ptr.sub9, i64* %ci_top, align 8
  %19 = load i32* %event.addr, align 4
  %event10 = getelementptr inbounds %struct.lua_Debug* %ar, i32 0, i32 0
  store i32 %19, i32* %event10, align 4
  %20 = load i32* %line.addr, align 4
  %currentline = getelementptr inbounds %struct.lua_Debug* %ar, i32 0, i32 5
  store i32 %20, i32* %currentline, align 4
  %21 = load %struct.CallInfo** %ci, align 8
  %i_ci = getelementptr inbounds %struct.lua_Debug* %ar, i32 0, i32 13
  store %struct.CallInfo* %21, %struct.CallInfo** %i_ci, align 8
  %22 = load %struct.lua_State** %L.addr, align 8
  %stack_last = getelementptr inbounds %struct.lua_State* %22, i32 0, i32 8
  %23 = load %struct.lua_TValue** %stack_last, align 8
  %24 = load %struct.lua_State** %L.addr, align 8
  %top11 = getelementptr inbounds %struct.lua_State* %24, i32 0, i32 4
  %25 = load %struct.lua_TValue** %top11, align 8
  %sub.ptr.lhs.cast12 = ptrtoint %struct.lua_TValue* %23 to i64
  %sub.ptr.rhs.cast13 = ptrtoint %struct.lua_TValue* %25 to i64
  %sub.ptr.sub14 = sub i64 %sub.ptr.lhs.cast12, %sub.ptr.rhs.cast13
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub14, 16
  %cmp = icmp sle i64 %sub.ptr.div, 20
  br i1 %cmp, label %if.then16, label %if.else

if.then16:                                        ; preds = %if.then
  %26 = load %struct.lua_State** %L.addr, align 8
  call void @luaD_growstack(%struct.lua_State* %26, i32 20)
  br label %if.end

if.else:                                          ; preds = %if.then
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then16
  %27 = load %struct.lua_State** %L.addr, align 8
  %top17 = getelementptr inbounds %struct.lua_State* %27, i32 0, i32 4
  %28 = load %struct.lua_TValue** %top17, align 8
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %28, i64 20
  %29 = load %struct.CallInfo** %ci, align 8
  %top18 = getelementptr inbounds %struct.CallInfo* %29, i32 0, i32 1
  store %struct.lua_TValue* %add.ptr, %struct.lua_TValue** %top18, align 8
  %30 = load %struct.lua_State** %L.addr, align 8
  %allowhook19 = getelementptr inbounds %struct.lua_State* %30, i32 0, i32 14
  store i8 0, i8* %allowhook19, align 1
  %31 = load %struct.CallInfo** %ci, align 8
  %callstatus = getelementptr inbounds %struct.CallInfo* %31, i32 0, i32 5
  %32 = load i8* %callstatus, align 1
  %conv20 = zext i8 %32 to i32
  %or = or i32 %conv20, 2
  %conv21 = trunc i32 %or to i8
  store i8 %conv21, i8* %callstatus, align 1
  %33 = load void (%struct.lua_State*, %struct.lua_Debug*)** %hook, align 8
  %34 = load %struct.lua_State** %L.addr, align 8
  call void %33(%struct.lua_State* %34, %struct.lua_Debug* %ar)
  %35 = load %struct.lua_State** %L.addr, align 8
  %allowhook22 = getelementptr inbounds %struct.lua_State* %35, i32 0, i32 14
  store i8 1, i8* %allowhook22, align 1
  %36 = load %struct.lua_State** %L.addr, align 8
  %stack23 = getelementptr inbounds %struct.lua_State* %36, i32 0, i32 9
  %37 = load %struct.lua_TValue** %stack23, align 8
  %38 = bitcast %struct.lua_TValue* %37 to i8*
  %39 = load i64* %ci_top, align 8
  %add.ptr24 = getelementptr inbounds i8* %38, i64 %39
  %40 = bitcast i8* %add.ptr24 to %struct.lua_TValue*
  %41 = load %struct.CallInfo** %ci, align 8
  %top25 = getelementptr inbounds %struct.CallInfo* %41, i32 0, i32 1
  store %struct.lua_TValue* %40, %struct.lua_TValue** %top25, align 8
  %42 = load %struct.lua_State** %L.addr, align 8
  %stack26 = getelementptr inbounds %struct.lua_State* %42, i32 0, i32 9
  %43 = load %struct.lua_TValue** %stack26, align 8
  %44 = bitcast %struct.lua_TValue* %43 to i8*
  %45 = load i64* %top, align 8
  %add.ptr27 = getelementptr inbounds i8* %44, i64 %45
  %46 = bitcast i8* %add.ptr27 to %struct.lua_TValue*
  %47 = load %struct.lua_State** %L.addr, align 8
  %top28 = getelementptr inbounds %struct.lua_State* %47, i32 0, i32 4
  store %struct.lua_TValue* %46, %struct.lua_TValue** %top28, align 8
  %48 = load %struct.CallInfo** %ci, align 8
  %callstatus29 = getelementptr inbounds %struct.CallInfo* %48, i32 0, i32 5
  %49 = load i8* %callstatus29, align 1
  %conv30 = zext i8 %49 to i32
  %and = and i32 %conv30, -3
  %conv31 = trunc i32 %and to i8
  store i8 %conv31, i8* %callstatus29, align 1
  br label %if.end32

if.end32:                                         ; preds = %if.end, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define hidden i32 @luaD_precall(%struct.lua_State* %L, %struct.lua_TValue* %func, i32 %nresults) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %func.addr = alloca %struct.lua_TValue*, align 8
  %nresults.addr = alloca i32, align 4
  %f = alloca i32 (%struct.lua_State*)*, align 8
  %ci = alloca %struct.CallInfo*, align 8
  %n = alloca i32, align 4
  %funcr = alloca i64, align 8
  %base = alloca %struct.lua_TValue*, align 8
  %p = alloca %struct.Proto*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.lua_TValue* %func, %struct.lua_TValue** %func.addr, align 8
  store i32 %nresults, i32* %nresults.addr, align 4
  %0 = load %struct.lua_TValue** %func.addr, align 8
  %1 = bitcast %struct.lua_TValue* %0 to i8*
  %2 = load %struct.lua_State** %L.addr, align 8
  %stack = getelementptr inbounds %struct.lua_State* %2, i32 0, i32 9
  %3 = load %struct.lua_TValue** %stack, align 8
  %4 = bitcast %struct.lua_TValue* %3 to i8*
  %sub.ptr.lhs.cast = ptrtoint i8* %1 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %4 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, i64* %funcr, align 8
  %5 = load %struct.lua_TValue** %func.addr, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %5, i32 0, i32 1
  %6 = load i32* %tt_, align 4
  %and = and i32 %6, 63
  switch i32 %and, label %sw.default [
    i32 22, label %sw.bb
    i32 38, label %sw.bb2
    i32 6, label %sw.bb31
  ]

sw.bb:                                            ; preds = %entry
  %7 = load %struct.lua_TValue** %func.addr, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %7, i32 0, i32 0
  %f1 = bitcast %union.Value* %value_ to i32 (%struct.lua_State*)**
  %8 = load i32 (%struct.lua_State*)** %f1, align 8
  store i32 (%struct.lua_State*)* %8, i32 (%struct.lua_State*)** %f, align 8
  br label %Cfunc

sw.bb2:                                           ; preds = %entry
  %9 = load %struct.lua_TValue** %func.addr, align 8
  %value_3 = getelementptr inbounds %struct.lua_TValue* %9, i32 0, i32 0
  %gc = bitcast %union.Value* %value_3 to %union.GCObject**
  %10 = load %union.GCObject** %gc, align 8
  %cl = bitcast %union.GCObject* %10 to %union.Closure*
  %c = bitcast %union.Closure* %cl to %struct.CClosure*
  %f4 = getelementptr inbounds %struct.CClosure* %c, i32 0, i32 5
  %11 = load i32 (%struct.lua_State*)** %f4, align 8
  store i32 (%struct.lua_State*)* %11, i32 (%struct.lua_State*)** %f, align 8
  br label %Cfunc

Cfunc:                                            ; preds = %sw.bb2, %sw.bb
  %12 = load %struct.lua_State** %L.addr, align 8
  %stack_last = getelementptr inbounds %struct.lua_State* %12, i32 0, i32 8
  %13 = load %struct.lua_TValue** %stack_last, align 8
  %14 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %14, i32 0, i32 4
  %15 = load %struct.lua_TValue** %top, align 8
  %sub.ptr.lhs.cast5 = ptrtoint %struct.lua_TValue* %13 to i64
  %sub.ptr.rhs.cast6 = ptrtoint %struct.lua_TValue* %15 to i64
  %sub.ptr.sub7 = sub i64 %sub.ptr.lhs.cast5, %sub.ptr.rhs.cast6
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub7, 16
  %cmp = icmp sle i64 %sub.ptr.div, 20
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %Cfunc
  %16 = load %struct.lua_State** %L.addr, align 8
  call void @luaD_growstack(%struct.lua_State* %16, i32 20)
  br label %if.end

if.else:                                          ; preds = %Cfunc
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %17 = load %struct.lua_State** %L.addr, align 8
  %ci8 = getelementptr inbounds %struct.lua_State* %17, i32 0, i32 6
  %18 = load %struct.CallInfo** %ci8, align 8
  %next = getelementptr inbounds %struct.CallInfo* %18, i32 0, i32 3
  %19 = load %struct.CallInfo** %next, align 8
  %tobool = icmp ne %struct.CallInfo* %19, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %20 = load %struct.lua_State** %L.addr, align 8
  %ci9 = getelementptr inbounds %struct.lua_State* %20, i32 0, i32 6
  %21 = load %struct.CallInfo** %ci9, align 8
  %next10 = getelementptr inbounds %struct.CallInfo* %21, i32 0, i32 3
  %22 = load %struct.CallInfo** %next10, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %23 = load %struct.lua_State** %L.addr, align 8
  %call = call %struct.CallInfo* bitcast (%struct.CallInfo.340* (%struct.lua_State.343*)* @luaE_extendCI to %struct.CallInfo* (%struct.lua_State*)*)(%struct.lua_State* %23)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.CallInfo* [ %22, %cond.true ], [ %call, %cond.false ]
  %24 = load %struct.lua_State** %L.addr, align 8
  %ci11 = getelementptr inbounds %struct.lua_State* %24, i32 0, i32 6
  store %struct.CallInfo* %cond, %struct.CallInfo** %ci11, align 8
  store %struct.CallInfo* %cond, %struct.CallInfo** %ci, align 8
  %25 = load i32* %nresults.addr, align 4
  %conv = trunc i32 %25 to i16
  %26 = load %struct.CallInfo** %ci, align 8
  %nresults12 = getelementptr inbounds %struct.CallInfo* %26, i32 0, i32 4
  store i16 %conv, i16* %nresults12, align 2
  %27 = load %struct.lua_State** %L.addr, align 8
  %stack13 = getelementptr inbounds %struct.lua_State* %27, i32 0, i32 9
  %28 = load %struct.lua_TValue** %stack13, align 8
  %29 = bitcast %struct.lua_TValue* %28 to i8*
  %30 = load i64* %funcr, align 8
  %add.ptr = getelementptr inbounds i8* %29, i64 %30
  %31 = bitcast i8* %add.ptr to %struct.lua_TValue*
  %32 = load %struct.CallInfo** %ci, align 8
  %func14 = getelementptr inbounds %struct.CallInfo* %32, i32 0, i32 0
  store %struct.lua_TValue* %31, %struct.lua_TValue** %func14, align 8
  %33 = load %struct.lua_State** %L.addr, align 8
  %top15 = getelementptr inbounds %struct.lua_State* %33, i32 0, i32 4
  %34 = load %struct.lua_TValue** %top15, align 8
  %add.ptr16 = getelementptr inbounds %struct.lua_TValue* %34, i64 20
  %35 = load %struct.CallInfo** %ci, align 8
  %top17 = getelementptr inbounds %struct.CallInfo* %35, i32 0, i32 1
  store %struct.lua_TValue* %add.ptr16, %struct.lua_TValue** %top17, align 8
  %36 = load %struct.CallInfo** %ci, align 8
  %callstatus = getelementptr inbounds %struct.CallInfo* %36, i32 0, i32 5
  store i8 0, i8* %callstatus, align 1
  %37 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %37, i32 0, i32 5
  %38 = load %struct.global_State** %l_G, align 8
  %GCdebt = getelementptr inbounds %struct.global_State* %38, i32 0, i32 3
  %39 = load i64* %GCdebt, align 8
  %cmp18 = icmp sgt i64 %39, 0
  br i1 %cmp18, label %if.then20, label %if.end21

if.then20:                                        ; preds = %cond.end
  %40 = load %struct.lua_State** %L.addr, align 8
  call void @luaC_step(%struct.lua_State* %40)
  br label %if.end21

if.end21:                                         ; preds = %if.then20, %cond.end
  %41 = load %struct.lua_State** %L.addr, align 8
  %hookmask = getelementptr inbounds %struct.lua_State* %41, i32 0, i32 13
  %42 = load i8* %hookmask, align 1
  %conv22 = zext i8 %42 to i32
  %and23 = and i32 %conv22, 1
  %tobool24 = icmp ne i32 %and23, 0
  br i1 %tobool24, label %if.then25, label %if.end26

if.then25:                                        ; preds = %if.end21
  %43 = load %struct.lua_State** %L.addr, align 8
  call void @luaD_hook(%struct.lua_State* %43, i32 0, i32 -1)
  br label %if.end26

if.end26:                                         ; preds = %if.then25, %if.end21
  %44 = load i32 (%struct.lua_State*)** %f, align 8
  %45 = load %struct.lua_State** %L.addr, align 8
  %call27 = call i32 %44(%struct.lua_State* %45)
  store i32 %call27, i32* %n, align 4
  %46 = load %struct.lua_State** %L.addr, align 8
  %47 = load %struct.lua_State** %L.addr, align 8
  %top28 = getelementptr inbounds %struct.lua_State* %47, i32 0, i32 4
  %48 = load %struct.lua_TValue** %top28, align 8
  %49 = load i32* %n, align 4
  %idx.ext = sext i32 %49 to i64
  %idx.neg = sub i64 0, %idx.ext
  %add.ptr29 = getelementptr inbounds %struct.lua_TValue* %48, i64 %idx.neg
  %call30 = call i32 @luaD_poscall(%struct.lua_State* %46, %struct.lua_TValue* %add.ptr29)
  store i32 1, i32* %retval
  br label %return

sw.bb31:                                          ; preds = %entry
  %50 = load %struct.lua_TValue** %func.addr, align 8
  %value_32 = getelementptr inbounds %struct.lua_TValue* %50, i32 0, i32 0
  %gc33 = bitcast %union.Value* %value_32 to %union.GCObject**
  %51 = load %union.GCObject** %gc33, align 8
  %cl34 = bitcast %union.GCObject* %51 to %union.Closure*
  %l = bitcast %union.Closure* %cl34 to %struct.LClosure*
  %p35 = getelementptr inbounds %struct.LClosure* %l, i32 0, i32 5
  %52 = load %struct.Proto** %p35, align 8
  store %struct.Proto* %52, %struct.Proto** %p, align 8
  %53 = load %struct.lua_State** %L.addr, align 8
  %stack_last36 = getelementptr inbounds %struct.lua_State* %53, i32 0, i32 8
  %54 = load %struct.lua_TValue** %stack_last36, align 8
  %55 = load %struct.lua_State** %L.addr, align 8
  %top37 = getelementptr inbounds %struct.lua_State* %55, i32 0, i32 4
  %56 = load %struct.lua_TValue** %top37, align 8
  %sub.ptr.lhs.cast38 = ptrtoint %struct.lua_TValue* %54 to i64
  %sub.ptr.rhs.cast39 = ptrtoint %struct.lua_TValue* %56 to i64
  %sub.ptr.sub40 = sub i64 %sub.ptr.lhs.cast38, %sub.ptr.rhs.cast39
  %sub.ptr.div41 = sdiv exact i64 %sub.ptr.sub40, 16
  %57 = load %struct.Proto** %p, align 8
  %maxstacksize = getelementptr inbounds %struct.Proto* %57, i32 0, i32 22
  %58 = load i8* %maxstacksize, align 1
  %conv42 = zext i8 %58 to i64
  %cmp43 = icmp sle i64 %sub.ptr.div41, %conv42
  br i1 %cmp43, label %if.then45, label %if.else48

if.then45:                                        ; preds = %sw.bb31
  %59 = load %struct.lua_State** %L.addr, align 8
  %60 = load %struct.Proto** %p, align 8
  %maxstacksize46 = getelementptr inbounds %struct.Proto* %60, i32 0, i32 22
  %61 = load i8* %maxstacksize46, align 1
  %conv47 = zext i8 %61 to i32
  call void @luaD_growstack(%struct.lua_State* %59, i32 %conv47)
  br label %if.end49

if.else48:                                        ; preds = %sw.bb31
  br label %if.end49

if.end49:                                         ; preds = %if.else48, %if.then45
  %62 = load %struct.lua_State** %L.addr, align 8
  %stack50 = getelementptr inbounds %struct.lua_State* %62, i32 0, i32 9
  %63 = load %struct.lua_TValue** %stack50, align 8
  %64 = bitcast %struct.lua_TValue* %63 to i8*
  %65 = load i64* %funcr, align 8
  %add.ptr51 = getelementptr inbounds i8* %64, i64 %65
  %66 = bitcast i8* %add.ptr51 to %struct.lua_TValue*
  store %struct.lua_TValue* %66, %struct.lua_TValue** %func.addr, align 8
  %67 = load %struct.lua_State** %L.addr, align 8
  %top52 = getelementptr inbounds %struct.lua_State* %67, i32 0, i32 4
  %68 = load %struct.lua_TValue** %top52, align 8
  %69 = load %struct.lua_TValue** %func.addr, align 8
  %sub.ptr.lhs.cast53 = ptrtoint %struct.lua_TValue* %68 to i64
  %sub.ptr.rhs.cast54 = ptrtoint %struct.lua_TValue* %69 to i64
  %sub.ptr.sub55 = sub i64 %sub.ptr.lhs.cast53, %sub.ptr.rhs.cast54
  %sub.ptr.div56 = sdiv exact i64 %sub.ptr.sub55, 16
  %conv57 = trunc i64 %sub.ptr.div56 to i32
  %sub = sub nsw i32 %conv57, 1
  store i32 %sub, i32* %n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end49
  %70 = load i32* %n, align 4
  %71 = load %struct.Proto** %p, align 8
  %numparams = getelementptr inbounds %struct.Proto* %71, i32 0, i32 20
  %72 = load i8* %numparams, align 1
  %conv58 = zext i8 %72 to i32
  %cmp59 = icmp slt i32 %70, %conv58
  br i1 %cmp59, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %73 = load %struct.lua_State** %L.addr, align 8
  %top61 = getelementptr inbounds %struct.lua_State* %73, i32 0, i32 4
  %74 = load %struct.lua_TValue** %top61, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %74, i32 1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %top61, align 8
  %tt_62 = getelementptr inbounds %struct.lua_TValue* %74, i32 0, i32 1
  store i32 0, i32* %tt_62, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %75 = load i32* %n, align 4
  %inc = add nsw i32 %75, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %76 = load %struct.Proto** %p, align 8
  %is_vararg = getelementptr inbounds %struct.Proto* %76, i32 0, i32 21
  %77 = load i8* %is_vararg, align 1
  %tobool63 = icmp ne i8 %77, 0
  br i1 %tobool63, label %cond.false66, label %cond.true64

cond.true64:                                      ; preds = %for.end
  %78 = load %struct.lua_TValue** %func.addr, align 8
  %add.ptr65 = getelementptr inbounds %struct.lua_TValue* %78, i64 1
  br label %cond.end68

cond.false66:                                     ; preds = %for.end
  %79 = load %struct.lua_State** %L.addr, align 8
  %80 = load %struct.Proto** %p, align 8
  %81 = load i32* %n, align 4
  %call67 = call %struct.lua_TValue* @adjust_varargs(%struct.lua_State* %79, %struct.Proto* %80, i32 %81)
  br label %cond.end68

cond.end68:                                       ; preds = %cond.false66, %cond.true64
  %cond69 = phi %struct.lua_TValue* [ %add.ptr65, %cond.true64 ], [ %call67, %cond.false66 ]
  store %struct.lua_TValue* %cond69, %struct.lua_TValue** %base, align 8
  %82 = load %struct.lua_State** %L.addr, align 8
  %ci70 = getelementptr inbounds %struct.lua_State* %82, i32 0, i32 6
  %83 = load %struct.CallInfo** %ci70, align 8
  %next71 = getelementptr inbounds %struct.CallInfo* %83, i32 0, i32 3
  %84 = load %struct.CallInfo** %next71, align 8
  %tobool72 = icmp ne %struct.CallInfo* %84, null
  br i1 %tobool72, label %cond.true73, label %cond.false76

cond.true73:                                      ; preds = %cond.end68
  %85 = load %struct.lua_State** %L.addr, align 8
  %ci74 = getelementptr inbounds %struct.lua_State* %85, i32 0, i32 6
  %86 = load %struct.CallInfo** %ci74, align 8
  %next75 = getelementptr inbounds %struct.CallInfo* %86, i32 0, i32 3
  %87 = load %struct.CallInfo** %next75, align 8
  br label %cond.end78

cond.false76:                                     ; preds = %cond.end68
  %88 = load %struct.lua_State** %L.addr, align 8
  %call77 = call %struct.CallInfo* bitcast (%struct.CallInfo.340* (%struct.lua_State.343*)* @luaE_extendCI to %struct.CallInfo* (%struct.lua_State*)*)(%struct.lua_State* %88)
  br label %cond.end78

cond.end78:                                       ; preds = %cond.false76, %cond.true73
  %cond79 = phi %struct.CallInfo* [ %87, %cond.true73 ], [ %call77, %cond.false76 ]
  %89 = load %struct.lua_State** %L.addr, align 8
  %ci80 = getelementptr inbounds %struct.lua_State* %89, i32 0, i32 6
  store %struct.CallInfo* %cond79, %struct.CallInfo** %ci80, align 8
  store %struct.CallInfo* %cond79, %struct.CallInfo** %ci, align 8
  %90 = load i32* %nresults.addr, align 4
  %conv81 = trunc i32 %90 to i16
  %91 = load %struct.CallInfo** %ci, align 8
  %nresults82 = getelementptr inbounds %struct.CallInfo* %91, i32 0, i32 4
  store i16 %conv81, i16* %nresults82, align 2
  %92 = load %struct.lua_TValue** %func.addr, align 8
  %93 = load %struct.CallInfo** %ci, align 8
  %func83 = getelementptr inbounds %struct.CallInfo* %93, i32 0, i32 0
  store %struct.lua_TValue* %92, %struct.lua_TValue** %func83, align 8
  %94 = load %struct.lua_TValue** %base, align 8
  %95 = load %struct.CallInfo** %ci, align 8
  %u = getelementptr inbounds %struct.CallInfo* %95, i32 0, i32 7
  %l84 = bitcast %union.anon.2* %u to %struct.anon.3*
  %base85 = getelementptr inbounds %struct.anon.3* %l84, i32 0, i32 0
  store %struct.lua_TValue* %94, %struct.lua_TValue** %base85, align 8
  %96 = load %struct.lua_TValue** %base, align 8
  %97 = load %struct.Proto** %p, align 8
  %maxstacksize86 = getelementptr inbounds %struct.Proto* %97, i32 0, i32 22
  %98 = load i8* %maxstacksize86, align 1
  %conv87 = zext i8 %98 to i32
  %idx.ext88 = sext i32 %conv87 to i64
  %add.ptr89 = getelementptr inbounds %struct.lua_TValue* %96, i64 %idx.ext88
  %99 = load %struct.CallInfo** %ci, align 8
  %top90 = getelementptr inbounds %struct.CallInfo* %99, i32 0, i32 1
  store %struct.lua_TValue* %add.ptr89, %struct.lua_TValue** %top90, align 8
  %100 = load %struct.Proto** %p, align 8
  %code = getelementptr inbounds %struct.Proto* %100, i32 0, i32 4
  %101 = load i32** %code, align 8
  %102 = load %struct.CallInfo** %ci, align 8
  %u91 = getelementptr inbounds %struct.CallInfo* %102, i32 0, i32 7
  %l92 = bitcast %union.anon.2* %u91 to %struct.anon.3*
  %savedpc = getelementptr inbounds %struct.anon.3* %l92, i32 0, i32 1
  store i32* %101, i32** %savedpc, align 8
  %103 = load %struct.CallInfo** %ci, align 8
  %callstatus93 = getelementptr inbounds %struct.CallInfo* %103, i32 0, i32 5
  store i8 1, i8* %callstatus93, align 1
  %104 = load %struct.CallInfo** %ci, align 8
  %top94 = getelementptr inbounds %struct.CallInfo* %104, i32 0, i32 1
  %105 = load %struct.lua_TValue** %top94, align 8
  %106 = load %struct.lua_State** %L.addr, align 8
  %top95 = getelementptr inbounds %struct.lua_State* %106, i32 0, i32 4
  store %struct.lua_TValue* %105, %struct.lua_TValue** %top95, align 8
  %107 = load %struct.lua_State** %L.addr, align 8
  %l_G96 = getelementptr inbounds %struct.lua_State* %107, i32 0, i32 5
  %108 = load %struct.global_State** %l_G96, align 8
  %GCdebt97 = getelementptr inbounds %struct.global_State* %108, i32 0, i32 3
  %109 = load i64* %GCdebt97, align 8
  %cmp98 = icmp sgt i64 %109, 0
  br i1 %cmp98, label %if.then100, label %if.end101

if.then100:                                       ; preds = %cond.end78
  %110 = load %struct.lua_State** %L.addr, align 8
  call void @luaC_step(%struct.lua_State* %110)
  br label %if.end101

if.end101:                                        ; preds = %if.then100, %cond.end78
  %111 = load %struct.lua_State** %L.addr, align 8
  %hookmask102 = getelementptr inbounds %struct.lua_State* %111, i32 0, i32 13
  %112 = load i8* %hookmask102, align 1
  %conv103 = zext i8 %112 to i32
  %and104 = and i32 %conv103, 1
  %tobool105 = icmp ne i32 %and104, 0
  br i1 %tobool105, label %if.then106, label %if.end107

if.then106:                                       ; preds = %if.end101
  %113 = load %struct.lua_State** %L.addr, align 8
  %114 = load %struct.CallInfo** %ci, align 8
  call void @callhook(%struct.lua_State* %113, %struct.CallInfo* %114)
  br label %if.end107

if.end107:                                        ; preds = %if.then106, %if.end101
  store i32 0, i32* %retval
  br label %return

sw.default:                                       ; preds = %entry
  %115 = load %struct.lua_State** %L.addr, align 8
  %116 = load %struct.lua_TValue** %func.addr, align 8
  %call108 = call %struct.lua_TValue* @tryfuncTM(%struct.lua_State* %115, %struct.lua_TValue* %116)
  store %struct.lua_TValue* %call108, %struct.lua_TValue** %func.addr, align 8
  %117 = load %struct.lua_State** %L.addr, align 8
  %118 = load %struct.lua_TValue** %func.addr, align 8
  %119 = load i32* %nresults.addr, align 4
  %call109 = call i32 @luaD_precall(%struct.lua_State* %117, %struct.lua_TValue* %118, i32 %119)
  store i32 %call109, i32* %retval
  br label %return

return:                                           ; preds = %sw.default, %if.end107, %if.end26
  %120 = load i32* %retval
  ret i32 %120
}

; Function Attrs: nounwind uwtable
define hidden i32 @luaD_poscall(%struct.lua_State* %L, %struct.lua_TValue* %firstResult) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %firstResult.addr = alloca %struct.lua_TValue*, align 8
  %res = alloca %struct.lua_TValue*, align 8
  %wanted = alloca i32, align 4
  %i = alloca i32, align 4
  %ci = alloca %struct.CallInfo*, align 8
  %fr = alloca i64, align 8
  %io2 = alloca %struct.lua_TValue*, align 8
  %io1 = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.lua_TValue* %firstResult, %struct.lua_TValue** %firstResult.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %ci1 = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 6
  %1 = load %struct.CallInfo** %ci1, align 8
  store %struct.CallInfo* %1, %struct.CallInfo** %ci, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %hookmask = getelementptr inbounds %struct.lua_State* %2, i32 0, i32 13
  %3 = load i8* %hookmask, align 1
  %conv = zext i8 %3 to i32
  %and = and i32 %conv, 6
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end8

if.then:                                          ; preds = %entry
  %4 = load %struct.lua_State** %L.addr, align 8
  %hookmask2 = getelementptr inbounds %struct.lua_State* %4, i32 0, i32 13
  %5 = load i8* %hookmask2, align 1
  %conv3 = zext i8 %5 to i32
  %and4 = and i32 %conv3, 2
  %tobool5 = icmp ne i32 %and4, 0
  br i1 %tobool5, label %if.then6, label %if.end

if.then6:                                         ; preds = %if.then
  %6 = load %struct.lua_TValue** %firstResult.addr, align 8
  %7 = bitcast %struct.lua_TValue* %6 to i8*
  %8 = load %struct.lua_State** %L.addr, align 8
  %stack = getelementptr inbounds %struct.lua_State* %8, i32 0, i32 9
  %9 = load %struct.lua_TValue** %stack, align 8
  %10 = bitcast %struct.lua_TValue* %9 to i8*
  %sub.ptr.lhs.cast = ptrtoint i8* %7 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %10 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, i64* %fr, align 8
  %11 = load %struct.lua_State** %L.addr, align 8
  call void @luaD_hook(%struct.lua_State* %11, i32 1, i32 -1)
  %12 = load %struct.lua_State** %L.addr, align 8
  %stack7 = getelementptr inbounds %struct.lua_State* %12, i32 0, i32 9
  %13 = load %struct.lua_TValue** %stack7, align 8
  %14 = bitcast %struct.lua_TValue* %13 to i8*
  %15 = load i64* %fr, align 8
  %add.ptr = getelementptr inbounds i8* %14, i64 %15
  %16 = bitcast i8* %add.ptr to %struct.lua_TValue*
  store %struct.lua_TValue* %16, %struct.lua_TValue** %firstResult.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then6, %if.then
  %17 = load %struct.CallInfo** %ci, align 8
  %previous = getelementptr inbounds %struct.CallInfo* %17, i32 0, i32 2
  %18 = load %struct.CallInfo** %previous, align 8
  %u = getelementptr inbounds %struct.CallInfo* %18, i32 0, i32 7
  %l = bitcast %union.anon.2* %u to %struct.anon.3*
  %savedpc = getelementptr inbounds %struct.anon.3* %l, i32 0, i32 1
  %19 = load i32** %savedpc, align 8
  %20 = load %struct.lua_State** %L.addr, align 8
  %oldpc = getelementptr inbounds %struct.lua_State* %20, i32 0, i32 7
  store i32* %19, i32** %oldpc, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.end, %entry
  %21 = load %struct.CallInfo** %ci, align 8
  %func = getelementptr inbounds %struct.CallInfo* %21, i32 0, i32 0
  %22 = load %struct.lua_TValue** %func, align 8
  store %struct.lua_TValue* %22, %struct.lua_TValue** %res, align 8
  %23 = load %struct.CallInfo** %ci, align 8
  %nresults = getelementptr inbounds %struct.CallInfo* %23, i32 0, i32 4
  %24 = load i16* %nresults, align 2
  %conv9 = sext i16 %24 to i32
  store i32 %conv9, i32* %wanted, align 4
  %25 = load %struct.CallInfo** %ci, align 8
  %previous10 = getelementptr inbounds %struct.CallInfo* %25, i32 0, i32 2
  %26 = load %struct.CallInfo** %previous10, align 8
  store %struct.CallInfo* %26, %struct.CallInfo** %ci, align 8
  %27 = load %struct.lua_State** %L.addr, align 8
  %ci11 = getelementptr inbounds %struct.lua_State* %27, i32 0, i32 6
  store %struct.CallInfo* %26, %struct.CallInfo** %ci11, align 8
  %28 = load i32* %wanted, align 4
  store i32 %28, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end8
  %29 = load i32* %i, align 4
  %cmp = icmp ne i32 %29, 0
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %30 = load %struct.lua_TValue** %firstResult.addr, align 8
  %31 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %31, i32 0, i32 4
  %32 = load %struct.lua_TValue** %top, align 8
  %cmp13 = icmp ult %struct.lua_TValue* %30, %32
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %33 = phi i1 [ false, %for.cond ], [ %cmp13, %land.rhs ]
  br i1 %33, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %34 = load %struct.lua_TValue** %firstResult.addr, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %34, i32 1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %firstResult.addr, align 8
  store %struct.lua_TValue* %34, %struct.lua_TValue** %io2, align 8
  %35 = load %struct.lua_TValue** %res, align 8
  %incdec.ptr15 = getelementptr inbounds %struct.lua_TValue* %35, i32 1
  store %struct.lua_TValue* %incdec.ptr15, %struct.lua_TValue** %res, align 8
  store %struct.lua_TValue* %35, %struct.lua_TValue** %io1, align 8
  %36 = load %struct.lua_TValue** %io1, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %36, i32 0, i32 0
  %37 = load %struct.lua_TValue** %io2, align 8
  %value_16 = getelementptr inbounds %struct.lua_TValue* %37, i32 0, i32 0
  %38 = bitcast %union.Value* %value_ to i8*
  %39 = bitcast %union.Value* %value_16 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %38, i8* %39, i64 8, i32 8, i1 false)
  %40 = load %struct.lua_TValue** %io2, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %40, i32 0, i32 1
  %41 = load i32* %tt_, align 4
  %42 = load %struct.lua_TValue** %io1, align 8
  %tt_17 = getelementptr inbounds %struct.lua_TValue* %42, i32 0, i32 1
  store i32 %41, i32* %tt_17, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %43 = load i32* %i, align 4
  %dec = add nsw i32 %43, -1
  store i32 %dec, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %land.end
  br label %while.cond

while.cond:                                       ; preds = %while.body, %for.end
  %44 = load i32* %i, align 4
  %dec18 = add nsw i32 %44, -1
  store i32 %dec18, i32* %i, align 4
  %cmp19 = icmp sgt i32 %44, 0
  br i1 %cmp19, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %45 = load %struct.lua_TValue** %res, align 8
  %incdec.ptr21 = getelementptr inbounds %struct.lua_TValue* %45, i32 1
  store %struct.lua_TValue* %incdec.ptr21, %struct.lua_TValue** %res, align 8
  %tt_22 = getelementptr inbounds %struct.lua_TValue* %45, i32 0, i32 1
  store i32 0, i32* %tt_22, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %46 = load %struct.lua_TValue** %res, align 8
  %47 = load %struct.lua_State** %L.addr, align 8
  %top23 = getelementptr inbounds %struct.lua_State* %47, i32 0, i32 4
  store %struct.lua_TValue* %46, %struct.lua_TValue** %top23, align 8
  %48 = load i32* %wanted, align 4
  %sub = sub nsw i32 %48, -1
  ret i32 %sub
}

; Function Attrs: nounwind uwtable
define hidden void @luaD_call(%struct.lua_State* %L, %struct.lua_TValue* %func, i32 %nResults, i32 %allowyield) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %func.addr = alloca %struct.lua_TValue*, align 8
  %nResults.addr = alloca i32, align 4
  %allowyield.addr = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.lua_TValue* %func, %struct.lua_TValue** %func.addr, align 8
  store i32 %nResults, i32* %nResults.addr, align 4
  store i32 %allowyield, i32* %allowyield.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %nCcalls = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 12
  %1 = load i16* %nCcalls, align 2
  %inc = add i16 %1, 1
  store i16 %inc, i16* %nCcalls, align 2
  %conv = zext i16 %inc to i32
  %cmp = icmp sge i32 %conv, 200
  br i1 %cmp, label %if.then, label %if.end13

if.then:                                          ; preds = %entry
  %2 = load %struct.lua_State** %L.addr, align 8
  %nCcalls2 = getelementptr inbounds %struct.lua_State* %2, i32 0, i32 12
  %3 = load i16* %nCcalls2, align 2
  %conv3 = zext i16 %3 to i32
  %cmp4 = icmp eq i32 %conv3, 200
  br i1 %cmp4, label %if.then6, label %if.else

if.then6:                                         ; preds = %if.then
  %4 = load %struct.lua_State** %L.addr, align 8
  call void (%struct.lua_State*, i8*, ...)* @luaG_runerror(%struct.lua_State* %4, i8* getelementptr inbounds ([17 x i8]* @.str1238, i32 0, i32 0)) #9
  unreachable

if.else:                                          ; preds = %if.then
  %5 = load %struct.lua_State** %L.addr, align 8
  %nCcalls7 = getelementptr inbounds %struct.lua_State* %5, i32 0, i32 12
  %6 = load i16* %nCcalls7, align 2
  %conv8 = zext i16 %6 to i32
  %cmp9 = icmp sge i32 %conv8, 225
  br i1 %cmp9, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.else
  %7 = load %struct.lua_State** %L.addr, align 8
  call void @luaD_throw(%struct.lua_State* %7, i32 6) #9
  unreachable

if.end:                                           ; preds = %if.else
  br label %if.end12

if.end12:                                         ; preds = %if.end
  br label %if.end13

if.end13:                                         ; preds = %if.end12, %entry
  %8 = load i32* %allowyield.addr, align 4
  %tobool = icmp ne i32 %8, 0
  br i1 %tobool, label %if.end16, label %if.then14

if.then14:                                        ; preds = %if.end13
  %9 = load %struct.lua_State** %L.addr, align 8
  %nny = getelementptr inbounds %struct.lua_State* %9, i32 0, i32 11
  %10 = load i16* %nny, align 2
  %inc15 = add i16 %10, 1
  store i16 %inc15, i16* %nny, align 2
  br label %if.end16

if.end16:                                         ; preds = %if.then14, %if.end13
  %11 = load %struct.lua_State** %L.addr, align 8
  %12 = load %struct.lua_TValue** %func.addr, align 8
  %13 = load i32* %nResults.addr, align 4
  %call = call i32 @luaD_precall(%struct.lua_State* %11, %struct.lua_TValue* %12, i32 %13)
  %tobool17 = icmp ne i32 %call, 0
  br i1 %tobool17, label %if.end19, label %if.then18

if.then18:                                        ; preds = %if.end16
  %14 = load %struct.lua_State** %L.addr, align 8
  call void bitcast (void (%struct.lua_State.364*)* @luaV_execute to void (%struct.lua_State*)*)(%struct.lua_State* %14)
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.end16
  %15 = load i32* %allowyield.addr, align 4
  %tobool20 = icmp ne i32 %15, 0
  br i1 %tobool20, label %if.end23, label %if.then21

if.then21:                                        ; preds = %if.end19
  %16 = load %struct.lua_State** %L.addr, align 8
  %nny22 = getelementptr inbounds %struct.lua_State* %16, i32 0, i32 11
  %17 = load i16* %nny22, align 2
  %dec = add i16 %17, -1
  store i16 %dec, i16* %nny22, align 2
  br label %if.end23

if.end23:                                         ; preds = %if.then21, %if.end19
  %18 = load %struct.lua_State** %L.addr, align 8
  %nCcalls24 = getelementptr inbounds %struct.lua_State* %18, i32 0, i32 12
  %19 = load i16* %nCcalls24, align 2
  %dec25 = add i16 %19, -1
  store i16 %dec25, i16* %nCcalls24, align 2
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @lua_resume(%struct.lua_State* %L, %struct.lua_State* %from, i32 %nargs) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %from.addr = alloca %struct.lua_State*, align 8
  %nargs.addr = alloca i32, align 4
  %status = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.lua_State* %from, %struct.lua_State** %from.addr, align 8
  store i32 %nargs, i32* %nargs.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load %struct.lua_State** %from.addr, align 8
  %tobool = icmp ne %struct.lua_State* %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load %struct.lua_State** %from.addr, align 8
  %nCcalls = getelementptr inbounds %struct.lua_State* %2, i32 0, i32 12
  %3 = load i16* %nCcalls, align 2
  %conv = zext i16 %3 to i32
  %add = add nsw i32 %conv, 1
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %add, %cond.true ], [ 1, %cond.false ]
  %conv1 = trunc i32 %cond to i16
  %4 = load %struct.lua_State** %L.addr, align 8
  %nCcalls2 = getelementptr inbounds %struct.lua_State* %4, i32 0, i32 12
  store i16 %conv1, i16* %nCcalls2, align 2
  %5 = load %struct.lua_State** %L.addr, align 8
  %nny = getelementptr inbounds %struct.lua_State* %5, i32 0, i32 11
  store i16 0, i16* %nny, align 2
  %6 = load %struct.lua_State** %L.addr, align 8
  %7 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %7, i32 0, i32 4
  %8 = load %struct.lua_TValue** %top, align 8
  %9 = load i32* %nargs.addr, align 4
  %idx.ext = sext i32 %9 to i64
  %idx.neg = sub i64 0, %idx.ext
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %8, i64 %idx.neg
  %10 = bitcast %struct.lua_TValue* %add.ptr to i8*
  %call = call i32 @luaD_rawrunprotected(%struct.lua_State* %6, void (%struct.lua_State*, i8*)* @resume, i8* %10)
  store i32 %call, i32* %status, align 4
  %11 = load i32* %status, align 4
  %cmp = icmp eq i32 %11, -1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %cond.end
  store i32 2, i32* %status, align 4
  br label %if.end18

if.else:                                          ; preds = %cond.end
  br label %while.cond

while.cond:                                       ; preds = %if.end, %if.else
  %12 = load i32* %status, align 4
  %cmp4 = icmp ne i32 %12, 0
  br i1 %cmp4, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %13 = load i32* %status, align 4
  %cmp6 = icmp ne i32 %13, 1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %14 = phi i1 [ false, %while.cond ], [ %cmp6, %land.rhs ]
  br i1 %14, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %15 = load %struct.lua_State** %L.addr, align 8
  %16 = load i32* %status, align 4
  %call8 = call i32 @recover(%struct.lua_State* %15, i32 %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.then10, label %if.else12

if.then10:                                        ; preds = %while.body
  %17 = load %struct.lua_State** %L.addr, align 8
  %call11 = call i32 @luaD_rawrunprotected(%struct.lua_State* %17, void (%struct.lua_State*, i8*)* @unroll, i8* null)
  store i32 %call11, i32* %status, align 4
  br label %if.end

if.else12:                                        ; preds = %while.body
  %18 = load i32* %status, align 4
  %conv13 = trunc i32 %18 to i8
  %19 = load %struct.lua_State** %L.addr, align 8
  %status14 = getelementptr inbounds %struct.lua_State* %19, i32 0, i32 3
  store i8 %conv13, i8* %status14, align 1
  %20 = load %struct.lua_State** %L.addr, align 8
  %21 = load i32* %status, align 4
  %22 = load %struct.lua_State** %L.addr, align 8
  %top15 = getelementptr inbounds %struct.lua_State* %22, i32 0, i32 4
  %23 = load %struct.lua_TValue** %top15, align 8
  call void @seterrorobj(%struct.lua_State* %20, i32 %21, %struct.lua_TValue* %23)
  %24 = load %struct.lua_State** %L.addr, align 8
  %top16 = getelementptr inbounds %struct.lua_State* %24, i32 0, i32 4
  %25 = load %struct.lua_TValue** %top16, align 8
  %26 = load %struct.lua_State** %L.addr, align 8
  %ci = getelementptr inbounds %struct.lua_State* %26, i32 0, i32 6
  %27 = load %struct.CallInfo** %ci, align 8
  %top17 = getelementptr inbounds %struct.CallInfo* %27, i32 0, i32 1
  store %struct.lua_TValue* %25, %struct.lua_TValue** %top17, align 8
  br label %while.end

if.end:                                           ; preds = %if.then10
  br label %while.cond

while.end:                                        ; preds = %if.else12, %land.end
  br label %if.end18

if.end18:                                         ; preds = %while.end, %if.then
  %28 = load %struct.lua_State** %L.addr, align 8
  %nny19 = getelementptr inbounds %struct.lua_State* %28, i32 0, i32 11
  store i16 1, i16* %nny19, align 2
  %29 = load %struct.lua_State** %L.addr, align 8
  %nCcalls20 = getelementptr inbounds %struct.lua_State* %29, i32 0, i32 12
  %30 = load i16* %nCcalls20, align 2
  %dec = add i16 %30, -1
  store i16 %dec, i16* %nCcalls20, align 2
  %31 = load i32* %status, align 4
  ret i32 %31
}

; Function Attrs: nounwind uwtable
define i32 @lua_yieldk(%struct.lua_State* %L, i32 %nresults, i32 %ctx, i32 (%struct.lua_State*)* %k) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %nresults.addr = alloca i32, align 4
  %ctx.addr = alloca i32, align 4
  %k.addr = alloca i32 (%struct.lua_State*)*, align 8
  %ci = alloca %struct.CallInfo*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %nresults, i32* %nresults.addr, align 4
  store i32 %ctx, i32* %ctx.addr, align 4
  store i32 (%struct.lua_State*)* %k, i32 (%struct.lua_State*)** %k.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %ci1 = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 6
  %1 = load %struct.CallInfo** %ci1, align 8
  store %struct.CallInfo* %1, %struct.CallInfo** %ci, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load %struct.lua_State** %L.addr, align 8
  %nny = getelementptr inbounds %struct.lua_State* %3, i32 0, i32 11
  %4 = load i16* %nny, align 2
  %conv = zext i16 %4 to i32
  %cmp = icmp sgt i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load %struct.lua_State** %L.addr, align 8
  %6 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %6, i32 0, i32 5
  %7 = load %struct.global_State** %l_G, align 8
  %mainthread = getelementptr inbounds %struct.global_State* %7, i32 0, i32 30
  %8 = load %struct.lua_State** %mainthread, align 8
  %cmp3 = icmp ne %struct.lua_State* %5, %8
  br i1 %cmp3, label %if.then5, label %if.else

if.then5:                                         ; preds = %if.then
  %9 = load %struct.lua_State** %L.addr, align 8
  call void (%struct.lua_State*, i8*, ...)* @luaG_runerror(%struct.lua_State* %9, i8* getelementptr inbounds ([42 x i8]* @.str2239, i32 0, i32 0)) #9
  unreachable

if.else:                                          ; preds = %if.then
  %10 = load %struct.lua_State** %L.addr, align 8
  call void (%struct.lua_State*, i8*, ...)* @luaG_runerror(%struct.lua_State* %10, i8* getelementptr inbounds ([42 x i8]* @.str3240, i32 0, i32 0)) #9
  unreachable

if.end:                                           ; preds = %entry
  %11 = load %struct.lua_State** %L.addr, align 8
  %status = getelementptr inbounds %struct.lua_State* %11, i32 0, i32 3
  store i8 1, i8* %status, align 1
  %12 = load %struct.CallInfo** %ci, align 8
  %func = getelementptr inbounds %struct.CallInfo* %12, i32 0, i32 0
  %13 = load %struct.lua_TValue** %func, align 8
  %14 = bitcast %struct.lua_TValue* %13 to i8*
  %15 = load %struct.lua_State** %L.addr, align 8
  %stack = getelementptr inbounds %struct.lua_State* %15, i32 0, i32 9
  %16 = load %struct.lua_TValue** %stack, align 8
  %17 = bitcast %struct.lua_TValue* %16 to i8*
  %sub.ptr.lhs.cast = ptrtoint i8* %14 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %17 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %18 = load %struct.CallInfo** %ci, align 8
  %extra = getelementptr inbounds %struct.CallInfo* %18, i32 0, i32 6
  store i64 %sub.ptr.sub, i64* %extra, align 8
  %19 = load %struct.CallInfo** %ci, align 8
  %callstatus = getelementptr inbounds %struct.CallInfo* %19, i32 0, i32 5
  %20 = load i8* %callstatus, align 1
  %conv6 = zext i8 %20 to i32
  %and = and i32 %conv6, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then7, label %if.else8

if.then7:                                         ; preds = %if.end
  br label %if.end19

if.else8:                                         ; preds = %if.end
  %21 = load i32 (%struct.lua_State*)** %k.addr, align 8
  %22 = load %struct.CallInfo** %ci, align 8
  %u = getelementptr inbounds %struct.CallInfo* %22, i32 0, i32 7
  %c = bitcast %union.anon.2* %u to %struct.anon.4*
  %k9 = getelementptr inbounds %struct.anon.4* %c, i32 0, i32 1
  store i32 (%struct.lua_State*)* %21, i32 (%struct.lua_State*)** %k9, align 8
  %cmp10 = icmp ne i32 (%struct.lua_State*)* %21, null
  br i1 %cmp10, label %if.then12, label %if.end16

if.then12:                                        ; preds = %if.else8
  %23 = load i32* %ctx.addr, align 4
  %24 = load %struct.CallInfo** %ci, align 8
  %u13 = getelementptr inbounds %struct.CallInfo* %24, i32 0, i32 7
  %c14 = bitcast %union.anon.2* %u13 to %struct.anon.4*
  %ctx15 = getelementptr inbounds %struct.anon.4* %c14, i32 0, i32 0
  store i32 %23, i32* %ctx15, align 4
  br label %if.end16

if.end16:                                         ; preds = %if.then12, %if.else8
  %25 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %25, i32 0, i32 4
  %26 = load %struct.lua_TValue** %top, align 8
  %27 = load i32* %nresults.addr, align 4
  %idx.ext = sext i32 %27 to i64
  %idx.neg = sub i64 0, %idx.ext
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %26, i64 %idx.neg
  %add.ptr17 = getelementptr inbounds %struct.lua_TValue* %add.ptr, i64 -1
  %28 = load %struct.CallInfo** %ci, align 8
  %func18 = getelementptr inbounds %struct.CallInfo* %28, i32 0, i32 0
  store %struct.lua_TValue* %add.ptr17, %struct.lua_TValue** %func18, align 8
  %29 = load %struct.lua_State** %L.addr, align 8
  call void @luaD_throw(%struct.lua_State* %29, i32 1) #9
  unreachable

if.end19:                                         ; preds = %if.then7
  ret i32 0
}

; Function Attrs: nounwind uwtable
define hidden i32 @luaD_pcall(%struct.lua_State* %L, void (%struct.lua_State*, i8*)* %func, i8* %u, i64 %old_top, i64 %ef) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %func.addr = alloca void (%struct.lua_State*, i8*)*, align 8
  %u.addr = alloca i8*, align 8
  %old_top.addr = alloca i64, align 8
  %ef.addr = alloca i64, align 8
  %status = alloca i32, align 4
  %old_ci = alloca %struct.CallInfo*, align 8
  %old_allowhooks = alloca i8, align 1
  %old_nny = alloca i16, align 2
  %old_errfunc = alloca i64, align 8
  %oldtop = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store void (%struct.lua_State*, i8*)* %func, void (%struct.lua_State*, i8*)** %func.addr, align 8
  store i8* %u, i8** %u.addr, align 8
  store i64 %old_top, i64* %old_top.addr, align 8
  store i64 %ef, i64* %ef.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %ci = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 6
  %1 = load %struct.CallInfo** %ci, align 8
  store %struct.CallInfo* %1, %struct.CallInfo** %old_ci, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %allowhook = getelementptr inbounds %struct.lua_State* %2, i32 0, i32 14
  %3 = load i8* %allowhook, align 1
  store i8 %3, i8* %old_allowhooks, align 1
  %4 = load %struct.lua_State** %L.addr, align 8
  %nny = getelementptr inbounds %struct.lua_State* %4, i32 0, i32 11
  %5 = load i16* %nny, align 2
  store i16 %5, i16* %old_nny, align 2
  %6 = load %struct.lua_State** %L.addr, align 8
  %errfunc = getelementptr inbounds %struct.lua_State* %6, i32 0, i32 21
  %7 = load i64* %errfunc, align 8
  store i64 %7, i64* %old_errfunc, align 8
  %8 = load i64* %ef.addr, align 8
  %9 = load %struct.lua_State** %L.addr, align 8
  %errfunc1 = getelementptr inbounds %struct.lua_State* %9, i32 0, i32 21
  store i64 %8, i64* %errfunc1, align 8
  %10 = load %struct.lua_State** %L.addr, align 8
  %11 = load void (%struct.lua_State*, i8*)** %func.addr, align 8
  %12 = load i8** %u.addr, align 8
  %call = call i32 @luaD_rawrunprotected(%struct.lua_State* %10, void (%struct.lua_State*, i8*)* %11, i8* %12)
  store i32 %call, i32* %status, align 4
  %13 = load i32* %status, align 4
  %cmp = icmp ne i32 %13, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %14 = load %struct.lua_State** %L.addr, align 8
  %stack = getelementptr inbounds %struct.lua_State* %14, i32 0, i32 9
  %15 = load %struct.lua_TValue** %stack, align 8
  %16 = bitcast %struct.lua_TValue* %15 to i8*
  %17 = load i64* %old_top.addr, align 8
  %add.ptr = getelementptr inbounds i8* %16, i64 %17
  %18 = bitcast i8* %add.ptr to %struct.lua_TValue*
  store %struct.lua_TValue* %18, %struct.lua_TValue** %oldtop, align 8
  %19 = load %struct.lua_State** %L.addr, align 8
  %20 = load %struct.lua_TValue** %oldtop, align 8
  call void bitcast (void (%struct.lua_State.154*, %struct.lua_TValue.137*)* @luaF_close to void (%struct.lua_State*, %struct.lua_TValue*)*)(%struct.lua_State* %19, %struct.lua_TValue* %20)
  %21 = load %struct.lua_State** %L.addr, align 8
  %22 = load i32* %status, align 4
  %23 = load %struct.lua_TValue** %oldtop, align 8
  call void @seterrorobj(%struct.lua_State* %21, i32 %22, %struct.lua_TValue* %23)
  %24 = load %struct.CallInfo** %old_ci, align 8
  %25 = load %struct.lua_State** %L.addr, align 8
  %ci2 = getelementptr inbounds %struct.lua_State* %25, i32 0, i32 6
  store %struct.CallInfo* %24, %struct.CallInfo** %ci2, align 8
  %26 = load i8* %old_allowhooks, align 1
  %27 = load %struct.lua_State** %L.addr, align 8
  %allowhook3 = getelementptr inbounds %struct.lua_State* %27, i32 0, i32 14
  store i8 %26, i8* %allowhook3, align 1
  %28 = load i16* %old_nny, align 2
  %29 = load %struct.lua_State** %L.addr, align 8
  %nny4 = getelementptr inbounds %struct.lua_State* %29, i32 0, i32 11
  store i16 %28, i16* %nny4, align 2
  %30 = load %struct.lua_State** %L.addr, align 8
  call void @luaD_shrinkstack(%struct.lua_State* %30)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %31 = load i64* %old_errfunc, align 8
  %32 = load %struct.lua_State** %L.addr, align 8
  %errfunc5 = getelementptr inbounds %struct.lua_State* %32, i32 0, i32 21
  store i64 %31, i64* %errfunc5, align 8
  %33 = load i32* %status, align 4
  ret i32 %33
}

; Function Attrs: nounwind uwtable
define hidden i32 @luaD_protectedparser(%struct.lua_State* %L, %struct.Zio* %z, i8* %name, i8* %mode) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %z.addr = alloca %struct.Zio*, align 8
  %name.addr = alloca i8*, align 8
  %mode.addr = alloca i8*, align 8
  %p = alloca %struct.SParser, align 8
  %status = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.Zio* %z, %struct.Zio** %z.addr, align 8
  store i8* %name, i8** %name.addr, align 8
  store i8* %mode, i8** %mode.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %nny = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 11
  %1 = load i16* %nny, align 2
  %inc = add i16 %1, 1
  store i16 %inc, i16* %nny, align 2
  %2 = load %struct.Zio** %z.addr, align 8
  %z1 = getelementptr inbounds %struct.SParser* %p, i32 0, i32 0
  store %struct.Zio* %2, %struct.Zio** %z1, align 8
  %3 = load i8** %name.addr, align 8
  %name2 = getelementptr inbounds %struct.SParser* %p, i32 0, i32 4
  store i8* %3, i8** %name2, align 8
  %4 = load i8** %mode.addr, align 8
  %mode3 = getelementptr inbounds %struct.SParser* %p, i32 0, i32 3
  store i8* %4, i8** %mode3, align 8
  %dyd = getelementptr inbounds %struct.SParser* %p, i32 0, i32 2
  %actvar = getelementptr inbounds %struct.Dyndata.107* %dyd, i32 0, i32 0
  %arr = getelementptr inbounds %struct.anon.6* %actvar, i32 0, i32 0
  store %struct.Vardesc* null, %struct.Vardesc** %arr, align 8
  %dyd4 = getelementptr inbounds %struct.SParser* %p, i32 0, i32 2
  %actvar5 = getelementptr inbounds %struct.Dyndata.107* %dyd4, i32 0, i32 0
  %size = getelementptr inbounds %struct.anon.6* %actvar5, i32 0, i32 2
  store i32 0, i32* %size, align 4
  %dyd6 = getelementptr inbounds %struct.SParser* %p, i32 0, i32 2
  %gt = getelementptr inbounds %struct.Dyndata.107* %dyd6, i32 0, i32 1
  %arr7 = getelementptr inbounds %struct.Labellist.106* %gt, i32 0, i32 0
  store %struct.Labeldesc.105* null, %struct.Labeldesc.105** %arr7, align 8
  %dyd8 = getelementptr inbounds %struct.SParser* %p, i32 0, i32 2
  %gt9 = getelementptr inbounds %struct.Dyndata.107* %dyd8, i32 0, i32 1
  %size10 = getelementptr inbounds %struct.Labellist.106* %gt9, i32 0, i32 2
  store i32 0, i32* %size10, align 4
  %dyd11 = getelementptr inbounds %struct.SParser* %p, i32 0, i32 2
  %label = getelementptr inbounds %struct.Dyndata.107* %dyd11, i32 0, i32 2
  %arr12 = getelementptr inbounds %struct.Labellist.106* %label, i32 0, i32 0
  store %struct.Labeldesc.105* null, %struct.Labeldesc.105** %arr12, align 8
  %dyd13 = getelementptr inbounds %struct.SParser* %p, i32 0, i32 2
  %label14 = getelementptr inbounds %struct.Dyndata.107* %dyd13, i32 0, i32 2
  %size15 = getelementptr inbounds %struct.Labellist.106* %label14, i32 0, i32 2
  store i32 0, i32* %size15, align 4
  %buff = getelementptr inbounds %struct.SParser* %p, i32 0, i32 1
  %buffer = getelementptr inbounds %struct.Mbuffer* %buff, i32 0, i32 0
  store i8* null, i8** %buffer, align 8
  %buff16 = getelementptr inbounds %struct.SParser* %p, i32 0, i32 1
  %buffsize = getelementptr inbounds %struct.Mbuffer* %buff16, i32 0, i32 2
  store i64 0, i64* %buffsize, align 8
  %5 = load %struct.lua_State** %L.addr, align 8
  %6 = bitcast %struct.SParser* %p to i8*
  %7 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %7, i32 0, i32 4
  %8 = load %struct.lua_TValue** %top, align 8
  %9 = bitcast %struct.lua_TValue* %8 to i8*
  %10 = load %struct.lua_State** %L.addr, align 8
  %stack = getelementptr inbounds %struct.lua_State* %10, i32 0, i32 9
  %11 = load %struct.lua_TValue** %stack, align 8
  %12 = bitcast %struct.lua_TValue* %11 to i8*
  %sub.ptr.lhs.cast = ptrtoint i8* %9 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %12 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %13 = load %struct.lua_State** %L.addr, align 8
  %errfunc = getelementptr inbounds %struct.lua_State* %13, i32 0, i32 21
  %14 = load i64* %errfunc, align 8
  %call = call i32 @luaD_pcall(%struct.lua_State* %5, void (%struct.lua_State*, i8*)* @f_parser, i8* %6, i64 %sub.ptr.sub, i64 %14)
  store i32 %call, i32* %status, align 4
  %15 = load %struct.lua_State** %L.addr, align 8
  %buff17 = getelementptr inbounds %struct.SParser* %p, i32 0, i32 1
  %buffer18 = getelementptr inbounds %struct.Mbuffer* %buff17, i32 0, i32 0
  %16 = load i8** %buffer18, align 8
  %buff19 = getelementptr inbounds %struct.SParser* %p, i32 0, i32 1
  %buffsize20 = getelementptr inbounds %struct.Mbuffer* %buff19, i32 0, i32 2
  %17 = load i64* %buffsize20, align 8
  %mul = mul i64 %17, 1
  %call21 = call i8* @luaM_realloc_(%struct.lua_State* %15, i8* %16, i64 %mul, i64 0)
  %buff22 = getelementptr inbounds %struct.SParser* %p, i32 0, i32 1
  %buffer23 = getelementptr inbounds %struct.Mbuffer* %buff22, i32 0, i32 0
  store i8* %call21, i8** %buffer23, align 8
  %buff24 = getelementptr inbounds %struct.SParser* %p, i32 0, i32 1
  %buffsize25 = getelementptr inbounds %struct.Mbuffer* %buff24, i32 0, i32 2
  store i64 0, i64* %buffsize25, align 8
  %18 = load %struct.lua_State** %L.addr, align 8
  %dyd26 = getelementptr inbounds %struct.SParser* %p, i32 0, i32 2
  %actvar27 = getelementptr inbounds %struct.Dyndata.107* %dyd26, i32 0, i32 0
  %arr28 = getelementptr inbounds %struct.anon.6* %actvar27, i32 0, i32 0
  %19 = load %struct.Vardesc** %arr28, align 8
  %20 = bitcast %struct.Vardesc* %19 to i8*
  %dyd29 = getelementptr inbounds %struct.SParser* %p, i32 0, i32 2
  %actvar30 = getelementptr inbounds %struct.Dyndata.107* %dyd29, i32 0, i32 0
  %size31 = getelementptr inbounds %struct.anon.6* %actvar30, i32 0, i32 2
  %21 = load i32* %size31, align 4
  %conv = sext i32 %21 to i64
  %mul32 = mul i64 %conv, 2
  %call33 = call i8* @luaM_realloc_(%struct.lua_State* %18, i8* %20, i64 %mul32, i64 0)
  %22 = load %struct.lua_State** %L.addr, align 8
  %dyd34 = getelementptr inbounds %struct.SParser* %p, i32 0, i32 2
  %gt35 = getelementptr inbounds %struct.Dyndata.107* %dyd34, i32 0, i32 1
  %arr36 = getelementptr inbounds %struct.Labellist.106* %gt35, i32 0, i32 0
  %23 = load %struct.Labeldesc.105** %arr36, align 8
  %24 = bitcast %struct.Labeldesc.105* %23 to i8*
  %dyd37 = getelementptr inbounds %struct.SParser* %p, i32 0, i32 2
  %gt38 = getelementptr inbounds %struct.Dyndata.107* %dyd37, i32 0, i32 1
  %size39 = getelementptr inbounds %struct.Labellist.106* %gt38, i32 0, i32 2
  %25 = load i32* %size39, align 4
  %conv40 = sext i32 %25 to i64
  %mul41 = mul i64 %conv40, 24
  %call42 = call i8* @luaM_realloc_(%struct.lua_State* %22, i8* %24, i64 %mul41, i64 0)
  %26 = load %struct.lua_State** %L.addr, align 8
  %dyd43 = getelementptr inbounds %struct.SParser* %p, i32 0, i32 2
  %label44 = getelementptr inbounds %struct.Dyndata.107* %dyd43, i32 0, i32 2
  %arr45 = getelementptr inbounds %struct.Labellist.106* %label44, i32 0, i32 0
  %27 = load %struct.Labeldesc.105** %arr45, align 8
  %28 = bitcast %struct.Labeldesc.105* %27 to i8*
  %dyd46 = getelementptr inbounds %struct.SParser* %p, i32 0, i32 2
  %label47 = getelementptr inbounds %struct.Dyndata.107* %dyd46, i32 0, i32 2
  %size48 = getelementptr inbounds %struct.Labellist.106* %label47, i32 0, i32 2
  %29 = load i32* %size48, align 4
  %conv49 = sext i32 %29 to i64
  %mul50 = mul i64 %conv49, 24
  %call51 = call i8* @luaM_realloc_(%struct.lua_State* %26, i8* %28, i64 %mul50, i64 0)
  %30 = load %struct.lua_State** %L.addr, align 8
  %nny52 = getelementptr inbounds %struct.lua_State* %30, i32 0, i32 11
  %31 = load i16* %nny52, align 2
  %dec = add i16 %31, -1
  store i16 %dec, i16* %nny52, align 2
  %32 = load i32* %status, align 4
  ret i32 %32
}

; Function Attrs: nounwind uwtable
define internal void @correctstack(%struct.lua_State* %L, %struct.lua_TValue* %oldstack) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %oldstack.addr = alloca %struct.lua_TValue*, align 8
  %ci = alloca %struct.CallInfo*, align 8
  %up = alloca %union.GCObject*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.lua_TValue* %oldstack, %struct.lua_TValue** %oldstack.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 4
  %1 = load %struct.lua_TValue** %top, align 8
  %2 = load %struct.lua_TValue** %oldstack.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.lua_TValue* %1 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.lua_TValue* %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 16
  %3 = load %struct.lua_State** %L.addr, align 8
  %stack = getelementptr inbounds %struct.lua_State* %3, i32 0, i32 9
  %4 = load %struct.lua_TValue** %stack, align 8
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %4, i64 %sub.ptr.div
  %5 = load %struct.lua_State** %L.addr, align 8
  %top1 = getelementptr inbounds %struct.lua_State* %5, i32 0, i32 4
  store %struct.lua_TValue* %add.ptr, %struct.lua_TValue** %top1, align 8
  %6 = load %struct.lua_State** %L.addr, align 8
  %openupval = getelementptr inbounds %struct.lua_State* %6, i32 0, i32 18
  %7 = load %union.GCObject** %openupval, align 8
  store %union.GCObject* %7, %union.GCObject** %up, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load %union.GCObject** %up, align 8
  %cmp = icmp ne %union.GCObject* %8, null
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load %union.GCObject** %up, align 8
  %uv = bitcast %union.GCObject* %9 to %struct.UpVal*
  %v = getelementptr inbounds %struct.UpVal* %uv, i32 0, i32 3
  %10 = load %struct.lua_TValue** %v, align 8
  %11 = load %struct.lua_TValue** %oldstack.addr, align 8
  %sub.ptr.lhs.cast2 = ptrtoint %struct.lua_TValue* %10 to i64
  %sub.ptr.rhs.cast3 = ptrtoint %struct.lua_TValue* %11 to i64
  %sub.ptr.sub4 = sub i64 %sub.ptr.lhs.cast2, %sub.ptr.rhs.cast3
  %sub.ptr.div5 = sdiv exact i64 %sub.ptr.sub4, 16
  %12 = load %struct.lua_State** %L.addr, align 8
  %stack6 = getelementptr inbounds %struct.lua_State* %12, i32 0, i32 9
  %13 = load %struct.lua_TValue** %stack6, align 8
  %add.ptr7 = getelementptr inbounds %struct.lua_TValue* %13, i64 %sub.ptr.div5
  %14 = load %union.GCObject** %up, align 8
  %uv8 = bitcast %union.GCObject* %14 to %struct.UpVal*
  %v9 = getelementptr inbounds %struct.UpVal* %uv8, i32 0, i32 3
  store %struct.lua_TValue* %add.ptr7, %struct.lua_TValue** %v9, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %15 = load %union.GCObject** %up, align 8
  %gch = bitcast %union.GCObject* %15 to %struct.GCheader*
  %next = getelementptr inbounds %struct.GCheader* %gch, i32 0, i32 0
  %16 = load %union.GCObject** %next, align 8
  store %union.GCObject* %16, %union.GCObject** %up, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %17 = load %struct.lua_State** %L.addr, align 8
  %ci10 = getelementptr inbounds %struct.lua_State* %17, i32 0, i32 6
  %18 = load %struct.CallInfo** %ci10, align 8
  store %struct.CallInfo* %18, %struct.CallInfo** %ci, align 8
  br label %for.cond11

for.cond11:                                       ; preds = %for.inc38, %for.end
  %19 = load %struct.CallInfo** %ci, align 8
  %cmp12 = icmp ne %struct.CallInfo* %19, null
  br i1 %cmp12, label %for.body13, label %for.end39

for.body13:                                       ; preds = %for.cond11
  %20 = load %struct.CallInfo** %ci, align 8
  %top14 = getelementptr inbounds %struct.CallInfo* %20, i32 0, i32 1
  %21 = load %struct.lua_TValue** %top14, align 8
  %22 = load %struct.lua_TValue** %oldstack.addr, align 8
  %sub.ptr.lhs.cast15 = ptrtoint %struct.lua_TValue* %21 to i64
  %sub.ptr.rhs.cast16 = ptrtoint %struct.lua_TValue* %22 to i64
  %sub.ptr.sub17 = sub i64 %sub.ptr.lhs.cast15, %sub.ptr.rhs.cast16
  %sub.ptr.div18 = sdiv exact i64 %sub.ptr.sub17, 16
  %23 = load %struct.lua_State** %L.addr, align 8
  %stack19 = getelementptr inbounds %struct.lua_State* %23, i32 0, i32 9
  %24 = load %struct.lua_TValue** %stack19, align 8
  %add.ptr20 = getelementptr inbounds %struct.lua_TValue* %24, i64 %sub.ptr.div18
  %25 = load %struct.CallInfo** %ci, align 8
  %top21 = getelementptr inbounds %struct.CallInfo* %25, i32 0, i32 1
  store %struct.lua_TValue* %add.ptr20, %struct.lua_TValue** %top21, align 8
  %26 = load %struct.CallInfo** %ci, align 8
  %func = getelementptr inbounds %struct.CallInfo* %26, i32 0, i32 0
  %27 = load %struct.lua_TValue** %func, align 8
  %28 = load %struct.lua_TValue** %oldstack.addr, align 8
  %sub.ptr.lhs.cast22 = ptrtoint %struct.lua_TValue* %27 to i64
  %sub.ptr.rhs.cast23 = ptrtoint %struct.lua_TValue* %28 to i64
  %sub.ptr.sub24 = sub i64 %sub.ptr.lhs.cast22, %sub.ptr.rhs.cast23
  %sub.ptr.div25 = sdiv exact i64 %sub.ptr.sub24, 16
  %29 = load %struct.lua_State** %L.addr, align 8
  %stack26 = getelementptr inbounds %struct.lua_State* %29, i32 0, i32 9
  %30 = load %struct.lua_TValue** %stack26, align 8
  %add.ptr27 = getelementptr inbounds %struct.lua_TValue* %30, i64 %sub.ptr.div25
  %31 = load %struct.CallInfo** %ci, align 8
  %func28 = getelementptr inbounds %struct.CallInfo* %31, i32 0, i32 0
  store %struct.lua_TValue* %add.ptr27, %struct.lua_TValue** %func28, align 8
  %32 = load %struct.CallInfo** %ci, align 8
  %callstatus = getelementptr inbounds %struct.CallInfo* %32, i32 0, i32 5
  %33 = load i8* %callstatus, align 1
  %conv = zext i8 %33 to i32
  %and = and i32 %conv, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body13
  %34 = load %struct.CallInfo** %ci, align 8
  %u = getelementptr inbounds %struct.CallInfo* %34, i32 0, i32 7
  %l = bitcast %union.anon.2* %u to %struct.anon.3*
  %base = getelementptr inbounds %struct.anon.3* %l, i32 0, i32 0
  %35 = load %struct.lua_TValue** %base, align 8
  %36 = load %struct.lua_TValue** %oldstack.addr, align 8
  %sub.ptr.lhs.cast29 = ptrtoint %struct.lua_TValue* %35 to i64
  %sub.ptr.rhs.cast30 = ptrtoint %struct.lua_TValue* %36 to i64
  %sub.ptr.sub31 = sub i64 %sub.ptr.lhs.cast29, %sub.ptr.rhs.cast30
  %sub.ptr.div32 = sdiv exact i64 %sub.ptr.sub31, 16
  %37 = load %struct.lua_State** %L.addr, align 8
  %stack33 = getelementptr inbounds %struct.lua_State* %37, i32 0, i32 9
  %38 = load %struct.lua_TValue** %stack33, align 8
  %add.ptr34 = getelementptr inbounds %struct.lua_TValue* %38, i64 %sub.ptr.div32
  %39 = load %struct.CallInfo** %ci, align 8
  %u35 = getelementptr inbounds %struct.CallInfo* %39, i32 0, i32 7
  %l36 = bitcast %union.anon.2* %u35 to %struct.anon.3*
  %base37 = getelementptr inbounds %struct.anon.3* %l36, i32 0, i32 0
  store %struct.lua_TValue* %add.ptr34, %struct.lua_TValue** %base37, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body13
  br label %for.inc38

for.inc38:                                        ; preds = %if.end
  %40 = load %struct.CallInfo** %ci, align 8
  %previous = getelementptr inbounds %struct.CallInfo* %40, i32 0, i32 2
  %41 = load %struct.CallInfo** %previous, align 8
  store %struct.CallInfo* %41, %struct.CallInfo** %ci, align 8
  br label %for.cond11

for.end39:                                        ; preds = %for.cond11
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @stackinuse(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %ci = alloca %struct.CallInfo*, align 8
  %lim = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 4
  %1 = load %struct.lua_TValue** %top, align 8
  store %struct.lua_TValue* %1, %struct.lua_TValue** %lim, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %ci1 = getelementptr inbounds %struct.lua_State* %2, i32 0, i32 6
  %3 = load %struct.CallInfo** %ci1, align 8
  store %struct.CallInfo* %3, %struct.CallInfo** %ci, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %4 = load %struct.CallInfo** %ci, align 8
  %cmp = icmp ne %struct.CallInfo* %4, null
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load %struct.lua_TValue** %lim, align 8
  %6 = load %struct.CallInfo** %ci, align 8
  %top2 = getelementptr inbounds %struct.CallInfo* %6, i32 0, i32 1
  %7 = load %struct.lua_TValue** %top2, align 8
  %cmp3 = icmp ult %struct.lua_TValue* %5, %7
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %8 = load %struct.CallInfo** %ci, align 8
  %top4 = getelementptr inbounds %struct.CallInfo* %8, i32 0, i32 1
  %9 = load %struct.lua_TValue** %top4, align 8
  store %struct.lua_TValue* %9, %struct.lua_TValue** %lim, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %10 = load %struct.CallInfo** %ci, align 8
  %previous = getelementptr inbounds %struct.CallInfo* %10, i32 0, i32 2
  %11 = load %struct.CallInfo** %previous, align 8
  store %struct.CallInfo* %11, %struct.CallInfo** %ci, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %12 = load %struct.lua_TValue** %lim, align 8
  %13 = load %struct.lua_State** %L.addr, align 8
  %stack = getelementptr inbounds %struct.lua_State* %13, i32 0, i32 9
  %14 = load %struct.lua_TValue** %stack, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.lua_TValue* %12 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.lua_TValue* %14 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 16
  %conv = trunc i64 %sub.ptr.div to i32
  %add = add nsw i32 %conv, 1
  ret i32 %add
}

; Function Attrs: nounwind uwtable
define internal %struct.lua_TValue* @adjust_varargs(%struct.lua_State* %L, %struct.Proto* %p, i32 %actual) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %p.addr = alloca %struct.Proto*, align 8
  %actual.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %nfixargs = alloca i32, align 4
  %base = alloca %struct.lua_TValue*, align 8
  %fixed = alloca %struct.lua_TValue*, align 8
  %io2 = alloca %struct.lua_TValue*, align 8
  %io1 = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.Proto* %p, %struct.Proto** %p.addr, align 8
  store i32 %actual, i32* %actual.addr, align 4
  %0 = load %struct.Proto** %p.addr, align 8
  %numparams = getelementptr inbounds %struct.Proto* %0, i32 0, i32 20
  %1 = load i8* %numparams, align 1
  %conv = zext i8 %1 to i32
  store i32 %conv, i32* %nfixargs, align 4
  %2 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %2, i32 0, i32 4
  %3 = load %struct.lua_TValue** %top, align 8
  %4 = load i32* %actual.addr, align 4
  %idx.ext = sext i32 %4 to i64
  %idx.neg = sub i64 0, %idx.ext
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %3, i64 %idx.neg
  store %struct.lua_TValue* %add.ptr, %struct.lua_TValue** %fixed, align 8
  %5 = load %struct.lua_State** %L.addr, align 8
  %top1 = getelementptr inbounds %struct.lua_State* %5, i32 0, i32 4
  %6 = load %struct.lua_TValue** %top1, align 8
  store %struct.lua_TValue* %6, %struct.lua_TValue** %base, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %7 = load i32* %i, align 4
  %8 = load i32* %nfixargs, align 4
  %cmp = icmp slt i32 %7, %8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load %struct.lua_TValue** %fixed, align 8
  %10 = load i32* %i, align 4
  %idx.ext3 = sext i32 %10 to i64
  %add.ptr4 = getelementptr inbounds %struct.lua_TValue* %9, i64 %idx.ext3
  store %struct.lua_TValue* %add.ptr4, %struct.lua_TValue** %io2, align 8
  %11 = load %struct.lua_State** %L.addr, align 8
  %top5 = getelementptr inbounds %struct.lua_State* %11, i32 0, i32 4
  %12 = load %struct.lua_TValue** %top5, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %12, i32 1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %top5, align 8
  store %struct.lua_TValue* %12, %struct.lua_TValue** %io1, align 8
  %13 = load %struct.lua_TValue** %io1, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %13, i32 0, i32 0
  %14 = load %struct.lua_TValue** %io2, align 8
  %value_6 = getelementptr inbounds %struct.lua_TValue* %14, i32 0, i32 0
  %15 = bitcast %union.Value* %value_ to i8*
  %16 = bitcast %union.Value* %value_6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %15, i8* %16, i64 8, i32 8, i1 false)
  %17 = load %struct.lua_TValue** %io2, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %17, i32 0, i32 1
  %18 = load i32* %tt_, align 4
  %19 = load %struct.lua_TValue** %io1, align 8
  %tt_7 = getelementptr inbounds %struct.lua_TValue* %19, i32 0, i32 1
  store i32 %18, i32* %tt_7, align 4
  %20 = load %struct.lua_TValue** %fixed, align 8
  %21 = load i32* %i, align 4
  %idx.ext8 = sext i32 %21 to i64
  %add.ptr9 = getelementptr inbounds %struct.lua_TValue* %20, i64 %idx.ext8
  %tt_10 = getelementptr inbounds %struct.lua_TValue* %add.ptr9, i32 0, i32 1
  store i32 0, i32* %tt_10, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %22 = load i32* %i, align 4
  %inc = add nsw i32 %22, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %23 = load %struct.lua_TValue** %base, align 8
  ret %struct.lua_TValue* %23
}

; Function Attrs: nounwind uwtable
define internal void @callhook(%struct.lua_State* %L, %struct.CallInfo* %ci) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %ci.addr = alloca %struct.CallInfo*, align 8
  %hook = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.CallInfo* %ci, %struct.CallInfo** %ci.addr, align 8
  store i32 0, i32* %hook, align 4
  %0 = load %struct.CallInfo** %ci.addr, align 8
  %u = getelementptr inbounds %struct.CallInfo* %0, i32 0, i32 7
  %l = bitcast %union.anon.2* %u to %struct.anon.3*
  %savedpc = getelementptr inbounds %struct.anon.3* %l, i32 0, i32 1
  %1 = load i32** %savedpc, align 8
  %incdec.ptr = getelementptr inbounds i32* %1, i32 1
  store i32* %incdec.ptr, i32** %savedpc, align 8
  %2 = load %struct.CallInfo** %ci.addr, align 8
  %previous = getelementptr inbounds %struct.CallInfo* %2, i32 0, i32 2
  %3 = load %struct.CallInfo** %previous, align 8
  %callstatus = getelementptr inbounds %struct.CallInfo* %3, i32 0, i32 5
  %4 = load i8* %callstatus, align 1
  %conv = zext i8 %4 to i32
  %and = and i32 %conv, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %5 = load %struct.CallInfo** %ci.addr, align 8
  %previous1 = getelementptr inbounds %struct.CallInfo* %5, i32 0, i32 2
  %6 = load %struct.CallInfo** %previous1, align 8
  %u2 = getelementptr inbounds %struct.CallInfo* %6, i32 0, i32 7
  %l3 = bitcast %union.anon.2* %u2 to %struct.anon.3*
  %savedpc4 = getelementptr inbounds %struct.anon.3* %l3, i32 0, i32 1
  %7 = load i32** %savedpc4, align 8
  %add.ptr = getelementptr inbounds i32* %7, i64 -1
  %8 = load i32* %add.ptr, align 4
  %shr = lshr i32 %8, 0
  %and5 = and i32 %shr, 63
  %cmp = icmp eq i32 %and5, 30
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %9 = load %struct.CallInfo** %ci.addr, align 8
  %callstatus7 = getelementptr inbounds %struct.CallInfo* %9, i32 0, i32 5
  %10 = load i8* %callstatus7, align 1
  %conv8 = zext i8 %10 to i32
  %or = or i32 %conv8, 64
  %conv9 = trunc i32 %or to i8
  store i8 %conv9, i8* %callstatus7, align 1
  store i32 4, i32* %hook, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %11 = load %struct.lua_State** %L.addr, align 8
  %12 = load i32* %hook, align 4
  call void @luaD_hook(%struct.lua_State* %11, i32 %12, i32 -1)
  %13 = load %struct.CallInfo** %ci.addr, align 8
  %u10 = getelementptr inbounds %struct.CallInfo* %13, i32 0, i32 7
  %l11 = bitcast %union.anon.2* %u10 to %struct.anon.3*
  %savedpc12 = getelementptr inbounds %struct.anon.3* %l11, i32 0, i32 1
  %14 = load i32** %savedpc12, align 8
  %incdec.ptr13 = getelementptr inbounds i32* %14, i32 -1
  store i32* %incdec.ptr13, i32** %savedpc12, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal %struct.lua_TValue* @tryfuncTM(%struct.lua_State* %L, %struct.lua_TValue* %func) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %func.addr = alloca %struct.lua_TValue*, align 8
  %tm = alloca %struct.lua_TValue*, align 8
  %p = alloca %struct.lua_TValue*, align 8
  %funcr = alloca i64, align 8
  %io2 = alloca %struct.lua_TValue*, align 8
  %io1 = alloca %struct.lua_TValue*, align 8
  %io216 = alloca %struct.lua_TValue*, align 8
  %io117 = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.lua_TValue* %func, %struct.lua_TValue** %func.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load %struct.lua_TValue** %func.addr, align 8
  %call = call %struct.lua_TValue* @luaT_gettmbyobj(%struct.lua_State* %0, %struct.lua_TValue* %1, i32 16)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %tm, align 8
  %2 = load %struct.lua_TValue** %func.addr, align 8
  %3 = bitcast %struct.lua_TValue* %2 to i8*
  %4 = load %struct.lua_State** %L.addr, align 8
  %stack = getelementptr inbounds %struct.lua_State* %4, i32 0, i32 9
  %5 = load %struct.lua_TValue** %stack, align 8
  %6 = bitcast %struct.lua_TValue* %5 to i8*
  %sub.ptr.lhs.cast = ptrtoint i8* %3 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %6 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, i64* %funcr, align 8
  %7 = load %struct.lua_TValue** %tm, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %7, i32 0, i32 1
  %8 = load i32* %tt_, align 4
  %and = and i32 %8, 15
  %cmp = icmp eq i32 %and, 6
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %9 = load %struct.lua_State** %L.addr, align 8
  %10 = load %struct.lua_TValue** %func.addr, align 8
  call void @luaG_typeerror(%struct.lua_State* %9, %struct.lua_TValue* %10, i8* getelementptr inbounds ([5 x i8]* @.str11248, i32 0, i32 0)) #9
  unreachable

if.end:                                           ; preds = %entry
  %11 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %11, i32 0, i32 4
  %12 = load %struct.lua_TValue** %top, align 8
  store %struct.lua_TValue* %12, %struct.lua_TValue** %p, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %13 = load %struct.lua_TValue** %p, align 8
  %14 = load %struct.lua_TValue** %func.addr, align 8
  %cmp1 = icmp ugt %struct.lua_TValue* %13, %14
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %15 = load %struct.lua_TValue** %p, align 8
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %15, i64 -1
  store %struct.lua_TValue* %add.ptr, %struct.lua_TValue** %io2, align 8
  %16 = load %struct.lua_TValue** %p, align 8
  store %struct.lua_TValue* %16, %struct.lua_TValue** %io1, align 8
  %17 = load %struct.lua_TValue** %io1, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %17, i32 0, i32 0
  %18 = load %struct.lua_TValue** %io2, align 8
  %value_2 = getelementptr inbounds %struct.lua_TValue* %18, i32 0, i32 0
  %19 = bitcast %union.Value* %value_ to i8*
  %20 = bitcast %union.Value* %value_2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %19, i8* %20, i64 8, i32 8, i1 false)
  %21 = load %struct.lua_TValue** %io2, align 8
  %tt_3 = getelementptr inbounds %struct.lua_TValue* %21, i32 0, i32 1
  %22 = load i32* %tt_3, align 4
  %23 = load %struct.lua_TValue** %io1, align 8
  %tt_4 = getelementptr inbounds %struct.lua_TValue* %23, i32 0, i32 1
  store i32 %22, i32* %tt_4, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %24 = load %struct.lua_TValue** %p, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %24, i32 -1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %p, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %25 = load %struct.lua_State** %L.addr, align 8
  %top5 = getelementptr inbounds %struct.lua_State* %25, i32 0, i32 4
  %26 = load %struct.lua_TValue** %top5, align 8
  %incdec.ptr6 = getelementptr inbounds %struct.lua_TValue* %26, i32 1
  store %struct.lua_TValue* %incdec.ptr6, %struct.lua_TValue** %top5, align 8
  %27 = load %struct.lua_State** %L.addr, align 8
  %stack_last = getelementptr inbounds %struct.lua_State* %27, i32 0, i32 8
  %28 = load %struct.lua_TValue** %stack_last, align 8
  %29 = load %struct.lua_State** %L.addr, align 8
  %top7 = getelementptr inbounds %struct.lua_State* %29, i32 0, i32 4
  %30 = load %struct.lua_TValue** %top7, align 8
  %sub.ptr.lhs.cast8 = ptrtoint %struct.lua_TValue* %28 to i64
  %sub.ptr.rhs.cast9 = ptrtoint %struct.lua_TValue* %30 to i64
  %sub.ptr.sub10 = sub i64 %sub.ptr.lhs.cast8, %sub.ptr.rhs.cast9
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub10, 16
  %cmp11 = icmp sle i64 %sub.ptr.div, 0
  br i1 %cmp11, label %if.then12, label %if.else

if.then12:                                        ; preds = %for.end
  %31 = load %struct.lua_State** %L.addr, align 8
  call void @luaD_growstack(%struct.lua_State* %31, i32 0)
  br label %if.end13

if.else:                                          ; preds = %for.end
  br label %if.end13

if.end13:                                         ; preds = %if.else, %if.then12
  %32 = load %struct.lua_State** %L.addr, align 8
  %stack14 = getelementptr inbounds %struct.lua_State* %32, i32 0, i32 9
  %33 = load %struct.lua_TValue** %stack14, align 8
  %34 = bitcast %struct.lua_TValue* %33 to i8*
  %35 = load i64* %funcr, align 8
  %add.ptr15 = getelementptr inbounds i8* %34, i64 %35
  %36 = bitcast i8* %add.ptr15 to %struct.lua_TValue*
  store %struct.lua_TValue* %36, %struct.lua_TValue** %func.addr, align 8
  %37 = load %struct.lua_TValue** %tm, align 8
  store %struct.lua_TValue* %37, %struct.lua_TValue** %io216, align 8
  %38 = load %struct.lua_TValue** %func.addr, align 8
  store %struct.lua_TValue* %38, %struct.lua_TValue** %io117, align 8
  %39 = load %struct.lua_TValue** %io117, align 8
  %value_18 = getelementptr inbounds %struct.lua_TValue* %39, i32 0, i32 0
  %40 = load %struct.lua_TValue** %io216, align 8
  %value_19 = getelementptr inbounds %struct.lua_TValue* %40, i32 0, i32 0
  %41 = bitcast %union.Value* %value_18 to i8*
  %42 = bitcast %union.Value* %value_19 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %41, i8* %42, i64 8, i32 8, i1 false)
  %43 = load %struct.lua_TValue** %io216, align 8
  %tt_20 = getelementptr inbounds %struct.lua_TValue* %43, i32 0, i32 1
  %44 = load i32* %tt_20, align 4
  %45 = load %struct.lua_TValue** %io117, align 8
  %tt_21 = getelementptr inbounds %struct.lua_TValue* %45, i32 0, i32 1
  store i32 %44, i32* %tt_21, align 4
  %46 = load %struct.lua_TValue** %func.addr, align 8
  ret %struct.lua_TValue* %46
}

; Function Attrs: nounwind uwtable
define internal void @resume(%struct.lua_State* %L, i8* %ud) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %ud.addr = alloca i8*, align 8
  %nCcalls = alloca i32, align 4
  %firstArg = alloca %struct.lua_TValue*, align 8
  %ci = alloca %struct.CallInfo*, align 8
  %n = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %ud, i8** %ud.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %nCcalls1 = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 12
  %1 = load i16* %nCcalls1, align 2
  %conv = zext i16 %1 to i32
  store i32 %conv, i32* %nCcalls, align 4
  %2 = load i8** %ud.addr, align 8
  %3 = bitcast i8* %2 to %struct.lua_TValue*
  store %struct.lua_TValue* %3, %struct.lua_TValue** %firstArg, align 8
  %4 = load %struct.lua_State** %L.addr, align 8
  %ci2 = getelementptr inbounds %struct.lua_State* %4, i32 0, i32 6
  %5 = load %struct.CallInfo** %ci2, align 8
  store %struct.CallInfo* %5, %struct.CallInfo** %ci, align 8
  %6 = load i32* %nCcalls, align 4
  %cmp = icmp sge i32 %6, 200
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %7 = load %struct.lua_State** %L.addr, align 8
  %8 = load %struct.lua_TValue** %firstArg, align 8
  call void @resume_error(%struct.lua_State* %7, i8* getelementptr inbounds ([17 x i8]* @.str1238, i32 0, i32 0), %struct.lua_TValue* %8) #9
  unreachable

if.end:                                           ; preds = %entry
  %9 = load %struct.lua_State** %L.addr, align 8
  %status = getelementptr inbounds %struct.lua_State* %9, i32 0, i32 3
  %10 = load i8* %status, align 1
  %conv4 = zext i8 %10 to i32
  %cmp5 = icmp eq i32 %conv4, 0
  br i1 %cmp5, label %if.then7, label %if.else

if.then7:                                         ; preds = %if.end
  %11 = load %struct.CallInfo** %ci, align 8
  %12 = load %struct.lua_State** %L.addr, align 8
  %base_ci = getelementptr inbounds %struct.lua_State* %12, i32 0, i32 22
  %cmp8 = icmp ne %struct.CallInfo* %11, %base_ci
  br i1 %cmp8, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.then7
  %13 = load %struct.lua_State** %L.addr, align 8
  %14 = load %struct.lua_TValue** %firstArg, align 8
  call void @resume_error(%struct.lua_State* %13, i8* getelementptr inbounds ([38 x i8]* @.str9246, i32 0, i32 0), %struct.lua_TValue* %14) #9
  unreachable

if.end11:                                         ; preds = %if.then7
  %15 = load %struct.lua_State** %L.addr, align 8
  %16 = load %struct.lua_TValue** %firstArg, align 8
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %16, i64 -1
  %call = call i32 @luaD_precall(%struct.lua_State* %15, %struct.lua_TValue* %add.ptr, i32 -1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end13, label %if.then12

if.then12:                                        ; preds = %if.end11
  %17 = load %struct.lua_State** %L.addr, align 8
  call void bitcast (void (%struct.lua_State.364*)* @luaV_execute to void (%struct.lua_State*)*)(%struct.lua_State* %17)
  br label %if.end13

if.end13:                                         ; preds = %if.then12, %if.end11
  br label %if.end44

if.else:                                          ; preds = %if.end
  %18 = load %struct.lua_State** %L.addr, align 8
  %status14 = getelementptr inbounds %struct.lua_State* %18, i32 0, i32 3
  %19 = load i8* %status14, align 1
  %conv15 = zext i8 %19 to i32
  %cmp16 = icmp ne i32 %conv15, 1
  br i1 %cmp16, label %if.then18, label %if.else19

if.then18:                                        ; preds = %if.else
  %20 = load %struct.lua_State** %L.addr, align 8
  %21 = load %struct.lua_TValue** %firstArg, align 8
  call void @resume_error(%struct.lua_State* %20, i8* getelementptr inbounds ([29 x i8]* @.str10247, i32 0, i32 0), %struct.lua_TValue* %21) #9
  unreachable

if.else19:                                        ; preds = %if.else
  %22 = load %struct.lua_State** %L.addr, align 8
  %status20 = getelementptr inbounds %struct.lua_State* %22, i32 0, i32 3
  store i8 0, i8* %status20, align 1
  %23 = load %struct.lua_State** %L.addr, align 8
  %stack = getelementptr inbounds %struct.lua_State* %23, i32 0, i32 9
  %24 = load %struct.lua_TValue** %stack, align 8
  %25 = bitcast %struct.lua_TValue* %24 to i8*
  %26 = load %struct.CallInfo** %ci, align 8
  %extra = getelementptr inbounds %struct.CallInfo* %26, i32 0, i32 6
  %27 = load i64* %extra, align 8
  %add.ptr21 = getelementptr inbounds i8* %25, i64 %27
  %28 = bitcast i8* %add.ptr21 to %struct.lua_TValue*
  %29 = load %struct.CallInfo** %ci, align 8
  %func = getelementptr inbounds %struct.CallInfo* %29, i32 0, i32 0
  store %struct.lua_TValue* %28, %struct.lua_TValue** %func, align 8
  %30 = load %struct.CallInfo** %ci, align 8
  %callstatus = getelementptr inbounds %struct.CallInfo* %30, i32 0, i32 5
  %31 = load i8* %callstatus, align 1
  %conv22 = zext i8 %31 to i32
  %and = and i32 %conv22, 1
  %tobool23 = icmp ne i32 %and, 0
  br i1 %tobool23, label %if.then24, label %if.else25

if.then24:                                        ; preds = %if.else19
  %32 = load %struct.lua_State** %L.addr, align 8
  call void bitcast (void (%struct.lua_State.364*)* @luaV_execute to void (%struct.lua_State*)*)(%struct.lua_State* %32)
  br label %if.end42

if.else25:                                        ; preds = %if.else19
  %33 = load %struct.CallInfo** %ci, align 8
  %u = getelementptr inbounds %struct.CallInfo* %33, i32 0, i32 7
  %c = bitcast %union.anon.2* %u to %struct.anon.4*
  %k = getelementptr inbounds %struct.anon.4* %c, i32 0, i32 1
  %34 = load i32 (%struct.lua_State*)** %k, align 8
  %cmp26 = icmp ne i32 (%struct.lua_State*)* %34, null
  br i1 %cmp26, label %if.then28, label %if.end40

if.then28:                                        ; preds = %if.else25
  %35 = load %struct.CallInfo** %ci, align 8
  %u29 = getelementptr inbounds %struct.CallInfo* %35, i32 0, i32 7
  %c30 = bitcast %union.anon.2* %u29 to %struct.anon.4*
  %status31 = getelementptr inbounds %struct.anon.4* %c30, i32 0, i32 4
  store i8 1, i8* %status31, align 1
  %36 = load %struct.CallInfo** %ci, align 8
  %callstatus32 = getelementptr inbounds %struct.CallInfo* %36, i32 0, i32 5
  %37 = load i8* %callstatus32, align 1
  %conv33 = zext i8 %37 to i32
  %or = or i32 %conv33, 8
  %conv34 = trunc i32 %or to i8
  store i8 %conv34, i8* %callstatus32, align 1
  %38 = load %struct.CallInfo** %ci, align 8
  %u35 = getelementptr inbounds %struct.CallInfo* %38, i32 0, i32 7
  %c36 = bitcast %union.anon.2* %u35 to %struct.anon.4*
  %k37 = getelementptr inbounds %struct.anon.4* %c36, i32 0, i32 1
  %39 = load i32 (%struct.lua_State*)** %k37, align 8
  %40 = load %struct.lua_State** %L.addr, align 8
  %call38 = call i32 %39(%struct.lua_State* %40)
  store i32 %call38, i32* %n, align 4
  %41 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %41, i32 0, i32 4
  %42 = load %struct.lua_TValue** %top, align 8
  %43 = load i32* %n, align 4
  %idx.ext = sext i32 %43 to i64
  %idx.neg = sub i64 0, %idx.ext
  %add.ptr39 = getelementptr inbounds %struct.lua_TValue* %42, i64 %idx.neg
  store %struct.lua_TValue* %add.ptr39, %struct.lua_TValue** %firstArg, align 8
  br label %if.end40

if.end40:                                         ; preds = %if.then28, %if.else25
  %44 = load %struct.lua_State** %L.addr, align 8
  %45 = load %struct.lua_TValue** %firstArg, align 8
  %call41 = call i32 @luaD_poscall(%struct.lua_State* %44, %struct.lua_TValue* %45)
  br label %if.end42

if.end42:                                         ; preds = %if.end40, %if.then24
  %46 = load %struct.lua_State** %L.addr, align 8
  call void @unroll(%struct.lua_State* %46, i8* null)
  br label %if.end43

if.end43:                                         ; preds = %if.end42
  br label %if.end44

if.end44:                                         ; preds = %if.end43, %if.end13
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @recover(%struct.lua_State* %L, i32 %status) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %status.addr = alloca i32, align 4
  %oldtop = alloca %struct.lua_TValue*, align 8
  %ci = alloca %struct.CallInfo*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %status, i32* %status.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call %struct.CallInfo* @findpcall(%struct.lua_State* %0)
  store %struct.CallInfo* %call, %struct.CallInfo** %ci, align 8
  %1 = load %struct.CallInfo** %ci, align 8
  %cmp = icmp eq %struct.CallInfo* %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.lua_State** %L.addr, align 8
  %stack = getelementptr inbounds %struct.lua_State* %2, i32 0, i32 9
  %3 = load %struct.lua_TValue** %stack, align 8
  %4 = bitcast %struct.lua_TValue* %3 to i8*
  %5 = load %struct.CallInfo** %ci, align 8
  %extra = getelementptr inbounds %struct.CallInfo* %5, i32 0, i32 6
  %6 = load i64* %extra, align 8
  %add.ptr = getelementptr inbounds i8* %4, i64 %6
  %7 = bitcast i8* %add.ptr to %struct.lua_TValue*
  store %struct.lua_TValue* %7, %struct.lua_TValue** %oldtop, align 8
  %8 = load %struct.lua_State** %L.addr, align 8
  %9 = load %struct.lua_TValue** %oldtop, align 8
  call void bitcast (void (%struct.lua_State.154*, %struct.lua_TValue.137*)* @luaF_close to void (%struct.lua_State*, %struct.lua_TValue*)*)(%struct.lua_State* %8, %struct.lua_TValue* %9)
  %10 = load %struct.lua_State** %L.addr, align 8
  %11 = load i32* %status.addr, align 4
  %12 = load %struct.lua_TValue** %oldtop, align 8
  call void @seterrorobj(%struct.lua_State* %10, i32 %11, %struct.lua_TValue* %12)
  %13 = load %struct.CallInfo** %ci, align 8
  %14 = load %struct.lua_State** %L.addr, align 8
  %ci1 = getelementptr inbounds %struct.lua_State* %14, i32 0, i32 6
  store %struct.CallInfo* %13, %struct.CallInfo** %ci1, align 8
  %15 = load %struct.CallInfo** %ci, align 8
  %u = getelementptr inbounds %struct.CallInfo* %15, i32 0, i32 7
  %c = bitcast %union.anon.2* %u to %struct.anon.4*
  %old_allowhook = getelementptr inbounds %struct.anon.4* %c, i32 0, i32 3
  %16 = load i8* %old_allowhook, align 1
  %17 = load %struct.lua_State** %L.addr, align 8
  %allowhook = getelementptr inbounds %struct.lua_State* %17, i32 0, i32 14
  store i8 %16, i8* %allowhook, align 1
  %18 = load %struct.lua_State** %L.addr, align 8
  %nny = getelementptr inbounds %struct.lua_State* %18, i32 0, i32 11
  store i16 0, i16* %nny, align 2
  %19 = load %struct.lua_State** %L.addr, align 8
  call void @luaD_shrinkstack(%struct.lua_State* %19)
  %20 = load %struct.CallInfo** %ci, align 8
  %u2 = getelementptr inbounds %struct.CallInfo* %20, i32 0, i32 7
  %c3 = bitcast %union.anon.2* %u2 to %struct.anon.4*
  %old_errfunc = getelementptr inbounds %struct.anon.4* %c3, i32 0, i32 2
  %21 = load i64* %old_errfunc, align 8
  %22 = load %struct.lua_State** %L.addr, align 8
  %errfunc = getelementptr inbounds %struct.lua_State* %22, i32 0, i32 21
  store i64 %21, i64* %errfunc, align 8
  %23 = load %struct.CallInfo** %ci, align 8
  %callstatus = getelementptr inbounds %struct.CallInfo* %23, i32 0, i32 5
  %24 = load i8* %callstatus, align 1
  %conv = zext i8 %24 to i32
  %or = or i32 %conv, 32
  %conv4 = trunc i32 %or to i8
  store i8 %conv4, i8* %callstatus, align 1
  %25 = load i32* %status.addr, align 4
  %conv5 = trunc i32 %25 to i8
  %26 = load %struct.CallInfo** %ci, align 8
  %u6 = getelementptr inbounds %struct.CallInfo* %26, i32 0, i32 7
  %c7 = bitcast %union.anon.2* %u6 to %struct.anon.4*
  %status8 = getelementptr inbounds %struct.anon.4* %c7, i32 0, i32 4
  store i8 %conv5, i8* %status8, align 1
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %27 = load i32* %retval
  ret i32 %27
}

; Function Attrs: nounwind uwtable
define internal void @unroll(%struct.lua_State* %L, i8* %ud) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %ud.addr = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %ud, i8** %ud.addr, align 8
  %0 = load i8** %ud.addr, align 8
  br label %for.cond

for.cond:                                         ; preds = %if.end3, %entry
  %1 = load %struct.lua_State** %L.addr, align 8
  %ci = getelementptr inbounds %struct.lua_State* %1, i32 0, i32 6
  %2 = load %struct.CallInfo** %ci, align 8
  %3 = load %struct.lua_State** %L.addr, align 8
  %base_ci = getelementptr inbounds %struct.lua_State* %3, i32 0, i32 22
  %cmp = icmp eq %struct.CallInfo* %2, %base_ci
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %for.cond
  ret void

if.end:                                           ; preds = %for.cond
  %4 = load %struct.lua_State** %L.addr, align 8
  %ci1 = getelementptr inbounds %struct.lua_State* %4, i32 0, i32 6
  %5 = load %struct.CallInfo** %ci1, align 8
  %callstatus = getelementptr inbounds %struct.CallInfo* %5, i32 0, i32 5
  %6 = load i8* %callstatus, align 1
  %conv = zext i8 %6 to i32
  %and = and i32 %conv, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.else, label %if.then2

if.then2:                                         ; preds = %if.end
  %7 = load %struct.lua_State** %L.addr, align 8
  call void @finishCcall(%struct.lua_State* %7)
  br label %if.end3

if.else:                                          ; preds = %if.end
  %8 = load %struct.lua_State** %L.addr, align 8
  call void bitcast (void (%struct.lua_State.364*)* @luaV_finishOp to void (%struct.lua_State*)*)(%struct.lua_State* %8)
  %9 = load %struct.lua_State** %L.addr, align 8
  call void bitcast (void (%struct.lua_State.364*)* @luaV_execute to void (%struct.lua_State*)*)(%struct.lua_State* %9)
  br label %if.end3

if.end3:                                          ; preds = %if.else, %if.then2
  br label %for.cond
}

; Function Attrs: nounwind uwtable
define internal void @seterrorobj(%struct.lua_State* %L, i32 %errcode, %struct.lua_TValue* %oldtop) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %errcode.addr = alloca i32, align 4
  %oldtop.addr = alloca %struct.lua_TValue*, align 8
  %io = alloca %struct.lua_TValue*, align 8
  %x_ = alloca %union.TString*, align 8
  %io2 = alloca %struct.lua_TValue*, align 8
  %x_3 = alloca %union.TString*, align 8
  %io211 = alloca %struct.lua_TValue*, align 8
  %io1 = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %errcode, i32* %errcode.addr, align 4
  store %struct.lua_TValue* %oldtop, %struct.lua_TValue** %oldtop.addr, align 8
  %0 = load i32* %errcode.addr, align 4
  switch i32 %0, label %sw.default [
    i32 4, label %sw.bb
    i32 6, label %sw.bb1
  ]

sw.bb:                                            ; preds = %entry
  %1 = load %struct.lua_TValue** %oldtop.addr, align 8
  store %struct.lua_TValue* %1, %struct.lua_TValue** %io, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %2, i32 0, i32 5
  %3 = load %struct.global_State** %l_G, align 8
  %memerrmsg = getelementptr inbounds %struct.global_State* %3, i32 0, i32 32
  %4 = load %union.TString** %memerrmsg, align 8
  store %union.TString* %4, %union.TString** %x_, align 8
  %5 = load %union.TString** %x_, align 8
  %6 = bitcast %union.TString* %5 to %union.GCObject*
  %7 = load %struct.lua_TValue** %io, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %7, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  store %union.GCObject* %6, %union.GCObject** %gc, align 8
  %8 = load %union.TString** %x_, align 8
  %tsv = bitcast %union.TString* %8 to %struct.anon.0*
  %tt = getelementptr inbounds %struct.anon.0* %tsv, i32 0, i32 1
  %9 = load i8* %tt, align 1
  %conv = zext i8 %9 to i32
  %or = or i32 %conv, 64
  %10 = load %struct.lua_TValue** %io, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %10, i32 0, i32 1
  store i32 %or, i32* %tt_, align 4
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  %11 = load %struct.lua_TValue** %oldtop.addr, align 8
  store %struct.lua_TValue* %11, %struct.lua_TValue** %io2, align 8
  %12 = load %struct.lua_State** %L.addr, align 8
  %call = call %union.TString* bitcast (%union.TString.367* (%struct.lua_State.364*, i8*, i64)* @luaS_newlstr to %union.TString* (%struct.lua_State*, i8*, i64)*)(%struct.lua_State* %12, i8* getelementptr inbounds ([24 x i8]* @.str8245, i32 0, i32 0), i64 23)
  store %union.TString* %call, %union.TString** %x_3, align 8
  %13 = load %union.TString** %x_3, align 8
  %14 = bitcast %union.TString* %13 to %union.GCObject*
  %15 = load %struct.lua_TValue** %io2, align 8
  %value_4 = getelementptr inbounds %struct.lua_TValue* %15, i32 0, i32 0
  %gc5 = bitcast %union.Value* %value_4 to %union.GCObject**
  store %union.GCObject* %14, %union.GCObject** %gc5, align 8
  %16 = load %union.TString** %x_3, align 8
  %tsv6 = bitcast %union.TString* %16 to %struct.anon.0*
  %tt7 = getelementptr inbounds %struct.anon.0* %tsv6, i32 0, i32 1
  %17 = load i8* %tt7, align 1
  %conv8 = zext i8 %17 to i32
  %or9 = or i32 %conv8, 64
  %18 = load %struct.lua_TValue** %io2, align 8
  %tt_10 = getelementptr inbounds %struct.lua_TValue* %18, i32 0, i32 1
  store i32 %or9, i32* %tt_10, align 4
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %19 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %19, i32 0, i32 4
  %20 = load %struct.lua_TValue** %top, align 8
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %20, i64 -1
  store %struct.lua_TValue* %add.ptr, %struct.lua_TValue** %io211, align 8
  %21 = load %struct.lua_TValue** %oldtop.addr, align 8
  store %struct.lua_TValue* %21, %struct.lua_TValue** %io1, align 8
  %22 = load %struct.lua_TValue** %io1, align 8
  %value_12 = getelementptr inbounds %struct.lua_TValue* %22, i32 0, i32 0
  %23 = load %struct.lua_TValue** %io211, align 8
  %value_13 = getelementptr inbounds %struct.lua_TValue* %23, i32 0, i32 0
  %24 = bitcast %union.Value* %value_12 to i8*
  %25 = bitcast %union.Value* %value_13 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %24, i8* %25, i64 8, i32 8, i1 false)
  %26 = load %struct.lua_TValue** %io211, align 8
  %tt_14 = getelementptr inbounds %struct.lua_TValue* %26, i32 0, i32 1
  %27 = load i32* %tt_14, align 4
  %28 = load %struct.lua_TValue** %io1, align 8
  %tt_15 = getelementptr inbounds %struct.lua_TValue* %28, i32 0, i32 1
  store i32 %27, i32* %tt_15, align 4
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb1, %sw.bb
  %29 = load %struct.lua_TValue** %oldtop.addr, align 8
  %add.ptr16 = getelementptr inbounds %struct.lua_TValue* %29, i64 1
  %30 = load %struct.lua_State** %L.addr, align 8
  %top17 = getelementptr inbounds %struct.lua_State* %30, i32 0, i32 4
  store %struct.lua_TValue* %add.ptr16, %struct.lua_TValue** %top17, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @f_parser(%struct.lua_State* %L, i8* %ud) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %ud.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %cl = alloca %union.Closure*, align 8
  %p = alloca %struct.SParser*, align 8
  %c = alloca i32, align 4
  %up = alloca %struct.UpVal*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %ud, i8** %ud.addr, align 8
  %0 = load i8** %ud.addr, align 8
  %1 = bitcast i8* %0 to %struct.SParser*
  store %struct.SParser* %1, %struct.SParser** %p, align 8
  %2 = load %struct.SParser** %p, align 8
  %z = getelementptr inbounds %struct.SParser* %2, i32 0, i32 0
  %3 = load %struct.Zio** %z, align 8
  %n = getelementptr inbounds %struct.Zio* %3, i32 0, i32 0
  %4 = load i64* %n, align 8
  %dec = add i64 %4, -1
  store i64 %dec, i64* %n, align 8
  %cmp = icmp ugt i64 %4, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %5 = load %struct.SParser** %p, align 8
  %z1 = getelementptr inbounds %struct.SParser* %5, i32 0, i32 0
  %6 = load %struct.Zio** %z1, align 8
  %p2 = getelementptr inbounds %struct.Zio* %6, i32 0, i32 1
  %7 = load i8** %p2, align 8
  %incdec.ptr = getelementptr inbounds i8* %7, i32 1
  store i8* %incdec.ptr, i8** %p2, align 8
  %8 = load i8* %7, align 1
  %conv = zext i8 %8 to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  %9 = load %struct.SParser** %p, align 8
  %z3 = getelementptr inbounds %struct.SParser* %9, i32 0, i32 0
  %10 = load %struct.Zio** %z3, align 8
  %call = call i32 @luaZ_fill(%struct.Zio* %10)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv, %cond.true ], [ %call, %cond.false ]
  store i32 %cond, i32* %c, align 4
  %11 = load i32* %c, align 4
  %12 = load i8* getelementptr inbounds ([5 x i8]* @.str4241, i32 0, i64 0), align 1
  %conv4 = sext i8 %12 to i32
  %cmp5 = icmp eq i32 %11, %conv4
  br i1 %cmp5, label %if.then, label %if.else

if.then:                                          ; preds = %cond.end
  %13 = load %struct.lua_State** %L.addr, align 8
  %14 = load %struct.SParser** %p, align 8
  %mode = getelementptr inbounds %struct.SParser* %14, i32 0, i32 3
  %15 = load i8** %mode, align 8
  call void @checkmode(%struct.lua_State* %13, i8* %15, i8* getelementptr inbounds ([7 x i8]* @.str5242, i32 0, i32 0))
  %16 = load %struct.lua_State** %L.addr, align 8
  %17 = load %struct.SParser** %p, align 8
  %z7 = getelementptr inbounds %struct.SParser* %17, i32 0, i32 0
  %18 = load %struct.Zio** %z7, align 8
  %19 = load %struct.SParser** %p, align 8
  %buff = getelementptr inbounds %struct.SParser* %19, i32 0, i32 1
  %20 = load %struct.SParser** %p, align 8
  %name = getelementptr inbounds %struct.SParser* %20, i32 0, i32 4
  %21 = load i8** %name, align 8
  %call8 = call %union.Closure* bitcast (%union.Closure.157* (%struct.lua_State.154*, %struct.Zio.449*, %struct.Mbuffer*, i8*)* @luaU_undump to %union.Closure* (%struct.lua_State*, %struct.Zio*, %struct.Mbuffer*, i8*)*)(%struct.lua_State* %16, %struct.Zio* %18, %struct.Mbuffer* %buff, i8* %21)
  store %union.Closure* %call8, %union.Closure** %cl, align 8
  br label %if.end

if.else:                                          ; preds = %cond.end
  %22 = load %struct.lua_State** %L.addr, align 8
  %23 = load %struct.SParser** %p, align 8
  %mode9 = getelementptr inbounds %struct.SParser* %23, i32 0, i32 3
  %24 = load i8** %mode9, align 8
  call void @checkmode(%struct.lua_State* %22, i8* %24, i8* getelementptr inbounds ([5 x i8]* @.str6243, i32 0, i32 0))
  %25 = load %struct.lua_State** %L.addr, align 8
  %26 = load %struct.SParser** %p, align 8
  %z10 = getelementptr inbounds %struct.SParser* %26, i32 0, i32 0
  %27 = load %struct.Zio** %z10, align 8
  %28 = load %struct.SParser** %p, align 8
  %buff11 = getelementptr inbounds %struct.SParser* %28, i32 0, i32 1
  %29 = load %struct.SParser** %p, align 8
  %dyd = getelementptr inbounds %struct.SParser* %29, i32 0, i32 2
  %30 = load %struct.SParser** %p, align 8
  %name12 = getelementptr inbounds %struct.SParser* %30, i32 0, i32 4
  %31 = load i8** %name12, align 8
  %32 = load i32* %c, align 4
  %call13 = call %union.Closure* bitcast (%union.Closure.157* (%struct.lua_State.154*, %struct.Zio.308*, %struct.Mbuffer*, %struct.Dyndata.313*, i8*, i32)* @luaY_parser to %union.Closure* (%struct.lua_State*, %struct.Zio*, %struct.Mbuffer*, %struct.Dyndata.107*, i8*, i32)*)(%struct.lua_State* %25, %struct.Zio* %27, %struct.Mbuffer* %buff11, %struct.Dyndata.107* %dyd, i8* %31, i32 %32)
  store %union.Closure* %call13, %union.Closure** %cl, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %33 = load i32* %i, align 4
  %34 = load %union.Closure** %cl, align 8
  %l = bitcast %union.Closure* %34 to %struct.LClosure*
  %nupvalues = getelementptr inbounds %struct.LClosure* %l, i32 0, i32 3
  %35 = load i8* %nupvalues, align 1
  %conv14 = zext i8 %35 to i32
  %cmp15 = icmp slt i32 %33, %conv14
  br i1 %cmp15, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %36 = load %struct.lua_State** %L.addr, align 8
  %call17 = call %struct.UpVal* bitcast (%struct.UpVal.140* (%struct.lua_State.154*)* @luaF_newupval to %struct.UpVal* (%struct.lua_State*)*)(%struct.lua_State* %36)
  store %struct.UpVal* %call17, %struct.UpVal** %up, align 8
  %37 = load %struct.UpVal** %up, align 8
  %38 = load i32* %i, align 4
  %idxprom = sext i32 %38 to i64
  %39 = load %union.Closure** %cl, align 8
  %l18 = bitcast %union.Closure* %39 to %struct.LClosure*
  %upvals = getelementptr inbounds %struct.LClosure* %l18, i32 0, i32 6
  %arrayidx = getelementptr inbounds [1 x %struct.UpVal*]* %upvals, i32 0, i64 %idxprom
  store %struct.UpVal* %37, %struct.UpVal** %arrayidx, align 8
  %40 = load %struct.UpVal** %up, align 8
  %41 = bitcast %struct.UpVal* %40 to %union.GCObject*
  %gch = bitcast %union.GCObject* %41 to %struct.GCheader*
  %marked = getelementptr inbounds %struct.GCheader* %gch, i32 0, i32 2
  %42 = load i8* %marked, align 1
  %conv19 = zext i8 %42 to i32
  %and = and i32 %conv19, 3
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end26

land.lhs.true:                                    ; preds = %for.body
  %43 = load %union.Closure** %cl, align 8
  %44 = bitcast %union.Closure* %43 to %union.GCObject*
  %gch20 = bitcast %union.GCObject* %44 to %struct.GCheader*
  %marked21 = getelementptr inbounds %struct.GCheader* %gch20, i32 0, i32 2
  %45 = load i8* %marked21, align 1
  %conv22 = zext i8 %45 to i32
  %and23 = and i32 %conv22, 4
  %tobool24 = icmp ne i32 %and23, 0
  br i1 %tobool24, label %if.then25, label %if.end26

if.then25:                                        ; preds = %land.lhs.true
  %46 = load %struct.lua_State** %L.addr, align 8
  %47 = load %union.Closure** %cl, align 8
  %48 = bitcast %union.Closure* %47 to %union.GCObject*
  %49 = load %struct.UpVal** %up, align 8
  %50 = bitcast %struct.UpVal* %49 to %union.GCObject*
  call void @luaC_barrier_(%struct.lua_State* %46, %union.GCObject* %48, %union.GCObject* %50)
  br label %if.end26

if.end26:                                         ; preds = %if.then25, %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end26
  %51 = load i32* %i, align 4
  %inc = add nsw i32 %51, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noreturn nounwind uwtable
define internal void @resume_error(%struct.lua_State* %L, i8* %msg, %struct.lua_TValue* %firstArg) #6 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %msg.addr = alloca i8*, align 8
  %firstArg.addr = alloca %struct.lua_TValue*, align 8
  %io = alloca %struct.lua_TValue*, align 8
  %x_ = alloca %union.TString*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %msg, i8** %msg.addr, align 8
  store %struct.lua_TValue* %firstArg, %struct.lua_TValue** %firstArg.addr, align 8
  %0 = load %struct.lua_TValue** %firstArg.addr, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %1, i32 0, i32 4
  store %struct.lua_TValue* %0, %struct.lua_TValue** %top, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %top1 = getelementptr inbounds %struct.lua_State* %2, i32 0, i32 4
  %3 = load %struct.lua_TValue** %top1, align 8
  store %struct.lua_TValue* %3, %struct.lua_TValue** %io, align 8
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load i8** %msg.addr, align 8
  %call = call %union.TString* bitcast (%union.TString.367* (%struct.lua_State.364*, i8*)* @luaS_new to %union.TString* (%struct.lua_State*, i8*)*)(%struct.lua_State* %4, i8* %5)
  store %union.TString* %call, %union.TString** %x_, align 8
  %6 = load %union.TString** %x_, align 8
  %7 = bitcast %union.TString* %6 to %union.GCObject*
  %8 = load %struct.lua_TValue** %io, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %8, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  store %union.GCObject* %7, %union.GCObject** %gc, align 8
  %9 = load %union.TString** %x_, align 8
  %tsv = bitcast %union.TString* %9 to %struct.anon.0*
  %tt = getelementptr inbounds %struct.anon.0* %tsv, i32 0, i32 1
  %10 = load i8* %tt, align 1
  %conv = zext i8 %10 to i32
  %or = or i32 %conv, 64
  %11 = load %struct.lua_TValue** %io, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %11, i32 0, i32 1
  store i32 %or, i32* %tt_, align 4
  %12 = load %struct.lua_State** %L.addr, align 8
  %top2 = getelementptr inbounds %struct.lua_State* %12, i32 0, i32 4
  %13 = load %struct.lua_TValue** %top2, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %13, i32 1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %top2, align 8
  %14 = load %struct.lua_State** %L.addr, align 8
  call void @luaD_throw(%struct.lua_State* %14, i32 -1) #9
  unreachable

return:                                           ; No predecessors!
  ret void
}

; Function Attrs: nounwind uwtable
define internal %struct.CallInfo* @findpcall(%struct.lua_State* %L) #0 {
entry:
  %retval = alloca %struct.CallInfo*, align 8
  %L.addr = alloca %struct.lua_State*, align 8
  %ci = alloca %struct.CallInfo*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %ci1 = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 6
  %1 = load %struct.CallInfo** %ci1, align 8
  store %struct.CallInfo* %1, %struct.CallInfo** %ci, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load %struct.CallInfo** %ci, align 8
  %cmp = icmp ne %struct.CallInfo* %2, null
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %struct.CallInfo** %ci, align 8
  %callstatus = getelementptr inbounds %struct.CallInfo* %3, i32 0, i32 5
  %4 = load i8* %callstatus, align 1
  %conv = zext i8 %4 to i32
  %and = and i32 %conv, 16
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %5 = load %struct.CallInfo** %ci, align 8
  store %struct.CallInfo* %5, %struct.CallInfo** %retval
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %6 = load %struct.CallInfo** %ci, align 8
  %previous = getelementptr inbounds %struct.CallInfo* %6, i32 0, i32 2
  %7 = load %struct.CallInfo** %previous, align 8
  store %struct.CallInfo* %7, %struct.CallInfo** %ci, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store %struct.CallInfo* null, %struct.CallInfo** %retval
  br label %return

return:                                           ; preds = %for.end, %if.then
  %8 = load %struct.CallInfo** %retval
  ret %struct.CallInfo* %8
}

; Function Attrs: nounwind uwtable
define internal void @finishCcall(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %ci = alloca %struct.CallInfo*, align 8
  %n = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %ci1 = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 6
  %1 = load %struct.CallInfo** %ci1, align 8
  store %struct.CallInfo* %1, %struct.CallInfo** %ci, align 8
  %2 = load %struct.CallInfo** %ci, align 8
  %callstatus = getelementptr inbounds %struct.CallInfo* %2, i32 0, i32 5
  %3 = load i8* %callstatus, align 1
  %conv = zext i8 %3 to i32
  %and = and i32 %conv, 16
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load %struct.CallInfo** %ci, align 8
  %callstatus2 = getelementptr inbounds %struct.CallInfo* %4, i32 0, i32 5
  %5 = load i8* %callstatus2, align 1
  %conv3 = zext i8 %5 to i32
  %and4 = and i32 %conv3, -17
  %conv5 = trunc i32 %and4 to i8
  store i8 %conv5, i8* %callstatus2, align 1
  %6 = load %struct.CallInfo** %ci, align 8
  %u = getelementptr inbounds %struct.CallInfo* %6, i32 0, i32 7
  %c = bitcast %union.anon.2* %u to %struct.anon.4*
  %old_errfunc = getelementptr inbounds %struct.anon.4* %c, i32 0, i32 2
  %7 = load i64* %old_errfunc, align 8
  %8 = load %struct.lua_State** %L.addr, align 8
  %errfunc = getelementptr inbounds %struct.lua_State* %8, i32 0, i32 21
  store i64 %7, i64* %errfunc, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %9 = load %struct.CallInfo** %ci, align 8
  %nresults = getelementptr inbounds %struct.CallInfo* %9, i32 0, i32 4
  %10 = load i16* %nresults, align 2
  %conv6 = sext i16 %10 to i32
  %cmp = icmp eq i32 %conv6, -1
  br i1 %cmp, label %land.lhs.true, label %if.end16

land.lhs.true:                                    ; preds = %if.end
  %11 = load %struct.lua_State** %L.addr, align 8
  %ci8 = getelementptr inbounds %struct.lua_State* %11, i32 0, i32 6
  %12 = load %struct.CallInfo** %ci8, align 8
  %top = getelementptr inbounds %struct.CallInfo* %12, i32 0, i32 1
  %13 = load %struct.lua_TValue** %top, align 8
  %14 = load %struct.lua_State** %L.addr, align 8
  %top9 = getelementptr inbounds %struct.lua_State* %14, i32 0, i32 4
  %15 = load %struct.lua_TValue** %top9, align 8
  %cmp10 = icmp ult %struct.lua_TValue* %13, %15
  br i1 %cmp10, label %if.then12, label %if.end16

if.then12:                                        ; preds = %land.lhs.true
  %16 = load %struct.lua_State** %L.addr, align 8
  %top13 = getelementptr inbounds %struct.lua_State* %16, i32 0, i32 4
  %17 = load %struct.lua_TValue** %top13, align 8
  %18 = load %struct.lua_State** %L.addr, align 8
  %ci14 = getelementptr inbounds %struct.lua_State* %18, i32 0, i32 6
  %19 = load %struct.CallInfo** %ci14, align 8
  %top15 = getelementptr inbounds %struct.CallInfo* %19, i32 0, i32 1
  store %struct.lua_TValue* %17, %struct.lua_TValue** %top15, align 8
  br label %if.end16

if.end16:                                         ; preds = %if.then12, %land.lhs.true, %if.end
  %20 = load %struct.CallInfo** %ci, align 8
  %callstatus17 = getelementptr inbounds %struct.CallInfo* %20, i32 0, i32 5
  %21 = load i8* %callstatus17, align 1
  %conv18 = zext i8 %21 to i32
  %and19 = and i32 %conv18, 32
  %tobool20 = icmp ne i32 %and19, 0
  br i1 %tobool20, label %if.end24, label %if.then21

if.then21:                                        ; preds = %if.end16
  %22 = load %struct.CallInfo** %ci, align 8
  %u22 = getelementptr inbounds %struct.CallInfo* %22, i32 0, i32 7
  %c23 = bitcast %union.anon.2* %u22 to %struct.anon.4*
  %status = getelementptr inbounds %struct.anon.4* %c23, i32 0, i32 4
  store i8 1, i8* %status, align 1
  br label %if.end24

if.end24:                                         ; preds = %if.then21, %if.end16
  %23 = load %struct.CallInfo** %ci, align 8
  %callstatus25 = getelementptr inbounds %struct.CallInfo* %23, i32 0, i32 5
  %24 = load i8* %callstatus25, align 1
  %conv26 = zext i8 %24 to i32
  %and27 = and i32 %conv26, -49
  %or = or i32 %and27, 8
  %conv28 = trunc i32 %or to i8
  %25 = load %struct.CallInfo** %ci, align 8
  %callstatus29 = getelementptr inbounds %struct.CallInfo* %25, i32 0, i32 5
  store i8 %conv28, i8* %callstatus29, align 1
  %26 = load %struct.CallInfo** %ci, align 8
  %u30 = getelementptr inbounds %struct.CallInfo* %26, i32 0, i32 7
  %c31 = bitcast %union.anon.2* %u30 to %struct.anon.4*
  %k = getelementptr inbounds %struct.anon.4* %c31, i32 0, i32 1
  %27 = load i32 (%struct.lua_State*)** %k, align 8
  %28 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 %27(%struct.lua_State* %28)
  store i32 %call, i32* %n, align 4
  %29 = load %struct.lua_State** %L.addr, align 8
  %30 = load %struct.lua_State** %L.addr, align 8
  %top32 = getelementptr inbounds %struct.lua_State* %30, i32 0, i32 4
  %31 = load %struct.lua_TValue** %top32, align 8
  %32 = load i32* %n, align 4
  %idx.ext = sext i32 %32 to i64
  %idx.neg = sub i64 0, %idx.ext
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %31, i64 %idx.neg
  %call33 = call i32 @luaD_poscall(%struct.lua_State* %29, %struct.lua_TValue* %add.ptr)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @checkmode(%struct.lua_State* %L, i8* %mode, i8* %x) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %mode.addr = alloca i8*, align 8
  %x.addr = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %mode, i8** %mode.addr, align 8
  store i8* %x, i8** %x.addr, align 8
  %0 = load i8** %mode.addr, align 8
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load i8** %mode.addr, align 8
  %2 = load i8** %x.addr, align 8
  %arrayidx = getelementptr inbounds i8* %2, i64 0
  %3 = load i8* %arrayidx, align 1
  %conv = sext i8 %3 to i32
  %call = call i8* @strchr(i8* %1, i32 %conv) #10
  %cmp = icmp eq i8* %call, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load i8** %x.addr, align 8
  %6 = load i8** %mode.addr, align 8
  %call2 = call i8* (%struct.lua_State*, i8*, ...)* bitcast (i8* (%struct.lua_State.279*, i8*, ...)* @luaO_pushfstring to i8* (%struct.lua_State*, i8*, ...)*)(%struct.lua_State* %4, i8* getelementptr inbounds ([42 x i8]* @.str7244, i32 0, i32 0), i8* %5, i8* %6)
  %7 = load %struct.lua_State** %L.addr, align 8
  call void @luaD_throw(%struct.lua_State* %7, i32 3) #9
  unreachable

if.end:                                           ; preds = %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define hidden i32 @luaU_dump(%struct.lua_State* %L, %struct.Proto* %f, i32 (%struct.lua_State*, i8*, i64, i8*)* %w, i8* %data, i32 %strip) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %f.addr = alloca %struct.Proto*, align 8
  %w.addr = alloca i32 (%struct.lua_State*, i8*, i64, i8*)*, align 8
  %data.addr = alloca i8*, align 8
  %strip.addr = alloca i32, align 4
  %D = alloca %struct.DumpState, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.Proto* %f, %struct.Proto** %f.addr, align 8
  store i32 (%struct.lua_State*, i8*, i64, i8*)* %w, i32 (%struct.lua_State*, i8*, i64, i8*)** %w.addr, align 8
  store i8* %data, i8** %data.addr, align 8
  store i32 %strip, i32* %strip.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %L1 = getelementptr inbounds %struct.DumpState* %D, i32 0, i32 0
  store %struct.lua_State* %0, %struct.lua_State** %L1, align 8
  %1 = load i32 (%struct.lua_State*, i8*, i64, i8*)** %w.addr, align 8
  %writer = getelementptr inbounds %struct.DumpState* %D, i32 0, i32 1
  store i32 (%struct.lua_State*, i8*, i64, i8*)* %1, i32 (%struct.lua_State*, i8*, i64, i8*)** %writer, align 8
  %2 = load i8** %data.addr, align 8
  %data2 = getelementptr inbounds %struct.DumpState* %D, i32 0, i32 2
  store i8* %2, i8** %data2, align 8
  %3 = load i32* %strip.addr, align 4
  %strip3 = getelementptr inbounds %struct.DumpState* %D, i32 0, i32 3
  store i32 %3, i32* %strip3, align 4
  %status = getelementptr inbounds %struct.DumpState* %D, i32 0, i32 4
  store i32 0, i32* %status, align 4
  call void @DumpHeader(%struct.DumpState* %D)
  %4 = load %struct.Proto** %f.addr, align 8
  call void @DumpFunction(%struct.Proto* %4, %struct.DumpState* %D)
  %status4 = getelementptr inbounds %struct.DumpState* %D, i32 0, i32 4
  %5 = load i32* %status4, align 4
  ret i32 %5
}

; Function Attrs: nounwind uwtable
define internal void @DumpHeader(%struct.DumpState* %D) #0 {
entry:
  %D.addr = alloca %struct.DumpState*, align 8
  %h = alloca [18 x i8], align 16
  store %struct.DumpState* %D, %struct.DumpState** %D.addr, align 8
  %arraydecay = getelementptr inbounds [18 x i8]* %h, i32 0, i32 0
  call void @luaU_header(i8* %arraydecay)
  %arraydecay1 = getelementptr inbounds [18 x i8]* %h, i32 0, i32 0
  %0 = load %struct.DumpState** %D.addr, align 8
  call void @DumpBlock(i8* %arraydecay1, i64 18, %struct.DumpState* %0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @DumpFunction(%struct.Proto* %f, %struct.DumpState* %D) #0 {
entry:
  %f.addr = alloca %struct.Proto*, align 8
  %D.addr = alloca %struct.DumpState*, align 8
  store %struct.Proto* %f, %struct.Proto** %f.addr, align 8
  store %struct.DumpState* %D, %struct.DumpState** %D.addr, align 8
  %0 = load %struct.Proto** %f.addr, align 8
  %linedefined = getelementptr inbounds %struct.Proto* %0, i32 0, i32 17
  %1 = load i32* %linedefined, align 4
  %2 = load %struct.DumpState** %D.addr, align 8
  call void @DumpInt(i32 %1, %struct.DumpState* %2)
  %3 = load %struct.Proto** %f.addr, align 8
  %lastlinedefined = getelementptr inbounds %struct.Proto* %3, i32 0, i32 18
  %4 = load i32* %lastlinedefined, align 4
  %5 = load %struct.DumpState** %D.addr, align 8
  call void @DumpInt(i32 %4, %struct.DumpState* %5)
  %6 = load %struct.Proto** %f.addr, align 8
  %numparams = getelementptr inbounds %struct.Proto* %6, i32 0, i32 20
  %7 = load i8* %numparams, align 1
  %conv = zext i8 %7 to i32
  %8 = load %struct.DumpState** %D.addr, align 8
  call void @DumpChar(i32 %conv, %struct.DumpState* %8)
  %9 = load %struct.Proto** %f.addr, align 8
  %is_vararg = getelementptr inbounds %struct.Proto* %9, i32 0, i32 21
  %10 = load i8* %is_vararg, align 1
  %conv1 = zext i8 %10 to i32
  %11 = load %struct.DumpState** %D.addr, align 8
  call void @DumpChar(i32 %conv1, %struct.DumpState* %11)
  %12 = load %struct.Proto** %f.addr, align 8
  %maxstacksize = getelementptr inbounds %struct.Proto* %12, i32 0, i32 22
  %13 = load i8* %maxstacksize, align 1
  %conv2 = zext i8 %13 to i32
  %14 = load %struct.DumpState** %D.addr, align 8
  call void @DumpChar(i32 %conv2, %struct.DumpState* %14)
  %15 = load %struct.Proto** %f.addr, align 8
  %code = getelementptr inbounds %struct.Proto* %15, i32 0, i32 4
  %16 = load i32** %code, align 8
  %17 = bitcast i32* %16 to i8*
  %18 = load %struct.Proto** %f.addr, align 8
  %sizecode = getelementptr inbounds %struct.Proto* %18, i32 0, i32 13
  %19 = load i32* %sizecode, align 4
  %20 = load %struct.DumpState** %D.addr, align 8
  call void @DumpVector(i8* %17, i32 %19, i64 4, %struct.DumpState* %20)
  %21 = load %struct.Proto** %f.addr, align 8
  %22 = load %struct.DumpState** %D.addr, align 8
  call void @DumpConstants(%struct.Proto* %21, %struct.DumpState* %22)
  %23 = load %struct.Proto** %f.addr, align 8
  %24 = load %struct.DumpState** %D.addr, align 8
  call void @DumpUpvalues(%struct.Proto* %23, %struct.DumpState* %24)
  %25 = load %struct.Proto** %f.addr, align 8
  %26 = load %struct.DumpState** %D.addr, align 8
  call void @DumpDebug(%struct.Proto* %25, %struct.DumpState* %26)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @DumpBlock(i8* %b, i64 %size, %struct.DumpState* %D) #0 {
entry:
  %b.addr = alloca i8*, align 8
  %size.addr = alloca i64, align 8
  %D.addr = alloca %struct.DumpState*, align 8
  store i8* %b, i8** %b.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store %struct.DumpState* %D, %struct.DumpState** %D.addr, align 8
  %0 = load %struct.DumpState** %D.addr, align 8
  %status = getelementptr inbounds %struct.DumpState* %0, i32 0, i32 4
  %1 = load i32* %status, align 4
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.DumpState** %D.addr, align 8
  %writer = getelementptr inbounds %struct.DumpState* %2, i32 0, i32 1
  %3 = load i32 (%struct.lua_State*, i8*, i64, i8*)** %writer, align 8
  %4 = load %struct.DumpState** %D.addr, align 8
  %L = getelementptr inbounds %struct.DumpState* %4, i32 0, i32 0
  %5 = load %struct.lua_State** %L, align 8
  %6 = load i8** %b.addr, align 8
  %7 = load i64* %size.addr, align 8
  %8 = load %struct.DumpState** %D.addr, align 8
  %data = getelementptr inbounds %struct.DumpState* %8, i32 0, i32 2
  %9 = load i8** %data, align 8
  %call = call i32 %3(%struct.lua_State* %5, i8* %6, i64 %7, i8* %9)
  %10 = load %struct.DumpState** %D.addr, align 8
  %status1 = getelementptr inbounds %struct.DumpState* %10, i32 0, i32 4
  store i32 %call, i32* %status1, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @DumpInt(i32 %x, %struct.DumpState* %D) #0 {
entry:
  %x.addr = alloca i32, align 4
  %D.addr = alloca %struct.DumpState*, align 8
  store i32 %x, i32* %x.addr, align 4
  store %struct.DumpState* %D, %struct.DumpState** %D.addr, align 8
  %0 = bitcast i32* %x.addr to i8*
  %1 = load %struct.DumpState** %D.addr, align 8
  call void @DumpBlock(i8* %0, i64 4, %struct.DumpState* %1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @DumpChar(i32 %y, %struct.DumpState* %D) #0 {
entry:
  %y.addr = alloca i32, align 4
  %D.addr = alloca %struct.DumpState*, align 8
  %x = alloca i8, align 1
  store i32 %y, i32* %y.addr, align 4
  store %struct.DumpState* %D, %struct.DumpState** %D.addr, align 8
  %0 = load i32* %y.addr, align 4
  %conv = trunc i32 %0 to i8
  store i8 %conv, i8* %x, align 1
  %1 = load %struct.DumpState** %D.addr, align 8
  call void @DumpBlock(i8* %x, i64 1, %struct.DumpState* %1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @DumpVector(i8* %b, i32 %n, i64 %size, %struct.DumpState* %D) #0 {
entry:
  %b.addr = alloca i8*, align 8
  %n.addr = alloca i32, align 4
  %size.addr = alloca i64, align 8
  %D.addr = alloca %struct.DumpState*, align 8
  store i8* %b, i8** %b.addr, align 8
  store i32 %n, i32* %n.addr, align 4
  store i64 %size, i64* %size.addr, align 8
  store %struct.DumpState* %D, %struct.DumpState** %D.addr, align 8
  %0 = load i32* %n.addr, align 4
  %1 = load %struct.DumpState** %D.addr, align 8
  call void @DumpInt(i32 %0, %struct.DumpState* %1)
  %2 = load i8** %b.addr, align 8
  %3 = load i32* %n.addr, align 4
  %conv = sext i32 %3 to i64
  %4 = load i64* %size.addr, align 8
  %mul = mul i64 %conv, %4
  %5 = load %struct.DumpState** %D.addr, align 8
  call void @DumpBlock(i8* %2, i64 %mul, %struct.DumpState* %5)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @DumpConstants(%struct.Proto* %f, %struct.DumpState* %D) #0 {
entry:
  %f.addr = alloca %struct.Proto*, align 8
  %D.addr = alloca %struct.DumpState*, align 8
  %i = alloca i32, align 4
  %n = alloca i32, align 4
  %o = alloca %struct.lua_TValue*, align 8
  store %struct.Proto* %f, %struct.Proto** %f.addr, align 8
  store %struct.DumpState* %D, %struct.DumpState** %D.addr, align 8
  %0 = load %struct.Proto** %f.addr, align 8
  %sizek = getelementptr inbounds %struct.Proto* %0, i32 0, i32 12
  %1 = load i32* %sizek, align 4
  store i32 %1, i32* %n, align 4
  %2 = load i32* %n, align 4
  %3 = load %struct.DumpState** %D.addr, align 8
  call void @DumpInt(i32 %2, %struct.DumpState* %3)
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %4 = load i32* %i, align 4
  %5 = load i32* %n, align 4
  %cmp = icmp slt i32 %4, %5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load i32* %i, align 4
  %idxprom = sext i32 %6 to i64
  %7 = load %struct.Proto** %f.addr, align 8
  %k = getelementptr inbounds %struct.Proto* %7, i32 0, i32 3
  %8 = load %struct.lua_TValue** %k, align 8
  %arrayidx = getelementptr inbounds %struct.lua_TValue* %8, i64 %idxprom
  store %struct.lua_TValue* %arrayidx, %struct.lua_TValue** %o, align 8
  %9 = load %struct.lua_TValue** %o, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %9, i32 0, i32 1
  %10 = load i32* %tt_, align 4
  %and = and i32 %10, 15
  %11 = load %struct.DumpState** %D.addr, align 8
  call void @DumpChar(i32 %and, %struct.DumpState* %11)
  %12 = load %struct.lua_TValue** %o, align 8
  %tt_1 = getelementptr inbounds %struct.lua_TValue* %12, i32 0, i32 1
  %13 = load i32* %tt_1, align 4
  %and2 = and i32 %13, 15
  switch i32 %and2, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb3
    i32 3, label %sw.bb4
    i32 4, label %sw.bb7
  ]

sw.bb:                                            ; preds = %for.body
  br label %sw.epilog

sw.bb3:                                           ; preds = %for.body
  %14 = load %struct.lua_TValue** %o, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %14, i32 0, i32 0
  %b = bitcast %union.Value* %value_ to i32*
  %15 = load i32* %b, align 4
  %16 = load %struct.DumpState** %D.addr, align 8
  call void @DumpChar(i32 %15, %struct.DumpState* %16)
  br label %sw.epilog

sw.bb4:                                           ; preds = %for.body
  %17 = load %struct.lua_TValue** %o, align 8
  %value_5 = getelementptr inbounds %struct.lua_TValue* %17, i32 0, i32 0
  %n6 = bitcast %union.Value* %value_5 to double*
  %18 = load double* %n6, align 8
  %19 = load %struct.DumpState** %D.addr, align 8
  call void @DumpNumber(double %18, %struct.DumpState* %19)
  br label %sw.epilog

sw.bb7:                                           ; preds = %for.body
  %20 = load %struct.lua_TValue** %o, align 8
  %value_8 = getelementptr inbounds %struct.lua_TValue* %20, i32 0, i32 0
  %gc = bitcast %union.Value* %value_8 to %union.GCObject**
  %21 = load %union.GCObject** %gc, align 8
  %ts = bitcast %union.GCObject* %21 to %union.TString*
  %22 = load %struct.DumpState** %D.addr, align 8
  call void @DumpString(%union.TString* %ts, %struct.DumpState* %22)
  br label %sw.epilog

sw.default:                                       ; preds = %for.body
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb7, %sw.bb4, %sw.bb3, %sw.bb
  br label %for.inc

for.inc:                                          ; preds = %sw.epilog
  %23 = load i32* %i, align 4
  %inc = add nsw i32 %23, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %24 = load %struct.Proto** %f.addr, align 8
  %sizep = getelementptr inbounds %struct.Proto* %24, i32 0, i32 15
  %25 = load i32* %sizep, align 4
  store i32 %25, i32* %n, align 4
  %26 = load i32* %n, align 4
  %27 = load %struct.DumpState** %D.addr, align 8
  call void @DumpInt(i32 %26, %struct.DumpState* %27)
  store i32 0, i32* %i, align 4
  br label %for.cond9

for.cond9:                                        ; preds = %for.inc14, %for.end
  %28 = load i32* %i, align 4
  %29 = load i32* %n, align 4
  %cmp10 = icmp slt i32 %28, %29
  br i1 %cmp10, label %for.body11, label %for.end16

for.body11:                                       ; preds = %for.cond9
  %30 = load i32* %i, align 4
  %idxprom12 = sext i32 %30 to i64
  %31 = load %struct.Proto** %f.addr, align 8
  %p = getelementptr inbounds %struct.Proto* %31, i32 0, i32 5
  %32 = load %struct.Proto*** %p, align 8
  %arrayidx13 = getelementptr inbounds %struct.Proto** %32, i64 %idxprom12
  %33 = load %struct.Proto** %arrayidx13, align 8
  %34 = load %struct.DumpState** %D.addr, align 8
  call void @DumpFunction(%struct.Proto* %33, %struct.DumpState* %34)
  br label %for.inc14

for.inc14:                                        ; preds = %for.body11
  %35 = load i32* %i, align 4
  %inc15 = add nsw i32 %35, 1
  store i32 %inc15, i32* %i, align 4
  br label %for.cond9

for.end16:                                        ; preds = %for.cond9
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @DumpUpvalues(%struct.Proto* %f, %struct.DumpState* %D) #0 {
entry:
  %f.addr = alloca %struct.Proto*, align 8
  %D.addr = alloca %struct.DumpState*, align 8
  %i = alloca i32, align 4
  %n = alloca i32, align 4
  store %struct.Proto* %f, %struct.Proto** %f.addr, align 8
  store %struct.DumpState* %D, %struct.DumpState** %D.addr, align 8
  %0 = load %struct.Proto** %f.addr, align 8
  %sizeupvalues = getelementptr inbounds %struct.Proto* %0, i32 0, i32 11
  %1 = load i32* %sizeupvalues, align 4
  store i32 %1, i32* %n, align 4
  %2 = load i32* %n, align 4
  %3 = load %struct.DumpState** %D.addr, align 8
  call void @DumpInt(i32 %2, %struct.DumpState* %3)
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %4 = load i32* %i, align 4
  %5 = load i32* %n, align 4
  %cmp = icmp slt i32 %4, %5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load i32* %i, align 4
  %idxprom = sext i32 %6 to i64
  %7 = load %struct.Proto** %f.addr, align 8
  %upvalues = getelementptr inbounds %struct.Proto* %7, i32 0, i32 8
  %8 = load %struct.Upvaldesc** %upvalues, align 8
  %arrayidx = getelementptr inbounds %struct.Upvaldesc* %8, i64 %idxprom
  %instack = getelementptr inbounds %struct.Upvaldesc* %arrayidx, i32 0, i32 1
  %9 = load i8* %instack, align 1
  %conv = zext i8 %9 to i32
  %10 = load %struct.DumpState** %D.addr, align 8
  call void @DumpChar(i32 %conv, %struct.DumpState* %10)
  %11 = load i32* %i, align 4
  %idxprom1 = sext i32 %11 to i64
  %12 = load %struct.Proto** %f.addr, align 8
  %upvalues2 = getelementptr inbounds %struct.Proto* %12, i32 0, i32 8
  %13 = load %struct.Upvaldesc** %upvalues2, align 8
  %arrayidx3 = getelementptr inbounds %struct.Upvaldesc* %13, i64 %idxprom1
  %idx = getelementptr inbounds %struct.Upvaldesc* %arrayidx3, i32 0, i32 2
  %14 = load i8* %idx, align 1
  %conv4 = zext i8 %14 to i32
  %15 = load %struct.DumpState** %D.addr, align 8
  call void @DumpChar(i32 %conv4, %struct.DumpState* %15)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %16 = load i32* %i, align 4
  %inc = add nsw i32 %16, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @DumpDebug(%struct.Proto* %f, %struct.DumpState* %D) #0 {
entry:
  %f.addr = alloca %struct.Proto*, align 8
  %D.addr = alloca %struct.DumpState*, align 8
  %i = alloca i32, align 4
  %n = alloca i32, align 4
  store %struct.Proto* %f, %struct.Proto** %f.addr, align 8
  store %struct.DumpState* %D, %struct.DumpState** %D.addr, align 8
  %0 = load %struct.DumpState** %D.addr, align 8
  %strip = getelementptr inbounds %struct.DumpState* %0, i32 0, i32 3
  %1 = load i32* %strip, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %2 = load %struct.Proto** %f.addr, align 8
  %source = getelementptr inbounds %struct.Proto* %2, i32 0, i32 10
  %3 = load %union.TString** %source, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %union.TString* [ null, %cond.true ], [ %3, %cond.false ]
  %4 = load %struct.DumpState** %D.addr, align 8
  call void @DumpString(%union.TString* %cond, %struct.DumpState* %4)
  %5 = load %struct.DumpState** %D.addr, align 8
  %strip1 = getelementptr inbounds %struct.DumpState* %5, i32 0, i32 3
  %6 = load i32* %strip1, align 4
  %tobool2 = icmp ne i32 %6, 0
  br i1 %tobool2, label %cond.true3, label %cond.false4

cond.true3:                                       ; preds = %cond.end
  br label %cond.end5

cond.false4:                                      ; preds = %cond.end
  %7 = load %struct.Proto** %f.addr, align 8
  %sizelineinfo = getelementptr inbounds %struct.Proto* %7, i32 0, i32 14
  %8 = load i32* %sizelineinfo, align 4
  br label %cond.end5

cond.end5:                                        ; preds = %cond.false4, %cond.true3
  %cond6 = phi i32 [ 0, %cond.true3 ], [ %8, %cond.false4 ]
  store i32 %cond6, i32* %n, align 4
  %9 = load %struct.Proto** %f.addr, align 8
  %lineinfo = getelementptr inbounds %struct.Proto* %9, i32 0, i32 6
  %10 = load i32** %lineinfo, align 8
  %11 = bitcast i32* %10 to i8*
  %12 = load i32* %n, align 4
  %13 = load %struct.DumpState** %D.addr, align 8
  call void @DumpVector(i8* %11, i32 %12, i64 4, %struct.DumpState* %13)
  %14 = load %struct.DumpState** %D.addr, align 8
  %strip7 = getelementptr inbounds %struct.DumpState* %14, i32 0, i32 3
  %15 = load i32* %strip7, align 4
  %tobool8 = icmp ne i32 %15, 0
  br i1 %tobool8, label %cond.true9, label %cond.false10

cond.true9:                                       ; preds = %cond.end5
  br label %cond.end11

cond.false10:                                     ; preds = %cond.end5
  %16 = load %struct.Proto** %f.addr, align 8
  %sizelocvars = getelementptr inbounds %struct.Proto* %16, i32 0, i32 16
  %17 = load i32* %sizelocvars, align 4
  br label %cond.end11

cond.end11:                                       ; preds = %cond.false10, %cond.true9
  %cond12 = phi i32 [ 0, %cond.true9 ], [ %17, %cond.false10 ]
  store i32 %cond12, i32* %n, align 4
  %18 = load i32* %n, align 4
  %19 = load %struct.DumpState** %D.addr, align 8
  call void @DumpInt(i32 %18, %struct.DumpState* %19)
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end11
  %20 = load i32* %i, align 4
  %21 = load i32* %n, align 4
  %cmp = icmp slt i32 %20, %21
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %22 = load i32* %i, align 4
  %idxprom = sext i32 %22 to i64
  %23 = load %struct.Proto** %f.addr, align 8
  %locvars = getelementptr inbounds %struct.Proto* %23, i32 0, i32 7
  %24 = load %struct.LocVar** %locvars, align 8
  %arrayidx = getelementptr inbounds %struct.LocVar* %24, i64 %idxprom
  %varname = getelementptr inbounds %struct.LocVar* %arrayidx, i32 0, i32 0
  %25 = load %union.TString** %varname, align 8
  %26 = load %struct.DumpState** %D.addr, align 8
  call void @DumpString(%union.TString* %25, %struct.DumpState* %26)
  %27 = load i32* %i, align 4
  %idxprom13 = sext i32 %27 to i64
  %28 = load %struct.Proto** %f.addr, align 8
  %locvars14 = getelementptr inbounds %struct.Proto* %28, i32 0, i32 7
  %29 = load %struct.LocVar** %locvars14, align 8
  %arrayidx15 = getelementptr inbounds %struct.LocVar* %29, i64 %idxprom13
  %startpc = getelementptr inbounds %struct.LocVar* %arrayidx15, i32 0, i32 1
  %30 = load i32* %startpc, align 4
  %31 = load %struct.DumpState** %D.addr, align 8
  call void @DumpInt(i32 %30, %struct.DumpState* %31)
  %32 = load i32* %i, align 4
  %idxprom16 = sext i32 %32 to i64
  %33 = load %struct.Proto** %f.addr, align 8
  %locvars17 = getelementptr inbounds %struct.Proto* %33, i32 0, i32 7
  %34 = load %struct.LocVar** %locvars17, align 8
  %arrayidx18 = getelementptr inbounds %struct.LocVar* %34, i64 %idxprom16
  %endpc = getelementptr inbounds %struct.LocVar* %arrayidx18, i32 0, i32 2
  %35 = load i32* %endpc, align 4
  %36 = load %struct.DumpState** %D.addr, align 8
  call void @DumpInt(i32 %35, %struct.DumpState* %36)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %37 = load i32* %i, align 4
  %inc = add nsw i32 %37, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %38 = load %struct.DumpState** %D.addr, align 8
  %strip19 = getelementptr inbounds %struct.DumpState* %38, i32 0, i32 3
  %39 = load i32* %strip19, align 4
  %tobool20 = icmp ne i32 %39, 0
  br i1 %tobool20, label %cond.true21, label %cond.false22

cond.true21:                                      ; preds = %for.end
  br label %cond.end23

cond.false22:                                     ; preds = %for.end
  %40 = load %struct.Proto** %f.addr, align 8
  %sizeupvalues = getelementptr inbounds %struct.Proto* %40, i32 0, i32 11
  %41 = load i32* %sizeupvalues, align 4
  br label %cond.end23

cond.end23:                                       ; preds = %cond.false22, %cond.true21
  %cond24 = phi i32 [ 0, %cond.true21 ], [ %41, %cond.false22 ]
  store i32 %cond24, i32* %n, align 4
  %42 = load i32* %n, align 4
  %43 = load %struct.DumpState** %D.addr, align 8
  call void @DumpInt(i32 %42, %struct.DumpState* %43)
  store i32 0, i32* %i, align 4
  br label %for.cond25

for.cond25:                                       ; preds = %for.inc30, %cond.end23
  %44 = load i32* %i, align 4
  %45 = load i32* %n, align 4
  %cmp26 = icmp slt i32 %44, %45
  br i1 %cmp26, label %for.body27, label %for.end32

for.body27:                                       ; preds = %for.cond25
  %46 = load i32* %i, align 4
  %idxprom28 = sext i32 %46 to i64
  %47 = load %struct.Proto** %f.addr, align 8
  %upvalues = getelementptr inbounds %struct.Proto* %47, i32 0, i32 8
  %48 = load %struct.Upvaldesc** %upvalues, align 8
  %arrayidx29 = getelementptr inbounds %struct.Upvaldesc* %48, i64 %idxprom28
  %name = getelementptr inbounds %struct.Upvaldesc* %arrayidx29, i32 0, i32 0
  %49 = load %union.TString** %name, align 8
  %50 = load %struct.DumpState** %D.addr, align 8
  call void @DumpString(%union.TString* %49, %struct.DumpState* %50)
  br label %for.inc30

for.inc30:                                        ; preds = %for.body27
  %51 = load i32* %i, align 4
  %inc31 = add nsw i32 %51, 1
  store i32 %inc31, i32* %i, align 4
  br label %for.cond25

for.end32:                                        ; preds = %for.cond25
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @DumpNumber(double %x, %struct.DumpState* %D) #0 {
entry:
  %x.addr = alloca double, align 8
  %D.addr = alloca %struct.DumpState*, align 8
  store double %x, double* %x.addr, align 8
  store %struct.DumpState* %D, %struct.DumpState** %D.addr, align 8
  %0 = bitcast double* %x.addr to i8*
  %1 = load %struct.DumpState** %D.addr, align 8
  call void @DumpBlock(i8* %0, i64 8, %struct.DumpState* %1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @DumpString(%union.TString* %s, %struct.DumpState* %D) #0 {
entry:
  %s.addr = alloca %union.TString*, align 8
  %D.addr = alloca %struct.DumpState*, align 8
  %size = alloca i64, align 8
  %size1 = alloca i64, align 8
  store %union.TString* %s, %union.TString** %s.addr, align 8
  store %struct.DumpState* %D, %struct.DumpState** %D.addr, align 8
  %0 = load %union.TString** %s.addr, align 8
  %cmp = icmp eq %union.TString* %0, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i64 0, i64* %size, align 8
  %1 = bitcast i64* %size to i8*
  %2 = load %struct.DumpState** %D.addr, align 8
  call void @DumpBlock(i8* %1, i64 8, %struct.DumpState* %2)
  br label %if.end

if.else:                                          ; preds = %entry
  %3 = load %union.TString** %s.addr, align 8
  %tsv = bitcast %union.TString* %3 to %struct.anon.0*
  %len = getelementptr inbounds %struct.anon.0* %tsv, i32 0, i32 5
  %4 = load i64* %len, align 8
  %add = add i64 %4, 1
  store i64 %add, i64* %size1, align 8
  %5 = bitcast i64* %size1 to i8*
  %6 = load %struct.DumpState** %D.addr, align 8
  call void @DumpBlock(i8* %5, i64 8, %struct.DumpState* %6)
  %7 = load %union.TString** %s.addr, align 8
  %add.ptr = getelementptr inbounds %union.TString* %7, i64 1
  %8 = bitcast %union.TString* %add.ptr to i8*
  %9 = load i64* %size1, align 8
  %mul = mul i64 %9, 1
  %10 = load %struct.DumpState** %D.addr, align 8
  call void @DumpBlock(i8* %8, i64 %mul, %struct.DumpState* %10)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define hidden %union.Closure.157* @luaF_newCclosure(%struct.lua_State.154* %L, i32 %n) #0 {
entry:
  %L.addr = alloca %struct.lua_State.154*, align 8
  %n.addr = alloca i32, align 4
  %c = alloca %union.Closure.157*, align 8
  store %struct.lua_State.154* %L, %struct.lua_State.154** %L.addr, align 8
  store i32 %n, i32* %n.addr, align 4
  %0 = load %struct.lua_State.154** %L.addr, align 8
  %1 = load i32* %n.addr, align 4
  %sub = sub nsw i32 %1, 1
  %conv = sext i32 %sub to i64
  %mul = mul i64 16, %conv
  %conv1 = trunc i64 %mul to i32
  %add = add nsw i32 48, %conv1
  %conv2 = sext i32 %add to i64
  %call = call %union.GCObject.155* bitcast (%union.GCObject* (%struct.lua_State*, i32, i64, %union.GCObject**, i32)* @luaC_newobj to %union.GCObject.155* (%struct.lua_State.154*, i32, i64, %union.GCObject.155**, i32)*)(%struct.lua_State.154* %0, i32 38, i64 %conv2, %union.GCObject.155** null, i32 0)
  %cl = bitcast %union.GCObject.155* %call to %union.Closure.157*
  store %union.Closure.157* %cl, %union.Closure.157** %c, align 8
  %2 = load i32* %n.addr, align 4
  %conv3 = trunc i32 %2 to i8
  %3 = load %union.Closure.157** %c, align 8
  %c4 = bitcast %union.Closure.157* %3 to %struct.CClosure.156*
  %nupvalues = getelementptr inbounds %struct.CClosure.156* %c4, i32 0, i32 3
  store i8 %conv3, i8* %nupvalues, align 1
  %4 = load %union.Closure.157** %c, align 8
  ret %union.Closure.157* %4
}

; Function Attrs: nounwind uwtable
define hidden %union.Closure.157* @luaF_newLclosure(%struct.lua_State.154* %L, i32 %n) #0 {
entry:
  %L.addr = alloca %struct.lua_State.154*, align 8
  %n.addr = alloca i32, align 4
  %c = alloca %union.Closure.157*, align 8
  store %struct.lua_State.154* %L, %struct.lua_State.154** %L.addr, align 8
  store i32 %n, i32* %n.addr, align 4
  %0 = load %struct.lua_State.154** %L.addr, align 8
  %1 = load i32* %n.addr, align 4
  %sub = sub nsw i32 %1, 1
  %conv = sext i32 %sub to i64
  %mul = mul i64 8, %conv
  %conv1 = trunc i64 %mul to i32
  %add = add nsw i32 40, %conv1
  %conv2 = sext i32 %add to i64
  %call = call %union.GCObject.155* bitcast (%union.GCObject* (%struct.lua_State*, i32, i64, %union.GCObject**, i32)* @luaC_newobj to %union.GCObject.155* (%struct.lua_State.154*, i32, i64, %union.GCObject.155**, i32)*)(%struct.lua_State.154* %0, i32 6, i64 %conv2, %union.GCObject.155** null, i32 0)
  %cl = bitcast %union.GCObject.155* %call to %union.Closure.157*
  store %union.Closure.157* %cl, %union.Closure.157** %c, align 8
  %2 = load %union.Closure.157** %c, align 8
  %l = bitcast %union.Closure.157* %2 to %struct.LClosure.161*
  %p = getelementptr inbounds %struct.LClosure.161* %l, i32 0, i32 5
  store %struct.Proto.160* null, %struct.Proto.160** %p, align 8
  %3 = load i32* %n.addr, align 4
  %conv3 = trunc i32 %3 to i8
  %4 = load %union.Closure.157** %c, align 8
  %l4 = bitcast %union.Closure.157* %4 to %struct.LClosure.161*
  %nupvalues = getelementptr inbounds %struct.LClosure.161* %l4, i32 0, i32 3
  store i8 %conv3, i8* %nupvalues, align 1
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %5 = load i32* %n.addr, align 4
  %dec = add nsw i32 %5, -1
  store i32 %dec, i32* %n.addr, align 4
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %6 = load i32* %n.addr, align 4
  %idxprom = sext i32 %6 to i64
  %7 = load %union.Closure.157** %c, align 8
  %l5 = bitcast %union.Closure.157* %7 to %struct.LClosure.161*
  %upvals = getelementptr inbounds %struct.LClosure.161* %l5, i32 0, i32 6
  %arrayidx = getelementptr inbounds [1 x %struct.UpVal.140*]* %upvals, i32 0, i64 %idxprom
  store %struct.UpVal.140* null, %struct.UpVal.140** %arrayidx, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %8 = load %union.Closure.157** %c, align 8
  ret %union.Closure.157* %8
}

; Function Attrs: nounwind uwtable
define hidden %struct.UpVal.140* @luaF_newupval(%struct.lua_State.154* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State.154*, align 8
  %uv = alloca %struct.UpVal.140*, align 8
  store %struct.lua_State.154* %L, %struct.lua_State.154** %L.addr, align 8
  %0 = load %struct.lua_State.154** %L.addr, align 8
  %call = call %union.GCObject.155* bitcast (%union.GCObject* (%struct.lua_State*, i32, i64, %union.GCObject**, i32)* @luaC_newobj to %union.GCObject.155* (%struct.lua_State.154*, i32, i64, %union.GCObject.155**, i32)*)(%struct.lua_State.154* %0, i32 10, i64 40, %union.GCObject.155** null, i32 0)
  %uv1 = bitcast %union.GCObject.155* %call to %struct.UpVal.140*
  store %struct.UpVal.140* %uv1, %struct.UpVal.140** %uv, align 8
  %1 = load %struct.UpVal.140** %uv, align 8
  %u = getelementptr inbounds %struct.UpVal.140* %1, i32 0, i32 4
  %value = bitcast %union.anon.139* %u to %struct.lua_TValue.137*
  %2 = load %struct.UpVal.140** %uv, align 8
  %v = getelementptr inbounds %struct.UpVal.140* %2, i32 0, i32 3
  store %struct.lua_TValue.137* %value, %struct.lua_TValue.137** %v, align 8
  %3 = load %struct.UpVal.140** %uv, align 8
  %v2 = getelementptr inbounds %struct.UpVal.140* %3, i32 0, i32 3
  %4 = load %struct.lua_TValue.137** %v2, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue.137* %4, i32 0, i32 1
  store i32 0, i32* %tt_, align 4
  %5 = load %struct.UpVal.140** %uv, align 8
  ret %struct.UpVal.140* %5
}

; Function Attrs: nounwind uwtable
define hidden %struct.UpVal.140* @luaF_findupval(%struct.lua_State.154* %L, %struct.lua_TValue.137* %level) #0 {
entry:
  %retval = alloca %struct.UpVal.140*, align 8
  %L.addr = alloca %struct.lua_State.154*, align 8
  %level.addr = alloca %struct.lua_TValue.137*, align 8
  %g = alloca %struct.global_State.148*, align 8
  %pp = alloca %union.GCObject.155**, align 8
  %p = alloca %struct.UpVal.140*, align 8
  %uv = alloca %struct.UpVal.140*, align 8
  %o = alloca %union.GCObject.155*, align 8
  store %struct.lua_State.154* %L, %struct.lua_State.154** %L.addr, align 8
  store %struct.lua_TValue.137* %level, %struct.lua_TValue.137** %level.addr, align 8
  %0 = load %struct.lua_State.154** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State.154* %0, i32 0, i32 5
  %1 = load %struct.global_State.148** %l_G, align 8
  store %struct.global_State.148* %1, %struct.global_State.148** %g, align 8
  %2 = load %struct.lua_State.154** %L.addr, align 8
  %openupval = getelementptr inbounds %struct.lua_State.154* %2, i32 0, i32 18
  store %union.GCObject.155** %openupval, %union.GCObject.155*** %pp, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end13, %entry
  %3 = load %union.GCObject.155*** %pp, align 8
  %4 = load %union.GCObject.155** %3, align 8
  %cmp = icmp ne %union.GCObject.155* %4, null
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %5 = load %union.GCObject.155*** %pp, align 8
  %6 = load %union.GCObject.155** %5, align 8
  %uv1 = bitcast %union.GCObject.155* %6 to %struct.UpVal.140*
  store %struct.UpVal.140* %uv1, %struct.UpVal.140** %p, align 8
  %v = getelementptr inbounds %struct.UpVal.140* %uv1, i32 0, i32 3
  %7 = load %struct.lua_TValue.137** %v, align 8
  %8 = load %struct.lua_TValue.137** %level.addr, align 8
  %cmp2 = icmp uge %struct.lua_TValue.137* %7, %8
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %9 = phi i1 [ false, %while.cond ], [ %cmp2, %land.rhs ]
  br i1 %9, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %10 = load %struct.UpVal.140** %p, align 8
  %11 = bitcast %struct.UpVal.140* %10 to %union.GCObject.155*
  store %union.GCObject.155* %11, %union.GCObject.155** %o, align 8
  %12 = load %struct.UpVal.140** %p, align 8
  %v3 = getelementptr inbounds %struct.UpVal.140* %12, i32 0, i32 3
  %13 = load %struct.lua_TValue.137** %v3, align 8
  %14 = load %struct.lua_TValue.137** %level.addr, align 8
  %cmp4 = icmp eq %struct.lua_TValue.137* %13, %14
  br i1 %cmp4, label %if.then, label %if.end13

if.then:                                          ; preds = %while.body
  %15 = load %union.GCObject.155** %o, align 8
  %gch = bitcast %union.GCObject.155* %15 to %struct.GCheader.162*
  %marked = getelementptr inbounds %struct.GCheader.162* %gch, i32 0, i32 2
  %16 = load i8* %marked, align 1
  %conv = zext i8 %16 to i32
  %xor = xor i32 %conv, 3
  %17 = load %struct.global_State.148** %g, align 8
  %currentwhite = getelementptr inbounds %struct.global_State.148* %17, i32 0, i32 9
  %18 = load i8* %currentwhite, align 1
  %conv5 = zext i8 %18 to i32
  %xor6 = xor i32 %conv5, 3
  %and = and i32 %xor, %xor6
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then7

if.then7:                                         ; preds = %if.then
  %19 = load %union.GCObject.155** %o, align 8
  %gch8 = bitcast %union.GCObject.155* %19 to %struct.GCheader.162*
  %marked9 = getelementptr inbounds %struct.GCheader.162* %gch8, i32 0, i32 2
  %20 = load i8* %marked9, align 1
  %conv10 = zext i8 %20 to i32
  %xor11 = xor i32 %conv10, 3
  %conv12 = trunc i32 %xor11 to i8
  store i8 %conv12, i8* %marked9, align 1
  br label %if.end

if.end:                                           ; preds = %if.then7, %if.then
  %21 = load %struct.UpVal.140** %p, align 8
  store %struct.UpVal.140* %21, %struct.UpVal.140** %retval
  br label %return

if.end13:                                         ; preds = %while.body
  %22 = load %struct.UpVal.140** %p, align 8
  %next = getelementptr inbounds %struct.UpVal.140* %22, i32 0, i32 0
  store %union.GCObject.155** %next, %union.GCObject.155*** %pp, align 8
  br label %while.cond

while.end:                                        ; preds = %land.end
  %23 = load %struct.lua_State.154** %L.addr, align 8
  %24 = load %union.GCObject.155*** %pp, align 8
  %call = call %union.GCObject.155* bitcast (%union.GCObject* (%struct.lua_State*, i32, i64, %union.GCObject**, i32)* @luaC_newobj to %union.GCObject.155* (%struct.lua_State.154*, i32, i64, %union.GCObject.155**, i32)*)(%struct.lua_State.154* %23, i32 10, i64 40, %union.GCObject.155** %24, i32 0)
  %uv14 = bitcast %union.GCObject.155* %call to %struct.UpVal.140*
  store %struct.UpVal.140* %uv14, %struct.UpVal.140** %uv, align 8
  %25 = load %struct.lua_TValue.137** %level.addr, align 8
  %26 = load %struct.UpVal.140** %uv, align 8
  %v15 = getelementptr inbounds %struct.UpVal.140* %26, i32 0, i32 3
  store %struct.lua_TValue.137* %25, %struct.lua_TValue.137** %v15, align 8
  %27 = load %struct.global_State.148** %g, align 8
  %uvhead = getelementptr inbounds %struct.global_State.148* %27, i32 0, i32 24
  %28 = load %struct.UpVal.140** %uv, align 8
  %u = getelementptr inbounds %struct.UpVal.140* %28, i32 0, i32 4
  %l = bitcast %union.anon.139* %u to %struct.anon*
  %prev = getelementptr inbounds %struct.anon* %l, i32 0, i32 0
  store %struct.UpVal.140* %uvhead, %struct.UpVal.140** %prev, align 8
  %29 = load %struct.global_State.148** %g, align 8
  %uvhead16 = getelementptr inbounds %struct.global_State.148* %29, i32 0, i32 24
  %u17 = getelementptr inbounds %struct.UpVal.140* %uvhead16, i32 0, i32 4
  %l18 = bitcast %union.anon.139* %u17 to %struct.anon*
  %next19 = getelementptr inbounds %struct.anon* %l18, i32 0, i32 1
  %30 = load %struct.UpVal.140** %next19, align 8
  %31 = load %struct.UpVal.140** %uv, align 8
  %u20 = getelementptr inbounds %struct.UpVal.140* %31, i32 0, i32 4
  %l21 = bitcast %union.anon.139* %u20 to %struct.anon*
  %next22 = getelementptr inbounds %struct.anon* %l21, i32 0, i32 1
  store %struct.UpVal.140* %30, %struct.UpVal.140** %next22, align 8
  %32 = load %struct.UpVal.140** %uv, align 8
  %33 = load %struct.UpVal.140** %uv, align 8
  %u23 = getelementptr inbounds %struct.UpVal.140* %33, i32 0, i32 4
  %l24 = bitcast %union.anon.139* %u23 to %struct.anon*
  %next25 = getelementptr inbounds %struct.anon* %l24, i32 0, i32 1
  %34 = load %struct.UpVal.140** %next25, align 8
  %u26 = getelementptr inbounds %struct.UpVal.140* %34, i32 0, i32 4
  %l27 = bitcast %union.anon.139* %u26 to %struct.anon*
  %prev28 = getelementptr inbounds %struct.anon* %l27, i32 0, i32 0
  store %struct.UpVal.140* %32, %struct.UpVal.140** %prev28, align 8
  %35 = load %struct.UpVal.140** %uv, align 8
  %36 = load %struct.global_State.148** %g, align 8
  %uvhead29 = getelementptr inbounds %struct.global_State.148* %36, i32 0, i32 24
  %u30 = getelementptr inbounds %struct.UpVal.140* %uvhead29, i32 0, i32 4
  %l31 = bitcast %union.anon.139* %u30 to %struct.anon*
  %next32 = getelementptr inbounds %struct.anon* %l31, i32 0, i32 1
  store %struct.UpVal.140* %35, %struct.UpVal.140** %next32, align 8
  %37 = load %struct.UpVal.140** %uv, align 8
  store %struct.UpVal.140* %37, %struct.UpVal.140** %retval
  br label %return

return:                                           ; preds = %while.end, %if.end
  %38 = load %struct.UpVal.140** %retval
  ret %struct.UpVal.140* %38
}

; Function Attrs: nounwind uwtable
define hidden void @luaF_freeupval(%struct.lua_State.154* %L, %struct.UpVal.140* %uv) #0 {
entry:
  %L.addr = alloca %struct.lua_State.154*, align 8
  %uv.addr = alloca %struct.UpVal.140*, align 8
  store %struct.lua_State.154* %L, %struct.lua_State.154** %L.addr, align 8
  store %struct.UpVal.140* %uv, %struct.UpVal.140** %uv.addr, align 8
  %0 = load %struct.UpVal.140** %uv.addr, align 8
  %v = getelementptr inbounds %struct.UpVal.140* %0, i32 0, i32 3
  %1 = load %struct.lua_TValue.137** %v, align 8
  %2 = load %struct.UpVal.140** %uv.addr, align 8
  %u = getelementptr inbounds %struct.UpVal.140* %2, i32 0, i32 4
  %value = bitcast %union.anon.139* %u to %struct.lua_TValue.137*
  %cmp = icmp ne %struct.lua_TValue.137* %1, %value
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load %struct.UpVal.140** %uv.addr, align 8
  call void @unlinkupval(%struct.UpVal.140* %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load %struct.lua_State.154** %L.addr, align 8
  %5 = load %struct.UpVal.140** %uv.addr, align 8
  %6 = bitcast %struct.UpVal.140* %5 to i8*
  %call = call i8* bitcast (i8* (%struct.lua_State*, i8*, i64, i64)* @luaM_realloc_ to i8* (%struct.lua_State.154*, i8*, i64, i64)*)(%struct.lua_State.154* %4, i8* %6, i64 40, i64 0)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @luaF_close(%struct.lua_State.154* %L, %struct.lua_TValue.137* %level) #0 {
entry:
  %L.addr = alloca %struct.lua_State.154*, align 8
  %level.addr = alloca %struct.lua_TValue.137*, align 8
  %uv = alloca %struct.UpVal.140*, align 8
  %g = alloca %struct.global_State.148*, align 8
  %o = alloca %union.GCObject.155*, align 8
  %io2 = alloca %struct.lua_TValue.137*, align 8
  %io1 = alloca %struct.lua_TValue.137*, align 8
  store %struct.lua_State.154* %L, %struct.lua_State.154** %L.addr, align 8
  store %struct.lua_TValue.137* %level, %struct.lua_TValue.137** %level.addr, align 8
  %0 = load %struct.lua_State.154** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State.154* %0, i32 0, i32 5
  %1 = load %struct.global_State.148** %l_G, align 8
  store %struct.global_State.148* %1, %struct.global_State.148** %g, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %2 = load %struct.lua_State.154** %L.addr, align 8
  %openupval = getelementptr inbounds %struct.lua_State.154* %2, i32 0, i32 18
  %3 = load %union.GCObject.155** %openupval, align 8
  %cmp = icmp ne %union.GCObject.155* %3, null
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %4 = load %struct.lua_State.154** %L.addr, align 8
  %openupval1 = getelementptr inbounds %struct.lua_State.154* %4, i32 0, i32 18
  %5 = load %union.GCObject.155** %openupval1, align 8
  %uv2 = bitcast %union.GCObject.155* %5 to %struct.UpVal.140*
  store %struct.UpVal.140* %uv2, %struct.UpVal.140** %uv, align 8
  %v = getelementptr inbounds %struct.UpVal.140* %uv2, i32 0, i32 3
  %6 = load %struct.lua_TValue.137** %v, align 8
  %7 = load %struct.lua_TValue.137** %level.addr, align 8
  %cmp3 = icmp uge %struct.lua_TValue.137* %6, %7
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %8 = phi i1 [ false, %while.cond ], [ %cmp3, %land.rhs ]
  br i1 %8, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %9 = load %struct.UpVal.140** %uv, align 8
  %10 = bitcast %struct.UpVal.140* %9 to %union.GCObject.155*
  store %union.GCObject.155* %10, %union.GCObject.155** %o, align 8
  %11 = load %struct.UpVal.140** %uv, align 8
  %next = getelementptr inbounds %struct.UpVal.140* %11, i32 0, i32 0
  %12 = load %union.GCObject.155** %next, align 8
  %13 = load %struct.lua_State.154** %L.addr, align 8
  %openupval4 = getelementptr inbounds %struct.lua_State.154* %13, i32 0, i32 18
  store %union.GCObject.155* %12, %union.GCObject.155** %openupval4, align 8
  %14 = load %union.GCObject.155** %o, align 8
  %gch = bitcast %union.GCObject.155* %14 to %struct.GCheader.162*
  %marked = getelementptr inbounds %struct.GCheader.162* %gch, i32 0, i32 2
  %15 = load i8* %marked, align 1
  %conv = zext i8 %15 to i32
  %xor = xor i32 %conv, 3
  %16 = load %struct.global_State.148** %g, align 8
  %currentwhite = getelementptr inbounds %struct.global_State.148* %16, i32 0, i32 9
  %17 = load i8* %currentwhite, align 1
  %conv5 = zext i8 %17 to i32
  %xor6 = xor i32 %conv5, 3
  %and = and i32 %xor, %xor6
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %while.body
  %18 = load %struct.lua_State.154** %L.addr, align 8
  %19 = load %struct.UpVal.140** %uv, align 8
  call void @luaF_freeupval(%struct.lua_State.154* %18, %struct.UpVal.140* %19)
  br label %if.end

if.else:                                          ; preds = %while.body
  %20 = load %struct.UpVal.140** %uv, align 8
  call void @unlinkupval(%struct.UpVal.140* %20)
  %21 = load %struct.UpVal.140** %uv, align 8
  %v7 = getelementptr inbounds %struct.UpVal.140* %21, i32 0, i32 3
  %22 = load %struct.lua_TValue.137** %v7, align 8
  store %struct.lua_TValue.137* %22, %struct.lua_TValue.137** %io2, align 8
  %23 = load %struct.UpVal.140** %uv, align 8
  %u = getelementptr inbounds %struct.UpVal.140* %23, i32 0, i32 4
  %value = bitcast %union.anon.139* %u to %struct.lua_TValue.137*
  store %struct.lua_TValue.137* %value, %struct.lua_TValue.137** %io1, align 8
  %24 = load %struct.lua_TValue.137** %io1, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue.137* %24, i32 0, i32 0
  %25 = load %struct.lua_TValue.137** %io2, align 8
  %value_8 = getelementptr inbounds %struct.lua_TValue.137* %25, i32 0, i32 0
  %26 = bitcast %union.Value.136* %value_ to i8*
  %27 = bitcast %union.Value.136* %value_8 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %26, i8* %27, i64 8, i32 8, i1 false)
  %28 = load %struct.lua_TValue.137** %io2, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue.137* %28, i32 0, i32 1
  %29 = load i32* %tt_, align 4
  %30 = load %struct.lua_TValue.137** %io1, align 8
  %tt_9 = getelementptr inbounds %struct.lua_TValue.137* %30, i32 0, i32 1
  store i32 %29, i32* %tt_9, align 4
  %31 = load %struct.UpVal.140** %uv, align 8
  %u10 = getelementptr inbounds %struct.UpVal.140* %31, i32 0, i32 4
  %value11 = bitcast %union.anon.139* %u10 to %struct.lua_TValue.137*
  %32 = load %struct.UpVal.140** %uv, align 8
  %v12 = getelementptr inbounds %struct.UpVal.140* %32, i32 0, i32 3
  store %struct.lua_TValue.137* %value11, %struct.lua_TValue.137** %v12, align 8
  %33 = load %struct.global_State.148** %g, align 8
  %allgc = getelementptr inbounds %struct.global_State.148* %33, i32 0, i32 14
  %34 = load %union.GCObject.155** %allgc, align 8
  %35 = load %union.GCObject.155** %o, align 8
  %gch13 = bitcast %union.GCObject.155* %35 to %struct.GCheader.162*
  %next14 = getelementptr inbounds %struct.GCheader.162* %gch13, i32 0, i32 0
  store %union.GCObject.155* %34, %union.GCObject.155** %next14, align 8
  %36 = load %union.GCObject.155** %o, align 8
  %37 = load %struct.global_State.148** %g, align 8
  %allgc15 = getelementptr inbounds %struct.global_State.148* %37, i32 0, i32 14
  store %union.GCObject.155* %36, %union.GCObject.155** %allgc15, align 8
  %38 = load %struct.global_State.148** %g, align 8
  %39 = load %struct.UpVal.140** %uv, align 8
  call void bitcast (void (%struct.global_State*, %struct.UpVal*)* @luaC_checkupvalcolor to void (%struct.global_State.148*, %struct.UpVal.140*)*)(%struct.global_State.148* %38, %struct.UpVal.140* %39)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  br label %while.cond

while.end:                                        ; preds = %land.end
  ret void
}

; Function Attrs: nounwind uwtable
define hidden %struct.Proto.160* @luaF_newproto(%struct.lua_State.154* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State.154*, align 8
  %f = alloca %struct.Proto.160*, align 8
  store %struct.lua_State.154* %L, %struct.lua_State.154** %L.addr, align 8
  %0 = load %struct.lua_State.154** %L.addr, align 8
  %call = call %union.GCObject.155* bitcast (%union.GCObject* (%struct.lua_State*, i32, i64, %union.GCObject**, i32)* @luaC_newobj to %union.GCObject.155* (%struct.lua_State.154*, i32, i64, %union.GCObject.155**, i32)*)(%struct.lua_State.154* %0, i32 9, i64 128, %union.GCObject.155** null, i32 0)
  %p = bitcast %union.GCObject.155* %call to %struct.Proto.160*
  store %struct.Proto.160* %p, %struct.Proto.160** %f, align 8
  %1 = load %struct.Proto.160** %f, align 8
  %k = getelementptr inbounds %struct.Proto.160* %1, i32 0, i32 3
  store %struct.lua_TValue.137* null, %struct.lua_TValue.137** %k, align 8
  %2 = load %struct.Proto.160** %f, align 8
  %sizek = getelementptr inbounds %struct.Proto.160* %2, i32 0, i32 12
  store i32 0, i32* %sizek, align 4
  %3 = load %struct.Proto.160** %f, align 8
  %p1 = getelementptr inbounds %struct.Proto.160* %3, i32 0, i32 5
  store %struct.Proto.160** null, %struct.Proto.160*** %p1, align 8
  %4 = load %struct.Proto.160** %f, align 8
  %sizep = getelementptr inbounds %struct.Proto.160* %4, i32 0, i32 15
  store i32 0, i32* %sizep, align 4
  %5 = load %struct.Proto.160** %f, align 8
  %code = getelementptr inbounds %struct.Proto.160* %5, i32 0, i32 4
  store i32* null, i32** %code, align 8
  %6 = load %struct.Proto.160** %f, align 8
  %cache = getelementptr inbounds %struct.Proto.160* %6, i32 0, i32 9
  store %union.Closure.157* null, %union.Closure.157** %cache, align 8
  %7 = load %struct.Proto.160** %f, align 8
  %sizecode = getelementptr inbounds %struct.Proto.160* %7, i32 0, i32 13
  store i32 0, i32* %sizecode, align 4
  %8 = load %struct.Proto.160** %f, align 8
  %lineinfo = getelementptr inbounds %struct.Proto.160* %8, i32 0, i32 6
  store i32* null, i32** %lineinfo, align 8
  %9 = load %struct.Proto.160** %f, align 8
  %sizelineinfo = getelementptr inbounds %struct.Proto.160* %9, i32 0, i32 14
  store i32 0, i32* %sizelineinfo, align 4
  %10 = load %struct.Proto.160** %f, align 8
  %upvalues = getelementptr inbounds %struct.Proto.160* %10, i32 0, i32 8
  store %struct.Upvaldesc.159* null, %struct.Upvaldesc.159** %upvalues, align 8
  %11 = load %struct.Proto.160** %f, align 8
  %sizeupvalues = getelementptr inbounds %struct.Proto.160* %11, i32 0, i32 11
  store i32 0, i32* %sizeupvalues, align 4
  %12 = load %struct.Proto.160** %f, align 8
  %numparams = getelementptr inbounds %struct.Proto.160* %12, i32 0, i32 20
  store i8 0, i8* %numparams, align 1
  %13 = load %struct.Proto.160** %f, align 8
  %is_vararg = getelementptr inbounds %struct.Proto.160* %13, i32 0, i32 21
  store i8 0, i8* %is_vararg, align 1
  %14 = load %struct.Proto.160** %f, align 8
  %maxstacksize = getelementptr inbounds %struct.Proto.160* %14, i32 0, i32 22
  store i8 0, i8* %maxstacksize, align 1
  %15 = load %struct.Proto.160** %f, align 8
  %locvars = getelementptr inbounds %struct.Proto.160* %15, i32 0, i32 7
  store %struct.LocVar.158* null, %struct.LocVar.158** %locvars, align 8
  %16 = load %struct.Proto.160** %f, align 8
  %sizelocvars = getelementptr inbounds %struct.Proto.160* %16, i32 0, i32 16
  store i32 0, i32* %sizelocvars, align 4
  %17 = load %struct.Proto.160** %f, align 8
  %linedefined = getelementptr inbounds %struct.Proto.160* %17, i32 0, i32 17
  store i32 0, i32* %linedefined, align 4
  %18 = load %struct.Proto.160** %f, align 8
  %lastlinedefined = getelementptr inbounds %struct.Proto.160* %18, i32 0, i32 18
  store i32 0, i32* %lastlinedefined, align 4
  %19 = load %struct.Proto.160** %f, align 8
  %source = getelementptr inbounds %struct.Proto.160* %19, i32 0, i32 10
  store %union.TString.143* null, %union.TString.143** %source, align 8
  %20 = load %struct.Proto.160** %f, align 8
  ret %struct.Proto.160* %20
}

; Function Attrs: nounwind uwtable
define hidden void @luaF_freeproto(%struct.lua_State.154* %L, %struct.Proto.160* %f) #0 {
entry:
  %L.addr = alloca %struct.lua_State.154*, align 8
  %f.addr = alloca %struct.Proto.160*, align 8
  store %struct.lua_State.154* %L, %struct.lua_State.154** %L.addr, align 8
  store %struct.Proto.160* %f, %struct.Proto.160** %f.addr, align 8
  %0 = load %struct.lua_State.154** %L.addr, align 8
  %1 = load %struct.Proto.160** %f.addr, align 8
  %code = getelementptr inbounds %struct.Proto.160* %1, i32 0, i32 4
  %2 = load i32** %code, align 8
  %3 = bitcast i32* %2 to i8*
  %4 = load %struct.Proto.160** %f.addr, align 8
  %sizecode = getelementptr inbounds %struct.Proto.160* %4, i32 0, i32 13
  %5 = load i32* %sizecode, align 4
  %conv = sext i32 %5 to i64
  %mul = mul i64 %conv, 4
  %call = call i8* bitcast (i8* (%struct.lua_State*, i8*, i64, i64)* @luaM_realloc_ to i8* (%struct.lua_State.154*, i8*, i64, i64)*)(%struct.lua_State.154* %0, i8* %3, i64 %mul, i64 0)
  %6 = load %struct.lua_State.154** %L.addr, align 8
  %7 = load %struct.Proto.160** %f.addr, align 8
  %p = getelementptr inbounds %struct.Proto.160* %7, i32 0, i32 5
  %8 = load %struct.Proto.160*** %p, align 8
  %9 = bitcast %struct.Proto.160** %8 to i8*
  %10 = load %struct.Proto.160** %f.addr, align 8
  %sizep = getelementptr inbounds %struct.Proto.160* %10, i32 0, i32 15
  %11 = load i32* %sizep, align 4
  %conv1 = sext i32 %11 to i64
  %mul2 = mul i64 %conv1, 8
  %call3 = call i8* bitcast (i8* (%struct.lua_State*, i8*, i64, i64)* @luaM_realloc_ to i8* (%struct.lua_State.154*, i8*, i64, i64)*)(%struct.lua_State.154* %6, i8* %9, i64 %mul2, i64 0)
  %12 = load %struct.lua_State.154** %L.addr, align 8
  %13 = load %struct.Proto.160** %f.addr, align 8
  %k = getelementptr inbounds %struct.Proto.160* %13, i32 0, i32 3
  %14 = load %struct.lua_TValue.137** %k, align 8
  %15 = bitcast %struct.lua_TValue.137* %14 to i8*
  %16 = load %struct.Proto.160** %f.addr, align 8
  %sizek = getelementptr inbounds %struct.Proto.160* %16, i32 0, i32 12
  %17 = load i32* %sizek, align 4
  %conv4 = sext i32 %17 to i64
  %mul5 = mul i64 %conv4, 16
  %call6 = call i8* bitcast (i8* (%struct.lua_State*, i8*, i64, i64)* @luaM_realloc_ to i8* (%struct.lua_State.154*, i8*, i64, i64)*)(%struct.lua_State.154* %12, i8* %15, i64 %mul5, i64 0)
  %18 = load %struct.lua_State.154** %L.addr, align 8
  %19 = load %struct.Proto.160** %f.addr, align 8
  %lineinfo = getelementptr inbounds %struct.Proto.160* %19, i32 0, i32 6
  %20 = load i32** %lineinfo, align 8
  %21 = bitcast i32* %20 to i8*
  %22 = load %struct.Proto.160** %f.addr, align 8
  %sizelineinfo = getelementptr inbounds %struct.Proto.160* %22, i32 0, i32 14
  %23 = load i32* %sizelineinfo, align 4
  %conv7 = sext i32 %23 to i64
  %mul8 = mul i64 %conv7, 4
  %call9 = call i8* bitcast (i8* (%struct.lua_State*, i8*, i64, i64)* @luaM_realloc_ to i8* (%struct.lua_State.154*, i8*, i64, i64)*)(%struct.lua_State.154* %18, i8* %21, i64 %mul8, i64 0)
  %24 = load %struct.lua_State.154** %L.addr, align 8
  %25 = load %struct.Proto.160** %f.addr, align 8
  %locvars = getelementptr inbounds %struct.Proto.160* %25, i32 0, i32 7
  %26 = load %struct.LocVar.158** %locvars, align 8
  %27 = bitcast %struct.LocVar.158* %26 to i8*
  %28 = load %struct.Proto.160** %f.addr, align 8
  %sizelocvars = getelementptr inbounds %struct.Proto.160* %28, i32 0, i32 16
  %29 = load i32* %sizelocvars, align 4
  %conv10 = sext i32 %29 to i64
  %mul11 = mul i64 %conv10, 16
  %call12 = call i8* bitcast (i8* (%struct.lua_State*, i8*, i64, i64)* @luaM_realloc_ to i8* (%struct.lua_State.154*, i8*, i64, i64)*)(%struct.lua_State.154* %24, i8* %27, i64 %mul11, i64 0)
  %30 = load %struct.lua_State.154** %L.addr, align 8
  %31 = load %struct.Proto.160** %f.addr, align 8
  %upvalues = getelementptr inbounds %struct.Proto.160* %31, i32 0, i32 8
  %32 = load %struct.Upvaldesc.159** %upvalues, align 8
  %33 = bitcast %struct.Upvaldesc.159* %32 to i8*
  %34 = load %struct.Proto.160** %f.addr, align 8
  %sizeupvalues = getelementptr inbounds %struct.Proto.160* %34, i32 0, i32 11
  %35 = load i32* %sizeupvalues, align 4
  %conv13 = sext i32 %35 to i64
  %mul14 = mul i64 %conv13, 16
  %call15 = call i8* bitcast (i8* (%struct.lua_State*, i8*, i64, i64)* @luaM_realloc_ to i8* (%struct.lua_State.154*, i8*, i64, i64)*)(%struct.lua_State.154* %30, i8* %33, i64 %mul14, i64 0)
  %36 = load %struct.lua_State.154** %L.addr, align 8
  %37 = load %struct.Proto.160** %f.addr, align 8
  %38 = bitcast %struct.Proto.160* %37 to i8*
  %call16 = call i8* bitcast (i8* (%struct.lua_State*, i8*, i64, i64)* @luaM_realloc_ to i8* (%struct.lua_State.154*, i8*, i64, i64)*)(%struct.lua_State.154* %36, i8* %38, i64 128, i64 0)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden i8* @luaF_getlocalname(%struct.Proto.160* %f, i32 %local_number, i32 %pc) #0 {
entry:
  %retval = alloca i8*, align 8
  %f.addr = alloca %struct.Proto.160*, align 8
  %local_number.addr = alloca i32, align 4
  %pc.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.Proto.160* %f, %struct.Proto.160** %f.addr, align 8
  store i32 %local_number, i32* %local_number.addr, align 4
  store i32 %pc, i32* %pc.addr, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32* %i, align 4
  %1 = load %struct.Proto.160** %f.addr, align 8
  %sizelocvars = getelementptr inbounds %struct.Proto.160* %1, i32 0, i32 16
  %2 = load i32* %sizelocvars, align 4
  %cmp = icmp slt i32 %0, %2
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %3 = load i32* %i, align 4
  %idxprom = sext i32 %3 to i64
  %4 = load %struct.Proto.160** %f.addr, align 8
  %locvars = getelementptr inbounds %struct.Proto.160* %4, i32 0, i32 7
  %5 = load %struct.LocVar.158** %locvars, align 8
  %arrayidx = getelementptr inbounds %struct.LocVar.158* %5, i64 %idxprom
  %startpc = getelementptr inbounds %struct.LocVar.158* %arrayidx, i32 0, i32 1
  %6 = load i32* %startpc, align 4
  %7 = load i32* %pc.addr, align 4
  %cmp1 = icmp sle i32 %6, %7
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %8 = phi i1 [ false, %for.cond ], [ %cmp1, %land.rhs ]
  br i1 %8, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %9 = load i32* %pc.addr, align 4
  %10 = load i32* %i, align 4
  %idxprom2 = sext i32 %10 to i64
  %11 = load %struct.Proto.160** %f.addr, align 8
  %locvars3 = getelementptr inbounds %struct.Proto.160* %11, i32 0, i32 7
  %12 = load %struct.LocVar.158** %locvars3, align 8
  %arrayidx4 = getelementptr inbounds %struct.LocVar.158* %12, i64 %idxprom2
  %endpc = getelementptr inbounds %struct.LocVar.158* %arrayidx4, i32 0, i32 2
  %13 = load i32* %endpc, align 4
  %cmp5 = icmp slt i32 %9, %13
  br i1 %cmp5, label %if.then, label %if.end11

if.then:                                          ; preds = %for.body
  %14 = load i32* %local_number.addr, align 4
  %dec = add nsw i32 %14, -1
  store i32 %dec, i32* %local_number.addr, align 4
  %15 = load i32* %local_number.addr, align 4
  %cmp6 = icmp eq i32 %15, 0
  br i1 %cmp6, label %if.then7, label %if.end

if.then7:                                         ; preds = %if.then
  %16 = load i32* %i, align 4
  %idxprom8 = sext i32 %16 to i64
  %17 = load %struct.Proto.160** %f.addr, align 8
  %locvars9 = getelementptr inbounds %struct.Proto.160* %17, i32 0, i32 7
  %18 = load %struct.LocVar.158** %locvars9, align 8
  %arrayidx10 = getelementptr inbounds %struct.LocVar.158* %18, i64 %idxprom8
  %varname = getelementptr inbounds %struct.LocVar.158* %arrayidx10, i32 0, i32 0
  %19 = load %union.TString.143** %varname, align 8
  %add.ptr = getelementptr inbounds %union.TString.143* %19, i64 1
  %20 = bitcast %union.TString.143* %add.ptr to i8*
  store i8* %20, i8** %retval
  br label %return

if.end:                                           ; preds = %if.then
  br label %if.end11

if.end11:                                         ; preds = %if.end, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end11
  %21 = load i32* %i, align 4
  %inc = add nsw i32 %21, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %land.end
  store i8* null, i8** %retval
  br label %return

return:                                           ; preds = %for.end, %if.then7
  %22 = load i8** %retval
  ret i8* %22
}

; Function Attrs: nounwind uwtable
define internal void @unlinkupval(%struct.UpVal.140* %uv) #0 {
entry:
  %uv.addr = alloca %struct.UpVal.140*, align 8
  store %struct.UpVal.140* %uv, %struct.UpVal.140** %uv.addr, align 8
  %0 = load %struct.UpVal.140** %uv.addr, align 8
  %u = getelementptr inbounds %struct.UpVal.140* %0, i32 0, i32 4
  %l = bitcast %union.anon.139* %u to %struct.anon*
  %prev = getelementptr inbounds %struct.anon* %l, i32 0, i32 0
  %1 = load %struct.UpVal.140** %prev, align 8
  %2 = load %struct.UpVal.140** %uv.addr, align 8
  %u1 = getelementptr inbounds %struct.UpVal.140* %2, i32 0, i32 4
  %l2 = bitcast %union.anon.139* %u1 to %struct.anon*
  %next = getelementptr inbounds %struct.anon* %l2, i32 0, i32 1
  %3 = load %struct.UpVal.140** %next, align 8
  %u3 = getelementptr inbounds %struct.UpVal.140* %3, i32 0, i32 4
  %l4 = bitcast %union.anon.139* %u3 to %struct.anon*
  %prev5 = getelementptr inbounds %struct.anon* %l4, i32 0, i32 0
  store %struct.UpVal.140* %1, %struct.UpVal.140** %prev5, align 8
  %4 = load %struct.UpVal.140** %uv.addr, align 8
  %u6 = getelementptr inbounds %struct.UpVal.140* %4, i32 0, i32 4
  %l7 = bitcast %union.anon.139* %u6 to %struct.anon*
  %next8 = getelementptr inbounds %struct.anon* %l7, i32 0, i32 1
  %5 = load %struct.UpVal.140** %next8, align 8
  %6 = load %struct.UpVal.140** %uv.addr, align 8
  %u9 = getelementptr inbounds %struct.UpVal.140* %6, i32 0, i32 4
  %l10 = bitcast %union.anon.139* %u9 to %struct.anon*
  %prev11 = getelementptr inbounds %struct.anon* %l10, i32 0, i32 0
  %7 = load %struct.UpVal.140** %prev11, align 8
  %u12 = getelementptr inbounds %struct.UpVal.140* %7, i32 0, i32 4
  %l13 = bitcast %union.anon.139* %u12 to %struct.anon*
  %next14 = getelementptr inbounds %struct.anon* %l13, i32 0, i32 1
  store %struct.UpVal.140* %5, %struct.UpVal.140** %next14, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @luaC_barrier_(%struct.lua_State* %L, %union.GCObject* %o, %union.GCObject* %v) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %o.addr = alloca %union.GCObject*, align 8
  %v.addr = alloca %union.GCObject*, align 8
  %g = alloca %struct.global_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %union.GCObject* %o, %union.GCObject** %o.addr, align 8
  store %union.GCObject* %v, %union.GCObject** %v.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 5
  %1 = load %struct.global_State** %l_G, align 8
  store %struct.global_State* %1, %struct.global_State** %g, align 8
  %2 = load %struct.global_State** %g, align 8
  %gcstate = getelementptr inbounds %struct.global_State* %2, i32 0, i32 10
  %3 = load i8* %gcstate, align 1
  %conv = zext i8 %3 to i32
  %cmp = icmp sle i32 %conv, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %4 = load %struct.global_State** %g, align 8
  %5 = load %union.GCObject** %v.addr, align 8
  call void @reallymarkobject(%struct.global_State* %4, %union.GCObject* %5)
  br label %if.end

if.else:                                          ; preds = %entry
  %6 = load %union.GCObject** %o.addr, align 8
  %gch = bitcast %union.GCObject* %6 to %struct.GCheader*
  %marked = getelementptr inbounds %struct.GCheader* %gch, i32 0, i32 2
  %7 = load i8* %marked, align 1
  %conv2 = zext i8 %7 to i32
  %and = and i32 %conv2, -72
  %8 = load %struct.global_State** %g, align 8
  %currentwhite = getelementptr inbounds %struct.global_State* %8, i32 0, i32 9
  %9 = load i8* %currentwhite, align 1
  %conv3 = zext i8 %9 to i32
  %and4 = and i32 %conv3, 3
  %conv5 = trunc i32 %and4 to i8
  %conv6 = zext i8 %conv5 to i32
  %or = or i32 %and, %conv6
  %conv7 = trunc i32 %or to i8
  %10 = load %union.GCObject** %o.addr, align 8
  %gch8 = bitcast %union.GCObject* %10 to %struct.GCheader*
  %marked9 = getelementptr inbounds %struct.GCheader* %gch8, i32 0, i32 2
  store i8 %conv7, i8* %marked9, align 1
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @luaC_barrierback_(%struct.lua_State* %L, %union.GCObject* %o) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %o.addr = alloca %union.GCObject*, align 8
  %g = alloca %struct.global_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %union.GCObject* %o, %union.GCObject** %o.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 5
  %1 = load %struct.global_State** %l_G, align 8
  store %struct.global_State* %1, %struct.global_State** %g, align 8
  %2 = load %union.GCObject** %o.addr, align 8
  %gch = bitcast %union.GCObject* %2 to %struct.GCheader*
  %marked = getelementptr inbounds %struct.GCheader* %gch, i32 0, i32 2
  %3 = load i8* %marked, align 1
  %conv = zext i8 %3 to i32
  %and = and i32 %conv, 251
  %conv1 = trunc i32 %and to i8
  store i8 %conv1, i8* %marked, align 1
  %4 = load %struct.global_State** %g, align 8
  %grayagain = getelementptr inbounds %struct.global_State* %4, i32 0, i32 19
  %5 = load %union.GCObject** %grayagain, align 8
  %6 = load %union.GCObject** %o.addr, align 8
  %h = bitcast %union.GCObject* %6 to %struct.Table*
  %gclist = getelementptr inbounds %struct.Table* %h, i32 0, i32 9
  store %union.GCObject* %5, %union.GCObject** %gclist, align 8
  %7 = load %union.GCObject** %o.addr, align 8
  %8 = load %struct.global_State** %g, align 8
  %grayagain2 = getelementptr inbounds %struct.global_State* %8, i32 0, i32 19
  store %union.GCObject* %7, %union.GCObject** %grayagain2, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @luaC_barrierproto_(%struct.lua_State* %L, %struct.Proto* %p, %union.Closure* %c) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %p.addr = alloca %struct.Proto*, align 8
  %c.addr = alloca %union.Closure*, align 8
  %g = alloca %struct.global_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.Proto* %p, %struct.Proto** %p.addr, align 8
  store %union.Closure* %c, %union.Closure** %c.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 5
  %1 = load %struct.global_State** %l_G, align 8
  store %struct.global_State* %1, %struct.global_State** %g, align 8
  %2 = load %struct.Proto** %p.addr, align 8
  %cache = getelementptr inbounds %struct.Proto* %2, i32 0, i32 9
  %3 = load %union.Closure** %cache, align 8
  %cmp = icmp eq %union.Closure* %3, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %4 = load %union.Closure** %c.addr, align 8
  %5 = bitcast %union.Closure* %4 to %union.GCObject*
  %gch = bitcast %union.GCObject* %5 to %struct.GCheader*
  %marked = getelementptr inbounds %struct.GCheader* %gch, i32 0, i32 2
  %6 = load i8* %marked, align 1
  %conv = zext i8 %6 to i32
  %and = and i32 %conv, 3
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then
  %7 = load %struct.Proto** %p.addr, align 8
  %8 = bitcast %struct.Proto* %7 to %union.GCObject*
  %gch1 = bitcast %union.GCObject* %8 to %struct.GCheader*
  %marked2 = getelementptr inbounds %struct.GCheader* %gch1, i32 0, i32 2
  %9 = load i8* %marked2, align 1
  %conv3 = zext i8 %9 to i32
  %and4 = and i32 %conv3, 4
  %tobool5 = icmp ne i32 %and4, 0
  br i1 %tobool5, label %if.then6, label %if.end

if.then6:                                         ; preds = %land.lhs.true
  %10 = load %struct.lua_State** %L.addr, align 8
  %11 = load %struct.Proto** %p.addr, align 8
  %12 = bitcast %struct.Proto* %11 to %union.GCObject*
  %13 = load %union.Closure** %c.addr, align 8
  %14 = bitcast %union.Closure* %13 to %union.GCObject*
  call void @luaC_barrier_(%struct.lua_State* %10, %union.GCObject* %12, %union.GCObject* %14)
  br label %if.end

if.end:                                           ; preds = %if.then6, %land.lhs.true, %if.then
  br label %if.end13

if.else:                                          ; preds = %entry
  %15 = load %struct.Proto** %p.addr, align 8
  %16 = bitcast %struct.Proto* %15 to %union.GCObject*
  %gch7 = bitcast %union.GCObject* %16 to %struct.GCheader*
  %marked8 = getelementptr inbounds %struct.GCheader* %gch7, i32 0, i32 2
  %17 = load i8* %marked8, align 1
  %conv9 = zext i8 %17 to i32
  %and10 = and i32 %conv9, 251
  %conv11 = trunc i32 %and10 to i8
  store i8 %conv11, i8* %marked8, align 1
  %18 = load %struct.global_State** %g, align 8
  %grayagain = getelementptr inbounds %struct.global_State* %18, i32 0, i32 19
  %19 = load %union.GCObject** %grayagain, align 8
  %20 = load %struct.Proto** %p.addr, align 8
  %gclist = getelementptr inbounds %struct.Proto* %20, i32 0, i32 19
  store %union.GCObject* %19, %union.GCObject** %gclist, align 8
  %21 = load %struct.Proto** %p.addr, align 8
  %22 = bitcast %struct.Proto* %21 to %union.GCObject*
  %23 = load %struct.global_State** %g, align 8
  %grayagain12 = getelementptr inbounds %struct.global_State* %23, i32 0, i32 19
  store %union.GCObject* %22, %union.GCObject** %grayagain12, align 8
  br label %if.end13

if.end13:                                         ; preds = %if.else, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @luaC_checkupvalcolor(%struct.global_State* %g, %struct.UpVal* %uv) #0 {
entry:
  %g.addr = alloca %struct.global_State*, align 8
  %uv.addr = alloca %struct.UpVal*, align 8
  %o = alloca %union.GCObject*, align 8
  store %struct.global_State* %g, %struct.global_State** %g.addr, align 8
  store %struct.UpVal* %uv, %struct.UpVal** %uv.addr, align 8
  %0 = load %struct.UpVal** %uv.addr, align 8
  %1 = bitcast %struct.UpVal* %0 to %union.GCObject*
  store %union.GCObject* %1, %union.GCObject** %o, align 8
  %2 = load %union.GCObject** %o, align 8
  %gch = bitcast %union.GCObject* %2 to %struct.GCheader*
  %marked = getelementptr inbounds %struct.GCheader* %gch, i32 0, i32 2
  %3 = load i8* %marked, align 1
  %conv = zext i8 %3 to i32
  %and = and i32 %conv, 7
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end41, label %if.then

if.then:                                          ; preds = %entry
  %4 = load %struct.global_State** %g.addr, align 8
  %gckind = getelementptr inbounds %struct.global_State* %4, i32 0, i32 11
  %5 = load i8* %gckind, align 1
  %conv1 = zext i8 %5 to i32
  %cmp = icmp eq i32 %conv1, 2
  br i1 %cmp, label %if.then6, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %6 = load %struct.global_State** %g.addr, align 8
  %gcstate = getelementptr inbounds %struct.global_State* %6, i32 0, i32 10
  %7 = load i8* %gcstate, align 1
  %conv3 = zext i8 %7 to i32
  %cmp4 = icmp sle i32 %conv3, 1
  br i1 %cmp4, label %if.then6, label %if.else

if.then6:                                         ; preds = %lor.lhs.false, %if.then
  %8 = load %union.GCObject** %o, align 8
  %gch7 = bitcast %union.GCObject* %8 to %struct.GCheader*
  %marked8 = getelementptr inbounds %struct.GCheader* %gch7, i32 0, i32 2
  %9 = load i8* %marked8, align 1
  %conv9 = zext i8 %9 to i32
  %and10 = and i32 %conv9, 191
  %conv11 = trunc i32 %and10 to i8
  store i8 %conv11, i8* %marked8, align 1
  %10 = load %union.GCObject** %o, align 8
  %gch12 = bitcast %union.GCObject* %10 to %struct.GCheader*
  %marked13 = getelementptr inbounds %struct.GCheader* %gch12, i32 0, i32 2
  %11 = load i8* %marked13, align 1
  %conv14 = zext i8 %11 to i32
  %or = or i32 %conv14, 4
  %conv15 = trunc i32 %or to i8
  store i8 %conv15, i8* %marked13, align 1
  %12 = load %struct.UpVal** %uv.addr, align 8
  %v = getelementptr inbounds %struct.UpVal* %12, i32 0, i32 3
  %13 = load %struct.lua_TValue** %v, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %13, i32 0, i32 1
  %14 = load i32* %tt_, align 4
  %and16 = and i32 %14, 64
  %tobool17 = icmp ne i32 %and16, 0
  br i1 %tobool17, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then6
  %15 = load %struct.UpVal** %uv.addr, align 8
  %v18 = getelementptr inbounds %struct.UpVal* %15, i32 0, i32 3
  %16 = load %struct.lua_TValue** %v18, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %16, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %17 = load %union.GCObject** %gc, align 8
  %gch19 = bitcast %union.GCObject* %17 to %struct.GCheader*
  %marked20 = getelementptr inbounds %struct.GCheader* %gch19, i32 0, i32 2
  %18 = load i8* %marked20, align 1
  %conv21 = zext i8 %18 to i32
  %and22 = and i32 %conv21, 3
  %tobool23 = icmp ne i32 %and22, 0
  br i1 %tobool23, label %if.then24, label %if.end

if.then24:                                        ; preds = %land.lhs.true
  %19 = load %struct.global_State** %g.addr, align 8
  %20 = load %struct.UpVal** %uv.addr, align 8
  %v25 = getelementptr inbounds %struct.UpVal* %20, i32 0, i32 3
  %21 = load %struct.lua_TValue** %v25, align 8
  %value_26 = getelementptr inbounds %struct.lua_TValue* %21, i32 0, i32 0
  %gc27 = bitcast %union.Value* %value_26 to %union.GCObject**
  %22 = load %union.GCObject** %gc27, align 8
  call void @reallymarkobject(%struct.global_State* %19, %union.GCObject* %22)
  br label %if.end

if.end:                                           ; preds = %if.then24, %land.lhs.true, %if.then6
  br label %if.end40

if.else:                                          ; preds = %lor.lhs.false
  %23 = load %union.GCObject** %o, align 8
  %gch28 = bitcast %union.GCObject* %23 to %struct.GCheader*
  %marked29 = getelementptr inbounds %struct.GCheader* %gch28, i32 0, i32 2
  %24 = load i8* %marked29, align 1
  %conv30 = zext i8 %24 to i32
  %and31 = and i32 %conv30, -72
  %25 = load %struct.global_State** %g.addr, align 8
  %currentwhite = getelementptr inbounds %struct.global_State* %25, i32 0, i32 9
  %26 = load i8* %currentwhite, align 1
  %conv32 = zext i8 %26 to i32
  %and33 = and i32 %conv32, 3
  %conv34 = trunc i32 %and33 to i8
  %conv35 = zext i8 %conv34 to i32
  %or36 = or i32 %and31, %conv35
  %conv37 = trunc i32 %or36 to i8
  %27 = load %union.GCObject** %o, align 8
  %gch38 = bitcast %union.GCObject* %27 to %struct.GCheader*
  %marked39 = getelementptr inbounds %struct.GCheader* %gch38, i32 0, i32 2
  store i8 %conv37, i8* %marked39, align 1
  br label %if.end40

if.end40:                                         ; preds = %if.else, %if.end
  br label %if.end41

if.end41:                                         ; preds = %if.end40, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define hidden %union.GCObject* @luaC_newobj(%struct.lua_State* %L, i32 %tt, i64 %sz, %union.GCObject** %list, i32 %offset) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %tt.addr = alloca i32, align 4
  %sz.addr = alloca i64, align 8
  %list.addr = alloca %union.GCObject**, align 8
  %offset.addr = alloca i32, align 4
  %g = alloca %struct.global_State*, align 8
  %raw = alloca i8*, align 8
  %o = alloca %union.GCObject*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %tt, i32* %tt.addr, align 4
  store i64 %sz, i64* %sz.addr, align 8
  store %union.GCObject** %list, %union.GCObject*** %list.addr, align 8
  store i32 %offset, i32* %offset.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 5
  %1 = load %struct.global_State** %l_G, align 8
  store %struct.global_State* %1, %struct.global_State** %g, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load i32* %tt.addr, align 4
  %and = and i32 %3, 15
  %conv = sext i32 %and to i64
  %4 = load i64* %sz.addr, align 8
  %call = call i8* @luaM_realloc_(%struct.lua_State* %2, i8* null, i64 %conv, i64 %4)
  store i8* %call, i8** %raw, align 8
  %5 = load i8** %raw, align 8
  %6 = load i32* %offset.addr, align 4
  %idx.ext = sext i32 %6 to i64
  %add.ptr = getelementptr inbounds i8* %5, i64 %idx.ext
  %7 = bitcast i8* %add.ptr to %union.GCObject*
  store %union.GCObject* %7, %union.GCObject** %o, align 8
  %8 = load %union.GCObject*** %list.addr, align 8
  %cmp = icmp eq %union.GCObject** %8, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %9 = load %struct.global_State** %g, align 8
  %allgc = getelementptr inbounds %struct.global_State* %9, i32 0, i32 14
  store %union.GCObject** %allgc, %union.GCObject*** %list.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %10 = load %struct.global_State** %g, align 8
  %currentwhite = getelementptr inbounds %struct.global_State* %10, i32 0, i32 9
  %11 = load i8* %currentwhite, align 1
  %conv2 = zext i8 %11 to i32
  %and3 = and i32 %conv2, 3
  %conv4 = trunc i32 %and3 to i8
  %12 = load %union.GCObject** %o, align 8
  %gch = bitcast %union.GCObject* %12 to %struct.GCheader*
  %marked = getelementptr inbounds %struct.GCheader* %gch, i32 0, i32 2
  store i8 %conv4, i8* %marked, align 1
  %13 = load i32* %tt.addr, align 4
  %conv5 = trunc i32 %13 to i8
  %14 = load %union.GCObject** %o, align 8
  %gch6 = bitcast %union.GCObject* %14 to %struct.GCheader*
  %tt7 = getelementptr inbounds %struct.GCheader* %gch6, i32 0, i32 1
  store i8 %conv5, i8* %tt7, align 1
  %15 = load %union.GCObject*** %list.addr, align 8
  %16 = load %union.GCObject** %15, align 8
  %17 = load %union.GCObject** %o, align 8
  %gch8 = bitcast %union.GCObject* %17 to %struct.GCheader*
  %next = getelementptr inbounds %struct.GCheader* %gch8, i32 0, i32 0
  store %union.GCObject* %16, %union.GCObject** %next, align 8
  %18 = load %union.GCObject** %o, align 8
  %19 = load %union.GCObject*** %list.addr, align 8
  store %union.GCObject* %18, %union.GCObject** %19, align 8
  %20 = load %union.GCObject** %o, align 8
  ret %union.GCObject* %20
}

; Function Attrs: nounwind uwtable
define hidden void @luaC_checkfinalizer(%struct.lua_State* %L, %union.GCObject* %o, %struct.Table* %mt) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %o.addr = alloca %union.GCObject*, align 8
  %mt.addr = alloca %struct.Table*, align 8
  %g = alloca %struct.global_State*, align 8
  %p = alloca %union.GCObject**, align 8
  %ho = alloca %struct.GCheader*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %union.GCObject* %o, %union.GCObject** %o.addr, align 8
  store %struct.Table* %mt, %struct.Table** %mt.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 5
  %1 = load %struct.global_State** %l_G, align 8
  store %struct.global_State* %1, %struct.global_State** %g, align 8
  %2 = load %union.GCObject** %o.addr, align 8
  %gch = bitcast %union.GCObject* %2 to %struct.GCheader*
  %marked = getelementptr inbounds %struct.GCheader* %gch, i32 0, i32 2
  %3 = load i8* %marked, align 1
  %conv = zext i8 %3 to i32
  %and = and i32 %conv, 16
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %4 = load %union.GCObject** %o.addr, align 8
  %gch1 = bitcast %union.GCObject* %4 to %struct.GCheader*
  %marked2 = getelementptr inbounds %struct.GCheader* %gch1, i32 0, i32 2
  %5 = load i8* %marked2, align 1
  %conv3 = zext i8 %5 to i32
  %and4 = and i32 %conv3, 8
  %tobool5 = icmp ne i32 %and4, 0
  br i1 %tobool5, label %if.then, label %lor.lhs.false6

lor.lhs.false6:                                   ; preds = %lor.lhs.false
  %6 = load %struct.Table** %mt.addr, align 8
  %cmp = icmp eq %struct.Table* %6, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %lor.lhs.false6
  br label %cond.end13

cond.false:                                       ; preds = %lor.lhs.false6
  %7 = load %struct.Table** %mt.addr, align 8
  %flags = getelementptr inbounds %struct.Table* %7, i32 0, i32 3
  %8 = load i8* %flags, align 1
  %conv8 = zext i8 %8 to i32
  %and9 = and i32 %conv8, 4
  %tobool10 = icmp ne i32 %and9, 0
  br i1 %tobool10, label %cond.true11, label %cond.false12

cond.true11:                                      ; preds = %cond.false
  br label %cond.end

cond.false12:                                     ; preds = %cond.false
  %9 = load %struct.Table** %mt.addr, align 8
  %10 = load %struct.global_State** %g, align 8
  %tmname = getelementptr inbounds %struct.global_State* %10, i32 0, i32 33
  %arrayidx = getelementptr inbounds [17 x %union.TString*]* %tmname, i32 0, i64 2
  %11 = load %union.TString** %arrayidx, align 8
  %call = call %struct.lua_TValue* @luaT_gettm(%struct.Table* %9, i32 2, %union.TString* %11)
  br label %cond.end

cond.end:                                         ; preds = %cond.false12, %cond.true11
  %cond = phi %struct.lua_TValue* [ null, %cond.true11 ], [ %call, %cond.false12 ]
  br label %cond.end13

cond.end13:                                       ; preds = %cond.end, %cond.true
  %cond14 = phi %struct.lua_TValue* [ null, %cond.true ], [ %cond, %cond.end ]
  %cmp15 = icmp eq %struct.lua_TValue* %cond14, null
  br i1 %cmp15, label %if.then, label %if.else

if.then:                                          ; preds = %cond.end13, %lor.lhs.false, %entry
  br label %if.end57

if.else:                                          ; preds = %cond.end13
  %12 = load %union.GCObject** %o.addr, align 8
  %gch17 = bitcast %union.GCObject* %12 to %struct.GCheader*
  store %struct.GCheader* %gch17, %struct.GCheader** %ho, align 8
  %13 = load %struct.global_State** %g, align 8
  %sweepgc = getelementptr inbounds %struct.global_State* %13, i32 0, i32 16
  %14 = load %union.GCObject*** %sweepgc, align 8
  %15 = load %struct.GCheader** %ho, align 8
  %next = getelementptr inbounds %struct.GCheader* %15, i32 0, i32 0
  %cmp18 = icmp eq %union.GCObject** %14, %next
  br i1 %cmp18, label %if.then20, label %if.end

if.then20:                                        ; preds = %if.else
  %16 = load %struct.lua_State** %L.addr, align 8
  %17 = load %struct.global_State** %g, align 8
  %sweepgc21 = getelementptr inbounds %struct.global_State* %17, i32 0, i32 16
  %18 = load %union.GCObject*** %sweepgc21, align 8
  %call22 = call %union.GCObject** @sweeptolive(%struct.lua_State* %16, %union.GCObject** %18, i32* null)
  %19 = load %struct.global_State** %g, align 8
  %sweepgc23 = getelementptr inbounds %struct.global_State* %19, i32 0, i32 16
  store %union.GCObject** %call22, %union.GCObject*** %sweepgc23, align 8
  br label %if.end

if.end:                                           ; preds = %if.then20, %if.else
  %20 = load %struct.global_State** %g, align 8
  %allgc = getelementptr inbounds %struct.global_State* %20, i32 0, i32 14
  store %union.GCObject** %allgc, %union.GCObject*** %p, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %21 = load %union.GCObject*** %p, align 8
  %22 = load %union.GCObject** %21, align 8
  %23 = load %union.GCObject** %o.addr, align 8
  %cmp24 = icmp ne %union.GCObject* %22, %23
  br i1 %cmp24, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %24 = load %union.GCObject*** %p, align 8
  %25 = load %union.GCObject** %24, align 8
  %gch26 = bitcast %union.GCObject* %25 to %struct.GCheader*
  %next27 = getelementptr inbounds %struct.GCheader* %gch26, i32 0, i32 0
  store %union.GCObject** %next27, %union.GCObject*** %p, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %26 = load %struct.GCheader** %ho, align 8
  %next28 = getelementptr inbounds %struct.GCheader* %26, i32 0, i32 0
  %27 = load %union.GCObject** %next28, align 8
  %28 = load %union.GCObject*** %p, align 8
  store %union.GCObject* %27, %union.GCObject** %28, align 8
  %29 = load %struct.global_State** %g, align 8
  %finobj = getelementptr inbounds %struct.global_State* %29, i32 0, i32 15
  %30 = load %union.GCObject** %finobj, align 8
  %31 = load %struct.GCheader** %ho, align 8
  %next29 = getelementptr inbounds %struct.GCheader* %31, i32 0, i32 0
  store %union.GCObject* %30, %union.GCObject** %next29, align 8
  %32 = load %union.GCObject** %o.addr, align 8
  %33 = load %struct.global_State** %g, align 8
  %finobj30 = getelementptr inbounds %struct.global_State* %33, i32 0, i32 15
  store %union.GCObject* %32, %union.GCObject** %finobj30, align 8
  %34 = load %struct.GCheader** %ho, align 8
  %marked31 = getelementptr inbounds %struct.GCheader* %34, i32 0, i32 2
  %35 = load i8* %marked31, align 1
  %conv32 = zext i8 %35 to i32
  %or = or i32 %conv32, 16
  %conv33 = trunc i32 %or to i8
  store i8 %conv33, i8* %marked31, align 1
  %36 = load %struct.global_State** %g, align 8
  %gcstate = getelementptr inbounds %struct.global_State* %36, i32 0, i32 10
  %37 = load i8* %gcstate, align 1
  %conv34 = zext i8 %37 to i32
  %cmp35 = icmp sle i32 %conv34, 1
  br i1 %cmp35, label %if.else50, label %if.then37

if.then37:                                        ; preds = %for.end
  %38 = load %union.GCObject** %o.addr, align 8
  %gch38 = bitcast %union.GCObject* %38 to %struct.GCheader*
  %marked39 = getelementptr inbounds %struct.GCheader* %gch38, i32 0, i32 2
  %39 = load i8* %marked39, align 1
  %conv40 = zext i8 %39 to i32
  %and41 = and i32 %conv40, -72
  %40 = load %struct.global_State** %g, align 8
  %currentwhite = getelementptr inbounds %struct.global_State* %40, i32 0, i32 9
  %41 = load i8* %currentwhite, align 1
  %conv42 = zext i8 %41 to i32
  %and43 = and i32 %conv42, 3
  %conv44 = trunc i32 %and43 to i8
  %conv45 = zext i8 %conv44 to i32
  %or46 = or i32 %and41, %conv45
  %conv47 = trunc i32 %or46 to i8
  %42 = load %union.GCObject** %o.addr, align 8
  %gch48 = bitcast %union.GCObject* %42 to %struct.GCheader*
  %marked49 = getelementptr inbounds %struct.GCheader* %gch48, i32 0, i32 2
  store i8 %conv47, i8* %marked49, align 1
  br label %if.end56

if.else50:                                        ; preds = %for.end
  %43 = load %union.GCObject** %o.addr, align 8
  %gch51 = bitcast %union.GCObject* %43 to %struct.GCheader*
  %marked52 = getelementptr inbounds %struct.GCheader* %gch51, i32 0, i32 2
  %44 = load i8* %marked52, align 1
  %conv53 = zext i8 %44 to i32
  %and54 = and i32 %conv53, 191
  %conv55 = trunc i32 %and54 to i8
  store i8 %conv55, i8* %marked52, align 1
  br label %if.end56

if.end56:                                         ; preds = %if.else50, %if.then37
  br label %if.end57

if.end57:                                         ; preds = %if.end56, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @luaC_changemode(%struct.lua_State* %L, i32 %mode) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %mode.addr = alloca i32, align 4
  %g = alloca %struct.global_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %mode, i32* %mode.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 5
  %1 = load %struct.global_State** %l_G, align 8
  store %struct.global_State* %1, %struct.global_State** %g, align 8
  %2 = load i32* %mode.addr, align 4
  %3 = load %struct.global_State** %g, align 8
  %gckind = getelementptr inbounds %struct.global_State* %3, i32 0, i32 11
  %4 = load i8* %gckind, align 1
  %conv = zext i8 %4 to i32
  %cmp = icmp eq i32 %2, %conv
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end7

if.end:                                           ; preds = %entry
  %5 = load i32* %mode.addr, align 4
  %cmp2 = icmp eq i32 %5, 2
  br i1 %cmp2, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.end
  %6 = load %struct.lua_State** %L.addr, align 8
  call void @luaC_runtilstate(%struct.lua_State* %6, i32 1)
  %7 = load %struct.global_State** %g, align 8
  %totalbytes = getelementptr inbounds %struct.global_State* %7, i32 0, i32 2
  %8 = load i64* %totalbytes, align 8
  %9 = load %struct.global_State** %g, align 8
  %GCdebt = getelementptr inbounds %struct.global_State* %9, i32 0, i32 3
  %10 = load i64* %GCdebt, align 8
  %add = add i64 %8, %10
  %11 = load %struct.global_State** %g, align 8
  %GCestimate = getelementptr inbounds %struct.global_State* %11, i32 0, i32 5
  store i64 %add, i64* %GCestimate, align 8
  %12 = load %struct.global_State** %g, align 8
  %gckind5 = getelementptr inbounds %struct.global_State* %12, i32 0, i32 11
  store i8 2, i8* %gckind5, align 1
  br label %if.end7

if.else:                                          ; preds = %if.end
  %13 = load %struct.global_State** %g, align 8
  %gckind6 = getelementptr inbounds %struct.global_State* %13, i32 0, i32 11
  store i8 0, i8* %gckind6, align 1
  %14 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @entersweep(%struct.lua_State* %14)
  %15 = load %struct.lua_State** %L.addr, align 8
  call void @luaC_runtilstate(%struct.lua_State* %15, i32 -29)
  br label %if.end7

if.end7:                                          ; preds = %if.else, %if.then4, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @luaC_runtilstate(%struct.lua_State* %L, i32 %statesmask) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %statesmask.addr = alloca i32, align 4
  %g = alloca %struct.global_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %statesmask, i32* %statesmask.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 5
  %1 = load %struct.global_State** %l_G, align 8
  store %struct.global_State* %1, %struct.global_State** %g, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %2 = load i32* %statesmask.addr, align 4
  %3 = load %struct.global_State** %g, align 8
  %gcstate = getelementptr inbounds %struct.global_State* %3, i32 0, i32 10
  %4 = load i8* %gcstate, align 1
  %conv = zext i8 %4 to i32
  %shl = shl i32 1, %conv
  %and = and i32 %2, %shl
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %5 = load %struct.lua_State** %L.addr, align 8
  %call = call i64 @singlestep(%struct.lua_State* %5)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @luaC_freeallobjects(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %g = alloca %struct.global_State*, align 8
  %i = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 5
  %1 = load %struct.global_State** %l_G, align 8
  store %struct.global_State* %1, %struct.global_State** %g, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  call void @separatetobefnz(%struct.lua_State* %2, i32 1)
  %3 = load %struct.lua_State** %L.addr, align 8
  call void @callallpendingfinalizers(%struct.lua_State* %3, i32 0)
  %4 = load %struct.global_State** %g, align 8
  %currentwhite = getelementptr inbounds %struct.global_State* %4, i32 0, i32 9
  store i8 3, i8* %currentwhite, align 1
  %5 = load %struct.global_State** %g, align 8
  %gckind = getelementptr inbounds %struct.global_State* %5, i32 0, i32 11
  store i8 0, i8* %gckind, align 1
  %6 = load %struct.lua_State** %L.addr, align 8
  %7 = load %struct.global_State** %g, align 8
  %finobj = getelementptr inbounds %struct.global_State* %7, i32 0, i32 15
  %call = call %union.GCObject** @sweeplist(%struct.lua_State* %6, %union.GCObject** %finobj, i64 -3)
  %8 = load %struct.lua_State** %L.addr, align 8
  %9 = load %struct.global_State** %g, align 8
  %allgc = getelementptr inbounds %struct.global_State* %9, i32 0, i32 14
  %call1 = call %union.GCObject** @sweeplist(%struct.lua_State* %8, %union.GCObject** %allgc, i64 -3)
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32* %i, align 4
  %11 = load %struct.global_State** %g, align 8
  %strt = getelementptr inbounds %struct.global_State* %11, i32 0, i32 6
  %size = getelementptr inbounds %struct.stringtable* %strt, i32 0, i32 2
  %12 = load i32* %size, align 4
  %cmp = icmp slt i32 %10, %12
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %13 = load %struct.lua_State** %L.addr, align 8
  %14 = load i32* %i, align 4
  %idxprom = sext i32 %14 to i64
  %15 = load %struct.global_State** %g, align 8
  %strt2 = getelementptr inbounds %struct.global_State* %15, i32 0, i32 6
  %hash = getelementptr inbounds %struct.stringtable* %strt2, i32 0, i32 0
  %16 = load %union.GCObject*** %hash, align 8
  %arrayidx = getelementptr inbounds %union.GCObject** %16, i64 %idxprom
  %call3 = call %union.GCObject** @sweeplist(%struct.lua_State* %13, %union.GCObject** %arrayidx, i64 -3)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %17 = load i32* %i, align 4
  %inc = add nsw i32 %17, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @luaC_forcestep(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %g = alloca %struct.global_State*, align 8
  %i = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 5
  %1 = load %struct.global_State** %l_G, align 8
  store %struct.global_State* %1, %struct.global_State** %g, align 8
  %2 = load %struct.global_State** %g, align 8
  %gckind = getelementptr inbounds %struct.global_State* %2, i32 0, i32 11
  %3 = load i8* %gckind, align 1
  %conv = zext i8 %3 to i32
  %cmp = icmp eq i32 %conv, 2
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %4 = load %struct.lua_State** %L.addr, align 8
  call void @generationalcollection(%struct.lua_State* %4)
  br label %if.end

if.else:                                          ; preds = %entry
  %5 = load %struct.lua_State** %L.addr, align 8
  call void @incstep(%struct.lua_State* %5)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %6 = load %struct.global_State** %g, align 8
  %tobefnz = getelementptr inbounds %struct.global_State* %6, i32 0, i32 23
  %7 = load %union.GCObject** %tobefnz, align 8
  %tobool = icmp ne %union.GCObject* %7, null
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %8 = load i32* %i, align 4
  %cmp2 = icmp slt i32 %8, 4
  br i1 %cmp2, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.rhs
  %9 = load %struct.global_State** %g, align 8
  %gcstate = getelementptr inbounds %struct.global_State* %9, i32 0, i32 10
  %10 = load i8* %gcstate, align 1
  %conv4 = zext i8 %10 to i32
  %cmp5 = icmp eq i32 %conv4, 5
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.rhs
  %11 = phi i1 [ true, %land.rhs ], [ %cmp5, %lor.rhs ]
  br label %land.end

land.end:                                         ; preds = %lor.end, %for.cond
  %12 = phi i1 [ false, %for.cond ], [ %11, %lor.end ]
  br i1 %12, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %13 = load %struct.lua_State** %L.addr, align 8
  call void @GCTM(%struct.lua_State* %13, i32 1)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %14 = load i32* %i, align 4
  %inc = add nsw i32 %14, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %land.end
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @luaC_step(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %g = alloca %struct.global_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 5
  %1 = load %struct.global_State** %l_G, align 8
  store %struct.global_State* %1, %struct.global_State** %g, align 8
  %2 = load %struct.global_State** %g, align 8
  %gcrunning = getelementptr inbounds %struct.global_State* %2, i32 0, i32 12
  %3 = load i8* %gcrunning, align 1
  %tobool = icmp ne i8 %3, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %4 = load %struct.lua_State** %L.addr, align 8
  call void @luaC_forcestep(%struct.lua_State* %4)
  br label %if.end

if.else:                                          ; preds = %entry
  %5 = load %struct.global_State** %g, align 8
  call void bitcast (void (%struct.global_State.337*, i64)* @luaE_setdebt to void (%struct.global_State*, i64)*)(%struct.global_State* %5, i64 -2400)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @luaC_fullgc(%struct.lua_State* %L, i32 %isemergency) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %isemergency.addr = alloca i32, align 4
  %g = alloca %struct.global_State*, align 8
  %origkind = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %isemergency, i32* %isemergency.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 5
  %1 = load %struct.global_State** %l_G, align 8
  store %struct.global_State* %1, %struct.global_State** %g, align 8
  %2 = load %struct.global_State** %g, align 8
  %gckind = getelementptr inbounds %struct.global_State* %2, i32 0, i32 11
  %3 = load i8* %gckind, align 1
  %conv = zext i8 %3 to i32
  store i32 %conv, i32* %origkind, align 4
  %4 = load i32* %isemergency.addr, align 4
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %5 = load %struct.global_State** %g, align 8
  %gckind1 = getelementptr inbounds %struct.global_State* %5, i32 0, i32 11
  store i8 1, i8* %gckind1, align 1
  br label %if.end

if.else:                                          ; preds = %entry
  %6 = load %struct.global_State** %g, align 8
  %gckind2 = getelementptr inbounds %struct.global_State* %6, i32 0, i32 11
  store i8 0, i8* %gckind2, align 1
  %7 = load %struct.lua_State** %L.addr, align 8
  call void @callallpendingfinalizers(%struct.lua_State* %7, i32 1)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %8 = load %struct.global_State** %g, align 8
  %gckind3 = getelementptr inbounds %struct.global_State* %8, i32 0, i32 11
  %9 = load i8* %gckind3, align 1
  %conv4 = zext i8 %9 to i32
  %cmp = icmp eq i32 %conv4, 2
  br i1 %cmp, label %if.then9, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %10 = load %struct.global_State** %g, align 8
  %gcstate = getelementptr inbounds %struct.global_State* %10, i32 0, i32 10
  %11 = load i8* %gcstate, align 1
  %conv6 = zext i8 %11 to i32
  %cmp7 = icmp sle i32 %conv6, 1
  br i1 %cmp7, label %if.then9, label %if.end10

if.then9:                                         ; preds = %lor.lhs.false, %if.end
  %12 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @entersweep(%struct.lua_State* %12)
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %lor.lhs.false
  %13 = load %struct.lua_State** %L.addr, align 8
  call void @luaC_runtilstate(%struct.lua_State* %13, i32 32)
  %14 = load %struct.lua_State** %L.addr, align 8
  call void @luaC_runtilstate(%struct.lua_State* %14, i32 -33)
  %15 = load %struct.lua_State** %L.addr, align 8
  call void @luaC_runtilstate(%struct.lua_State* %15, i32 32)
  %16 = load i32* %origkind, align 4
  %cmp11 = icmp eq i32 %16, 2
  br i1 %cmp11, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end10
  %17 = load %struct.lua_State** %L.addr, align 8
  call void @luaC_runtilstate(%struct.lua_State* %17, i32 1)
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %if.end10
  %18 = load i32* %origkind, align 4
  %conv15 = trunc i32 %18 to i8
  %19 = load %struct.global_State** %g, align 8
  %gckind16 = getelementptr inbounds %struct.global_State* %19, i32 0, i32 11
  store i8 %conv15, i8* %gckind16, align 1
  %20 = load %struct.global_State** %g, align 8
  %21 = load %struct.global_State** %g, align 8
  %totalbytes = getelementptr inbounds %struct.global_State* %21, i32 0, i32 2
  %22 = load i64* %totalbytes, align 8
  %23 = load %struct.global_State** %g, align 8
  %GCdebt = getelementptr inbounds %struct.global_State* %23, i32 0, i32 3
  %24 = load i64* %GCdebt, align 8
  %add = add i64 %22, %24
  call void @setpause(%struct.global_State* %20, i64 %add)
  %25 = load i32* %isemergency.addr, align 4
  %tobool17 = icmp ne i32 %25, 0
  br i1 %tobool17, label %if.end19, label %if.then18

if.then18:                                        ; preds = %if.end14
  %26 = load %struct.lua_State** %L.addr, align 8
  call void @callallpendingfinalizers(%struct.lua_State* %26, i32 1)
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.end14
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @reallymarkobject(%struct.global_State* %g, %union.GCObject* %o) #0 {
entry:
  %g.addr = alloca %struct.global_State*, align 8
  %o.addr = alloca %union.GCObject*, align 8
  %size = alloca i64, align 8
  %mt = alloca %struct.Table*, align 8
  %uv33 = alloca %struct.UpVal*, align 8
  store %struct.global_State* %g, %struct.global_State** %g.addr, align 8
  store %union.GCObject* %o, %union.GCObject** %o.addr, align 8
  %0 = load %union.GCObject** %o.addr, align 8
  %gch = bitcast %union.GCObject* %0 to %struct.GCheader*
  %marked = getelementptr inbounds %struct.GCheader* %gch, i32 0, i32 2
  %1 = load i8* %marked, align 1
  %conv = zext i8 %1 to i32
  %and = and i32 %conv, 252
  %conv1 = trunc i32 %and to i8
  store i8 %conv1, i8* %marked, align 1
  %2 = load %union.GCObject** %o.addr, align 8
  %gch2 = bitcast %union.GCObject* %2 to %struct.GCheader*
  %tt = getelementptr inbounds %struct.GCheader* %gch2, i32 0, i32 1
  %3 = load i8* %tt, align 1
  %conv3 = zext i8 %3 to i32
  switch i32 %conv3, label %sw.default [
    i32 4, label %sw.bb
    i32 20, label %sw.bb
    i32 7, label %sw.bb5
    i32 10, label %sw.bb32
    i32 6, label %sw.bb54
    i32 38, label %sw.bb56
    i32 5, label %sw.bb61
    i32 8, label %sw.bb66
    i32 9, label %sw.bb70
  ]

sw.bb:                                            ; preds = %entry, %entry
  %4 = load %union.GCObject** %o.addr, align 8
  %ts = bitcast %union.GCObject* %4 to %union.TString*
  %tsv = bitcast %union.TString* %ts to %struct.anon.0*
  %len = getelementptr inbounds %struct.anon.0* %tsv, i32 0, i32 5
  %5 = load i64* %len, align 8
  %add = add i64 %5, 1
  %mul = mul i64 %add, 1
  %add4 = add i64 24, %mul
  store i64 %add4, i64* %size, align 8
  br label %sw.epilog

sw.bb5:                                           ; preds = %entry
  %6 = load %union.GCObject** %o.addr, align 8
  %u = bitcast %union.GCObject* %6 to %union.Udata*
  %uv = bitcast %union.Udata* %u to %struct.anon.5*
  %metatable = getelementptr inbounds %struct.anon.5* %uv, i32 0, i32 3
  %7 = load %struct.Table** %metatable, align 8
  store %struct.Table* %7, %struct.Table** %mt, align 8
  %8 = load %struct.Table** %mt, align 8
  %tobool = icmp ne %struct.Table* %8, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %sw.bb5
  %9 = load %struct.Table** %mt, align 8
  %10 = bitcast %struct.Table* %9 to %union.GCObject*
  %gch6 = bitcast %union.GCObject* %10 to %struct.GCheader*
  %marked7 = getelementptr inbounds %struct.GCheader* %gch6, i32 0, i32 2
  %11 = load i8* %marked7, align 1
  %conv8 = zext i8 %11 to i32
  %and9 = and i32 %conv8, 3
  %tobool10 = icmp ne i32 %and9, 0
  br i1 %tobool10, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %12 = load %struct.global_State** %g.addr, align 8
  %13 = load %struct.Table** %mt, align 8
  %14 = bitcast %struct.Table* %13 to %union.GCObject*
  call void @reallymarkobject(%struct.global_State* %12, %union.GCObject* %14)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %sw.bb5
  %15 = load %union.GCObject** %o.addr, align 8
  %u11 = bitcast %union.GCObject* %15 to %union.Udata*
  %uv12 = bitcast %union.Udata* %u11 to %struct.anon.5*
  %env = getelementptr inbounds %struct.anon.5* %uv12, i32 0, i32 4
  %16 = load %struct.Table** %env, align 8
  %tobool13 = icmp ne %struct.Table* %16, null
  br i1 %tobool13, label %land.lhs.true14, label %if.end27

land.lhs.true14:                                  ; preds = %if.end
  %17 = load %union.GCObject** %o.addr, align 8
  %u15 = bitcast %union.GCObject* %17 to %union.Udata*
  %uv16 = bitcast %union.Udata* %u15 to %struct.anon.5*
  %env17 = getelementptr inbounds %struct.anon.5* %uv16, i32 0, i32 4
  %18 = load %struct.Table** %env17, align 8
  %19 = bitcast %struct.Table* %18 to %union.GCObject*
  %gch18 = bitcast %union.GCObject* %19 to %struct.GCheader*
  %marked19 = getelementptr inbounds %struct.GCheader* %gch18, i32 0, i32 2
  %20 = load i8* %marked19, align 1
  %conv20 = zext i8 %20 to i32
  %and21 = and i32 %conv20, 3
  %tobool22 = icmp ne i32 %and21, 0
  br i1 %tobool22, label %if.then23, label %if.end27

if.then23:                                        ; preds = %land.lhs.true14
  %21 = load %struct.global_State** %g.addr, align 8
  %22 = load %union.GCObject** %o.addr, align 8
  %u24 = bitcast %union.GCObject* %22 to %union.Udata*
  %uv25 = bitcast %union.Udata* %u24 to %struct.anon.5*
  %env26 = getelementptr inbounds %struct.anon.5* %uv25, i32 0, i32 4
  %23 = load %struct.Table** %env26, align 8
  %24 = bitcast %struct.Table* %23 to %union.GCObject*
  call void @reallymarkobject(%struct.global_State* %21, %union.GCObject* %24)
  br label %if.end27

if.end27:                                         ; preds = %if.then23, %land.lhs.true14, %if.end
  %25 = load %union.GCObject** %o.addr, align 8
  %u28 = bitcast %union.GCObject* %25 to %union.Udata*
  %uv29 = bitcast %union.Udata* %u28 to %struct.anon.5*
  %len30 = getelementptr inbounds %struct.anon.5* %uv29, i32 0, i32 5
  %26 = load i64* %len30, align 8
  %add31 = add i64 40, %26
  store i64 %add31, i64* %size, align 8
  br label %sw.epilog

sw.bb32:                                          ; preds = %entry
  %27 = load %union.GCObject** %o.addr, align 8
  %uv34 = bitcast %union.GCObject* %27 to %struct.UpVal*
  store %struct.UpVal* %uv34, %struct.UpVal** %uv33, align 8
  %28 = load %struct.UpVal** %uv33, align 8
  %v = getelementptr inbounds %struct.UpVal* %28, i32 0, i32 3
  %29 = load %struct.lua_TValue** %v, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %29, i32 0, i32 1
  %30 = load i32* %tt_, align 4
  %and35 = and i32 %30, 64
  %tobool36 = icmp ne i32 %and35, 0
  br i1 %tobool36, label %land.lhs.true37, label %if.end48

land.lhs.true37:                                  ; preds = %sw.bb32
  %31 = load %struct.UpVal** %uv33, align 8
  %v38 = getelementptr inbounds %struct.UpVal* %31, i32 0, i32 3
  %32 = load %struct.lua_TValue** %v38, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %32, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %33 = load %union.GCObject** %gc, align 8
  %gch39 = bitcast %union.GCObject* %33 to %struct.GCheader*
  %marked40 = getelementptr inbounds %struct.GCheader* %gch39, i32 0, i32 2
  %34 = load i8* %marked40, align 1
  %conv41 = zext i8 %34 to i32
  %and42 = and i32 %conv41, 3
  %tobool43 = icmp ne i32 %and42, 0
  br i1 %tobool43, label %if.then44, label %if.end48

if.then44:                                        ; preds = %land.lhs.true37
  %35 = load %struct.global_State** %g.addr, align 8
  %36 = load %struct.UpVal** %uv33, align 8
  %v45 = getelementptr inbounds %struct.UpVal* %36, i32 0, i32 3
  %37 = load %struct.lua_TValue** %v45, align 8
  %value_46 = getelementptr inbounds %struct.lua_TValue* %37, i32 0, i32 0
  %gc47 = bitcast %union.Value* %value_46 to %union.GCObject**
  %38 = load %union.GCObject** %gc47, align 8
  call void @reallymarkobject(%struct.global_State* %35, %union.GCObject* %38)
  br label %if.end48

if.end48:                                         ; preds = %if.then44, %land.lhs.true37, %sw.bb32
  %39 = load %struct.UpVal** %uv33, align 8
  %v49 = getelementptr inbounds %struct.UpVal* %39, i32 0, i32 3
  %40 = load %struct.lua_TValue** %v49, align 8
  %41 = load %struct.UpVal** %uv33, align 8
  %u50 = getelementptr inbounds %struct.UpVal* %41, i32 0, i32 4
  %value = bitcast %union.anon* %u50 to %struct.lua_TValue*
  %cmp = icmp ne %struct.lua_TValue* %40, %value
  br i1 %cmp, label %if.then52, label %if.end53

if.then52:                                        ; preds = %if.end48
  br label %return

if.end53:                                         ; preds = %if.end48
  store i64 40, i64* %size, align 8
  br label %sw.epilog

sw.bb54:                                          ; preds = %entry
  %42 = load %struct.global_State** %g.addr, align 8
  %gray = getelementptr inbounds %struct.global_State* %42, i32 0, i32 18
  %43 = load %union.GCObject** %gray, align 8
  %44 = load %union.GCObject** %o.addr, align 8
  %cl = bitcast %union.GCObject* %44 to %union.Closure*
  %l = bitcast %union.Closure* %cl to %struct.LClosure*
  %gclist = getelementptr inbounds %struct.LClosure* %l, i32 0, i32 4
  store %union.GCObject* %43, %union.GCObject** %gclist, align 8
  %45 = load %union.GCObject** %o.addr, align 8
  %46 = load %struct.global_State** %g.addr, align 8
  %gray55 = getelementptr inbounds %struct.global_State* %46, i32 0, i32 18
  store %union.GCObject* %45, %union.GCObject** %gray55, align 8
  br label %return

sw.bb56:                                          ; preds = %entry
  %47 = load %struct.global_State** %g.addr, align 8
  %gray57 = getelementptr inbounds %struct.global_State* %47, i32 0, i32 18
  %48 = load %union.GCObject** %gray57, align 8
  %49 = load %union.GCObject** %o.addr, align 8
  %cl58 = bitcast %union.GCObject* %49 to %union.Closure*
  %c = bitcast %union.Closure* %cl58 to %struct.CClosure*
  %gclist59 = getelementptr inbounds %struct.CClosure* %c, i32 0, i32 4
  store %union.GCObject* %48, %union.GCObject** %gclist59, align 8
  %50 = load %union.GCObject** %o.addr, align 8
  %51 = load %struct.global_State** %g.addr, align 8
  %gray60 = getelementptr inbounds %struct.global_State* %51, i32 0, i32 18
  store %union.GCObject* %50, %union.GCObject** %gray60, align 8
  br label %return

sw.bb61:                                          ; preds = %entry
  %52 = load %struct.global_State** %g.addr, align 8
  %gray62 = getelementptr inbounds %struct.global_State* %52, i32 0, i32 18
  %53 = load %union.GCObject** %gray62, align 8
  %54 = load %union.GCObject** %o.addr, align 8
  %h = bitcast %union.GCObject* %54 to %struct.Table*
  %gclist63 = getelementptr inbounds %struct.Table* %h, i32 0, i32 9
  store %union.GCObject* %53, %union.GCObject** %gclist63, align 8
  %55 = load %union.GCObject** %o.addr, align 8
  %h64 = bitcast %union.GCObject* %55 to %struct.Table*
  %56 = bitcast %struct.Table* %h64 to %union.GCObject*
  %57 = load %struct.global_State** %g.addr, align 8
  %gray65 = getelementptr inbounds %struct.global_State* %57, i32 0, i32 18
  store %union.GCObject* %56, %union.GCObject** %gray65, align 8
  br label %return

sw.bb66:                                          ; preds = %entry
  %58 = load %struct.global_State** %g.addr, align 8
  %gray67 = getelementptr inbounds %struct.global_State* %58, i32 0, i32 18
  %59 = load %union.GCObject** %gray67, align 8
  %60 = load %union.GCObject** %o.addr, align 8
  %th = bitcast %union.GCObject* %60 to %struct.lua_State*
  %gclist68 = getelementptr inbounds %struct.lua_State* %th, i32 0, i32 19
  store %union.GCObject* %59, %union.GCObject** %gclist68, align 8
  %61 = load %union.GCObject** %o.addr, align 8
  %62 = load %struct.global_State** %g.addr, align 8
  %gray69 = getelementptr inbounds %struct.global_State* %62, i32 0, i32 18
  store %union.GCObject* %61, %union.GCObject** %gray69, align 8
  br label %return

sw.bb70:                                          ; preds = %entry
  %63 = load %struct.global_State** %g.addr, align 8
  %gray71 = getelementptr inbounds %struct.global_State* %63, i32 0, i32 18
  %64 = load %union.GCObject** %gray71, align 8
  %65 = load %union.GCObject** %o.addr, align 8
  %p = bitcast %union.GCObject* %65 to %struct.Proto*
  %gclist72 = getelementptr inbounds %struct.Proto* %p, i32 0, i32 19
  store %union.GCObject* %64, %union.GCObject** %gclist72, align 8
  %66 = load %union.GCObject** %o.addr, align 8
  %67 = load %struct.global_State** %g.addr, align 8
  %gray73 = getelementptr inbounds %struct.global_State* %67, i32 0, i32 18
  store %union.GCObject* %66, %union.GCObject** %gray73, align 8
  br label %return

sw.default:                                       ; preds = %entry
  br label %return

sw.epilog:                                        ; preds = %if.end53, %if.end27, %sw.bb
  %68 = load %union.GCObject** %o.addr, align 8
  %gch74 = bitcast %union.GCObject* %68 to %struct.GCheader*
  %marked75 = getelementptr inbounds %struct.GCheader* %gch74, i32 0, i32 2
  %69 = load i8* %marked75, align 1
  %conv76 = zext i8 %69 to i32
  %or = or i32 %conv76, 4
  %conv77 = trunc i32 %or to i8
  store i8 %conv77, i8* %marked75, align 1
  %70 = load i64* %size, align 8
  %71 = load %struct.global_State** %g.addr, align 8
  %GCmemtrav = getelementptr inbounds %struct.global_State* %71, i32 0, i32 4
  %72 = load i64* %GCmemtrav, align 8
  %add78 = add i64 %72, %70
  store i64 %add78, i64* %GCmemtrav, align 8
  br label %return

return:                                           ; preds = %sw.epilog, %sw.default, %sw.bb70, %sw.bb66, %sw.bb61, %sw.bb56, %sw.bb54, %if.then52
  ret void
}

; Function Attrs: nounwind uwtable
define internal %union.GCObject** @sweeptolive(%struct.lua_State* %L, %union.GCObject** %p, i32* %n) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %p.addr = alloca %union.GCObject**, align 8
  %n.addr = alloca i32*, align 8
  %old = alloca %union.GCObject**, align 8
  %i = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %union.GCObject** %p, %union.GCObject*** %p.addr, align 8
  store i32* %n, i32** %n.addr, align 8
  %0 = load %union.GCObject*** %p.addr, align 8
  store %union.GCObject** %0, %union.GCObject*** %old, align 8
  store i32 0, i32* %i, align 4
  br label %do.body

do.body:                                          ; preds = %do.cond, %entry
  %1 = load i32* %i, align 4
  %inc = add nsw i32 %1, 1
  store i32 %inc, i32* %i, align 4
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load %union.GCObject*** %p.addr, align 8
  %call = call %union.GCObject** @sweeplist(%struct.lua_State* %2, %union.GCObject** %3, i64 1)
  store %union.GCObject** %call, %union.GCObject*** %p.addr, align 8
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %4 = load %union.GCObject*** %p.addr, align 8
  %5 = load %union.GCObject*** %old, align 8
  %cmp = icmp eq %union.GCObject** %4, %5
  br i1 %cmp, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  %6 = load i32** %n.addr, align 8
  %tobool = icmp ne i32* %6, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.end
  %7 = load i32* %i, align 4
  %8 = load i32** %n.addr, align 8
  %9 = load i32* %8, align 4
  %add = add nsw i32 %9, %7
  store i32 %add, i32* %8, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %do.end
  %10 = load %union.GCObject*** %p.addr, align 8
  ret %union.GCObject** %10
}

; Function Attrs: nounwind uwtable
define internal i32 @entersweep(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %g = alloca %struct.global_State*, align 8
  %n = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 5
  %1 = load %struct.global_State** %l_G, align 8
  store %struct.global_State* %1, %struct.global_State** %g, align 8
  store i32 0, i32* %n, align 4
  %2 = load %struct.global_State** %g, align 8
  %gcstate = getelementptr inbounds %struct.global_State* %2, i32 0, i32 10
  store i8 2, i8* %gcstate, align 1
  %3 = load %struct.global_State** %g, align 8
  %sweepstrgc = getelementptr inbounds %struct.global_State* %3, i32 0, i32 13
  store i32 0, i32* %sweepstrgc, align 4
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load %struct.global_State** %g, align 8
  %finobj = getelementptr inbounds %struct.global_State* %5, i32 0, i32 15
  %call = call %union.GCObject** @sweeptolive(%struct.lua_State* %4, %union.GCObject** %finobj, i32* %n)
  %6 = load %struct.global_State** %g, align 8
  %sweepfin = getelementptr inbounds %struct.global_State* %6, i32 0, i32 17
  store %union.GCObject** %call, %union.GCObject*** %sweepfin, align 8
  %7 = load %struct.lua_State** %L.addr, align 8
  %8 = load %struct.global_State** %g, align 8
  %allgc = getelementptr inbounds %struct.global_State* %8, i32 0, i32 14
  %call1 = call %union.GCObject** @sweeptolive(%struct.lua_State* %7, %union.GCObject** %allgc, i32* %n)
  %9 = load %struct.global_State** %g, align 8
  %sweepgc = getelementptr inbounds %struct.global_State* %9, i32 0, i32 16
  store %union.GCObject** %call1, %union.GCObject*** %sweepgc, align 8
  %10 = load i32* %n, align 4
  ret i32 %10
}

; Function Attrs: nounwind uwtable
define internal i64 @singlestep(%struct.lua_State* %L) #0 {
entry:
  %retval = alloca i64, align 8
  %L.addr = alloca %struct.lua_State*, align 8
  %g = alloca %struct.global_State*, align 8
  %oldtrav = alloca i64, align 8
  %work = alloca i64, align 8
  %sw = alloca i32, align 4
  %i = alloca i32, align 4
  %mt = alloca %union.GCObject*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 5
  %1 = load %struct.global_State** %l_G, align 8
  store %struct.global_State* %1, %struct.global_State** %g, align 8
  %2 = load %struct.global_State** %g, align 8
  %gcstate = getelementptr inbounds %struct.global_State* %2, i32 0, i32 10
  %3 = load i8* %gcstate, align 1
  %conv = zext i8 %3 to i32
  switch i32 %conv, label %sw.default [
    i32 5, label %sw.bb
    i32 0, label %sw.bb4
    i32 2, label %sw.bb14
    i32 3, label %sw.bb36
    i32 4, label %sw.bb44
  ]

sw.bb:                                            ; preds = %entry
  %4 = load %struct.global_State** %g, align 8
  %strt = getelementptr inbounds %struct.global_State* %4, i32 0, i32 6
  %size = getelementptr inbounds %struct.stringtable* %strt, i32 0, i32 2
  %5 = load i32* %size, align 4
  %conv1 = sext i32 %5 to i64
  %mul = mul i64 %conv1, 8
  %6 = load %struct.global_State** %g, align 8
  %GCmemtrav = getelementptr inbounds %struct.global_State* %6, i32 0, i32 4
  store i64 %mul, i64* %GCmemtrav, align 8
  %7 = load %struct.global_State** %g, align 8
  call void @restartcollection(%struct.global_State* %7)
  %8 = load %struct.global_State** %g, align 8
  %gcstate2 = getelementptr inbounds %struct.global_State* %8, i32 0, i32 10
  store i8 0, i8* %gcstate2, align 1
  %9 = load %struct.global_State** %g, align 8
  %GCmemtrav3 = getelementptr inbounds %struct.global_State* %9, i32 0, i32 4
  %10 = load i64* %GCmemtrav3, align 8
  store i64 %10, i64* %retval
  br label %return

sw.bb4:                                           ; preds = %entry
  %11 = load %struct.global_State** %g, align 8
  %gray = getelementptr inbounds %struct.global_State* %11, i32 0, i32 18
  %12 = load %union.GCObject** %gray, align 8
  %tobool = icmp ne %union.GCObject* %12, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb4
  %13 = load %struct.global_State** %g, align 8
  %GCmemtrav5 = getelementptr inbounds %struct.global_State* %13, i32 0, i32 4
  %14 = load i64* %GCmemtrav5, align 8
  store i64 %14, i64* %oldtrav, align 8
  %15 = load %struct.global_State** %g, align 8
  call void @propagatemark(%struct.global_State* %15)
  %16 = load %struct.global_State** %g, align 8
  %GCmemtrav6 = getelementptr inbounds %struct.global_State* %16, i32 0, i32 4
  %17 = load i64* %GCmemtrav6, align 8
  %18 = load i64* %oldtrav, align 8
  %sub = sub i64 %17, %18
  store i64 %sub, i64* %retval
  br label %return

if.else:                                          ; preds = %sw.bb4
  %19 = load %struct.global_State** %g, align 8
  %gcstate7 = getelementptr inbounds %struct.global_State* %19, i32 0, i32 10
  store i8 1, i8* %gcstate7, align 1
  %20 = load %struct.global_State** %g, align 8
  %GCmemtrav8 = getelementptr inbounds %struct.global_State* %20, i32 0, i32 4
  %21 = load i64* %GCmemtrav8, align 8
  %22 = load %struct.global_State** %g, align 8
  %GCestimate = getelementptr inbounds %struct.global_State* %22, i32 0, i32 5
  store i64 %21, i64* %GCestimate, align 8
  %23 = load %struct.lua_State** %L.addr, align 8
  %call = call i64 @atomic(%struct.lua_State* %23)
  store i64 %call, i64* %work, align 8
  %24 = load i64* %work, align 8
  %25 = load %struct.global_State** %g, align 8
  %GCestimate9 = getelementptr inbounds %struct.global_State* %25, i32 0, i32 5
  %26 = load i64* %GCestimate9, align 8
  %add = add i64 %26, %24
  store i64 %add, i64* %GCestimate9, align 8
  %27 = load %struct.lua_State** %L.addr, align 8
  %call10 = call i32 @entersweep(%struct.lua_State* %27)
  store i32 %call10, i32* %sw, align 4
  %28 = load i64* %work, align 8
  %29 = load i32* %sw, align 4
  %conv11 = sext i32 %29 to i64
  %mul12 = mul i64 %conv11, 7
  %add13 = add i64 %28, %mul12
  store i64 %add13, i64* %retval
  br label %return

sw.bb14:                                          ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %sw.bb14
  %30 = load i32* %i, align 4
  %cmp = icmp slt i32 %30, 85
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %31 = load %struct.global_State** %g, align 8
  %sweepstrgc = getelementptr inbounds %struct.global_State* %31, i32 0, i32 13
  %32 = load i32* %sweepstrgc, align 4
  %33 = load i32* %i, align 4
  %add16 = add nsw i32 %32, %33
  %34 = load %struct.global_State** %g, align 8
  %strt17 = getelementptr inbounds %struct.global_State* %34, i32 0, i32 6
  %size18 = getelementptr inbounds %struct.stringtable* %strt17, i32 0, i32 2
  %35 = load i32* %size18, align 4
  %cmp19 = icmp slt i32 %add16, %35
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %36 = phi i1 [ false, %for.cond ], [ %cmp19, %land.rhs ]
  br i1 %36, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %37 = load %struct.lua_State** %L.addr, align 8
  %38 = load %struct.global_State** %g, align 8
  %sweepstrgc21 = getelementptr inbounds %struct.global_State* %38, i32 0, i32 13
  %39 = load i32* %sweepstrgc21, align 4
  %40 = load i32* %i, align 4
  %add22 = add nsw i32 %39, %40
  %idxprom = sext i32 %add22 to i64
  %41 = load %struct.global_State** %g, align 8
  %strt23 = getelementptr inbounds %struct.global_State* %41, i32 0, i32 6
  %hash = getelementptr inbounds %struct.stringtable* %strt23, i32 0, i32 0
  %42 = load %union.GCObject*** %hash, align 8
  %arrayidx = getelementptr inbounds %union.GCObject** %42, i64 %idxprom
  %call24 = call %union.GCObject** @sweeplist(%struct.lua_State* %37, %union.GCObject** %arrayidx, i64 -3)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %43 = load i32* %i, align 4
  %inc = add nsw i32 %43, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %land.end
  %44 = load i32* %i, align 4
  %45 = load %struct.global_State** %g, align 8
  %sweepstrgc25 = getelementptr inbounds %struct.global_State* %45, i32 0, i32 13
  %46 = load i32* %sweepstrgc25, align 4
  %add26 = add nsw i32 %46, %44
  store i32 %add26, i32* %sweepstrgc25, align 4
  %47 = load %struct.global_State** %g, align 8
  %sweepstrgc27 = getelementptr inbounds %struct.global_State* %47, i32 0, i32 13
  %48 = load i32* %sweepstrgc27, align 4
  %49 = load %struct.global_State** %g, align 8
  %strt28 = getelementptr inbounds %struct.global_State* %49, i32 0, i32 6
  %size29 = getelementptr inbounds %struct.stringtable* %strt28, i32 0, i32 2
  %50 = load i32* %size29, align 4
  %cmp30 = icmp sge i32 %48, %50
  br i1 %cmp30, label %if.then32, label %if.end

if.then32:                                        ; preds = %for.end
  %51 = load %struct.global_State** %g, align 8
  %gcstate33 = getelementptr inbounds %struct.global_State* %51, i32 0, i32 10
  store i8 3, i8* %gcstate33, align 1
  br label %if.end

if.end:                                           ; preds = %if.then32, %for.end
  %52 = load i32* %i, align 4
  %conv34 = sext i32 %52 to i64
  %mul35 = mul i64 %conv34, 7
  store i64 %mul35, i64* %retval
  br label %return

sw.bb36:                                          ; preds = %entry
  %53 = load %struct.global_State** %g, align 8
  %sweepfin = getelementptr inbounds %struct.global_State* %53, i32 0, i32 17
  %54 = load %union.GCObject*** %sweepfin, align 8
  %tobool37 = icmp ne %union.GCObject** %54, null
  br i1 %tobool37, label %if.then38, label %if.else42

if.then38:                                        ; preds = %sw.bb36
  %55 = load %struct.lua_State** %L.addr, align 8
  %56 = load %struct.global_State** %g, align 8
  %sweepfin39 = getelementptr inbounds %struct.global_State* %56, i32 0, i32 17
  %57 = load %union.GCObject*** %sweepfin39, align 8
  %call40 = call %union.GCObject** @sweeplist(%struct.lua_State* %55, %union.GCObject** %57, i64 85)
  %58 = load %struct.global_State** %g, align 8
  %sweepfin41 = getelementptr inbounds %struct.global_State* %58, i32 0, i32 17
  store %union.GCObject** %call40, %union.GCObject*** %sweepfin41, align 8
  store i64 595, i64* %retval
  br label %return

if.else42:                                        ; preds = %sw.bb36
  %59 = load %struct.global_State** %g, align 8
  %gcstate43 = getelementptr inbounds %struct.global_State* %59, i32 0, i32 10
  store i8 4, i8* %gcstate43, align 1
  store i64 0, i64* %retval
  br label %return

sw.bb44:                                          ; preds = %entry
  %60 = load %struct.global_State** %g, align 8
  %sweepgc = getelementptr inbounds %struct.global_State* %60, i32 0, i32 16
  %61 = load %union.GCObject*** %sweepgc, align 8
  %tobool45 = icmp ne %union.GCObject** %61, null
  br i1 %tobool45, label %if.then46, label %if.else50

if.then46:                                        ; preds = %sw.bb44
  %62 = load %struct.lua_State** %L.addr, align 8
  %63 = load %struct.global_State** %g, align 8
  %sweepgc47 = getelementptr inbounds %struct.global_State* %63, i32 0, i32 16
  %64 = load %union.GCObject*** %sweepgc47, align 8
  %call48 = call %union.GCObject** @sweeplist(%struct.lua_State* %62, %union.GCObject** %64, i64 85)
  %65 = load %struct.global_State** %g, align 8
  %sweepgc49 = getelementptr inbounds %struct.global_State* %65, i32 0, i32 16
  store %union.GCObject** %call48, %union.GCObject*** %sweepgc49, align 8
  store i64 595, i64* %retval
  br label %return

if.else50:                                        ; preds = %sw.bb44
  %66 = load %struct.global_State** %g, align 8
  %mainthread = getelementptr inbounds %struct.global_State* %66, i32 0, i32 30
  %67 = load %struct.lua_State** %mainthread, align 8
  %68 = bitcast %struct.lua_State* %67 to %union.GCObject*
  store %union.GCObject* %68, %union.GCObject** %mt, align 8
  %69 = load %struct.lua_State** %L.addr, align 8
  %call51 = call %union.GCObject** @sweeplist(%struct.lua_State* %69, %union.GCObject** %mt, i64 1)
  %70 = load %struct.lua_State** %L.addr, align 8
  call void @checkSizes(%struct.lua_State* %70)
  %71 = load %struct.global_State** %g, align 8
  %gcstate52 = getelementptr inbounds %struct.global_State* %71, i32 0, i32 10
  store i8 5, i8* %gcstate52, align 1
  store i64 7, i64* %retval
  br label %return

sw.default:                                       ; preds = %entry
  store i64 0, i64* %retval
  br label %return

return:                                           ; preds = %sw.default, %if.else50, %if.then46, %if.else42, %if.then38, %if.end, %if.else, %if.then, %sw.bb
  %72 = load i64* %retval
  ret i64 %72
}

; Function Attrs: nounwind uwtable
define internal void @separatetobefnz(%struct.lua_State* %L, i32 %all) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %all.addr = alloca i32, align 4
  %g = alloca %struct.global_State*, align 8
  %p = alloca %union.GCObject**, align 8
  %curr = alloca %union.GCObject*, align 8
  %lastnext = alloca %union.GCObject**, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %all, i32* %all.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 5
  %1 = load %struct.global_State** %l_G, align 8
  store %struct.global_State* %1, %struct.global_State** %g, align 8
  %2 = load %struct.global_State** %g, align 8
  %finobj = getelementptr inbounds %struct.global_State* %2, i32 0, i32 15
  store %union.GCObject** %finobj, %union.GCObject*** %p, align 8
  %3 = load %struct.global_State** %g, align 8
  %tobefnz = getelementptr inbounds %struct.global_State* %3, i32 0, i32 23
  store %union.GCObject** %tobefnz, %union.GCObject*** %lastnext, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %4 = load %union.GCObject*** %lastnext, align 8
  %5 = load %union.GCObject** %4, align 8
  %cmp = icmp ne %union.GCObject* %5, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %6 = load %union.GCObject*** %lastnext, align 8
  %7 = load %union.GCObject** %6, align 8
  %gch = bitcast %union.GCObject* %7 to %struct.GCheader*
  %next = getelementptr inbounds %struct.GCheader* %gch, i32 0, i32 0
  store %union.GCObject** %next, %union.GCObject*** %lastnext, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  br label %while.cond1

while.cond1:                                      ; preds = %if.end, %while.end
  %8 = load %union.GCObject*** %p, align 8
  %9 = load %union.GCObject** %8, align 8
  store %union.GCObject* %9, %union.GCObject** %curr, align 8
  %cmp2 = icmp ne %union.GCObject* %9, null
  br i1 %cmp2, label %while.body3, label %while.end18

while.body3:                                      ; preds = %while.cond1
  %10 = load %union.GCObject** %curr, align 8
  %gch4 = bitcast %union.GCObject* %10 to %struct.GCheader*
  %marked = getelementptr inbounds %struct.GCheader* %gch4, i32 0, i32 2
  %11 = load i8* %marked, align 1
  %conv = zext i8 %11 to i32
  %and = and i32 %conv, 3
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.else, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.body3
  %12 = load i32* %all.addr, align 4
  %tobool5 = icmp ne i32 %12, 0
  br i1 %tobool5, label %if.else, label %if.then

if.then:                                          ; preds = %lor.lhs.false
  %13 = load %union.GCObject** %curr, align 8
  %gch6 = bitcast %union.GCObject* %13 to %struct.GCheader*
  %next7 = getelementptr inbounds %struct.GCheader* %gch6, i32 0, i32 0
  store %union.GCObject** %next7, %union.GCObject*** %p, align 8
  br label %if.end

if.else:                                          ; preds = %lor.lhs.false, %while.body3
  %14 = load %union.GCObject** %curr, align 8
  %gch8 = bitcast %union.GCObject* %14 to %struct.GCheader*
  %marked9 = getelementptr inbounds %struct.GCheader* %gch8, i32 0, i32 2
  %15 = load i8* %marked9, align 1
  %conv10 = zext i8 %15 to i32
  %or = or i32 %conv10, 8
  %conv11 = trunc i32 %or to i8
  store i8 %conv11, i8* %marked9, align 1
  %16 = load %union.GCObject** %curr, align 8
  %gch12 = bitcast %union.GCObject* %16 to %struct.GCheader*
  %next13 = getelementptr inbounds %struct.GCheader* %gch12, i32 0, i32 0
  %17 = load %union.GCObject** %next13, align 8
  %18 = load %union.GCObject*** %p, align 8
  store %union.GCObject* %17, %union.GCObject** %18, align 8
  %19 = load %union.GCObject*** %lastnext, align 8
  %20 = load %union.GCObject** %19, align 8
  %21 = load %union.GCObject** %curr, align 8
  %gch14 = bitcast %union.GCObject* %21 to %struct.GCheader*
  %next15 = getelementptr inbounds %struct.GCheader* %gch14, i32 0, i32 0
  store %union.GCObject* %20, %union.GCObject** %next15, align 8
  %22 = load %union.GCObject** %curr, align 8
  %23 = load %union.GCObject*** %lastnext, align 8
  store %union.GCObject* %22, %union.GCObject** %23, align 8
  %24 = load %union.GCObject** %curr, align 8
  %gch16 = bitcast %union.GCObject* %24 to %struct.GCheader*
  %next17 = getelementptr inbounds %struct.GCheader* %gch16, i32 0, i32 0
  store %union.GCObject** %next17, %union.GCObject*** %lastnext, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  br label %while.cond1

while.end18:                                      ; preds = %while.cond1
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @callallpendingfinalizers(%struct.lua_State* %L, i32 %propagateerrors) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %propagateerrors.addr = alloca i32, align 4
  %g = alloca %struct.global_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %propagateerrors, i32* %propagateerrors.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 5
  %1 = load %struct.global_State** %l_G, align 8
  store %struct.global_State* %1, %struct.global_State** %g, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %2 = load %struct.global_State** %g, align 8
  %tobefnz = getelementptr inbounds %struct.global_State* %2, i32 0, i32 23
  %3 = load %union.GCObject** %tobefnz, align 8
  %tobool = icmp ne %union.GCObject* %3, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %4 = load %struct.global_State** %g, align 8
  %tobefnz1 = getelementptr inbounds %struct.global_State* %4, i32 0, i32 23
  %5 = load %union.GCObject** %tobefnz1, align 8
  %gch = bitcast %union.GCObject* %5 to %struct.GCheader*
  %marked = getelementptr inbounds %struct.GCheader* %gch, i32 0, i32 2
  %6 = load i8* %marked, align 1
  %conv = zext i8 %6 to i32
  %and = and i32 %conv, 191
  %conv2 = trunc i32 %and to i8
  store i8 %conv2, i8* %marked, align 1
  %7 = load %struct.lua_State** %L.addr, align 8
  %8 = load i32* %propagateerrors.addr, align 4
  call void @GCTM(%struct.lua_State* %7, i32 %8)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal %union.GCObject** @sweeplist(%struct.lua_State* %L, %union.GCObject** %p, i64 %count) #0 {
entry:
  %retval = alloca %union.GCObject**, align 8
  %L.addr = alloca %struct.lua_State*, align 8
  %p.addr = alloca %union.GCObject**, align 8
  %count.addr = alloca i64, align 8
  %g = alloca %struct.global_State*, align 8
  %ow = alloca i32, align 4
  %toclear = alloca i32, align 4
  %toset = alloca i32, align 4
  %tostop = alloca i32, align 4
  %curr = alloca %union.GCObject*, align 8
  %marked = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %union.GCObject** %p, %union.GCObject*** %p.addr, align 8
  store i64 %count, i64* %count.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 5
  %1 = load %struct.global_State** %l_G, align 8
  store %struct.global_State* %1, %struct.global_State** %g, align 8
  %2 = load %struct.global_State** %g, align 8
  %currentwhite = getelementptr inbounds %struct.global_State* %2, i32 0, i32 9
  %3 = load i8* %currentwhite, align 1
  %conv = zext i8 %3 to i32
  %xor = xor i32 %conv, 3
  store i32 %xor, i32* %ow, align 4
  %4 = load %struct.global_State** %g, align 8
  %gckind = getelementptr inbounds %struct.global_State* %4, i32 0, i32 11
  %5 = load i8* %gckind, align 1
  %conv1 = zext i8 %5 to i32
  %cmp = icmp eq i32 %conv1, 2
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 -1, i32* %toclear, align 4
  store i32 64, i32* %toset, align 4
  store i32 64, i32* %tostop, align 4
  br label %if.end

if.else:                                          ; preds = %entry
  store i32 -72, i32* %toclear, align 4
  %6 = load %struct.global_State** %g, align 8
  %currentwhite3 = getelementptr inbounds %struct.global_State* %6, i32 0, i32 9
  %7 = load i8* %currentwhite3, align 1
  %conv4 = zext i8 %7 to i32
  %and = and i32 %conv4, 3
  %conv5 = trunc i32 %and to i8
  %conv6 = zext i8 %conv5 to i32
  store i32 %conv6, i32* %toset, align 4
  store i32 0, i32* %tostop, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  br label %while.cond

while.cond:                                       ; preds = %if.end34, %if.end
  %8 = load %union.GCObject*** %p.addr, align 8
  %9 = load %union.GCObject** %8, align 8
  %cmp7 = icmp ne %union.GCObject* %9, null
  br i1 %cmp7, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %10 = load i64* %count.addr, align 8
  %dec = add i64 %10, -1
  store i64 %dec, i64* %count.addr, align 8
  %cmp9 = icmp ugt i64 %10, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %11 = phi i1 [ false, %while.cond ], [ %cmp9, %land.rhs ]
  br i1 %11, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %12 = load %union.GCObject*** %p.addr, align 8
  %13 = load %union.GCObject** %12, align 8
  store %union.GCObject* %13, %union.GCObject** %curr, align 8
  %14 = load %union.GCObject** %curr, align 8
  %gch = bitcast %union.GCObject* %14 to %struct.GCheader*
  %marked11 = getelementptr inbounds %struct.GCheader* %gch, i32 0, i32 2
  %15 = load i8* %marked11, align 1
  %conv12 = zext i8 %15 to i32
  store i32 %conv12, i32* %marked, align 4
  %16 = load i32* %marked, align 4
  %xor13 = xor i32 %16, 3
  %17 = load i32* %ow, align 4
  %and14 = and i32 %xor13, %17
  %tobool = icmp ne i32 %and14, 0
  br i1 %tobool, label %if.else17, label %if.then15

if.then15:                                        ; preds = %while.body
  %18 = load %union.GCObject** %curr, align 8
  %gch16 = bitcast %union.GCObject* %18 to %struct.GCheader*
  %next = getelementptr inbounds %struct.GCheader* %gch16, i32 0, i32 0
  %19 = load %union.GCObject** %next, align 8
  %20 = load %union.GCObject*** %p.addr, align 8
  store %union.GCObject* %19, %union.GCObject** %20, align 8
  %21 = load %struct.lua_State** %L.addr, align 8
  %22 = load %union.GCObject** %curr, align 8
  call void @freeobj(%struct.lua_State* %21, %union.GCObject* %22)
  br label %if.end34

if.else17:                                        ; preds = %while.body
  %23 = load i32* %marked, align 4
  %24 = load i32* %tostop, align 4
  %and18 = and i32 %23, %24
  %tobool19 = icmp ne i32 %and18, 0
  br i1 %tobool19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %if.else17
  store %union.GCObject** null, %union.GCObject*** %retval
  br label %return

if.end21:                                         ; preds = %if.else17
  %25 = load %union.GCObject** %curr, align 8
  %gch22 = bitcast %union.GCObject* %25 to %struct.GCheader*
  %tt = getelementptr inbounds %struct.GCheader* %gch22, i32 0, i32 1
  %26 = load i8* %tt, align 1
  %conv23 = zext i8 %26 to i32
  %cmp24 = icmp eq i32 %conv23, 8
  br i1 %cmp24, label %if.then26, label %if.end27

if.then26:                                        ; preds = %if.end21
  %27 = load %struct.lua_State** %L.addr, align 8
  %28 = load %union.GCObject** %curr, align 8
  %th = bitcast %union.GCObject* %28 to %struct.lua_State*
  call void @sweepthread(%struct.lua_State* %27, %struct.lua_State* %th)
  br label %if.end27

if.end27:                                         ; preds = %if.then26, %if.end21
  %29 = load i32* %marked, align 4
  %30 = load i32* %toclear, align 4
  %and28 = and i32 %29, %30
  %31 = load i32* %toset, align 4
  %or = or i32 %and28, %31
  %conv29 = trunc i32 %or to i8
  %32 = load %union.GCObject** %curr, align 8
  %gch30 = bitcast %union.GCObject* %32 to %struct.GCheader*
  %marked31 = getelementptr inbounds %struct.GCheader* %gch30, i32 0, i32 2
  store i8 %conv29, i8* %marked31, align 1
  %33 = load %union.GCObject** %curr, align 8
  %gch32 = bitcast %union.GCObject* %33 to %struct.GCheader*
  %next33 = getelementptr inbounds %struct.GCheader* %gch32, i32 0, i32 0
  store %union.GCObject** %next33, %union.GCObject*** %p.addr, align 8
  br label %if.end34

if.end34:                                         ; preds = %if.end27, %if.then15
  br label %while.cond

while.end:                                        ; preds = %land.end
  %34 = load %union.GCObject*** %p.addr, align 8
  %35 = load %union.GCObject** %34, align 8
  %cmp35 = icmp eq %union.GCObject* %35, null
  br i1 %cmp35, label %cond.true, label %cond.false

cond.true:                                        ; preds = %while.end
  br label %cond.end

cond.false:                                       ; preds = %while.end
  %36 = load %union.GCObject*** %p.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %union.GCObject** [ null, %cond.true ], [ %36, %cond.false ]
  store %union.GCObject** %cond, %union.GCObject*** %retval
  br label %return

return:                                           ; preds = %cond.end, %if.then20
  %37 = load %union.GCObject*** %retval
  ret %union.GCObject** %37
}

; Function Attrs: nounwind uwtable
define internal void @generationalcollection(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %g = alloca %struct.global_State*, align 8
  %estimate = alloca i64, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 5
  %1 = load %struct.global_State** %l_G, align 8
  store %struct.global_State* %1, %struct.global_State** %g, align 8
  %2 = load %struct.global_State** %g, align 8
  %GCestimate = getelementptr inbounds %struct.global_State* %2, i32 0, i32 5
  %3 = load i64* %GCestimate, align 8
  %cmp = icmp eq i64 %3, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %4 = load %struct.lua_State** %L.addr, align 8
  call void @luaC_fullgc(%struct.lua_State* %4, i32 0)
  %5 = load %struct.global_State** %g, align 8
  %totalbytes = getelementptr inbounds %struct.global_State* %5, i32 0, i32 2
  %6 = load i64* %totalbytes, align 8
  %7 = load %struct.global_State** %g, align 8
  %GCdebt = getelementptr inbounds %struct.global_State* %7, i32 0, i32 3
  %8 = load i64* %GCdebt, align 8
  %add = add i64 %6, %8
  %9 = load %struct.global_State** %g, align 8
  %GCestimate1 = getelementptr inbounds %struct.global_State* %9, i32 0, i32 5
  store i64 %add, i64* %GCestimate1, align 8
  br label %if.end12

if.else:                                          ; preds = %entry
  %10 = load %struct.global_State** %g, align 8
  %GCestimate2 = getelementptr inbounds %struct.global_State* %10, i32 0, i32 5
  %11 = load i64* %GCestimate2, align 8
  store i64 %11, i64* %estimate, align 8
  %12 = load %struct.lua_State** %L.addr, align 8
  call void @luaC_runtilstate(%struct.lua_State* %12, i32 32)
  %13 = load %struct.global_State** %g, align 8
  %gcstate = getelementptr inbounds %struct.global_State* %13, i32 0, i32 10
  store i8 0, i8* %gcstate, align 1
  %14 = load %struct.global_State** %g, align 8
  %totalbytes3 = getelementptr inbounds %struct.global_State* %14, i32 0, i32 2
  %15 = load i64* %totalbytes3, align 8
  %16 = load %struct.global_State** %g, align 8
  %GCdebt4 = getelementptr inbounds %struct.global_State* %16, i32 0, i32 3
  %17 = load i64* %GCdebt4, align 8
  %add5 = add i64 %15, %17
  %18 = load i64* %estimate, align 8
  %div = udiv i64 %18, 100
  %19 = load %struct.global_State** %g, align 8
  %gcmajorinc = getelementptr inbounds %struct.global_State* %19, i32 0, i32 27
  %20 = load i32* %gcmajorinc, align 4
  %conv = sext i32 %20 to i64
  %mul = mul i64 %div, %conv
  %cmp6 = icmp ugt i64 %add5, %mul
  br i1 %cmp6, label %if.then8, label %if.else10

if.then8:                                         ; preds = %if.else
  %21 = load %struct.global_State** %g, align 8
  %GCestimate9 = getelementptr inbounds %struct.global_State* %21, i32 0, i32 5
  store i64 0, i64* %GCestimate9, align 8
  br label %if.end

if.else10:                                        ; preds = %if.else
  %22 = load i64* %estimate, align 8
  %23 = load %struct.global_State** %g, align 8
  %GCestimate11 = getelementptr inbounds %struct.global_State* %23, i32 0, i32 5
  store i64 %22, i64* %GCestimate11, align 8
  br label %if.end

if.end:                                           ; preds = %if.else10, %if.then8
  br label %if.end12

if.end12:                                         ; preds = %if.end, %if.then
  %24 = load %struct.global_State** %g, align 8
  %25 = load %struct.global_State** %g, align 8
  %totalbytes13 = getelementptr inbounds %struct.global_State* %25, i32 0, i32 2
  %26 = load i64* %totalbytes13, align 8
  %27 = load %struct.global_State** %g, align 8
  %GCdebt14 = getelementptr inbounds %struct.global_State* %27, i32 0, i32 3
  %28 = load i64* %GCdebt14, align 8
  %add15 = add i64 %26, %28
  call void @setpause(%struct.global_State* %24, i64 %add15)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @incstep(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %g = alloca %struct.global_State*, align 8
  %debt = alloca i64, align 8
  %stepmul = alloca i32, align 4
  %work = alloca i64, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 5
  %1 = load %struct.global_State** %l_G, align 8
  store %struct.global_State* %1, %struct.global_State** %g, align 8
  %2 = load %struct.global_State** %g, align 8
  %GCdebt = getelementptr inbounds %struct.global_State* %2, i32 0, i32 3
  %3 = load i64* %GCdebt, align 8
  store i64 %3, i64* %debt, align 8
  %4 = load %struct.global_State** %g, align 8
  %gcstepmul = getelementptr inbounds %struct.global_State* %4, i32 0, i32 28
  %5 = load i32* %gcstepmul, align 4
  store i32 %5, i32* %stepmul, align 4
  %6 = load i32* %stepmul, align 4
  %cmp = icmp slt i32 %6, 40
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 40, i32* %stepmul, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %7 = load i64* %debt, align 8
  %div = sdiv i64 %7, 200
  %add = add nsw i64 %div, 1
  store i64 %add, i64* %debt, align 8
  %8 = load i64* %debt, align 8
  %9 = load i32* %stepmul, align 4
  %conv = sext i32 %9 to i64
  %div1 = sdiv i64 9223372036854775804, %conv
  %cmp2 = icmp slt i64 %8, %div1
  br i1 %cmp2, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %10 = load i64* %debt, align 8
  %11 = load i32* %stepmul, align 4
  %conv4 = sext i32 %11 to i64
  %mul = mul nsw i64 %10, %conv4
  br label %cond.end

cond.false:                                       ; preds = %if.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %mul, %cond.true ], [ 9223372036854775804, %cond.false ]
  store i64 %cond, i64* %debt, align 8
  br label %do.body

do.body:                                          ; preds = %land.end, %cond.end
  %12 = load %struct.lua_State** %L.addr, align 8
  %call = call i64 @singlestep(%struct.lua_State* %12)
  store i64 %call, i64* %work, align 8
  %13 = load i64* %work, align 8
  %14 = load i64* %debt, align 8
  %sub = sub i64 %14, %13
  store i64 %sub, i64* %debt, align 8
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %15 = load i64* %debt, align 8
  %cmp5 = icmp sgt i64 %15, -2400
  br i1 %cmp5, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %do.cond
  %16 = load %struct.global_State** %g, align 8
  %gcstate = getelementptr inbounds %struct.global_State* %16, i32 0, i32 10
  %17 = load i8* %gcstate, align 1
  %conv7 = zext i8 %17 to i32
  %cmp8 = icmp ne i32 %conv7, 5
  br label %land.end

land.end:                                         ; preds = %land.rhs, %do.cond
  %18 = phi i1 [ false, %do.cond ], [ %cmp8, %land.rhs ]
  br i1 %18, label %do.body, label %do.end

do.end:                                           ; preds = %land.end
  %19 = load %struct.global_State** %g, align 8
  %gcstate10 = getelementptr inbounds %struct.global_State* %19, i32 0, i32 10
  %20 = load i8* %gcstate10, align 1
  %conv11 = zext i8 %20 to i32
  %cmp12 = icmp eq i32 %conv11, 5
  br i1 %cmp12, label %if.then14, label %if.else

if.then14:                                        ; preds = %do.end
  %21 = load %struct.global_State** %g, align 8
  %22 = load %struct.global_State** %g, align 8
  %GCestimate = getelementptr inbounds %struct.global_State* %22, i32 0, i32 5
  %23 = load i64* %GCestimate, align 8
  call void @setpause(%struct.global_State* %21, i64 %23)
  br label %if.end18

if.else:                                          ; preds = %do.end
  %24 = load i64* %debt, align 8
  %25 = load i32* %stepmul, align 4
  %conv15 = sext i32 %25 to i64
  %div16 = sdiv i64 %24, %conv15
  %mul17 = mul nsw i64 %div16, 200
  store i64 %mul17, i64* %debt, align 8
  %26 = load %struct.global_State** %g, align 8
  %27 = load i64* %debt, align 8
  call void bitcast (void (%struct.global_State.337*, i64)* @luaE_setdebt to void (%struct.global_State*, i64)*)(%struct.global_State* %26, i64 %27)
  br label %if.end18

if.end18:                                         ; preds = %if.else, %if.then14
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @GCTM(%struct.lua_State* %L, i32 %propagateerrors) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %propagateerrors.addr = alloca i32, align 4
  %g = alloca %struct.global_State*, align 8
  %tm = alloca %struct.lua_TValue*, align 8
  %v = alloca %struct.lua_TValue, align 8
  %io = alloca %struct.lua_TValue*, align 8
  %i_g = alloca %union.GCObject*, align 8
  %status = alloca i32, align 4
  %oldah = alloca i8, align 1
  %running = alloca i32, align 4
  %io2 = alloca %struct.lua_TValue*, align 8
  %io1 = alloca %struct.lua_TValue*, align 8
  %io213 = alloca %struct.lua_TValue*, align 8
  %io114 = alloca %struct.lua_TValue*, align 8
  %msg = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %propagateerrors, i32* %propagateerrors.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 5
  %1 = load %struct.global_State** %l_G, align 8
  store %struct.global_State* %1, %struct.global_State** %g, align 8
  store %struct.lua_TValue* %v, %struct.lua_TValue** %io, align 8
  %2 = load %struct.global_State** %g, align 8
  %call = call %union.GCObject* @udata2finalize(%struct.global_State* %2)
  store %union.GCObject* %call, %union.GCObject** %i_g, align 8
  %3 = load %union.GCObject** %i_g, align 8
  %4 = load %struct.lua_TValue** %io, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %4, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  store %union.GCObject* %3, %union.GCObject** %gc, align 8
  %5 = load %union.GCObject** %i_g, align 8
  %gch = bitcast %union.GCObject* %5 to %struct.GCheader*
  %tt = getelementptr inbounds %struct.GCheader* %gch, i32 0, i32 1
  %6 = load i8* %tt, align 1
  %conv = zext i8 %6 to i32
  %or = or i32 %conv, 64
  %7 = load %struct.lua_TValue** %io, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %7, i32 0, i32 1
  store i32 %or, i32* %tt_, align 4
  %8 = load %struct.lua_State** %L.addr, align 8
  %call1 = call %struct.lua_TValue* @luaT_gettmbyobj(%struct.lua_State* %8, %struct.lua_TValue* %v, i32 2)
  store %struct.lua_TValue* %call1, %struct.lua_TValue** %tm, align 8
  %9 = load %struct.lua_TValue** %tm, align 8
  %cmp = icmp ne %struct.lua_TValue* %9, null
  br i1 %cmp, label %land.lhs.true, label %if.end48

land.lhs.true:                                    ; preds = %entry
  %10 = load %struct.lua_TValue** %tm, align 8
  %tt_3 = getelementptr inbounds %struct.lua_TValue* %10, i32 0, i32 1
  %11 = load i32* %tt_3, align 4
  %and = and i32 %11, 15
  %cmp4 = icmp eq i32 %and, 6
  br i1 %cmp4, label %if.then, label %if.end48

if.then:                                          ; preds = %land.lhs.true
  %12 = load %struct.lua_State** %L.addr, align 8
  %allowhook = getelementptr inbounds %struct.lua_State* %12, i32 0, i32 14
  %13 = load i8* %allowhook, align 1
  store i8 %13, i8* %oldah, align 1
  %14 = load %struct.global_State** %g, align 8
  %gcrunning = getelementptr inbounds %struct.global_State* %14, i32 0, i32 12
  %15 = load i8* %gcrunning, align 1
  %conv6 = zext i8 %15 to i32
  store i32 %conv6, i32* %running, align 4
  %16 = load %struct.lua_State** %L.addr, align 8
  %allowhook7 = getelementptr inbounds %struct.lua_State* %16, i32 0, i32 14
  store i8 0, i8* %allowhook7, align 1
  %17 = load %struct.global_State** %g, align 8
  %gcrunning8 = getelementptr inbounds %struct.global_State* %17, i32 0, i32 12
  store i8 0, i8* %gcrunning8, align 1
  %18 = load %struct.lua_TValue** %tm, align 8
  store %struct.lua_TValue* %18, %struct.lua_TValue** %io2, align 8
  %19 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %19, i32 0, i32 4
  %20 = load %struct.lua_TValue** %top, align 8
  store %struct.lua_TValue* %20, %struct.lua_TValue** %io1, align 8
  %21 = load %struct.lua_TValue** %io1, align 8
  %value_9 = getelementptr inbounds %struct.lua_TValue* %21, i32 0, i32 0
  %22 = load %struct.lua_TValue** %io2, align 8
  %value_10 = getelementptr inbounds %struct.lua_TValue* %22, i32 0, i32 0
  %23 = bitcast %union.Value* %value_9 to i8*
  %24 = bitcast %union.Value* %value_10 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %23, i8* %24, i64 8, i32 8, i1 false)
  %25 = load %struct.lua_TValue** %io2, align 8
  %tt_11 = getelementptr inbounds %struct.lua_TValue* %25, i32 0, i32 1
  %26 = load i32* %tt_11, align 4
  %27 = load %struct.lua_TValue** %io1, align 8
  %tt_12 = getelementptr inbounds %struct.lua_TValue* %27, i32 0, i32 1
  store i32 %26, i32* %tt_12, align 4
  store %struct.lua_TValue* %v, %struct.lua_TValue** %io213, align 8
  %28 = load %struct.lua_State** %L.addr, align 8
  %top15 = getelementptr inbounds %struct.lua_State* %28, i32 0, i32 4
  %29 = load %struct.lua_TValue** %top15, align 8
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %29, i64 1
  store %struct.lua_TValue* %add.ptr, %struct.lua_TValue** %io114, align 8
  %30 = load %struct.lua_TValue** %io114, align 8
  %value_16 = getelementptr inbounds %struct.lua_TValue* %30, i32 0, i32 0
  %31 = load %struct.lua_TValue** %io213, align 8
  %value_17 = getelementptr inbounds %struct.lua_TValue* %31, i32 0, i32 0
  %32 = bitcast %union.Value* %value_16 to i8*
  %33 = bitcast %union.Value* %value_17 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %32, i8* %33, i64 8, i32 8, i1 false)
  %34 = load %struct.lua_TValue** %io213, align 8
  %tt_18 = getelementptr inbounds %struct.lua_TValue* %34, i32 0, i32 1
  %35 = load i32* %tt_18, align 4
  %36 = load %struct.lua_TValue** %io114, align 8
  %tt_19 = getelementptr inbounds %struct.lua_TValue* %36, i32 0, i32 1
  store i32 %35, i32* %tt_19, align 4
  %37 = load %struct.lua_State** %L.addr, align 8
  %top20 = getelementptr inbounds %struct.lua_State* %37, i32 0, i32 4
  %38 = load %struct.lua_TValue** %top20, align 8
  %add.ptr21 = getelementptr inbounds %struct.lua_TValue* %38, i64 2
  store %struct.lua_TValue* %add.ptr21, %struct.lua_TValue** %top20, align 8
  %39 = load %struct.lua_State** %L.addr, align 8
  %40 = load %struct.lua_State** %L.addr, align 8
  %top22 = getelementptr inbounds %struct.lua_State* %40, i32 0, i32 4
  %41 = load %struct.lua_TValue** %top22, align 8
  %add.ptr23 = getelementptr inbounds %struct.lua_TValue* %41, i64 -2
  %42 = bitcast %struct.lua_TValue* %add.ptr23 to i8*
  %43 = load %struct.lua_State** %L.addr, align 8
  %stack = getelementptr inbounds %struct.lua_State* %43, i32 0, i32 9
  %44 = load %struct.lua_TValue** %stack, align 8
  %45 = bitcast %struct.lua_TValue* %44 to i8*
  %sub.ptr.lhs.cast = ptrtoint i8* %42 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %45 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %call24 = call i32 @luaD_pcall(%struct.lua_State* %39, void (%struct.lua_State*, i8*)* @dothecall, i8* null, i64 %sub.ptr.sub, i64 0)
  store i32 %call24, i32* %status, align 4
  %46 = load i8* %oldah, align 1
  %47 = load %struct.lua_State** %L.addr, align 8
  %allowhook25 = getelementptr inbounds %struct.lua_State* %47, i32 0, i32 14
  store i8 %46, i8* %allowhook25, align 1
  %48 = load i32* %running, align 4
  %conv26 = trunc i32 %48 to i8
  %49 = load %struct.global_State** %g, align 8
  %gcrunning27 = getelementptr inbounds %struct.global_State* %49, i32 0, i32 12
  store i8 %conv26, i8* %gcrunning27, align 1
  %50 = load i32* %status, align 4
  %cmp28 = icmp ne i32 %50, 0
  br i1 %cmp28, label %land.lhs.true30, label %if.end47

land.lhs.true30:                                  ; preds = %if.then
  %51 = load i32* %propagateerrors.addr, align 4
  %tobool = icmp ne i32 %51, 0
  br i1 %tobool, label %if.then31, label %if.end47

if.then31:                                        ; preds = %land.lhs.true30
  %52 = load i32* %status, align 4
  %cmp32 = icmp eq i32 %52, 2
  br i1 %cmp32, label %if.then34, label %if.end

if.then34:                                        ; preds = %if.then31
  %53 = load %struct.lua_State** %L.addr, align 8
  %top35 = getelementptr inbounds %struct.lua_State* %53, i32 0, i32 4
  %54 = load %struct.lua_TValue** %top35, align 8
  %add.ptr36 = getelementptr inbounds %struct.lua_TValue* %54, i64 -1
  %tt_37 = getelementptr inbounds %struct.lua_TValue* %add.ptr36, i32 0, i32 1
  %55 = load i32* %tt_37, align 4
  %and38 = and i32 %55, 15
  %cmp39 = icmp eq i32 %and38, 4
  br i1 %cmp39, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then34
  %56 = load %struct.lua_State** %L.addr, align 8
  %top41 = getelementptr inbounds %struct.lua_State* %56, i32 0, i32 4
  %57 = load %struct.lua_TValue** %top41, align 8
  %add.ptr42 = getelementptr inbounds %struct.lua_TValue* %57, i64 -1
  %value_43 = getelementptr inbounds %struct.lua_TValue* %add.ptr42, i32 0, i32 0
  %gc44 = bitcast %union.Value* %value_43 to %union.GCObject**
  %58 = load %union.GCObject** %gc44, align 8
  %ts = bitcast %union.GCObject* %58 to %union.TString*
  %add.ptr45 = getelementptr inbounds %union.TString* %ts, i64 1
  %59 = bitcast %union.TString* %add.ptr45 to i8*
  br label %cond.end

cond.false:                                       ; preds = %if.then34
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %59, %cond.true ], [ getelementptr inbounds ([11 x i8]* @.str275, i32 0, i32 0), %cond.false ]
  store i8* %cond, i8** %msg, align 8
  %60 = load %struct.lua_State** %L.addr, align 8
  %61 = load i8** %msg, align 8
  %call46 = call i8* (%struct.lua_State*, i8*, ...)* bitcast (i8* (%struct.lua_State.279*, i8*, ...)* @luaO_pushfstring to i8* (%struct.lua_State*, i8*, ...)*)(%struct.lua_State* %60, i8* getelementptr inbounds ([30 x i8]* @.str1276, i32 0, i32 0), i8* %61)
  store i32 5, i32* %status, align 4
  br label %if.end

if.end:                                           ; preds = %cond.end, %if.then31
  %62 = load %struct.lua_State** %L.addr, align 8
  %63 = load i32* %status, align 4
  call void @luaD_throw(%struct.lua_State* %62, i32 %63) #9
  unreachable

if.end47:                                         ; preds = %land.lhs.true30, %if.then
  br label %if.end48

if.end48:                                         ; preds = %if.end47, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @setpause(%struct.global_State* %g, i64 %estimate) #0 {
entry:
  %g.addr = alloca %struct.global_State*, align 8
  %estimate.addr = alloca i64, align 8
  %debt = alloca i64, align 8
  %threshold = alloca i64, align 8
  store %struct.global_State* %g, %struct.global_State** %g.addr, align 8
  store i64 %estimate, i64* %estimate.addr, align 8
  %0 = load i64* %estimate.addr, align 8
  %div = sdiv i64 %0, 100
  store i64 %div, i64* %estimate.addr, align 8
  %1 = load %struct.global_State** %g.addr, align 8
  %gcpause = getelementptr inbounds %struct.global_State* %1, i32 0, i32 26
  %2 = load i32* %gcpause, align 4
  %conv = sext i32 %2 to i64
  %3 = load i64* %estimate.addr, align 8
  %div1 = sdiv i64 9223372036854775804, %3
  %cmp = icmp slt i64 %conv, %div1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %4 = load i64* %estimate.addr, align 8
  %5 = load %struct.global_State** %g.addr, align 8
  %gcpause3 = getelementptr inbounds %struct.global_State* %5, i32 0, i32 26
  %6 = load i32* %gcpause3, align 4
  %conv4 = sext i32 %6 to i64
  %mul = mul nsw i64 %4, %conv4
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %mul, %cond.true ], [ 9223372036854775804, %cond.false ]
  store i64 %cond, i64* %threshold, align 8
  %7 = load i64* %threshold, align 8
  %8 = load %struct.global_State** %g.addr, align 8
  %totalbytes = getelementptr inbounds %struct.global_State* %8, i32 0, i32 2
  %9 = load i64* %totalbytes, align 8
  %10 = load %struct.global_State** %g.addr, align 8
  %GCdebt = getelementptr inbounds %struct.global_State* %10, i32 0, i32 3
  %11 = load i64* %GCdebt, align 8
  %add = add i64 %9, %11
  %sub = sub i64 %7, %add
  %sub5 = sub nsw i64 0, %sub
  store i64 %sub5, i64* %debt, align 8
  %12 = load %struct.global_State** %g.addr, align 8
  %13 = load i64* %debt, align 8
  call void bitcast (void (%struct.global_State.337*, i64)* @luaE_setdebt to void (%struct.global_State*, i64)*)(%struct.global_State* %12, i64 %13)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @restartcollection(%struct.global_State* %g) #0 {
entry:
  %g.addr = alloca %struct.global_State*, align 8
  store %struct.global_State* %g, %struct.global_State** %g.addr, align 8
  %0 = load %struct.global_State** %g.addr, align 8
  %grayagain = getelementptr inbounds %struct.global_State* %0, i32 0, i32 19
  store %union.GCObject* null, %union.GCObject** %grayagain, align 8
  %1 = load %struct.global_State** %g.addr, align 8
  %gray = getelementptr inbounds %struct.global_State* %1, i32 0, i32 18
  store %union.GCObject* null, %union.GCObject** %gray, align 8
  %2 = load %struct.global_State** %g.addr, align 8
  %ephemeron = getelementptr inbounds %struct.global_State* %2, i32 0, i32 21
  store %union.GCObject* null, %union.GCObject** %ephemeron, align 8
  %3 = load %struct.global_State** %g.addr, align 8
  %allweak = getelementptr inbounds %struct.global_State* %3, i32 0, i32 22
  store %union.GCObject* null, %union.GCObject** %allweak, align 8
  %4 = load %struct.global_State** %g.addr, align 8
  %weak = getelementptr inbounds %struct.global_State* %4, i32 0, i32 20
  store %union.GCObject* null, %union.GCObject** %weak, align 8
  %5 = load %struct.global_State** %g.addr, align 8
  %mainthread = getelementptr inbounds %struct.global_State* %5, i32 0, i32 30
  %6 = load %struct.lua_State** %mainthread, align 8
  %tobool = icmp ne %struct.lua_State* %6, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %7 = load %struct.global_State** %g.addr, align 8
  %mainthread1 = getelementptr inbounds %struct.global_State* %7, i32 0, i32 30
  %8 = load %struct.lua_State** %mainthread1, align 8
  %9 = bitcast %struct.lua_State* %8 to %union.GCObject*
  %gch = bitcast %union.GCObject* %9 to %struct.GCheader*
  %marked = getelementptr inbounds %struct.GCheader* %gch, i32 0, i32 2
  %10 = load i8* %marked, align 1
  %conv = zext i8 %10 to i32
  %and = and i32 %conv, 3
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %11 = load %struct.global_State** %g.addr, align 8
  %12 = load %struct.global_State** %g.addr, align 8
  %mainthread3 = getelementptr inbounds %struct.global_State* %12, i32 0, i32 30
  %13 = load %struct.lua_State** %mainthread3, align 8
  %14 = bitcast %struct.lua_State* %13 to %union.GCObject*
  call void @reallymarkobject(%struct.global_State* %11, %union.GCObject* %14)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %15 = load %struct.global_State** %g.addr, align 8
  %l_registry = getelementptr inbounds %struct.global_State* %15, i32 0, i32 7
  %tt_ = getelementptr inbounds %struct.lua_TValue* %l_registry, i32 0, i32 1
  %16 = load i32* %tt_, align 4
  %and4 = and i32 %16, 64
  %tobool5 = icmp ne i32 %and4, 0
  br i1 %tobool5, label %land.lhs.true6, label %if.end17

land.lhs.true6:                                   ; preds = %if.end
  %17 = load %struct.global_State** %g.addr, align 8
  %l_registry7 = getelementptr inbounds %struct.global_State* %17, i32 0, i32 7
  %value_ = getelementptr inbounds %struct.lua_TValue* %l_registry7, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %18 = load %union.GCObject** %gc, align 8
  %gch8 = bitcast %union.GCObject* %18 to %struct.GCheader*
  %marked9 = getelementptr inbounds %struct.GCheader* %gch8, i32 0, i32 2
  %19 = load i8* %marked9, align 1
  %conv10 = zext i8 %19 to i32
  %and11 = and i32 %conv10, 3
  %tobool12 = icmp ne i32 %and11, 0
  br i1 %tobool12, label %if.then13, label %if.end17

if.then13:                                        ; preds = %land.lhs.true6
  %20 = load %struct.global_State** %g.addr, align 8
  %21 = load %struct.global_State** %g.addr, align 8
  %l_registry14 = getelementptr inbounds %struct.global_State* %21, i32 0, i32 7
  %value_15 = getelementptr inbounds %struct.lua_TValue* %l_registry14, i32 0, i32 0
  %gc16 = bitcast %union.Value* %value_15 to %union.GCObject**
  %22 = load %union.GCObject** %gc16, align 8
  call void @reallymarkobject(%struct.global_State* %20, %union.GCObject* %22)
  br label %if.end17

if.end17:                                         ; preds = %if.then13, %land.lhs.true6, %if.end
  %23 = load %struct.global_State** %g.addr, align 8
  call void @markmt(%struct.global_State* %23)
  %24 = load %struct.global_State** %g.addr, align 8
  call void @markbeingfnz(%struct.global_State* %24)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @propagatemark(%struct.global_State* %g) #0 {
entry:
  %g.addr = alloca %struct.global_State*, align 8
  %size = alloca i64, align 8
  %o = alloca %union.GCObject*, align 8
  %h = alloca %struct.Table*, align 8
  %cl = alloca %struct.LClosure*, align 8
  %cl12 = alloca %struct.CClosure*, align 8
  %th = alloca %struct.lua_State*, align 8
  %p = alloca %struct.Proto*, align 8
  store %struct.global_State* %g, %struct.global_State** %g.addr, align 8
  %0 = load %struct.global_State** %g.addr, align 8
  %gray = getelementptr inbounds %struct.global_State* %0, i32 0, i32 18
  %1 = load %union.GCObject** %gray, align 8
  store %union.GCObject* %1, %union.GCObject** %o, align 8
  %2 = load %union.GCObject** %o, align 8
  %gch = bitcast %union.GCObject* %2 to %struct.GCheader*
  %marked = getelementptr inbounds %struct.GCheader* %gch, i32 0, i32 2
  %3 = load i8* %marked, align 1
  %conv = zext i8 %3 to i32
  %or = or i32 %conv, 4
  %conv1 = trunc i32 %or to i8
  store i8 %conv1, i8* %marked, align 1
  %4 = load %union.GCObject** %o, align 8
  %gch2 = bitcast %union.GCObject* %4 to %struct.GCheader*
  %tt = getelementptr inbounds %struct.GCheader* %gch2, i32 0, i32 1
  %5 = load i8* %tt, align 1
  %conv3 = zext i8 %5 to i32
  switch i32 %conv3, label %sw.default [
    i32 5, label %sw.bb
    i32 6, label %sw.bb6
    i32 38, label %sw.bb11
    i32 8, label %sw.bb17
    i32 9, label %sw.bb28
  ]

sw.bb:                                            ; preds = %entry
  %6 = load %union.GCObject** %o, align 8
  %h4 = bitcast %union.GCObject* %6 to %struct.Table*
  store %struct.Table* %h4, %struct.Table** %h, align 8
  %7 = load %struct.Table** %h, align 8
  %gclist = getelementptr inbounds %struct.Table* %7, i32 0, i32 9
  %8 = load %union.GCObject** %gclist, align 8
  %9 = load %struct.global_State** %g.addr, align 8
  %gray5 = getelementptr inbounds %struct.global_State* %9, i32 0, i32 18
  store %union.GCObject* %8, %union.GCObject** %gray5, align 8
  %10 = load %struct.global_State** %g.addr, align 8
  %11 = load %struct.Table** %h, align 8
  %call = call i64 @traversetable(%struct.global_State* %10, %struct.Table* %11)
  store i64 %call, i64* %size, align 8
  br label %sw.epilog

sw.bb6:                                           ; preds = %entry
  %12 = load %union.GCObject** %o, align 8
  %cl7 = bitcast %union.GCObject* %12 to %union.Closure*
  %l = bitcast %union.Closure* %cl7 to %struct.LClosure*
  store %struct.LClosure* %l, %struct.LClosure** %cl, align 8
  %13 = load %struct.LClosure** %cl, align 8
  %gclist8 = getelementptr inbounds %struct.LClosure* %13, i32 0, i32 4
  %14 = load %union.GCObject** %gclist8, align 8
  %15 = load %struct.global_State** %g.addr, align 8
  %gray9 = getelementptr inbounds %struct.global_State* %15, i32 0, i32 18
  store %union.GCObject* %14, %union.GCObject** %gray9, align 8
  %16 = load %struct.global_State** %g.addr, align 8
  %17 = load %struct.LClosure** %cl, align 8
  %call10 = call i64 @traverseLclosure(%struct.global_State* %16, %struct.LClosure* %17)
  store i64 %call10, i64* %size, align 8
  br label %sw.epilog

sw.bb11:                                          ; preds = %entry
  %18 = load %union.GCObject** %o, align 8
  %cl13 = bitcast %union.GCObject* %18 to %union.Closure*
  %c = bitcast %union.Closure* %cl13 to %struct.CClosure*
  store %struct.CClosure* %c, %struct.CClosure** %cl12, align 8
  %19 = load %struct.CClosure** %cl12, align 8
  %gclist14 = getelementptr inbounds %struct.CClosure* %19, i32 0, i32 4
  %20 = load %union.GCObject** %gclist14, align 8
  %21 = load %struct.global_State** %g.addr, align 8
  %gray15 = getelementptr inbounds %struct.global_State* %21, i32 0, i32 18
  store %union.GCObject* %20, %union.GCObject** %gray15, align 8
  %22 = load %struct.global_State** %g.addr, align 8
  %23 = load %struct.CClosure** %cl12, align 8
  %call16 = call i64 @traverseCclosure(%struct.global_State* %22, %struct.CClosure* %23)
  store i64 %call16, i64* %size, align 8
  br label %sw.epilog

sw.bb17:                                          ; preds = %entry
  %24 = load %union.GCObject** %o, align 8
  %th18 = bitcast %union.GCObject* %24 to %struct.lua_State*
  store %struct.lua_State* %th18, %struct.lua_State** %th, align 8
  %25 = load %struct.lua_State** %th, align 8
  %gclist19 = getelementptr inbounds %struct.lua_State* %25, i32 0, i32 19
  %26 = load %union.GCObject** %gclist19, align 8
  %27 = load %struct.global_State** %g.addr, align 8
  %gray20 = getelementptr inbounds %struct.global_State* %27, i32 0, i32 18
  store %union.GCObject* %26, %union.GCObject** %gray20, align 8
  %28 = load %struct.global_State** %g.addr, align 8
  %grayagain = getelementptr inbounds %struct.global_State* %28, i32 0, i32 19
  %29 = load %union.GCObject** %grayagain, align 8
  %30 = load %struct.lua_State** %th, align 8
  %gclist21 = getelementptr inbounds %struct.lua_State* %30, i32 0, i32 19
  store %union.GCObject* %29, %union.GCObject** %gclist21, align 8
  %31 = load %union.GCObject** %o, align 8
  %32 = load %struct.global_State** %g.addr, align 8
  %grayagain22 = getelementptr inbounds %struct.global_State* %32, i32 0, i32 19
  store %union.GCObject* %31, %union.GCObject** %grayagain22, align 8
  %33 = load %union.GCObject** %o, align 8
  %gch23 = bitcast %union.GCObject* %33 to %struct.GCheader*
  %marked24 = getelementptr inbounds %struct.GCheader* %gch23, i32 0, i32 2
  %34 = load i8* %marked24, align 1
  %conv25 = zext i8 %34 to i32
  %and = and i32 %conv25, 251
  %conv26 = trunc i32 %and to i8
  store i8 %conv26, i8* %marked24, align 1
  %35 = load %struct.global_State** %g.addr, align 8
  %36 = load %struct.lua_State** %th, align 8
  %call27 = call i64 @traversestack(%struct.global_State* %35, %struct.lua_State* %36)
  store i64 %call27, i64* %size, align 8
  br label %sw.epilog

sw.bb28:                                          ; preds = %entry
  %37 = load %union.GCObject** %o, align 8
  %p29 = bitcast %union.GCObject* %37 to %struct.Proto*
  store %struct.Proto* %p29, %struct.Proto** %p, align 8
  %38 = load %struct.Proto** %p, align 8
  %gclist30 = getelementptr inbounds %struct.Proto* %38, i32 0, i32 19
  %39 = load %union.GCObject** %gclist30, align 8
  %40 = load %struct.global_State** %g.addr, align 8
  %gray31 = getelementptr inbounds %struct.global_State* %40, i32 0, i32 18
  store %union.GCObject* %39, %union.GCObject** %gray31, align 8
  %41 = load %struct.global_State** %g.addr, align 8
  %42 = load %struct.Proto** %p, align 8
  %call32 = call i32 @traverseproto(%struct.global_State* %41, %struct.Proto* %42)
  %conv33 = sext i32 %call32 to i64
  store i64 %conv33, i64* %size, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  br label %return

sw.epilog:                                        ; preds = %sw.bb28, %sw.bb17, %sw.bb11, %sw.bb6, %sw.bb
  %43 = load i64* %size, align 8
  %44 = load %struct.global_State** %g.addr, align 8
  %GCmemtrav = getelementptr inbounds %struct.global_State* %44, i32 0, i32 4
  %45 = load i64* %GCmemtrav, align 8
  %add = add i64 %45, %43
  store i64 %add, i64* %GCmemtrav, align 8
  br label %return

return:                                           ; preds = %sw.epilog, %sw.default
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @atomic(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %g = alloca %struct.global_State*, align 8
  %work = alloca i64, align 8
  %origweak = alloca %union.GCObject*, align 8
  %origall = alloca %union.GCObject*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 5
  %1 = load %struct.global_State** %l_G, align 8
  store %struct.global_State* %1, %struct.global_State** %g, align 8
  %2 = load %struct.global_State** %g, align 8
  %GCmemtrav = getelementptr inbounds %struct.global_State* %2, i32 0, i32 4
  %3 = load i64* %GCmemtrav, align 8
  %sub = sub nsw i64 0, %3
  store i64 %sub, i64* %work, align 8
  %4 = load %struct.lua_State** %L.addr, align 8
  %tobool = icmp ne %struct.lua_State* %4, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %5 = load %struct.lua_State** %L.addr, align 8
  %6 = bitcast %struct.lua_State* %5 to %union.GCObject*
  %gch = bitcast %union.GCObject* %6 to %struct.GCheader*
  %marked = getelementptr inbounds %struct.GCheader* %gch, i32 0, i32 2
  %7 = load i8* %marked, align 1
  %conv = zext i8 %7 to i32
  %and = and i32 %conv, 3
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %8 = load %struct.global_State** %g, align 8
  %9 = load %struct.lua_State** %L.addr, align 8
  %10 = bitcast %struct.lua_State* %9 to %union.GCObject*
  call void @reallymarkobject(%struct.global_State* %8, %union.GCObject* %10)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %11 = load %struct.global_State** %g, align 8
  %l_registry = getelementptr inbounds %struct.global_State* %11, i32 0, i32 7
  %tt_ = getelementptr inbounds %struct.lua_TValue* %l_registry, i32 0, i32 1
  %12 = load i32* %tt_, align 4
  %and2 = and i32 %12, 64
  %tobool3 = icmp ne i32 %and2, 0
  br i1 %tobool3, label %land.lhs.true4, label %if.end15

land.lhs.true4:                                   ; preds = %if.end
  %13 = load %struct.global_State** %g, align 8
  %l_registry5 = getelementptr inbounds %struct.global_State* %13, i32 0, i32 7
  %value_ = getelementptr inbounds %struct.lua_TValue* %l_registry5, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %14 = load %union.GCObject** %gc, align 8
  %gch6 = bitcast %union.GCObject* %14 to %struct.GCheader*
  %marked7 = getelementptr inbounds %struct.GCheader* %gch6, i32 0, i32 2
  %15 = load i8* %marked7, align 1
  %conv8 = zext i8 %15 to i32
  %and9 = and i32 %conv8, 3
  %tobool10 = icmp ne i32 %and9, 0
  br i1 %tobool10, label %if.then11, label %if.end15

if.then11:                                        ; preds = %land.lhs.true4
  %16 = load %struct.global_State** %g, align 8
  %17 = load %struct.global_State** %g, align 8
  %l_registry12 = getelementptr inbounds %struct.global_State* %17, i32 0, i32 7
  %value_13 = getelementptr inbounds %struct.lua_TValue* %l_registry12, i32 0, i32 0
  %gc14 = bitcast %union.Value* %value_13 to %union.GCObject**
  %18 = load %union.GCObject** %gc14, align 8
  call void @reallymarkobject(%struct.global_State* %16, %union.GCObject* %18)
  br label %if.end15

if.end15:                                         ; preds = %if.then11, %land.lhs.true4, %if.end
  %19 = load %struct.global_State** %g, align 8
  call void @markmt(%struct.global_State* %19)
  %20 = load %struct.global_State** %g, align 8
  call void @remarkupvals(%struct.global_State* %20)
  %21 = load %struct.global_State** %g, align 8
  call void @propagateall(%struct.global_State* %21)
  %22 = load %struct.global_State** %g, align 8
  %GCmemtrav16 = getelementptr inbounds %struct.global_State* %22, i32 0, i32 4
  %23 = load i64* %GCmemtrav16, align 8
  %24 = load i64* %work, align 8
  %add = add i64 %24, %23
  store i64 %add, i64* %work, align 8
  %25 = load %struct.global_State** %g, align 8
  call void @retraversegrays(%struct.global_State* %25)
  %26 = load %struct.global_State** %g, align 8
  %GCmemtrav17 = getelementptr inbounds %struct.global_State* %26, i32 0, i32 4
  %27 = load i64* %GCmemtrav17, align 8
  %28 = load i64* %work, align 8
  %sub18 = sub i64 %28, %27
  store i64 %sub18, i64* %work, align 8
  %29 = load %struct.global_State** %g, align 8
  call void @convergeephemerons(%struct.global_State* %29)
  %30 = load %struct.global_State** %g, align 8
  %31 = load %struct.global_State** %g, align 8
  %weak = getelementptr inbounds %struct.global_State* %31, i32 0, i32 20
  %32 = load %union.GCObject** %weak, align 8
  call void @clearvalues(%struct.global_State* %30, %union.GCObject* %32, %union.GCObject* null)
  %33 = load %struct.global_State** %g, align 8
  %34 = load %struct.global_State** %g, align 8
  %allweak = getelementptr inbounds %struct.global_State* %34, i32 0, i32 22
  %35 = load %union.GCObject** %allweak, align 8
  call void @clearvalues(%struct.global_State* %33, %union.GCObject* %35, %union.GCObject* null)
  %36 = load %struct.global_State** %g, align 8
  %weak19 = getelementptr inbounds %struct.global_State* %36, i32 0, i32 20
  %37 = load %union.GCObject** %weak19, align 8
  store %union.GCObject* %37, %union.GCObject** %origweak, align 8
  %38 = load %struct.global_State** %g, align 8
  %allweak20 = getelementptr inbounds %struct.global_State* %38, i32 0, i32 22
  %39 = load %union.GCObject** %allweak20, align 8
  store %union.GCObject* %39, %union.GCObject** %origall, align 8
  %40 = load %struct.global_State** %g, align 8
  %GCmemtrav21 = getelementptr inbounds %struct.global_State* %40, i32 0, i32 4
  %41 = load i64* %GCmemtrav21, align 8
  %42 = load i64* %work, align 8
  %add22 = add i64 %42, %41
  store i64 %add22, i64* %work, align 8
  %43 = load %struct.lua_State** %L.addr, align 8
  call void @separatetobefnz(%struct.lua_State* %43, i32 0)
  %44 = load %struct.global_State** %g, align 8
  call void @markbeingfnz(%struct.global_State* %44)
  %45 = load %struct.global_State** %g, align 8
  call void @propagateall(%struct.global_State* %45)
  %46 = load %struct.global_State** %g, align 8
  %GCmemtrav23 = getelementptr inbounds %struct.global_State* %46, i32 0, i32 4
  %47 = load i64* %GCmemtrav23, align 8
  %48 = load i64* %work, align 8
  %sub24 = sub i64 %48, %47
  store i64 %sub24, i64* %work, align 8
  %49 = load %struct.global_State** %g, align 8
  call void @convergeephemerons(%struct.global_State* %49)
  %50 = load %struct.global_State** %g, align 8
  %51 = load %struct.global_State** %g, align 8
  %ephemeron = getelementptr inbounds %struct.global_State* %51, i32 0, i32 21
  %52 = load %union.GCObject** %ephemeron, align 8
  call void @clearkeys(%struct.global_State* %50, %union.GCObject* %52, %union.GCObject* null)
  %53 = load %struct.global_State** %g, align 8
  %54 = load %struct.global_State** %g, align 8
  %allweak25 = getelementptr inbounds %struct.global_State* %54, i32 0, i32 22
  %55 = load %union.GCObject** %allweak25, align 8
  call void @clearkeys(%struct.global_State* %53, %union.GCObject* %55, %union.GCObject* null)
  %56 = load %struct.global_State** %g, align 8
  %57 = load %struct.global_State** %g, align 8
  %weak26 = getelementptr inbounds %struct.global_State* %57, i32 0, i32 20
  %58 = load %union.GCObject** %weak26, align 8
  %59 = load %union.GCObject** %origweak, align 8
  call void @clearvalues(%struct.global_State* %56, %union.GCObject* %58, %union.GCObject* %59)
  %60 = load %struct.global_State** %g, align 8
  %61 = load %struct.global_State** %g, align 8
  %allweak27 = getelementptr inbounds %struct.global_State* %61, i32 0, i32 22
  %62 = load %union.GCObject** %allweak27, align 8
  %63 = load %union.GCObject** %origall, align 8
  call void @clearvalues(%struct.global_State* %60, %union.GCObject* %62, %union.GCObject* %63)
  %64 = load %struct.global_State** %g, align 8
  %currentwhite = getelementptr inbounds %struct.global_State* %64, i32 0, i32 9
  %65 = load i8* %currentwhite, align 1
  %conv28 = zext i8 %65 to i32
  %xor = xor i32 %conv28, 3
  %conv29 = trunc i32 %xor to i8
  %66 = load %struct.global_State** %g, align 8
  %currentwhite30 = getelementptr inbounds %struct.global_State* %66, i32 0, i32 9
  store i8 %conv29, i8* %currentwhite30, align 1
  %67 = load %struct.global_State** %g, align 8
  %GCmemtrav31 = getelementptr inbounds %struct.global_State* %67, i32 0, i32 4
  %68 = load i64* %GCmemtrav31, align 8
  %69 = load i64* %work, align 8
  %add32 = add i64 %69, %68
  store i64 %add32, i64* %work, align 8
  %70 = load i64* %work, align 8
  ret i64 %70
}

; Function Attrs: nounwind uwtable
define internal void @checkSizes(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %g = alloca %struct.global_State*, align 8
  %hs = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 5
  %1 = load %struct.global_State** %l_G, align 8
  store %struct.global_State* %1, %struct.global_State** %g, align 8
  %2 = load %struct.global_State** %g, align 8
  %gckind = getelementptr inbounds %struct.global_State* %2, i32 0, i32 11
  %3 = load i8* %gckind, align 1
  %conv = zext i8 %3 to i32
  %cmp = icmp ne i32 %conv, 1
  br i1 %cmp, label %if.then, label %if.end11

if.then:                                          ; preds = %entry
  %4 = load %struct.global_State** %g, align 8
  %strt = getelementptr inbounds %struct.global_State* %4, i32 0, i32 6
  %size = getelementptr inbounds %struct.stringtable* %strt, i32 0, i32 2
  %5 = load i32* %size, align 4
  %div = sdiv i32 %5, 2
  store i32 %div, i32* %hs, align 4
  %6 = load %struct.global_State** %g, align 8
  %strt2 = getelementptr inbounds %struct.global_State* %6, i32 0, i32 6
  %nuse = getelementptr inbounds %struct.stringtable* %strt2, i32 0, i32 1
  %7 = load i32* %nuse, align 4
  %8 = load i32* %hs, align 4
  %cmp3 = icmp ult i32 %7, %8
  br i1 %cmp3, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.then
  %9 = load %struct.lua_State** %L.addr, align 8
  %10 = load i32* %hs, align 4
  call void bitcast (void (%struct.lua_State.364*, i32)* @luaS_resize to void (%struct.lua_State*, i32)*)(%struct.lua_State* %9, i32 %10)
  br label %if.end

if.end:                                           ; preds = %if.then5, %if.then
  %11 = load %struct.lua_State** %L.addr, align 8
  %12 = load %struct.global_State** %g, align 8
  %buff = getelementptr inbounds %struct.global_State* %12, i32 0, i32 25
  %buffer = getelementptr inbounds %struct.Mbuffer* %buff, i32 0, i32 0
  %13 = load i8** %buffer, align 8
  %14 = load %struct.global_State** %g, align 8
  %buff6 = getelementptr inbounds %struct.global_State* %14, i32 0, i32 25
  %buffsize = getelementptr inbounds %struct.Mbuffer* %buff6, i32 0, i32 2
  %15 = load i64* %buffsize, align 8
  %mul = mul i64 %15, 1
  %call = call i8* @luaM_realloc_(%struct.lua_State* %11, i8* %13, i64 %mul, i64 0)
  %16 = load %struct.global_State** %g, align 8
  %buff7 = getelementptr inbounds %struct.global_State* %16, i32 0, i32 25
  %buffer8 = getelementptr inbounds %struct.Mbuffer* %buff7, i32 0, i32 0
  store i8* %call, i8** %buffer8, align 8
  %17 = load %struct.global_State** %g, align 8
  %buff9 = getelementptr inbounds %struct.global_State* %17, i32 0, i32 25
  %buffsize10 = getelementptr inbounds %struct.Mbuffer* %buff9, i32 0, i32 2
  store i64 0, i64* %buffsize10, align 8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @freeobj(%struct.lua_State* %L, %union.GCObject* %o) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %o.addr = alloca %union.GCObject*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %union.GCObject* %o, %union.GCObject** %o.addr, align 8
  %0 = load %union.GCObject** %o.addr, align 8
  %gch = bitcast %union.GCObject* %0 to %struct.GCheader*
  %tt = getelementptr inbounds %struct.GCheader* %gch, i32 0, i32 1
  %1 = load i8* %tt, align 1
  %conv = zext i8 %1 to i32
  switch i32 %conv, label %sw.default [
    i32 9, label %sw.bb
    i32 6, label %sw.bb1
    i32 38, label %sw.bb6
    i32 10, label %sw.bb17
    i32 5, label %sw.bb18
    i32 8, label %sw.bb19
    i32 7, label %sw.bb20
    i32 4, label %sw.bb24
    i32 20, label %sw.bb25
  ]

sw.bb:                                            ; preds = %entry
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load %union.GCObject** %o.addr, align 8
  %p = bitcast %union.GCObject* %3 to %struct.Proto*
  call void bitcast (void (%struct.lua_State.154*, %struct.Proto.160*)* @luaF_freeproto to void (%struct.lua_State*, %struct.Proto*)*)(%struct.lua_State* %2, %struct.Proto* %p)
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load %union.GCObject** %o.addr, align 8
  %6 = bitcast %union.GCObject* %5 to i8*
  %7 = load %union.GCObject** %o.addr, align 8
  %cl = bitcast %union.GCObject* %7 to %union.Closure*
  %l = bitcast %union.Closure* %cl to %struct.LClosure*
  %nupvalues = getelementptr inbounds %struct.LClosure* %l, i32 0, i32 3
  %8 = load i8* %nupvalues, align 1
  %conv2 = zext i8 %8 to i32
  %sub = sub nsw i32 %conv2, 1
  %conv3 = sext i32 %sub to i64
  %mul = mul i64 8, %conv3
  %conv4 = trunc i64 %mul to i32
  %add = add nsw i32 40, %conv4
  %conv5 = sext i32 %add to i64
  %call = call i8* @luaM_realloc_(%struct.lua_State* %4, i8* %6, i64 %conv5, i64 0)
  br label %sw.epilog

sw.bb6:                                           ; preds = %entry
  %9 = load %struct.lua_State** %L.addr, align 8
  %10 = load %union.GCObject** %o.addr, align 8
  %11 = bitcast %union.GCObject* %10 to i8*
  %12 = load %union.GCObject** %o.addr, align 8
  %cl7 = bitcast %union.GCObject* %12 to %union.Closure*
  %c = bitcast %union.Closure* %cl7 to %struct.CClosure*
  %nupvalues8 = getelementptr inbounds %struct.CClosure* %c, i32 0, i32 3
  %13 = load i8* %nupvalues8, align 1
  %conv9 = zext i8 %13 to i32
  %sub10 = sub nsw i32 %conv9, 1
  %conv11 = sext i32 %sub10 to i64
  %mul12 = mul i64 16, %conv11
  %conv13 = trunc i64 %mul12 to i32
  %add14 = add nsw i32 48, %conv13
  %conv15 = sext i32 %add14 to i64
  %call16 = call i8* @luaM_realloc_(%struct.lua_State* %9, i8* %11, i64 %conv15, i64 0)
  br label %sw.epilog

sw.bb17:                                          ; preds = %entry
  %14 = load %struct.lua_State** %L.addr, align 8
  %15 = load %union.GCObject** %o.addr, align 8
  %uv = bitcast %union.GCObject* %15 to %struct.UpVal*
  call void bitcast (void (%struct.lua_State.154*, %struct.UpVal.140*)* @luaF_freeupval to void (%struct.lua_State*, %struct.UpVal*)*)(%struct.lua_State* %14, %struct.UpVal* %uv)
  br label %sw.epilog

sw.bb18:                                          ; preds = %entry
  %16 = load %struct.lua_State** %L.addr, align 8
  %17 = load %union.GCObject** %o.addr, align 8
  %h = bitcast %union.GCObject* %17 to %struct.Table*
  call void @luaH_free(%struct.lua_State* %16, %struct.Table* %h)
  br label %sw.epilog

sw.bb19:                                          ; preds = %entry
  %18 = load %struct.lua_State** %L.addr, align 8
  %19 = load %union.GCObject** %o.addr, align 8
  %th = bitcast %union.GCObject* %19 to %struct.lua_State*
  call void bitcast (void (%struct.lua_State.343*, %struct.lua_State.343*)* @luaE_freethread to void (%struct.lua_State*, %struct.lua_State*)*)(%struct.lua_State* %18, %struct.lua_State* %th)
  br label %sw.epilog

sw.bb20:                                          ; preds = %entry
  %20 = load %struct.lua_State** %L.addr, align 8
  %21 = load %union.GCObject** %o.addr, align 8
  %22 = bitcast %union.GCObject* %21 to i8*
  %23 = load %union.GCObject** %o.addr, align 8
  %u = bitcast %union.GCObject* %23 to %union.Udata*
  %uv21 = bitcast %union.Udata* %u to %struct.anon.5*
  %len = getelementptr inbounds %struct.anon.5* %uv21, i32 0, i32 5
  %24 = load i64* %len, align 8
  %add22 = add i64 40, %24
  %call23 = call i8* @luaM_realloc_(%struct.lua_State* %20, i8* %22, i64 %add22, i64 0)
  br label %sw.epilog

sw.bb24:                                          ; preds = %entry
  %25 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %25, i32 0, i32 5
  %26 = load %struct.global_State** %l_G, align 8
  %strt = getelementptr inbounds %struct.global_State* %26, i32 0, i32 6
  %nuse = getelementptr inbounds %struct.stringtable* %strt, i32 0, i32 1
  %27 = load i32* %nuse, align 4
  %dec = add i32 %27, -1
  store i32 %dec, i32* %nuse, align 4
  br label %sw.bb25

sw.bb25:                                          ; preds = %sw.bb24, %entry
  %28 = load %struct.lua_State** %L.addr, align 8
  %29 = load %union.GCObject** %o.addr, align 8
  %30 = bitcast %union.GCObject* %29 to i8*
  %31 = load %union.GCObject** %o.addr, align 8
  %ts = bitcast %union.GCObject* %31 to %union.TString*
  %tsv = bitcast %union.TString* %ts to %struct.anon.0*
  %len26 = getelementptr inbounds %struct.anon.0* %tsv, i32 0, i32 5
  %32 = load i64* %len26, align 8
  %add27 = add i64 %32, 1
  %mul28 = mul i64 %add27, 1
  %add29 = add i64 24, %mul28
  %call30 = call i8* @luaM_realloc_(%struct.lua_State* %28, i8* %30, i64 %add29, i64 0)
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb25, %sw.bb20, %sw.bb19, %sw.bb18, %sw.bb17, %sw.bb6, %sw.bb1, %sw.bb
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sweepthread(%struct.lua_State* %L, %struct.lua_State* %L1) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %L1.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.lua_State* %L1, %struct.lua_State** %L1.addr, align 8
  %0 = load %struct.lua_State** %L1.addr, align 8
  %stack = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 9
  %1 = load %struct.lua_TValue** %stack, align 8
  %cmp = icmp eq %struct.lua_TValue* %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end4

if.end:                                           ; preds = %entry
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load %struct.lua_State** %L1.addr, align 8
  %openupval = getelementptr inbounds %struct.lua_State* %3, i32 0, i32 18
  %call = call %union.GCObject** @sweeplist(%struct.lua_State* %2, %union.GCObject** %openupval, i64 -3)
  %4 = load %struct.lua_State** %L1.addr, align 8
  call void bitcast (void (%struct.lua_State.343*)* @luaE_freeCI to void (%struct.lua_State*)*)(%struct.lua_State* %4)
  %5 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %5, i32 0, i32 5
  %6 = load %struct.global_State** %l_G, align 8
  %gckind = getelementptr inbounds %struct.global_State* %6, i32 0, i32 11
  %7 = load i8* %gckind, align 1
  %conv = zext i8 %7 to i32
  %cmp1 = icmp ne i32 %conv, 1
  br i1 %cmp1, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %8 = load %struct.lua_State** %L1.addr, align 8
  call void @luaD_shrinkstack(%struct.lua_State* %8)
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal %union.GCObject* @udata2finalize(%struct.global_State* %g) #0 {
entry:
  %g.addr = alloca %struct.global_State*, align 8
  %o = alloca %union.GCObject*, align 8
  store %struct.global_State* %g, %struct.global_State** %g.addr, align 8
  %0 = load %struct.global_State** %g.addr, align 8
  %tobefnz = getelementptr inbounds %struct.global_State* %0, i32 0, i32 23
  %1 = load %union.GCObject** %tobefnz, align 8
  store %union.GCObject* %1, %union.GCObject** %o, align 8
  %2 = load %union.GCObject** %o, align 8
  %gch = bitcast %union.GCObject* %2 to %struct.GCheader*
  %next = getelementptr inbounds %struct.GCheader* %gch, i32 0, i32 0
  %3 = load %union.GCObject** %next, align 8
  %4 = load %struct.global_State** %g.addr, align 8
  %tobefnz1 = getelementptr inbounds %struct.global_State* %4, i32 0, i32 23
  store %union.GCObject* %3, %union.GCObject** %tobefnz1, align 8
  %5 = load %struct.global_State** %g.addr, align 8
  %allgc = getelementptr inbounds %struct.global_State* %5, i32 0, i32 14
  %6 = load %union.GCObject** %allgc, align 8
  %7 = load %union.GCObject** %o, align 8
  %gch2 = bitcast %union.GCObject* %7 to %struct.GCheader*
  %next3 = getelementptr inbounds %struct.GCheader* %gch2, i32 0, i32 0
  store %union.GCObject* %6, %union.GCObject** %next3, align 8
  %8 = load %union.GCObject** %o, align 8
  %9 = load %struct.global_State** %g.addr, align 8
  %allgc4 = getelementptr inbounds %struct.global_State* %9, i32 0, i32 14
  store %union.GCObject* %8, %union.GCObject** %allgc4, align 8
  %10 = load %union.GCObject** %o, align 8
  %gch5 = bitcast %union.GCObject* %10 to %struct.GCheader*
  %marked = getelementptr inbounds %struct.GCheader* %gch5, i32 0, i32 2
  %11 = load i8* %marked, align 1
  %conv = zext i8 %11 to i32
  %and = and i32 %conv, 239
  %conv6 = trunc i32 %and to i8
  store i8 %conv6, i8* %marked, align 1
  %12 = load %struct.global_State** %g.addr, align 8
  %gcstate = getelementptr inbounds %struct.global_State* %12, i32 0, i32 10
  %13 = load i8* %gcstate, align 1
  %conv7 = zext i8 %13 to i32
  %cmp = icmp sle i32 %conv7, 1
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %14 = load %union.GCObject** %o, align 8
  %gch9 = bitcast %union.GCObject* %14 to %struct.GCheader*
  %marked10 = getelementptr inbounds %struct.GCheader* %gch9, i32 0, i32 2
  %15 = load i8* %marked10, align 1
  %conv11 = zext i8 %15 to i32
  %and12 = and i32 %conv11, -72
  %16 = load %struct.global_State** %g.addr, align 8
  %currentwhite = getelementptr inbounds %struct.global_State* %16, i32 0, i32 9
  %17 = load i8* %currentwhite, align 1
  %conv13 = zext i8 %17 to i32
  %and14 = and i32 %conv13, 3
  %conv15 = trunc i32 %and14 to i8
  %conv16 = zext i8 %conv15 to i32
  %or = or i32 %and12, %conv16
  %conv17 = trunc i32 %or to i8
  %18 = load %union.GCObject** %o, align 8
  %gch18 = bitcast %union.GCObject* %18 to %struct.GCheader*
  %marked19 = getelementptr inbounds %struct.GCheader* %gch18, i32 0, i32 2
  store i8 %conv17, i8* %marked19, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %19 = load %union.GCObject** %o, align 8
  ret %union.GCObject* %19
}

; Function Attrs: nounwind uwtable
define internal void @dothecall(%struct.lua_State* %L, i8* %ud) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %ud.addr = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %ud, i8** %ud.addr, align 8
  %0 = load i8** %ud.addr, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %2, i32 0, i32 4
  %3 = load %struct.lua_TValue** %top, align 8
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %3, i64 -2
  call void @luaD_call(%struct.lua_State* %1, %struct.lua_TValue* %add.ptr, i32 0, i32 0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @markmt(%struct.global_State* %g) #0 {
entry:
  %g.addr = alloca %struct.global_State*, align 8
  %i = alloca i32, align 4
  store %struct.global_State* %g, %struct.global_State** %g.addr, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32* %i, align 4
  %cmp = icmp slt i32 %0, 9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load i32* %i, align 4
  %idxprom = sext i32 %1 to i64
  %2 = load %struct.global_State** %g.addr, align 8
  %mt = getelementptr inbounds %struct.global_State* %2, i32 0, i32 34
  %arrayidx = getelementptr inbounds [9 x %struct.Table*]* %mt, i32 0, i64 %idxprom
  %3 = load %struct.Table** %arrayidx, align 8
  %tobool = icmp ne %struct.Table* %3, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.body
  %4 = load i32* %i, align 4
  %idxprom1 = sext i32 %4 to i64
  %5 = load %struct.global_State** %g.addr, align 8
  %mt2 = getelementptr inbounds %struct.global_State* %5, i32 0, i32 34
  %arrayidx3 = getelementptr inbounds [9 x %struct.Table*]* %mt2, i32 0, i64 %idxprom1
  %6 = load %struct.Table** %arrayidx3, align 8
  %7 = bitcast %struct.Table* %6 to %union.GCObject*
  %gch = bitcast %union.GCObject* %7 to %struct.GCheader*
  %marked = getelementptr inbounds %struct.GCheader* %gch, i32 0, i32 2
  %8 = load i8* %marked, align 1
  %conv = zext i8 %8 to i32
  %and = and i32 %conv, 3
  %tobool4 = icmp ne i32 %and, 0
  br i1 %tobool4, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %9 = load %struct.global_State** %g.addr, align 8
  %10 = load i32* %i, align 4
  %idxprom5 = sext i32 %10 to i64
  %11 = load %struct.global_State** %g.addr, align 8
  %mt6 = getelementptr inbounds %struct.global_State* %11, i32 0, i32 34
  %arrayidx7 = getelementptr inbounds [9 x %struct.Table*]* %mt6, i32 0, i64 %idxprom5
  %12 = load %struct.Table** %arrayidx7, align 8
  %13 = bitcast %struct.Table* %12 to %union.GCObject*
  call void @reallymarkobject(%struct.global_State* %9, %union.GCObject* %13)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %14 = load i32* %i, align 4
  %inc = add nsw i32 %14, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @markbeingfnz(%struct.global_State* %g) #0 {
entry:
  %g.addr = alloca %struct.global_State*, align 8
  %o = alloca %union.GCObject*, align 8
  store %struct.global_State* %g, %struct.global_State** %g.addr, align 8
  %0 = load %struct.global_State** %g.addr, align 8
  %tobefnz = getelementptr inbounds %struct.global_State* %0, i32 0, i32 23
  %1 = load %union.GCObject** %tobefnz, align 8
  store %union.GCObject* %1, %union.GCObject** %o, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load %union.GCObject** %o, align 8
  %cmp = icmp ne %union.GCObject* %2, null
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %union.GCObject** %o, align 8
  %gch = bitcast %union.GCObject* %3 to %struct.GCheader*
  %marked = getelementptr inbounds %struct.GCheader* %gch, i32 0, i32 2
  %4 = load i8* %marked, align 1
  %conv = zext i8 %4 to i32
  %and = and i32 %conv, -72
  %5 = load %struct.global_State** %g.addr, align 8
  %currentwhite = getelementptr inbounds %struct.global_State* %5, i32 0, i32 9
  %6 = load i8* %currentwhite, align 1
  %conv1 = zext i8 %6 to i32
  %and2 = and i32 %conv1, 3
  %conv3 = trunc i32 %and2 to i8
  %conv4 = zext i8 %conv3 to i32
  %or = or i32 %and, %conv4
  %conv5 = trunc i32 %or to i8
  %7 = load %union.GCObject** %o, align 8
  %gch6 = bitcast %union.GCObject* %7 to %struct.GCheader*
  %marked7 = getelementptr inbounds %struct.GCheader* %gch6, i32 0, i32 2
  store i8 %conv5, i8* %marked7, align 1
  %8 = load %struct.global_State** %g.addr, align 8
  %9 = load %union.GCObject** %o, align 8
  call void @reallymarkobject(%struct.global_State* %8, %union.GCObject* %9)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load %union.GCObject** %o, align 8
  %gch8 = bitcast %union.GCObject* %10 to %struct.GCheader*
  %next = getelementptr inbounds %struct.GCheader* %gch8, i32 0, i32 0
  %11 = load %union.GCObject** %next, align 8
  store %union.GCObject* %11, %union.GCObject** %o, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @traversetable(%struct.global_State* %g, %struct.Table* %h) #0 {
entry:
  %g.addr = alloca %struct.global_State*, align 8
  %h.addr = alloca %struct.Table*, align 8
  %weakkey = alloca i8*, align 8
  %weakvalue = alloca i8*, align 8
  %mode = alloca %struct.lua_TValue*, align 8
  store %struct.global_State* %g, %struct.global_State** %g.addr, align 8
  store %struct.Table* %h, %struct.Table** %h.addr, align 8
  %0 = load %struct.Table** %h.addr, align 8
  %metatable = getelementptr inbounds %struct.Table* %0, i32 0, i32 5
  %1 = load %struct.Table** %metatable, align 8
  %cmp = icmp eq %struct.Table* %1, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end5

cond.false:                                       ; preds = %entry
  %2 = load %struct.Table** %h.addr, align 8
  %metatable1 = getelementptr inbounds %struct.Table* %2, i32 0, i32 5
  %3 = load %struct.Table** %metatable1, align 8
  %flags = getelementptr inbounds %struct.Table* %3, i32 0, i32 3
  %4 = load i8* %flags, align 1
  %conv = zext i8 %4 to i32
  %and = and i32 %conv, 8
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  br label %cond.end

cond.false3:                                      ; preds = %cond.false
  %5 = load %struct.Table** %h.addr, align 8
  %metatable4 = getelementptr inbounds %struct.Table* %5, i32 0, i32 5
  %6 = load %struct.Table** %metatable4, align 8
  %7 = load %struct.global_State** %g.addr, align 8
  %tmname = getelementptr inbounds %struct.global_State* %7, i32 0, i32 33
  %arrayidx = getelementptr inbounds [17 x %union.TString*]* %tmname, i32 0, i64 3
  %8 = load %union.TString** %arrayidx, align 8
  %call = call %struct.lua_TValue* @luaT_gettm(%struct.Table* %6, i32 3, %union.TString* %8)
  br label %cond.end

cond.end:                                         ; preds = %cond.false3, %cond.true2
  %cond = phi %struct.lua_TValue* [ null, %cond.true2 ], [ %call, %cond.false3 ]
  br label %cond.end5

cond.end5:                                        ; preds = %cond.end, %cond.true
  %cond6 = phi %struct.lua_TValue* [ null, %cond.true ], [ %cond, %cond.end ]
  store %struct.lua_TValue* %cond6, %struct.lua_TValue** %mode, align 8
  %9 = load %struct.Table** %h.addr, align 8
  %metatable7 = getelementptr inbounds %struct.Table* %9, i32 0, i32 5
  %10 = load %struct.Table** %metatable7, align 8
  %tobool8 = icmp ne %struct.Table* %10, null
  br i1 %tobool8, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %cond.end5
  %11 = load %struct.Table** %h.addr, align 8
  %metatable9 = getelementptr inbounds %struct.Table* %11, i32 0, i32 5
  %12 = load %struct.Table** %metatable9, align 8
  %13 = bitcast %struct.Table* %12 to %union.GCObject*
  %gch = bitcast %union.GCObject* %13 to %struct.GCheader*
  %marked = getelementptr inbounds %struct.GCheader* %gch, i32 0, i32 2
  %14 = load i8* %marked, align 1
  %conv10 = zext i8 %14 to i32
  %and11 = and i32 %conv10, 3
  %tobool12 = icmp ne i32 %and11, 0
  br i1 %tobool12, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %15 = load %struct.global_State** %g.addr, align 8
  %16 = load %struct.Table** %h.addr, align 8
  %metatable13 = getelementptr inbounds %struct.Table* %16, i32 0, i32 5
  %17 = load %struct.Table** %metatable13, align 8
  %18 = bitcast %struct.Table* %17 to %union.GCObject*
  call void @reallymarkobject(%struct.global_State* %15, %union.GCObject* %18)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %cond.end5
  %19 = load %struct.lua_TValue** %mode, align 8
  %tobool14 = icmp ne %struct.lua_TValue* %19, null
  br i1 %tobool14, label %land.lhs.true15, label %if.else43

land.lhs.true15:                                  ; preds = %if.end
  %20 = load %struct.lua_TValue** %mode, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %20, i32 0, i32 1
  %21 = load i32* %tt_, align 4
  %and16 = and i32 %21, 15
  %cmp17 = icmp eq i32 %and16, 4
  br i1 %cmp17, label %land.lhs.true19, label %if.else43

land.lhs.true19:                                  ; preds = %land.lhs.true15
  %22 = load %struct.lua_TValue** %mode, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %22, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %23 = load %union.GCObject** %gc, align 8
  %ts = bitcast %union.GCObject* %23 to %union.TString*
  %add.ptr = getelementptr inbounds %union.TString* %ts, i64 1
  %24 = bitcast %union.TString* %add.ptr to i8*
  %call20 = call i8* @strchr(i8* %24, i32 107) #10
  store i8* %call20, i8** %weakkey, align 8
  %25 = load %struct.lua_TValue** %mode, align 8
  %value_21 = getelementptr inbounds %struct.lua_TValue* %25, i32 0, i32 0
  %gc22 = bitcast %union.Value* %value_21 to %union.GCObject**
  %26 = load %union.GCObject** %gc22, align 8
  %ts23 = bitcast %union.GCObject* %26 to %union.TString*
  %add.ptr24 = getelementptr inbounds %union.TString* %ts23, i64 1
  %27 = bitcast %union.TString* %add.ptr24 to i8*
  %call25 = call i8* @strchr(i8* %27, i32 118) #10
  store i8* %call25, i8** %weakvalue, align 8
  %28 = load i8** %weakkey, align 8
  %tobool26 = icmp ne i8* %28, null
  br i1 %tobool26, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.lhs.true19
  %29 = load i8** %weakvalue, align 8
  %tobool27 = icmp ne i8* %29, null
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.lhs.true19
  %30 = phi i1 [ true, %land.lhs.true19 ], [ %tobool27, %lor.rhs ]
  br i1 %30, label %if.then28, label %if.else43

if.then28:                                        ; preds = %lor.end
  %31 = load %struct.Table** %h.addr, align 8
  %32 = bitcast %struct.Table* %31 to %union.GCObject*
  %gch29 = bitcast %union.GCObject* %32 to %struct.GCheader*
  %marked30 = getelementptr inbounds %struct.GCheader* %gch29, i32 0, i32 2
  %33 = load i8* %marked30, align 1
  %conv31 = zext i8 %33 to i32
  %and32 = and i32 %conv31, 251
  %conv33 = trunc i32 %and32 to i8
  store i8 %conv33, i8* %marked30, align 1
  %34 = load i8** %weakkey, align 8
  %tobool34 = icmp ne i8* %34, null
  br i1 %tobool34, label %if.else, label %if.then35

if.then35:                                        ; preds = %if.then28
  %35 = load %struct.global_State** %g.addr, align 8
  %36 = load %struct.Table** %h.addr, align 8
  call void @traverseweakvalue(%struct.global_State* %35, %struct.Table* %36)
  br label %if.end42

if.else:                                          ; preds = %if.then28
  %37 = load i8** %weakvalue, align 8
  %tobool36 = icmp ne i8* %37, null
  br i1 %tobool36, label %if.else39, label %if.then37

if.then37:                                        ; preds = %if.else
  %38 = load %struct.global_State** %g.addr, align 8
  %39 = load %struct.Table** %h.addr, align 8
  %call38 = call i32 @traverseephemeron(%struct.global_State* %38, %struct.Table* %39)
  br label %if.end41

if.else39:                                        ; preds = %if.else
  %40 = load %struct.global_State** %g.addr, align 8
  %allweak = getelementptr inbounds %struct.global_State* %40, i32 0, i32 22
  %41 = load %union.GCObject** %allweak, align 8
  %42 = load %struct.Table** %h.addr, align 8
  %gclist = getelementptr inbounds %struct.Table* %42, i32 0, i32 9
  store %union.GCObject* %41, %union.GCObject** %gclist, align 8
  %43 = load %struct.Table** %h.addr, align 8
  %44 = bitcast %struct.Table* %43 to %union.GCObject*
  %45 = load %struct.global_State** %g.addr, align 8
  %allweak40 = getelementptr inbounds %struct.global_State* %45, i32 0, i32 22
  store %union.GCObject* %44, %union.GCObject** %allweak40, align 8
  br label %if.end41

if.end41:                                         ; preds = %if.else39, %if.then37
  br label %if.end42

if.end42:                                         ; preds = %if.end41, %if.then35
  br label %if.end44

if.else43:                                        ; preds = %lor.end, %land.lhs.true15, %if.end
  %46 = load %struct.global_State** %g.addr, align 8
  %47 = load %struct.Table** %h.addr, align 8
  call void @traversestrongtable(%struct.global_State* %46, %struct.Table* %47)
  br label %if.end44

if.end44:                                         ; preds = %if.else43, %if.end42
  %48 = load %struct.Table** %h.addr, align 8
  %sizearray = getelementptr inbounds %struct.Table* %48, i32 0, i32 10
  %49 = load i32* %sizearray, align 4
  %conv45 = sext i32 %49 to i64
  %mul = mul i64 16, %conv45
  %add = add i64 64, %mul
  %50 = load %struct.Table** %h.addr, align 8
  %lsizenode = getelementptr inbounds %struct.Table* %50, i32 0, i32 4
  %51 = load i8* %lsizenode, align 1
  %conv46 = zext i8 %51 to i32
  %shl = shl i32 1, %conv46
  %conv47 = sext i32 %shl to i64
  %mul48 = mul i64 40, %conv47
  %add49 = add i64 %add, %mul48
  ret i64 %add49
}

; Function Attrs: nounwind uwtable
define internal i64 @traverseLclosure(%struct.global_State* %g, %struct.LClosure* %cl) #0 {
entry:
  %g.addr = alloca %struct.global_State*, align 8
  %cl.addr = alloca %struct.LClosure*, align 8
  %i = alloca i32, align 4
  store %struct.global_State* %g, %struct.global_State** %g.addr, align 8
  store %struct.LClosure* %cl, %struct.LClosure** %cl.addr, align 8
  %0 = load %struct.LClosure** %cl.addr, align 8
  %p = getelementptr inbounds %struct.LClosure* %0, i32 0, i32 5
  %1 = load %struct.Proto** %p, align 8
  %tobool = icmp ne %struct.Proto* %1, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %2 = load %struct.LClosure** %cl.addr, align 8
  %p1 = getelementptr inbounds %struct.LClosure* %2, i32 0, i32 5
  %3 = load %struct.Proto** %p1, align 8
  %4 = bitcast %struct.Proto* %3 to %union.GCObject*
  %gch = bitcast %union.GCObject* %4 to %struct.GCheader*
  %marked = getelementptr inbounds %struct.GCheader* %gch, i32 0, i32 2
  %5 = load i8* %marked, align 1
  %conv = zext i8 %5 to i32
  %and = and i32 %conv, 3
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %6 = load %struct.global_State** %g.addr, align 8
  %7 = load %struct.LClosure** %cl.addr, align 8
  %p3 = getelementptr inbounds %struct.LClosure* %7, i32 0, i32 5
  %8 = load %struct.Proto** %p3, align 8
  %9 = bitcast %struct.Proto* %8 to %union.GCObject*
  call void @reallymarkobject(%struct.global_State* %6, %union.GCObject* %9)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32* %i, align 4
  %11 = load %struct.LClosure** %cl.addr, align 8
  %nupvalues = getelementptr inbounds %struct.LClosure* %11, i32 0, i32 3
  %12 = load i8* %nupvalues, align 1
  %conv4 = zext i8 %12 to i32
  %cmp = icmp slt i32 %10, %conv4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %13 = load i32* %i, align 4
  %idxprom = sext i32 %13 to i64
  %14 = load %struct.LClosure** %cl.addr, align 8
  %upvals = getelementptr inbounds %struct.LClosure* %14, i32 0, i32 6
  %arrayidx = getelementptr inbounds [1 x %struct.UpVal*]* %upvals, i32 0, i64 %idxprom
  %15 = load %struct.UpVal** %arrayidx, align 8
  %tobool6 = icmp ne %struct.UpVal* %15, null
  br i1 %tobool6, label %land.lhs.true7, label %if.end20

land.lhs.true7:                                   ; preds = %for.body
  %16 = load i32* %i, align 4
  %idxprom8 = sext i32 %16 to i64
  %17 = load %struct.LClosure** %cl.addr, align 8
  %upvals9 = getelementptr inbounds %struct.LClosure* %17, i32 0, i32 6
  %arrayidx10 = getelementptr inbounds [1 x %struct.UpVal*]* %upvals9, i32 0, i64 %idxprom8
  %18 = load %struct.UpVal** %arrayidx10, align 8
  %19 = bitcast %struct.UpVal* %18 to %union.GCObject*
  %gch11 = bitcast %union.GCObject* %19 to %struct.GCheader*
  %marked12 = getelementptr inbounds %struct.GCheader* %gch11, i32 0, i32 2
  %20 = load i8* %marked12, align 1
  %conv13 = zext i8 %20 to i32
  %and14 = and i32 %conv13, 3
  %tobool15 = icmp ne i32 %and14, 0
  br i1 %tobool15, label %if.then16, label %if.end20

if.then16:                                        ; preds = %land.lhs.true7
  %21 = load %struct.global_State** %g.addr, align 8
  %22 = load i32* %i, align 4
  %idxprom17 = sext i32 %22 to i64
  %23 = load %struct.LClosure** %cl.addr, align 8
  %upvals18 = getelementptr inbounds %struct.LClosure* %23, i32 0, i32 6
  %arrayidx19 = getelementptr inbounds [1 x %struct.UpVal*]* %upvals18, i32 0, i64 %idxprom17
  %24 = load %struct.UpVal** %arrayidx19, align 8
  %25 = bitcast %struct.UpVal* %24 to %union.GCObject*
  call void @reallymarkobject(%struct.global_State* %21, %union.GCObject* %25)
  br label %if.end20

if.end20:                                         ; preds = %if.then16, %land.lhs.true7, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end20
  %26 = load i32* %i, align 4
  %inc = add nsw i32 %26, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %27 = load %struct.LClosure** %cl.addr, align 8
  %nupvalues21 = getelementptr inbounds %struct.LClosure* %27, i32 0, i32 3
  %28 = load i8* %nupvalues21, align 1
  %conv22 = zext i8 %28 to i32
  %sub = sub nsw i32 %conv22, 1
  %conv23 = sext i32 %sub to i64
  %mul = mul i64 8, %conv23
  %conv24 = trunc i64 %mul to i32
  %add = add nsw i32 40, %conv24
  %conv25 = sext i32 %add to i64
  ret i64 %conv25
}

; Function Attrs: nounwind uwtable
define internal i64 @traverseCclosure(%struct.global_State* %g, %struct.CClosure* %cl) #0 {
entry:
  %g.addr = alloca %struct.global_State*, align 8
  %cl.addr = alloca %struct.CClosure*, align 8
  %i = alloca i32, align 4
  store %struct.global_State* %g, %struct.global_State** %g.addr, align 8
  store %struct.CClosure* %cl, %struct.CClosure** %cl.addr, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32* %i, align 4
  %1 = load %struct.CClosure** %cl.addr, align 8
  %nupvalues = getelementptr inbounds %struct.CClosure* %1, i32 0, i32 3
  %2 = load i8* %nupvalues, align 1
  %conv = zext i8 %2 to i32
  %cmp = icmp slt i32 %0, %conv
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i32* %i, align 4
  %idxprom = sext i32 %3 to i64
  %4 = load %struct.CClosure** %cl.addr, align 8
  %upvalue = getelementptr inbounds %struct.CClosure* %4, i32 0, i32 6
  %arrayidx = getelementptr inbounds [1 x %struct.lua_TValue]* %upvalue, i32 0, i64 %idxprom
  %tt_ = getelementptr inbounds %struct.lua_TValue* %arrayidx, i32 0, i32 1
  %5 = load i32* %tt_, align 4
  %and = and i32 %5, 64
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.body
  %6 = load i32* %i, align 4
  %idxprom2 = sext i32 %6 to i64
  %7 = load %struct.CClosure** %cl.addr, align 8
  %upvalue3 = getelementptr inbounds %struct.CClosure* %7, i32 0, i32 6
  %arrayidx4 = getelementptr inbounds [1 x %struct.lua_TValue]* %upvalue3, i32 0, i64 %idxprom2
  %value_ = getelementptr inbounds %struct.lua_TValue* %arrayidx4, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %8 = load %union.GCObject** %gc, align 8
  %gch = bitcast %union.GCObject* %8 to %struct.GCheader*
  %marked = getelementptr inbounds %struct.GCheader* %gch, i32 0, i32 2
  %9 = load i8* %marked, align 1
  %conv5 = zext i8 %9 to i32
  %and6 = and i32 %conv5, 3
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %10 = load %struct.global_State** %g.addr, align 8
  %11 = load i32* %i, align 4
  %idxprom8 = sext i32 %11 to i64
  %12 = load %struct.CClosure** %cl.addr, align 8
  %upvalue9 = getelementptr inbounds %struct.CClosure* %12, i32 0, i32 6
  %arrayidx10 = getelementptr inbounds [1 x %struct.lua_TValue]* %upvalue9, i32 0, i64 %idxprom8
  %value_11 = getelementptr inbounds %struct.lua_TValue* %arrayidx10, i32 0, i32 0
  %gc12 = bitcast %union.Value* %value_11 to %union.GCObject**
  %13 = load %union.GCObject** %gc12, align 8
  call void @reallymarkobject(%struct.global_State* %10, %union.GCObject* %13)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %14 = load i32* %i, align 4
  %inc = add nsw i32 %14, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %15 = load %struct.CClosure** %cl.addr, align 8
  %nupvalues13 = getelementptr inbounds %struct.CClosure* %15, i32 0, i32 3
  %16 = load i8* %nupvalues13, align 1
  %conv14 = zext i8 %16 to i32
  %sub = sub nsw i32 %conv14, 1
  %conv15 = sext i32 %sub to i64
  %mul = mul i64 16, %conv15
  %conv16 = trunc i64 %mul to i32
  %add = add nsw i32 48, %conv16
  %conv17 = sext i32 %add to i64
  ret i64 %conv17
}

; Function Attrs: nounwind uwtable
define internal i64 @traversestack(%struct.global_State* %g, %struct.lua_State* %th) #0 {
entry:
  %retval = alloca i64, align 8
  %g.addr = alloca %struct.global_State*, align 8
  %th.addr = alloca %struct.lua_State*, align 8
  %o = alloca %struct.lua_TValue*, align 8
  %lim = alloca %struct.lua_TValue*, align 8
  store %struct.global_State* %g, %struct.global_State** %g.addr, align 8
  store %struct.lua_State* %th, %struct.lua_State** %th.addr, align 8
  %0 = load %struct.lua_State** %th.addr, align 8
  %stack = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 9
  %1 = load %struct.lua_TValue** %stack, align 8
  store %struct.lua_TValue* %1, %struct.lua_TValue** %o, align 8
  %2 = load %struct.lua_TValue** %o, align 8
  %cmp = icmp eq %struct.lua_TValue* %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 1, i64* %retval
  br label %return

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %3 = load %struct.lua_TValue** %o, align 8
  %4 = load %struct.lua_State** %th.addr, align 8
  %top = getelementptr inbounds %struct.lua_State* %4, i32 0, i32 4
  %5 = load %struct.lua_TValue** %top, align 8
  %cmp1 = icmp ult %struct.lua_TValue* %3, %5
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load %struct.lua_TValue** %o, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %6, i32 0, i32 1
  %7 = load i32* %tt_, align 4
  %and = and i32 %7, 64
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end7

land.lhs.true:                                    ; preds = %for.body
  %8 = load %struct.lua_TValue** %o, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %8, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %9 = load %union.GCObject** %gc, align 8
  %gch = bitcast %union.GCObject* %9 to %struct.GCheader*
  %marked = getelementptr inbounds %struct.GCheader* %gch, i32 0, i32 2
  %10 = load i8* %marked, align 1
  %conv = zext i8 %10 to i32
  %and2 = and i32 %conv, 3
  %tobool3 = icmp ne i32 %and2, 0
  br i1 %tobool3, label %if.then4, label %if.end7

if.then4:                                         ; preds = %land.lhs.true
  %11 = load %struct.global_State** %g.addr, align 8
  %12 = load %struct.lua_TValue** %o, align 8
  %value_5 = getelementptr inbounds %struct.lua_TValue* %12, i32 0, i32 0
  %gc6 = bitcast %union.Value* %value_5 to %union.GCObject**
  %13 = load %union.GCObject** %gc6, align 8
  call void @reallymarkobject(%struct.global_State* %11, %union.GCObject* %13)
  br label %if.end7

if.end7:                                          ; preds = %if.then4, %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end7
  %14 = load %struct.lua_TValue** %o, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %14, i32 1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %o, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %15 = load %struct.global_State** %g.addr, align 8
  %gcstate = getelementptr inbounds %struct.global_State* %15, i32 0, i32 10
  %16 = load i8* %gcstate, align 1
  %conv8 = zext i8 %16 to i32
  %cmp9 = icmp eq i32 %conv8, 1
  br i1 %cmp9, label %if.then11, label %if.end21

if.then11:                                        ; preds = %for.end
  %17 = load %struct.lua_State** %th.addr, align 8
  %stack12 = getelementptr inbounds %struct.lua_State* %17, i32 0, i32 9
  %18 = load %struct.lua_TValue** %stack12, align 8
  %19 = load %struct.lua_State** %th.addr, align 8
  %stacksize = getelementptr inbounds %struct.lua_State* %19, i32 0, i32 10
  %20 = load i32* %stacksize, align 4
  %idx.ext = sext i32 %20 to i64
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %18, i64 %idx.ext
  store %struct.lua_TValue* %add.ptr, %struct.lua_TValue** %lim, align 8
  br label %for.cond13

for.cond13:                                       ; preds = %for.inc18, %if.then11
  %21 = load %struct.lua_TValue** %o, align 8
  %22 = load %struct.lua_TValue** %lim, align 8
  %cmp14 = icmp ult %struct.lua_TValue* %21, %22
  br i1 %cmp14, label %for.body16, label %for.end20

for.body16:                                       ; preds = %for.cond13
  %23 = load %struct.lua_TValue** %o, align 8
  %tt_17 = getelementptr inbounds %struct.lua_TValue* %23, i32 0, i32 1
  store i32 0, i32* %tt_17, align 4
  br label %for.inc18

for.inc18:                                        ; preds = %for.body16
  %24 = load %struct.lua_TValue** %o, align 8
  %incdec.ptr19 = getelementptr inbounds %struct.lua_TValue* %24, i32 1
  store %struct.lua_TValue* %incdec.ptr19, %struct.lua_TValue** %o, align 8
  br label %for.cond13

for.end20:                                        ; preds = %for.cond13
  br label %if.end21

if.end21:                                         ; preds = %for.end20, %for.end
  %25 = load %struct.lua_State** %th.addr, align 8
  %stacksize22 = getelementptr inbounds %struct.lua_State* %25, i32 0, i32 10
  %26 = load i32* %stacksize22, align 4
  %conv23 = sext i32 %26 to i64
  %mul = mul i64 16, %conv23
  %add = add i64 208, %mul
  store i64 %add, i64* %retval
  br label %return

return:                                           ; preds = %if.end21, %if.then
  %27 = load i64* %retval
  ret i64 %27
}

; Function Attrs: nounwind uwtable
define internal i32 @traverseproto(%struct.global_State* %g, %struct.Proto* %f) #0 {
entry:
  %g.addr = alloca %struct.global_State*, align 8
  %f.addr = alloca %struct.Proto*, align 8
  %i = alloca i32, align 4
  store %struct.global_State* %g, %struct.global_State** %g.addr, align 8
  store %struct.Proto* %f, %struct.Proto** %f.addr, align 8
  %0 = load %struct.Proto** %f.addr, align 8
  %cache = getelementptr inbounds %struct.Proto* %0, i32 0, i32 9
  %1 = load %union.Closure** %cache, align 8
  %tobool = icmp ne %union.Closure* %1, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %2 = load %struct.Proto** %f.addr, align 8
  %cache1 = getelementptr inbounds %struct.Proto* %2, i32 0, i32 9
  %3 = load %union.Closure** %cache1, align 8
  %4 = bitcast %union.Closure* %3 to %union.GCObject*
  %gch = bitcast %union.GCObject* %4 to %struct.GCheader*
  %marked = getelementptr inbounds %struct.GCheader* %gch, i32 0, i32 2
  %5 = load i8* %marked, align 1
  %conv = zext i8 %5 to i32
  %and = and i32 %conv, 3
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %6 = load %struct.Proto** %f.addr, align 8
  %cache3 = getelementptr inbounds %struct.Proto* %6, i32 0, i32 9
  store %union.Closure* null, %union.Closure** %cache3, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %7 = load %struct.Proto** %f.addr, align 8
  %source = getelementptr inbounds %struct.Proto* %7, i32 0, i32 10
  %8 = load %union.TString** %source, align 8
  %tobool4 = icmp ne %union.TString* %8, null
  br i1 %tobool4, label %land.lhs.true5, label %if.end14

land.lhs.true5:                                   ; preds = %if.end
  %9 = load %struct.Proto** %f.addr, align 8
  %source6 = getelementptr inbounds %struct.Proto* %9, i32 0, i32 10
  %10 = load %union.TString** %source6, align 8
  %11 = bitcast %union.TString* %10 to %union.GCObject*
  %gch7 = bitcast %union.GCObject* %11 to %struct.GCheader*
  %marked8 = getelementptr inbounds %struct.GCheader* %gch7, i32 0, i32 2
  %12 = load i8* %marked8, align 1
  %conv9 = zext i8 %12 to i32
  %and10 = and i32 %conv9, 3
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %land.lhs.true5
  %13 = load %struct.global_State** %g.addr, align 8
  %14 = load %struct.Proto** %f.addr, align 8
  %source13 = getelementptr inbounds %struct.Proto* %14, i32 0, i32 10
  %15 = load %union.TString** %source13, align 8
  %16 = bitcast %union.TString* %15 to %union.GCObject*
  call void @reallymarkobject(%struct.global_State* %13, %union.GCObject* %16)
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %land.lhs.true5, %if.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end14
  %17 = load i32* %i, align 4
  %18 = load %struct.Proto** %f.addr, align 8
  %sizek = getelementptr inbounds %struct.Proto* %18, i32 0, i32 12
  %19 = load i32* %sizek, align 4
  %cmp = icmp slt i32 %17, %19
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %20 = load i32* %i, align 4
  %idxprom = sext i32 %20 to i64
  %21 = load %struct.Proto** %f.addr, align 8
  %k = getelementptr inbounds %struct.Proto* %21, i32 0, i32 3
  %22 = load %struct.lua_TValue** %k, align 8
  %arrayidx = getelementptr inbounds %struct.lua_TValue* %22, i64 %idxprom
  %tt_ = getelementptr inbounds %struct.lua_TValue* %arrayidx, i32 0, i32 1
  %23 = load i32* %tt_, align 4
  %and16 = and i32 %23, 64
  %tobool17 = icmp ne i32 %and16, 0
  br i1 %tobool17, label %land.lhs.true18, label %if.end33

land.lhs.true18:                                  ; preds = %for.body
  %24 = load i32* %i, align 4
  %idxprom19 = sext i32 %24 to i64
  %25 = load %struct.Proto** %f.addr, align 8
  %k20 = getelementptr inbounds %struct.Proto* %25, i32 0, i32 3
  %26 = load %struct.lua_TValue** %k20, align 8
  %arrayidx21 = getelementptr inbounds %struct.lua_TValue* %26, i64 %idxprom19
  %value_ = getelementptr inbounds %struct.lua_TValue* %arrayidx21, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %27 = load %union.GCObject** %gc, align 8
  %gch22 = bitcast %union.GCObject* %27 to %struct.GCheader*
  %marked23 = getelementptr inbounds %struct.GCheader* %gch22, i32 0, i32 2
  %28 = load i8* %marked23, align 1
  %conv24 = zext i8 %28 to i32
  %and25 = and i32 %conv24, 3
  %tobool26 = icmp ne i32 %and25, 0
  br i1 %tobool26, label %if.then27, label %if.end33

if.then27:                                        ; preds = %land.lhs.true18
  %29 = load %struct.global_State** %g.addr, align 8
  %30 = load i32* %i, align 4
  %idxprom28 = sext i32 %30 to i64
  %31 = load %struct.Proto** %f.addr, align 8
  %k29 = getelementptr inbounds %struct.Proto* %31, i32 0, i32 3
  %32 = load %struct.lua_TValue** %k29, align 8
  %arrayidx30 = getelementptr inbounds %struct.lua_TValue* %32, i64 %idxprom28
  %value_31 = getelementptr inbounds %struct.lua_TValue* %arrayidx30, i32 0, i32 0
  %gc32 = bitcast %union.Value* %value_31 to %union.GCObject**
  %33 = load %union.GCObject** %gc32, align 8
  call void @reallymarkobject(%struct.global_State* %29, %union.GCObject* %33)
  br label %if.end33

if.end33:                                         ; preds = %if.then27, %land.lhs.true18, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end33
  %34 = load i32* %i, align 4
  %inc = add nsw i32 %34, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %i, align 4
  br label %for.cond34

for.cond34:                                       ; preds = %for.inc57, %for.end
  %35 = load i32* %i, align 4
  %36 = load %struct.Proto** %f.addr, align 8
  %sizeupvalues = getelementptr inbounds %struct.Proto* %36, i32 0, i32 11
  %37 = load i32* %sizeupvalues, align 4
  %cmp35 = icmp slt i32 %35, %37
  br i1 %cmp35, label %for.body37, label %for.end59

for.body37:                                       ; preds = %for.cond34
  %38 = load i32* %i, align 4
  %idxprom38 = sext i32 %38 to i64
  %39 = load %struct.Proto** %f.addr, align 8
  %upvalues = getelementptr inbounds %struct.Proto* %39, i32 0, i32 8
  %40 = load %struct.Upvaldesc** %upvalues, align 8
  %arrayidx39 = getelementptr inbounds %struct.Upvaldesc* %40, i64 %idxprom38
  %name = getelementptr inbounds %struct.Upvaldesc* %arrayidx39, i32 0, i32 0
  %41 = load %union.TString** %name, align 8
  %tobool40 = icmp ne %union.TString* %41, null
  br i1 %tobool40, label %land.lhs.true41, label %if.end56

land.lhs.true41:                                  ; preds = %for.body37
  %42 = load i32* %i, align 4
  %idxprom42 = sext i32 %42 to i64
  %43 = load %struct.Proto** %f.addr, align 8
  %upvalues43 = getelementptr inbounds %struct.Proto* %43, i32 0, i32 8
  %44 = load %struct.Upvaldesc** %upvalues43, align 8
  %arrayidx44 = getelementptr inbounds %struct.Upvaldesc* %44, i64 %idxprom42
  %name45 = getelementptr inbounds %struct.Upvaldesc* %arrayidx44, i32 0, i32 0
  %45 = load %union.TString** %name45, align 8
  %46 = bitcast %union.TString* %45 to %union.GCObject*
  %gch46 = bitcast %union.GCObject* %46 to %struct.GCheader*
  %marked47 = getelementptr inbounds %struct.GCheader* %gch46, i32 0, i32 2
  %47 = load i8* %marked47, align 1
  %conv48 = zext i8 %47 to i32
  %and49 = and i32 %conv48, 3
  %tobool50 = icmp ne i32 %and49, 0
  br i1 %tobool50, label %if.then51, label %if.end56

if.then51:                                        ; preds = %land.lhs.true41
  %48 = load %struct.global_State** %g.addr, align 8
  %49 = load i32* %i, align 4
  %idxprom52 = sext i32 %49 to i64
  %50 = load %struct.Proto** %f.addr, align 8
  %upvalues53 = getelementptr inbounds %struct.Proto* %50, i32 0, i32 8
  %51 = load %struct.Upvaldesc** %upvalues53, align 8
  %arrayidx54 = getelementptr inbounds %struct.Upvaldesc* %51, i64 %idxprom52
  %name55 = getelementptr inbounds %struct.Upvaldesc* %arrayidx54, i32 0, i32 0
  %52 = load %union.TString** %name55, align 8
  %53 = bitcast %union.TString* %52 to %union.GCObject*
  call void @reallymarkobject(%struct.global_State* %48, %union.GCObject* %53)
  br label %if.end56

if.end56:                                         ; preds = %if.then51, %land.lhs.true41, %for.body37
  br label %for.inc57

for.inc57:                                        ; preds = %if.end56
  %54 = load i32* %i, align 4
  %inc58 = add nsw i32 %54, 1
  store i32 %inc58, i32* %i, align 4
  br label %for.cond34

for.end59:                                        ; preds = %for.cond34
  store i32 0, i32* %i, align 4
  br label %for.cond60

for.cond60:                                       ; preds = %for.inc81, %for.end59
  %55 = load i32* %i, align 4
  %56 = load %struct.Proto** %f.addr, align 8
  %sizep = getelementptr inbounds %struct.Proto* %56, i32 0, i32 15
  %57 = load i32* %sizep, align 4
  %cmp61 = icmp slt i32 %55, %57
  br i1 %cmp61, label %for.body63, label %for.end83

for.body63:                                       ; preds = %for.cond60
  %58 = load i32* %i, align 4
  %idxprom64 = sext i32 %58 to i64
  %59 = load %struct.Proto** %f.addr, align 8
  %p = getelementptr inbounds %struct.Proto* %59, i32 0, i32 5
  %60 = load %struct.Proto*** %p, align 8
  %arrayidx65 = getelementptr inbounds %struct.Proto** %60, i64 %idxprom64
  %61 = load %struct.Proto** %arrayidx65, align 8
  %tobool66 = icmp ne %struct.Proto* %61, null
  br i1 %tobool66, label %land.lhs.true67, label %if.end80

land.lhs.true67:                                  ; preds = %for.body63
  %62 = load i32* %i, align 4
  %idxprom68 = sext i32 %62 to i64
  %63 = load %struct.Proto** %f.addr, align 8
  %p69 = getelementptr inbounds %struct.Proto* %63, i32 0, i32 5
  %64 = load %struct.Proto*** %p69, align 8
  %arrayidx70 = getelementptr inbounds %struct.Proto** %64, i64 %idxprom68
  %65 = load %struct.Proto** %arrayidx70, align 8
  %66 = bitcast %struct.Proto* %65 to %union.GCObject*
  %gch71 = bitcast %union.GCObject* %66 to %struct.GCheader*
  %marked72 = getelementptr inbounds %struct.GCheader* %gch71, i32 0, i32 2
  %67 = load i8* %marked72, align 1
  %conv73 = zext i8 %67 to i32
  %and74 = and i32 %conv73, 3
  %tobool75 = icmp ne i32 %and74, 0
  br i1 %tobool75, label %if.then76, label %if.end80

if.then76:                                        ; preds = %land.lhs.true67
  %68 = load %struct.global_State** %g.addr, align 8
  %69 = load i32* %i, align 4
  %idxprom77 = sext i32 %69 to i64
  %70 = load %struct.Proto** %f.addr, align 8
  %p78 = getelementptr inbounds %struct.Proto* %70, i32 0, i32 5
  %71 = load %struct.Proto*** %p78, align 8
  %arrayidx79 = getelementptr inbounds %struct.Proto** %71, i64 %idxprom77
  %72 = load %struct.Proto** %arrayidx79, align 8
  %73 = bitcast %struct.Proto* %72 to %union.GCObject*
  call void @reallymarkobject(%struct.global_State* %68, %union.GCObject* %73)
  br label %if.end80

if.end80:                                         ; preds = %if.then76, %land.lhs.true67, %for.body63
  br label %for.inc81

for.inc81:                                        ; preds = %if.end80
  %74 = load i32* %i, align 4
  %inc82 = add nsw i32 %74, 1
  store i32 %inc82, i32* %i, align 4
  br label %for.cond60

for.end83:                                        ; preds = %for.cond60
  store i32 0, i32* %i, align 4
  br label %for.cond84

for.cond84:                                       ; preds = %for.inc107, %for.end83
  %75 = load i32* %i, align 4
  %76 = load %struct.Proto** %f.addr, align 8
  %sizelocvars = getelementptr inbounds %struct.Proto* %76, i32 0, i32 16
  %77 = load i32* %sizelocvars, align 4
  %cmp85 = icmp slt i32 %75, %77
  br i1 %cmp85, label %for.body87, label %for.end109

for.body87:                                       ; preds = %for.cond84
  %78 = load i32* %i, align 4
  %idxprom88 = sext i32 %78 to i64
  %79 = load %struct.Proto** %f.addr, align 8
  %locvars = getelementptr inbounds %struct.Proto* %79, i32 0, i32 7
  %80 = load %struct.LocVar** %locvars, align 8
  %arrayidx89 = getelementptr inbounds %struct.LocVar* %80, i64 %idxprom88
  %varname = getelementptr inbounds %struct.LocVar* %arrayidx89, i32 0, i32 0
  %81 = load %union.TString** %varname, align 8
  %tobool90 = icmp ne %union.TString* %81, null
  br i1 %tobool90, label %land.lhs.true91, label %if.end106

land.lhs.true91:                                  ; preds = %for.body87
  %82 = load i32* %i, align 4
  %idxprom92 = sext i32 %82 to i64
  %83 = load %struct.Proto** %f.addr, align 8
  %locvars93 = getelementptr inbounds %struct.Proto* %83, i32 0, i32 7
  %84 = load %struct.LocVar** %locvars93, align 8
  %arrayidx94 = getelementptr inbounds %struct.LocVar* %84, i64 %idxprom92
  %varname95 = getelementptr inbounds %struct.LocVar* %arrayidx94, i32 0, i32 0
  %85 = load %union.TString** %varname95, align 8
  %86 = bitcast %union.TString* %85 to %union.GCObject*
  %gch96 = bitcast %union.GCObject* %86 to %struct.GCheader*
  %marked97 = getelementptr inbounds %struct.GCheader* %gch96, i32 0, i32 2
  %87 = load i8* %marked97, align 1
  %conv98 = zext i8 %87 to i32
  %and99 = and i32 %conv98, 3
  %tobool100 = icmp ne i32 %and99, 0
  br i1 %tobool100, label %if.then101, label %if.end106

if.then101:                                       ; preds = %land.lhs.true91
  %88 = load %struct.global_State** %g.addr, align 8
  %89 = load i32* %i, align 4
  %idxprom102 = sext i32 %89 to i64
  %90 = load %struct.Proto** %f.addr, align 8
  %locvars103 = getelementptr inbounds %struct.Proto* %90, i32 0, i32 7
  %91 = load %struct.LocVar** %locvars103, align 8
  %arrayidx104 = getelementptr inbounds %struct.LocVar* %91, i64 %idxprom102
  %varname105 = getelementptr inbounds %struct.LocVar* %arrayidx104, i32 0, i32 0
  %92 = load %union.TString** %varname105, align 8
  %93 = bitcast %union.TString* %92 to %union.GCObject*
  call void @reallymarkobject(%struct.global_State* %88, %union.GCObject* %93)
  br label %if.end106

if.end106:                                        ; preds = %if.then101, %land.lhs.true91, %for.body87
  br label %for.inc107

for.inc107:                                       ; preds = %if.end106
  %94 = load i32* %i, align 4
  %inc108 = add nsw i32 %94, 1
  store i32 %inc108, i32* %i, align 4
  br label %for.cond84

for.end109:                                       ; preds = %for.cond84
  %95 = load %struct.Proto** %f.addr, align 8
  %sizecode = getelementptr inbounds %struct.Proto* %95, i32 0, i32 13
  %96 = load i32* %sizecode, align 4
  %conv110 = sext i32 %96 to i64
  %mul = mul i64 4, %conv110
  %add = add i64 128, %mul
  %97 = load %struct.Proto** %f.addr, align 8
  %sizep111 = getelementptr inbounds %struct.Proto* %97, i32 0, i32 15
  %98 = load i32* %sizep111, align 4
  %conv112 = sext i32 %98 to i64
  %mul113 = mul i64 8, %conv112
  %add114 = add i64 %add, %mul113
  %99 = load %struct.Proto** %f.addr, align 8
  %sizek115 = getelementptr inbounds %struct.Proto* %99, i32 0, i32 12
  %100 = load i32* %sizek115, align 4
  %conv116 = sext i32 %100 to i64
  %mul117 = mul i64 16, %conv116
  %add118 = add i64 %add114, %mul117
  %101 = load %struct.Proto** %f.addr, align 8
  %sizelineinfo = getelementptr inbounds %struct.Proto* %101, i32 0, i32 14
  %102 = load i32* %sizelineinfo, align 4
  %conv119 = sext i32 %102 to i64
  %mul120 = mul i64 4, %conv119
  %add121 = add i64 %add118, %mul120
  %103 = load %struct.Proto** %f.addr, align 8
  %sizelocvars122 = getelementptr inbounds %struct.Proto* %103, i32 0, i32 16
  %104 = load i32* %sizelocvars122, align 4
  %conv123 = sext i32 %104 to i64
  %mul124 = mul i64 16, %conv123
  %add125 = add i64 %add121, %mul124
  %105 = load %struct.Proto** %f.addr, align 8
  %sizeupvalues126 = getelementptr inbounds %struct.Proto* %105, i32 0, i32 11
  %106 = load i32* %sizeupvalues126, align 4
  %conv127 = sext i32 %106 to i64
  %mul128 = mul i64 16, %conv127
  %add129 = add i64 %add125, %mul128
  %conv130 = trunc i64 %add129 to i32
  ret i32 %conv130
}

; Function Attrs: nounwind uwtable
define internal void @remarkupvals(%struct.global_State* %g) #0 {
entry:
  %g.addr = alloca %struct.global_State*, align 8
  %uv = alloca %struct.UpVal*, align 8
  store %struct.global_State* %g, %struct.global_State** %g.addr, align 8
  %0 = load %struct.global_State** %g.addr, align 8
  %uvhead = getelementptr inbounds %struct.global_State* %0, i32 0, i32 24
  %u = getelementptr inbounds %struct.UpVal* %uvhead, i32 0, i32 4
  %l = bitcast %union.anon* %u to %struct.anon.192*
  %next = getelementptr inbounds %struct.anon.192* %l, i32 0, i32 1
  %1 = load %struct.UpVal** %next, align 8
  store %struct.UpVal* %1, %struct.UpVal** %uv, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load %struct.UpVal** %uv, align 8
  %3 = load %struct.global_State** %g.addr, align 8
  %uvhead1 = getelementptr inbounds %struct.global_State* %3, i32 0, i32 24
  %cmp = icmp ne %struct.UpVal* %2, %uvhead1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load %struct.UpVal** %uv, align 8
  %5 = bitcast %struct.UpVal* %4 to %union.GCObject*
  %gch = bitcast %union.GCObject* %5 to %struct.GCheader*
  %marked = getelementptr inbounds %struct.GCheader* %gch, i32 0, i32 2
  %6 = load i8* %marked, align 1
  %conv = zext i8 %6 to i32
  %and = and i32 %conv, 7
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end14, label %if.then

if.then:                                          ; preds = %for.body
  %7 = load %struct.UpVal** %uv, align 8
  %v = getelementptr inbounds %struct.UpVal* %7, i32 0, i32 3
  %8 = load %struct.lua_TValue** %v, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %8, i32 0, i32 1
  %9 = load i32* %tt_, align 4
  %and2 = and i32 %9, 64
  %tobool3 = icmp ne i32 %and2, 0
  br i1 %tobool3, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then
  %10 = load %struct.UpVal** %uv, align 8
  %v4 = getelementptr inbounds %struct.UpVal* %10, i32 0, i32 3
  %11 = load %struct.lua_TValue** %v4, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %11, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %12 = load %union.GCObject** %gc, align 8
  %gch5 = bitcast %union.GCObject* %12 to %struct.GCheader*
  %marked6 = getelementptr inbounds %struct.GCheader* %gch5, i32 0, i32 2
  %13 = load i8* %marked6, align 1
  %conv7 = zext i8 %13 to i32
  %and8 = and i32 %conv7, 3
  %tobool9 = icmp ne i32 %and8, 0
  br i1 %tobool9, label %if.then10, label %if.end

if.then10:                                        ; preds = %land.lhs.true
  %14 = load %struct.global_State** %g.addr, align 8
  %15 = load %struct.UpVal** %uv, align 8
  %v11 = getelementptr inbounds %struct.UpVal* %15, i32 0, i32 3
  %16 = load %struct.lua_TValue** %v11, align 8
  %value_12 = getelementptr inbounds %struct.lua_TValue* %16, i32 0, i32 0
  %gc13 = bitcast %union.Value* %value_12 to %union.GCObject**
  %17 = load %union.GCObject** %gc13, align 8
  call void @reallymarkobject(%struct.global_State* %14, %union.GCObject* %17)
  br label %if.end

if.end:                                           ; preds = %if.then10, %land.lhs.true, %if.then
  br label %if.end14

if.end14:                                         ; preds = %if.end, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end14
  %18 = load %struct.UpVal** %uv, align 8
  %u15 = getelementptr inbounds %struct.UpVal* %18, i32 0, i32 4
  %l16 = bitcast %union.anon* %u15 to %struct.anon.192*
  %next17 = getelementptr inbounds %struct.anon.192* %l16, i32 0, i32 1
  %19 = load %struct.UpVal** %next17, align 8
  store %struct.UpVal* %19, %struct.UpVal** %uv, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @propagateall(%struct.global_State* %g) #0 {
entry:
  %g.addr = alloca %struct.global_State*, align 8
  store %struct.global_State* %g, %struct.global_State** %g.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load %struct.global_State** %g.addr, align 8
  %gray = getelementptr inbounds %struct.global_State* %0, i32 0, i32 18
  %1 = load %union.GCObject** %gray, align 8
  %tobool = icmp ne %union.GCObject* %1, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load %struct.global_State** %g.addr, align 8
  call void @propagatemark(%struct.global_State* %2)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @retraversegrays(%struct.global_State* %g) #0 {
entry:
  %g.addr = alloca %struct.global_State*, align 8
  %weak = alloca %union.GCObject*, align 8
  %grayagain = alloca %union.GCObject*, align 8
  %ephemeron = alloca %union.GCObject*, align 8
  store %struct.global_State* %g, %struct.global_State** %g.addr, align 8
  %0 = load %struct.global_State** %g.addr, align 8
  %weak1 = getelementptr inbounds %struct.global_State* %0, i32 0, i32 20
  %1 = load %union.GCObject** %weak1, align 8
  store %union.GCObject* %1, %union.GCObject** %weak, align 8
  %2 = load %struct.global_State** %g.addr, align 8
  %grayagain2 = getelementptr inbounds %struct.global_State* %2, i32 0, i32 19
  %3 = load %union.GCObject** %grayagain2, align 8
  store %union.GCObject* %3, %union.GCObject** %grayagain, align 8
  %4 = load %struct.global_State** %g.addr, align 8
  %ephemeron3 = getelementptr inbounds %struct.global_State* %4, i32 0, i32 21
  %5 = load %union.GCObject** %ephemeron3, align 8
  store %union.GCObject* %5, %union.GCObject** %ephemeron, align 8
  %6 = load %struct.global_State** %g.addr, align 8
  %ephemeron4 = getelementptr inbounds %struct.global_State* %6, i32 0, i32 21
  store %union.GCObject* null, %union.GCObject** %ephemeron4, align 8
  %7 = load %struct.global_State** %g.addr, align 8
  %grayagain5 = getelementptr inbounds %struct.global_State* %7, i32 0, i32 19
  store %union.GCObject* null, %union.GCObject** %grayagain5, align 8
  %8 = load %struct.global_State** %g.addr, align 8
  %weak6 = getelementptr inbounds %struct.global_State* %8, i32 0, i32 20
  store %union.GCObject* null, %union.GCObject** %weak6, align 8
  %9 = load %struct.global_State** %g.addr, align 8
  call void @propagateall(%struct.global_State* %9)
  %10 = load %struct.global_State** %g.addr, align 8
  %11 = load %union.GCObject** %grayagain, align 8
  call void @propagatelist(%struct.global_State* %10, %union.GCObject* %11)
  %12 = load %struct.global_State** %g.addr, align 8
  %13 = load %union.GCObject** %weak, align 8
  call void @propagatelist(%struct.global_State* %12, %union.GCObject* %13)
  %14 = load %struct.global_State** %g.addr, align 8
  %15 = load %union.GCObject** %ephemeron, align 8
  call void @propagatelist(%struct.global_State* %14, %union.GCObject* %15)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @convergeephemerons(%struct.global_State* %g) #0 {
entry:
  %g.addr = alloca %struct.global_State*, align 8
  %changed = alloca i32, align 4
  %w = alloca %union.GCObject*, align 8
  %next = alloca %union.GCObject*, align 8
  store %struct.global_State* %g, %struct.global_State** %g.addr, align 8
  br label %do.body

do.body:                                          ; preds = %do.cond, %entry
  %0 = load %struct.global_State** %g.addr, align 8
  %ephemeron = getelementptr inbounds %struct.global_State* %0, i32 0, i32 21
  %1 = load %union.GCObject** %ephemeron, align 8
  store %union.GCObject* %1, %union.GCObject** %next, align 8
  %2 = load %struct.global_State** %g.addr, align 8
  %ephemeron1 = getelementptr inbounds %struct.global_State* %2, i32 0, i32 21
  store %union.GCObject* null, %union.GCObject** %ephemeron1, align 8
  store i32 0, i32* %changed, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end, %do.body
  %3 = load %union.GCObject** %next, align 8
  store %union.GCObject* %3, %union.GCObject** %w, align 8
  %cmp = icmp ne %union.GCObject* %3, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %4 = load %union.GCObject** %w, align 8
  %h = bitcast %union.GCObject* %4 to %struct.Table*
  %gclist = getelementptr inbounds %struct.Table* %h, i32 0, i32 9
  %5 = load %union.GCObject** %gclist, align 8
  store %union.GCObject* %5, %union.GCObject** %next, align 8
  %6 = load %struct.global_State** %g.addr, align 8
  %7 = load %union.GCObject** %w, align 8
  %h2 = bitcast %union.GCObject* %7 to %struct.Table*
  %call = call i32 @traverseephemeron(%struct.global_State* %6, %struct.Table* %h2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %8 = load %struct.global_State** %g.addr, align 8
  call void @propagateall(%struct.global_State* %8)
  store i32 1, i32* %changed, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  br label %while.cond

while.end:                                        ; preds = %while.cond
  br label %do.cond

do.cond:                                          ; preds = %while.end
  %9 = load i32* %changed, align 4
  %tobool3 = icmp ne i32 %9, 0
  br i1 %tobool3, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @clearvalues(%struct.global_State* %g, %union.GCObject* %l, %union.GCObject* %f) #0 {
entry:
  %g.addr = alloca %struct.global_State*, align 8
  %l.addr = alloca %union.GCObject*, align 8
  %f.addr = alloca %union.GCObject*, align 8
  %h = alloca %struct.Table*, align 8
  %n = alloca %struct.Node*, align 8
  %limit = alloca %struct.Node*, align 8
  %i = alloca i32, align 4
  %o = alloca %struct.lua_TValue*, align 8
  store %struct.global_State* %g, %struct.global_State** %g.addr, align 8
  store %union.GCObject* %l, %union.GCObject** %l.addr, align 8
  store %union.GCObject* %f, %union.GCObject** %f.addr, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc26, %entry
  %0 = load %union.GCObject** %l.addr, align 8
  %1 = load %union.GCObject** %f.addr, align 8
  %cmp = icmp ne %union.GCObject* %0, %1
  br i1 %cmp, label %for.body, label %for.end28

for.body:                                         ; preds = %for.cond
  %2 = load %union.GCObject** %l.addr, align 8
  %h1 = bitcast %union.GCObject* %2 to %struct.Table*
  store %struct.Table* %h1, %struct.Table** %h, align 8
  %3 = load %struct.Table** %h, align 8
  %lsizenode = getelementptr inbounds %struct.Table* %3, i32 0, i32 4
  %4 = load i8* %lsizenode, align 1
  %conv = zext i8 %4 to i32
  %shl = shl i32 1, %conv
  %conv2 = sext i32 %shl to i64
  %5 = load %struct.Table** %h, align 8
  %node = getelementptr inbounds %struct.Table* %5, i32 0, i32 7
  %6 = load %struct.Node** %node, align 8
  %arrayidx = getelementptr inbounds %struct.Node* %6, i64 %conv2
  store %struct.Node* %arrayidx, %struct.Node** %limit, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond3

for.cond3:                                        ; preds = %for.inc, %for.body
  %7 = load i32* %i, align 4
  %8 = load %struct.Table** %h, align 8
  %sizearray = getelementptr inbounds %struct.Table* %8, i32 0, i32 10
  %9 = load i32* %sizearray, align 4
  %cmp4 = icmp slt i32 %7, %9
  br i1 %cmp4, label %for.body6, label %for.end

for.body6:                                        ; preds = %for.cond3
  %10 = load i32* %i, align 4
  %idxprom = sext i32 %10 to i64
  %11 = load %struct.Table** %h, align 8
  %array = getelementptr inbounds %struct.Table* %11, i32 0, i32 6
  %12 = load %struct.lua_TValue** %array, align 8
  %arrayidx7 = getelementptr inbounds %struct.lua_TValue* %12, i64 %idxprom
  store %struct.lua_TValue* %arrayidx7, %struct.lua_TValue** %o, align 8
  %13 = load %struct.global_State** %g.addr, align 8
  %14 = load %struct.lua_TValue** %o, align 8
  %call = call i32 @iscleared(%struct.global_State* %13, %struct.lua_TValue* %14)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body6
  %15 = load %struct.lua_TValue** %o, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %15, i32 0, i32 1
  store i32 0, i32* %tt_, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body6
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %16 = load i32* %i, align 4
  %inc = add nsw i32 %16, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond3

for.end:                                          ; preds = %for.cond3
  %17 = load %struct.Table** %h, align 8
  %node8 = getelementptr inbounds %struct.Table* %17, i32 0, i32 7
  %18 = load %struct.Node** %node8, align 8
  %arrayidx9 = getelementptr inbounds %struct.Node* %18, i64 0
  store %struct.Node* %arrayidx9, %struct.Node** %n, align 8
  br label %for.cond10

for.cond10:                                       ; preds = %for.inc24, %for.end
  %19 = load %struct.Node** %n, align 8
  %20 = load %struct.Node** %limit, align 8
  %cmp11 = icmp ult %struct.Node* %19, %20
  br i1 %cmp11, label %for.body13, label %for.end25

for.body13:                                       ; preds = %for.cond10
  %21 = load %struct.Node** %n, align 8
  %i_val = getelementptr inbounds %struct.Node* %21, i32 0, i32 0
  %tt_14 = getelementptr inbounds %struct.lua_TValue* %i_val, i32 0, i32 1
  %22 = load i32* %tt_14, align 4
  %cmp15 = icmp eq i32 %22, 0
  br i1 %cmp15, label %if.end23, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body13
  %23 = load %struct.global_State** %g.addr, align 8
  %24 = load %struct.Node** %n, align 8
  %i_val17 = getelementptr inbounds %struct.Node* %24, i32 0, i32 0
  %call18 = call i32 @iscleared(%struct.global_State* %23, %struct.lua_TValue* %i_val17)
  %tobool19 = icmp ne i32 %call18, 0
  br i1 %tobool19, label %if.then20, label %if.end23

if.then20:                                        ; preds = %land.lhs.true
  %25 = load %struct.Node** %n, align 8
  %i_val21 = getelementptr inbounds %struct.Node* %25, i32 0, i32 0
  %tt_22 = getelementptr inbounds %struct.lua_TValue* %i_val21, i32 0, i32 1
  store i32 0, i32* %tt_22, align 4
  %26 = load %struct.Node** %n, align 8
  call void @removeentry(%struct.Node* %26)
  br label %if.end23

if.end23:                                         ; preds = %if.then20, %land.lhs.true, %for.body13
  br label %for.inc24

for.inc24:                                        ; preds = %if.end23
  %27 = load %struct.Node** %n, align 8
  %incdec.ptr = getelementptr inbounds %struct.Node* %27, i32 1
  store %struct.Node* %incdec.ptr, %struct.Node** %n, align 8
  br label %for.cond10

for.end25:                                        ; preds = %for.cond10
  br label %for.inc26

for.inc26:                                        ; preds = %for.end25
  %28 = load %union.GCObject** %l.addr, align 8
  %h27 = bitcast %union.GCObject* %28 to %struct.Table*
  %gclist = getelementptr inbounds %struct.Table* %h27, i32 0, i32 9
  %29 = load %union.GCObject** %gclist, align 8
  store %union.GCObject* %29, %union.GCObject** %l.addr, align 8
  br label %for.cond

for.end28:                                        ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @clearkeys(%struct.global_State* %g, %union.GCObject* %l, %union.GCObject* %f) #0 {
entry:
  %g.addr = alloca %struct.global_State*, align 8
  %l.addr = alloca %union.GCObject*, align 8
  %f.addr = alloca %union.GCObject*, align 8
  %h = alloca %struct.Table*, align 8
  %n = alloca %struct.Node*, align 8
  %limit = alloca %struct.Node*, align 8
  store %struct.global_State* %g, %struct.global_State** %g.addr, align 8
  store %union.GCObject* %l, %union.GCObject** %l.addr, align 8
  store %union.GCObject* %f, %union.GCObject** %f.addr, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc13, %entry
  %0 = load %union.GCObject** %l.addr, align 8
  %1 = load %union.GCObject** %f.addr, align 8
  %cmp = icmp ne %union.GCObject* %0, %1
  br i1 %cmp, label %for.body, label %for.end15

for.body:                                         ; preds = %for.cond
  %2 = load %union.GCObject** %l.addr, align 8
  %h1 = bitcast %union.GCObject* %2 to %struct.Table*
  store %struct.Table* %h1, %struct.Table** %h, align 8
  %3 = load %struct.Table** %h, align 8
  %lsizenode = getelementptr inbounds %struct.Table* %3, i32 0, i32 4
  %4 = load i8* %lsizenode, align 1
  %conv = zext i8 %4 to i32
  %shl = shl i32 1, %conv
  %conv2 = sext i32 %shl to i64
  %5 = load %struct.Table** %h, align 8
  %node = getelementptr inbounds %struct.Table* %5, i32 0, i32 7
  %6 = load %struct.Node** %node, align 8
  %arrayidx = getelementptr inbounds %struct.Node* %6, i64 %conv2
  store %struct.Node* %arrayidx, %struct.Node** %limit, align 8
  %7 = load %struct.Table** %h, align 8
  %node3 = getelementptr inbounds %struct.Table* %7, i32 0, i32 7
  %8 = load %struct.Node** %node3, align 8
  %arrayidx4 = getelementptr inbounds %struct.Node* %8, i64 0
  store %struct.Node* %arrayidx4, %struct.Node** %n, align 8
  br label %for.cond5

for.cond5:                                        ; preds = %for.inc, %for.body
  %9 = load %struct.Node** %n, align 8
  %10 = load %struct.Node** %limit, align 8
  %cmp6 = icmp ult %struct.Node* %9, %10
  br i1 %cmp6, label %for.body8, label %for.end

for.body8:                                        ; preds = %for.cond5
  %11 = load %struct.Node** %n, align 8
  %i_val = getelementptr inbounds %struct.Node* %11, i32 0, i32 0
  %tt_ = getelementptr inbounds %struct.lua_TValue* %i_val, i32 0, i32 1
  %12 = load i32* %tt_, align 4
  %cmp9 = icmp eq i32 %12, 0
  br i1 %cmp9, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body8
  %13 = load %struct.global_State** %g.addr, align 8
  %14 = load %struct.Node** %n, align 8
  %i_key = getelementptr inbounds %struct.Node* %14, i32 0, i32 1
  %tvk = bitcast %union.TKey* %i_key to %struct.lua_TValue*
  %call = call i32 @iscleared(%struct.global_State* %13, %struct.lua_TValue* %tvk)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %15 = load %struct.Node** %n, align 8
  %i_val11 = getelementptr inbounds %struct.Node* %15, i32 0, i32 0
  %tt_12 = getelementptr inbounds %struct.lua_TValue* %i_val11, i32 0, i32 1
  store i32 0, i32* %tt_12, align 4
  %16 = load %struct.Node** %n, align 8
  call void @removeentry(%struct.Node* %16)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %for.body8
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %17 = load %struct.Node** %n, align 8
  %incdec.ptr = getelementptr inbounds %struct.Node* %17, i32 1
  store %struct.Node* %incdec.ptr, %struct.Node** %n, align 8
  br label %for.cond5

for.end:                                          ; preds = %for.cond5
  br label %for.inc13

for.inc13:                                        ; preds = %for.end
  %18 = load %union.GCObject** %l.addr, align 8
  %h14 = bitcast %union.GCObject* %18 to %struct.Table*
  %gclist = getelementptr inbounds %struct.Table* %h14, i32 0, i32 9
  %19 = load %union.GCObject** %gclist, align 8
  store %union.GCObject* %19, %union.GCObject** %l.addr, align 8
  br label %for.cond

for.end15:                                        ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @traverseweakvalue(%struct.global_State* %g, %struct.Table* %h) #0 {
entry:
  %g.addr = alloca %struct.global_State*, align 8
  %h.addr = alloca %struct.Table*, align 8
  %n = alloca %struct.Node*, align 8
  %limit = alloca %struct.Node*, align 8
  %hasclears = alloca i32, align 4
  store %struct.global_State* %g, %struct.global_State** %g.addr, align 8
  store %struct.Table* %h, %struct.Table** %h.addr, align 8
  %0 = load %struct.Table** %h.addr, align 8
  %lsizenode = getelementptr inbounds %struct.Table* %0, i32 0, i32 4
  %1 = load i8* %lsizenode, align 1
  %conv = zext i8 %1 to i32
  %shl = shl i32 1, %conv
  %conv1 = sext i32 %shl to i64
  %2 = load %struct.Table** %h.addr, align 8
  %node = getelementptr inbounds %struct.Table* %2, i32 0, i32 7
  %3 = load %struct.Node** %node, align 8
  %arrayidx = getelementptr inbounds %struct.Node* %3, i64 %conv1
  store %struct.Node* %arrayidx, %struct.Node** %limit, align 8
  %4 = load %struct.Table** %h.addr, align 8
  %sizearray = getelementptr inbounds %struct.Table* %4, i32 0, i32 10
  %5 = load i32* %sizearray, align 4
  %cmp = icmp sgt i32 %5, 0
  %conv2 = zext i1 %cmp to i32
  store i32 %conv2, i32* %hasclears, align 4
  %6 = load %struct.Table** %h.addr, align 8
  %node3 = getelementptr inbounds %struct.Table* %6, i32 0, i32 7
  %7 = load %struct.Node** %node3, align 8
  %arrayidx4 = getelementptr inbounds %struct.Node* %7, i64 0
  store %struct.Node* %arrayidx4, %struct.Node** %n, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load %struct.Node** %n, align 8
  %9 = load %struct.Node** %limit, align 8
  %cmp5 = icmp ult %struct.Node* %8, %9
  br i1 %cmp5, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load %struct.Node** %n, align 8
  %i_val = getelementptr inbounds %struct.Node* %10, i32 0, i32 0
  %tt_ = getelementptr inbounds %struct.lua_TValue* %i_val, i32 0, i32 1
  %11 = load i32* %tt_, align 4
  %cmp7 = icmp eq i32 %11, 0
  br i1 %cmp7, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %12 = load %struct.Node** %n, align 8
  call void @removeentry(%struct.Node* %12)
  br label %if.end26

if.else:                                          ; preds = %for.body
  %13 = load %struct.Node** %n, align 8
  %i_key = getelementptr inbounds %struct.Node* %13, i32 0, i32 1
  %tvk = bitcast %union.TKey* %i_key to %struct.lua_TValue*
  %tt_9 = getelementptr inbounds %struct.lua_TValue* %tvk, i32 0, i32 1
  %14 = load i32* %tt_9, align 4
  %and = and i32 %14, 64
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.else
  %15 = load %struct.Node** %n, align 8
  %i_key10 = getelementptr inbounds %struct.Node* %15, i32 0, i32 1
  %tvk11 = bitcast %union.TKey* %i_key10 to %struct.lua_TValue*
  %value_ = getelementptr inbounds %struct.lua_TValue* %tvk11, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %16 = load %union.GCObject** %gc, align 8
  %gch = bitcast %union.GCObject* %16 to %struct.GCheader*
  %marked = getelementptr inbounds %struct.GCheader* %gch, i32 0, i32 2
  %17 = load i8* %marked, align 1
  %conv12 = zext i8 %17 to i32
  %and13 = and i32 %conv12, 3
  %tobool14 = icmp ne i32 %and13, 0
  br i1 %tobool14, label %if.then15, label %if.end

if.then15:                                        ; preds = %land.lhs.true
  %18 = load %struct.global_State** %g.addr, align 8
  %19 = load %struct.Node** %n, align 8
  %i_key16 = getelementptr inbounds %struct.Node* %19, i32 0, i32 1
  %tvk17 = bitcast %union.TKey* %i_key16 to %struct.lua_TValue*
  %value_18 = getelementptr inbounds %struct.lua_TValue* %tvk17, i32 0, i32 0
  %gc19 = bitcast %union.Value* %value_18 to %union.GCObject**
  %20 = load %union.GCObject** %gc19, align 8
  call void @reallymarkobject(%struct.global_State* %18, %union.GCObject* %20)
  br label %if.end

if.end:                                           ; preds = %if.then15, %land.lhs.true, %if.else
  %21 = load i32* %hasclears, align 4
  %tobool20 = icmp ne i32 %21, 0
  br i1 %tobool20, label %if.end25, label %land.lhs.true21

land.lhs.true21:                                  ; preds = %if.end
  %22 = load %struct.global_State** %g.addr, align 8
  %23 = load %struct.Node** %n, align 8
  %i_val22 = getelementptr inbounds %struct.Node* %23, i32 0, i32 0
  %call = call i32 @iscleared(%struct.global_State* %22, %struct.lua_TValue* %i_val22)
  %tobool23 = icmp ne i32 %call, 0
  br i1 %tobool23, label %if.then24, label %if.end25

if.then24:                                        ; preds = %land.lhs.true21
  store i32 1, i32* %hasclears, align 4
  br label %if.end25

if.end25:                                         ; preds = %if.then24, %land.lhs.true21, %if.end
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %if.then
  br label %for.inc

for.inc:                                          ; preds = %if.end26
  %24 = load %struct.Node** %n, align 8
  %incdec.ptr = getelementptr inbounds %struct.Node* %24, i32 1
  store %struct.Node* %incdec.ptr, %struct.Node** %n, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %25 = load i32* %hasclears, align 4
  %tobool27 = icmp ne i32 %25, 0
  br i1 %tobool27, label %if.then28, label %if.else30

if.then28:                                        ; preds = %for.end
  %26 = load %struct.global_State** %g.addr, align 8
  %weak = getelementptr inbounds %struct.global_State* %26, i32 0, i32 20
  %27 = load %union.GCObject** %weak, align 8
  %28 = load %struct.Table** %h.addr, align 8
  %gclist = getelementptr inbounds %struct.Table* %28, i32 0, i32 9
  store %union.GCObject* %27, %union.GCObject** %gclist, align 8
  %29 = load %struct.Table** %h.addr, align 8
  %30 = bitcast %struct.Table* %29 to %union.GCObject*
  %31 = load %struct.global_State** %g.addr, align 8
  %weak29 = getelementptr inbounds %struct.global_State* %31, i32 0, i32 20
  store %union.GCObject* %30, %union.GCObject** %weak29, align 8
  br label %if.end33

if.else30:                                        ; preds = %for.end
  %32 = load %struct.global_State** %g.addr, align 8
  %grayagain = getelementptr inbounds %struct.global_State* %32, i32 0, i32 19
  %33 = load %union.GCObject** %grayagain, align 8
  %34 = load %struct.Table** %h.addr, align 8
  %gclist31 = getelementptr inbounds %struct.Table* %34, i32 0, i32 9
  store %union.GCObject* %33, %union.GCObject** %gclist31, align 8
  %35 = load %struct.Table** %h.addr, align 8
  %36 = bitcast %struct.Table* %35 to %union.GCObject*
  %37 = load %struct.global_State** %g.addr, align 8
  %grayagain32 = getelementptr inbounds %struct.global_State* %37, i32 0, i32 19
  store %union.GCObject* %36, %union.GCObject** %grayagain32, align 8
  br label %if.end33

if.end33:                                         ; preds = %if.else30, %if.then28
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @traverseephemeron(%struct.global_State* %g, %struct.Table* %h) #0 {
entry:
  %g.addr = alloca %struct.global_State*, align 8
  %h.addr = alloca %struct.Table*, align 8
  %marked = alloca i32, align 4
  %hasclears = alloca i32, align 4
  %prop = alloca i32, align 4
  %n = alloca %struct.Node*, align 8
  %limit = alloca %struct.Node*, align 8
  %i = alloca i32, align 4
  store %struct.global_State* %g, %struct.global_State** %g.addr, align 8
  store %struct.Table* %h, %struct.Table** %h.addr, align 8
  store i32 0, i32* %marked, align 4
  store i32 0, i32* %hasclears, align 4
  store i32 0, i32* %prop, align 4
  %0 = load %struct.Table** %h.addr, align 8
  %lsizenode = getelementptr inbounds %struct.Table* %0, i32 0, i32 4
  %1 = load i8* %lsizenode, align 1
  %conv = zext i8 %1 to i32
  %shl = shl i32 1, %conv
  %conv1 = sext i32 %shl to i64
  %2 = load %struct.Table** %h.addr, align 8
  %node = getelementptr inbounds %struct.Table* %2, i32 0, i32 7
  %3 = load %struct.Node** %node, align 8
  %arrayidx = getelementptr inbounds %struct.Node* %3, i64 %conv1
  store %struct.Node* %arrayidx, %struct.Node** %limit, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %4 = load i32* %i, align 4
  %5 = load %struct.Table** %h.addr, align 8
  %sizearray = getelementptr inbounds %struct.Table* %5, i32 0, i32 10
  %6 = load i32* %sizearray, align 4
  %cmp = icmp slt i32 %4, %6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load i32* %i, align 4
  %idxprom = sext i32 %7 to i64
  %8 = load %struct.Table** %h.addr, align 8
  %array = getelementptr inbounds %struct.Table* %8, i32 0, i32 6
  %9 = load %struct.lua_TValue** %array, align 8
  %arrayidx3 = getelementptr inbounds %struct.lua_TValue* %9, i64 %idxprom
  %tt_ = getelementptr inbounds %struct.lua_TValue* %arrayidx3, i32 0, i32 1
  %10 = load i32* %tt_, align 4
  %and = and i32 %10, 64
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.body
  %11 = load i32* %i, align 4
  %idxprom4 = sext i32 %11 to i64
  %12 = load %struct.Table** %h.addr, align 8
  %array5 = getelementptr inbounds %struct.Table* %12, i32 0, i32 6
  %13 = load %struct.lua_TValue** %array5, align 8
  %arrayidx6 = getelementptr inbounds %struct.lua_TValue* %13, i64 %idxprom4
  %value_ = getelementptr inbounds %struct.lua_TValue* %arrayidx6, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %14 = load %union.GCObject** %gc, align 8
  %gch = bitcast %union.GCObject* %14 to %struct.GCheader*
  %marked7 = getelementptr inbounds %struct.GCheader* %gch, i32 0, i32 2
  %15 = load i8* %marked7, align 1
  %conv8 = zext i8 %15 to i32
  %and9 = and i32 %conv8, 3
  %tobool10 = icmp ne i32 %and9, 0
  br i1 %tobool10, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store i32 1, i32* %marked, align 4
  %16 = load %struct.global_State** %g.addr, align 8
  %17 = load i32* %i, align 4
  %idxprom11 = sext i32 %17 to i64
  %18 = load %struct.Table** %h.addr, align 8
  %array12 = getelementptr inbounds %struct.Table* %18, i32 0, i32 6
  %19 = load %struct.lua_TValue** %array12, align 8
  %arrayidx13 = getelementptr inbounds %struct.lua_TValue* %19, i64 %idxprom11
  %value_14 = getelementptr inbounds %struct.lua_TValue* %arrayidx13, i32 0, i32 0
  %gc15 = bitcast %union.Value* %value_14 to %union.GCObject**
  %20 = load %union.GCObject** %gc15, align 8
  call void @reallymarkobject(%struct.global_State* %16, %union.GCObject* %20)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %21 = load i32* %i, align 4
  %inc = add nsw i32 %21, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %22 = load %struct.Table** %h.addr, align 8
  %node16 = getelementptr inbounds %struct.Table* %22, i32 0, i32 7
  %23 = load %struct.Node** %node16, align 8
  %arrayidx17 = getelementptr inbounds %struct.Node* %23, i64 0
  store %struct.Node* %arrayidx17, %struct.Node** %n, align 8
  br label %for.cond18

for.cond18:                                       ; preds = %for.inc64, %for.end
  %24 = load %struct.Node** %n, align 8
  %25 = load %struct.Node** %limit, align 8
  %cmp19 = icmp ult %struct.Node* %24, %25
  br i1 %cmp19, label %for.body21, label %for.end65

for.body21:                                       ; preds = %for.cond18
  %26 = load %struct.Node** %n, align 8
  %i_val = getelementptr inbounds %struct.Node* %26, i32 0, i32 0
  %tt_22 = getelementptr inbounds %struct.lua_TValue* %i_val, i32 0, i32 1
  %27 = load i32* %tt_22, align 4
  %cmp23 = icmp eq i32 %27, 0
  br i1 %cmp23, label %if.then25, label %if.else

if.then25:                                        ; preds = %for.body21
  %28 = load %struct.Node** %n, align 8
  call void @removeentry(%struct.Node* %28)
  br label %if.end63

if.else:                                          ; preds = %for.body21
  %29 = load %struct.global_State** %g.addr, align 8
  %30 = load %struct.Node** %n, align 8
  %i_key = getelementptr inbounds %struct.Node* %30, i32 0, i32 1
  %tvk = bitcast %union.TKey* %i_key to %struct.lua_TValue*
  %call = call i32 @iscleared(%struct.global_State* %29, %struct.lua_TValue* %tvk)
  %tobool26 = icmp ne i32 %call, 0
  br i1 %tobool26, label %if.then27, label %if.else43

if.then27:                                        ; preds = %if.else
  store i32 1, i32* %hasclears, align 4
  %31 = load %struct.Node** %n, align 8
  %i_val28 = getelementptr inbounds %struct.Node* %31, i32 0, i32 0
  %tt_29 = getelementptr inbounds %struct.lua_TValue* %i_val28, i32 0, i32 1
  %32 = load i32* %tt_29, align 4
  %and30 = and i32 %32, 64
  %tobool31 = icmp ne i32 %and30, 0
  br i1 %tobool31, label %land.lhs.true32, label %if.end42

land.lhs.true32:                                  ; preds = %if.then27
  %33 = load %struct.Node** %n, align 8
  %i_val33 = getelementptr inbounds %struct.Node* %33, i32 0, i32 0
  %value_34 = getelementptr inbounds %struct.lua_TValue* %i_val33, i32 0, i32 0
  %gc35 = bitcast %union.Value* %value_34 to %union.GCObject**
  %34 = load %union.GCObject** %gc35, align 8
  %gch36 = bitcast %union.GCObject* %34 to %struct.GCheader*
  %marked37 = getelementptr inbounds %struct.GCheader* %gch36, i32 0, i32 2
  %35 = load i8* %marked37, align 1
  %conv38 = zext i8 %35 to i32
  %and39 = and i32 %conv38, 3
  %tobool40 = icmp ne i32 %and39, 0
  br i1 %tobool40, label %if.then41, label %if.end42

if.then41:                                        ; preds = %land.lhs.true32
  store i32 1, i32* %prop, align 4
  br label %if.end42

if.end42:                                         ; preds = %if.then41, %land.lhs.true32, %if.then27
  br label %if.end62

if.else43:                                        ; preds = %if.else
  %36 = load %struct.Node** %n, align 8
  %i_val44 = getelementptr inbounds %struct.Node* %36, i32 0, i32 0
  %tt_45 = getelementptr inbounds %struct.lua_TValue* %i_val44, i32 0, i32 1
  %37 = load i32* %tt_45, align 4
  %and46 = and i32 %37, 64
  %tobool47 = icmp ne i32 %and46, 0
  br i1 %tobool47, label %land.lhs.true48, label %if.end61

land.lhs.true48:                                  ; preds = %if.else43
  %38 = load %struct.Node** %n, align 8
  %i_val49 = getelementptr inbounds %struct.Node* %38, i32 0, i32 0
  %value_50 = getelementptr inbounds %struct.lua_TValue* %i_val49, i32 0, i32 0
  %gc51 = bitcast %union.Value* %value_50 to %union.GCObject**
  %39 = load %union.GCObject** %gc51, align 8
  %gch52 = bitcast %union.GCObject* %39 to %struct.GCheader*
  %marked53 = getelementptr inbounds %struct.GCheader* %gch52, i32 0, i32 2
  %40 = load i8* %marked53, align 1
  %conv54 = zext i8 %40 to i32
  %and55 = and i32 %conv54, 3
  %tobool56 = icmp ne i32 %and55, 0
  br i1 %tobool56, label %if.then57, label %if.end61

if.then57:                                        ; preds = %land.lhs.true48
  store i32 1, i32* %marked, align 4
  %41 = load %struct.global_State** %g.addr, align 8
  %42 = load %struct.Node** %n, align 8
  %i_val58 = getelementptr inbounds %struct.Node* %42, i32 0, i32 0
  %value_59 = getelementptr inbounds %struct.lua_TValue* %i_val58, i32 0, i32 0
  %gc60 = bitcast %union.Value* %value_59 to %union.GCObject**
  %43 = load %union.GCObject** %gc60, align 8
  call void @reallymarkobject(%struct.global_State* %41, %union.GCObject* %43)
  br label %if.end61

if.end61:                                         ; preds = %if.then57, %land.lhs.true48, %if.else43
  br label %if.end62

if.end62:                                         ; preds = %if.end61, %if.end42
  br label %if.end63

if.end63:                                         ; preds = %if.end62, %if.then25
  br label %for.inc64

for.inc64:                                        ; preds = %if.end63
  %44 = load %struct.Node** %n, align 8
  %incdec.ptr = getelementptr inbounds %struct.Node* %44, i32 1
  store %struct.Node* %incdec.ptr, %struct.Node** %n, align 8
  br label %for.cond18

for.end65:                                        ; preds = %for.cond18
  %45 = load i32* %prop, align 4
  %tobool66 = icmp ne i32 %45, 0
  br i1 %tobool66, label %if.then67, label %if.else69

if.then67:                                        ; preds = %for.end65
  %46 = load %struct.global_State** %g.addr, align 8
  %ephemeron = getelementptr inbounds %struct.global_State* %46, i32 0, i32 21
  %47 = load %union.GCObject** %ephemeron, align 8
  %48 = load %struct.Table** %h.addr, align 8
  %gclist = getelementptr inbounds %struct.Table* %48, i32 0, i32 9
  store %union.GCObject* %47, %union.GCObject** %gclist, align 8
  %49 = load %struct.Table** %h.addr, align 8
  %50 = bitcast %struct.Table* %49 to %union.GCObject*
  %51 = load %struct.global_State** %g.addr, align 8
  %ephemeron68 = getelementptr inbounds %struct.global_State* %51, i32 0, i32 21
  store %union.GCObject* %50, %union.GCObject** %ephemeron68, align 8
  br label %if.end78

if.else69:                                        ; preds = %for.end65
  %52 = load i32* %hasclears, align 4
  %tobool70 = icmp ne i32 %52, 0
  br i1 %tobool70, label %if.then71, label %if.else74

if.then71:                                        ; preds = %if.else69
  %53 = load %struct.global_State** %g.addr, align 8
  %allweak = getelementptr inbounds %struct.global_State* %53, i32 0, i32 22
  %54 = load %union.GCObject** %allweak, align 8
  %55 = load %struct.Table** %h.addr, align 8
  %gclist72 = getelementptr inbounds %struct.Table* %55, i32 0, i32 9
  store %union.GCObject* %54, %union.GCObject** %gclist72, align 8
  %56 = load %struct.Table** %h.addr, align 8
  %57 = bitcast %struct.Table* %56 to %union.GCObject*
  %58 = load %struct.global_State** %g.addr, align 8
  %allweak73 = getelementptr inbounds %struct.global_State* %58, i32 0, i32 22
  store %union.GCObject* %57, %union.GCObject** %allweak73, align 8
  br label %if.end77

if.else74:                                        ; preds = %if.else69
  %59 = load %struct.global_State** %g.addr, align 8
  %grayagain = getelementptr inbounds %struct.global_State* %59, i32 0, i32 19
  %60 = load %union.GCObject** %grayagain, align 8
  %61 = load %struct.Table** %h.addr, align 8
  %gclist75 = getelementptr inbounds %struct.Table* %61, i32 0, i32 9
  store %union.GCObject* %60, %union.GCObject** %gclist75, align 8
  %62 = load %struct.Table** %h.addr, align 8
  %63 = bitcast %struct.Table* %62 to %union.GCObject*
  %64 = load %struct.global_State** %g.addr, align 8
  %grayagain76 = getelementptr inbounds %struct.global_State* %64, i32 0, i32 19
  store %union.GCObject* %63, %union.GCObject** %grayagain76, align 8
  br label %if.end77

if.end77:                                         ; preds = %if.else74, %if.then71
  br label %if.end78

if.end78:                                         ; preds = %if.end77, %if.then67
  %65 = load i32* %marked, align 4
  ret i32 %65
}

; Function Attrs: nounwind uwtable
define internal void @traversestrongtable(%struct.global_State* %g, %struct.Table* %h) #0 {
entry:
  %g.addr = alloca %struct.global_State*, align 8
  %h.addr = alloca %struct.Table*, align 8
  %n = alloca %struct.Node*, align 8
  %limit = alloca %struct.Node*, align 8
  %i = alloca i32, align 4
  store %struct.global_State* %g, %struct.global_State** %g.addr, align 8
  store %struct.Table* %h, %struct.Table** %h.addr, align 8
  %0 = load %struct.Table** %h.addr, align 8
  %lsizenode = getelementptr inbounds %struct.Table* %0, i32 0, i32 4
  %1 = load i8* %lsizenode, align 1
  %conv = zext i8 %1 to i32
  %shl = shl i32 1, %conv
  %conv1 = sext i32 %shl to i64
  %2 = load %struct.Table** %h.addr, align 8
  %node = getelementptr inbounds %struct.Table* %2, i32 0, i32 7
  %3 = load %struct.Node** %node, align 8
  %arrayidx = getelementptr inbounds %struct.Node* %3, i64 %conv1
  store %struct.Node* %arrayidx, %struct.Node** %limit, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %4 = load i32* %i, align 4
  %5 = load %struct.Table** %h.addr, align 8
  %sizearray = getelementptr inbounds %struct.Table* %5, i32 0, i32 10
  %6 = load i32* %sizearray, align 4
  %cmp = icmp slt i32 %4, %6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load i32* %i, align 4
  %idxprom = sext i32 %7 to i64
  %8 = load %struct.Table** %h.addr, align 8
  %array = getelementptr inbounds %struct.Table* %8, i32 0, i32 6
  %9 = load %struct.lua_TValue** %array, align 8
  %arrayidx3 = getelementptr inbounds %struct.lua_TValue* %9, i64 %idxprom
  %tt_ = getelementptr inbounds %struct.lua_TValue* %arrayidx3, i32 0, i32 1
  %10 = load i32* %tt_, align 4
  %and = and i32 %10, 64
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.body
  %11 = load i32* %i, align 4
  %idxprom4 = sext i32 %11 to i64
  %12 = load %struct.Table** %h.addr, align 8
  %array5 = getelementptr inbounds %struct.Table* %12, i32 0, i32 6
  %13 = load %struct.lua_TValue** %array5, align 8
  %arrayidx6 = getelementptr inbounds %struct.lua_TValue* %13, i64 %idxprom4
  %value_ = getelementptr inbounds %struct.lua_TValue* %arrayidx6, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %14 = load %union.GCObject** %gc, align 8
  %gch = bitcast %union.GCObject* %14 to %struct.GCheader*
  %marked = getelementptr inbounds %struct.GCheader* %gch, i32 0, i32 2
  %15 = load i8* %marked, align 1
  %conv7 = zext i8 %15 to i32
  %and8 = and i32 %conv7, 3
  %tobool9 = icmp ne i32 %and8, 0
  br i1 %tobool9, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %16 = load %struct.global_State** %g.addr, align 8
  %17 = load i32* %i, align 4
  %idxprom10 = sext i32 %17 to i64
  %18 = load %struct.Table** %h.addr, align 8
  %array11 = getelementptr inbounds %struct.Table* %18, i32 0, i32 6
  %19 = load %struct.lua_TValue** %array11, align 8
  %arrayidx12 = getelementptr inbounds %struct.lua_TValue* %19, i64 %idxprom10
  %value_13 = getelementptr inbounds %struct.lua_TValue* %arrayidx12, i32 0, i32 0
  %gc14 = bitcast %union.Value* %value_13 to %union.GCObject**
  %20 = load %union.GCObject** %gc14, align 8
  call void @reallymarkobject(%struct.global_State* %16, %union.GCObject* %20)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %21 = load i32* %i, align 4
  %inc = add nsw i32 %21, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %22 = load %struct.Table** %h.addr, align 8
  %node15 = getelementptr inbounds %struct.Table* %22, i32 0, i32 7
  %23 = load %struct.Node** %node15, align 8
  %arrayidx16 = getelementptr inbounds %struct.Node* %23, i64 0
  store %struct.Node* %arrayidx16, %struct.Node** %n, align 8
  br label %for.cond17

for.cond17:                                       ; preds = %for.inc63, %for.end
  %24 = load %struct.Node** %n, align 8
  %25 = load %struct.Node** %limit, align 8
  %cmp18 = icmp ult %struct.Node* %24, %25
  br i1 %cmp18, label %for.body20, label %for.end64

for.body20:                                       ; preds = %for.cond17
  %26 = load %struct.Node** %n, align 8
  %i_val = getelementptr inbounds %struct.Node* %26, i32 0, i32 0
  %tt_21 = getelementptr inbounds %struct.lua_TValue* %i_val, i32 0, i32 1
  %27 = load i32* %tt_21, align 4
  %cmp22 = icmp eq i32 %27, 0
  br i1 %cmp22, label %if.then24, label %if.else

if.then24:                                        ; preds = %for.body20
  %28 = load %struct.Node** %n, align 8
  call void @removeentry(%struct.Node* %28)
  br label %if.end62

if.else:                                          ; preds = %for.body20
  %29 = load %struct.Node** %n, align 8
  %i_key = getelementptr inbounds %struct.Node* %29, i32 0, i32 1
  %tvk = bitcast %union.TKey* %i_key to %struct.lua_TValue*
  %tt_25 = getelementptr inbounds %struct.lua_TValue* %tvk, i32 0, i32 1
  %30 = load i32* %tt_25, align 4
  %and26 = and i32 %30, 64
  %tobool27 = icmp ne i32 %and26, 0
  br i1 %tobool27, label %land.lhs.true28, label %if.end43

land.lhs.true28:                                  ; preds = %if.else
  %31 = load %struct.Node** %n, align 8
  %i_key29 = getelementptr inbounds %struct.Node* %31, i32 0, i32 1
  %tvk30 = bitcast %union.TKey* %i_key29 to %struct.lua_TValue*
  %value_31 = getelementptr inbounds %struct.lua_TValue* %tvk30, i32 0, i32 0
  %gc32 = bitcast %union.Value* %value_31 to %union.GCObject**
  %32 = load %union.GCObject** %gc32, align 8
  %gch33 = bitcast %union.GCObject* %32 to %struct.GCheader*
  %marked34 = getelementptr inbounds %struct.GCheader* %gch33, i32 0, i32 2
  %33 = load i8* %marked34, align 1
  %conv35 = zext i8 %33 to i32
  %and36 = and i32 %conv35, 3
  %tobool37 = icmp ne i32 %and36, 0
  br i1 %tobool37, label %if.then38, label %if.end43

if.then38:                                        ; preds = %land.lhs.true28
  %34 = load %struct.global_State** %g.addr, align 8
  %35 = load %struct.Node** %n, align 8
  %i_key39 = getelementptr inbounds %struct.Node* %35, i32 0, i32 1
  %tvk40 = bitcast %union.TKey* %i_key39 to %struct.lua_TValue*
  %value_41 = getelementptr inbounds %struct.lua_TValue* %tvk40, i32 0, i32 0
  %gc42 = bitcast %union.Value* %value_41 to %union.GCObject**
  %36 = load %union.GCObject** %gc42, align 8
  call void @reallymarkobject(%struct.global_State* %34, %union.GCObject* %36)
  br label %if.end43

if.end43:                                         ; preds = %if.then38, %land.lhs.true28, %if.else
  %37 = load %struct.Node** %n, align 8
  %i_val44 = getelementptr inbounds %struct.Node* %37, i32 0, i32 0
  %tt_45 = getelementptr inbounds %struct.lua_TValue* %i_val44, i32 0, i32 1
  %38 = load i32* %tt_45, align 4
  %and46 = and i32 %38, 64
  %tobool47 = icmp ne i32 %and46, 0
  br i1 %tobool47, label %land.lhs.true48, label %if.end61

land.lhs.true48:                                  ; preds = %if.end43
  %39 = load %struct.Node** %n, align 8
  %i_val49 = getelementptr inbounds %struct.Node* %39, i32 0, i32 0
  %value_50 = getelementptr inbounds %struct.lua_TValue* %i_val49, i32 0, i32 0
  %gc51 = bitcast %union.Value* %value_50 to %union.GCObject**
  %40 = load %union.GCObject** %gc51, align 8
  %gch52 = bitcast %union.GCObject* %40 to %struct.GCheader*
  %marked53 = getelementptr inbounds %struct.GCheader* %gch52, i32 0, i32 2
  %41 = load i8* %marked53, align 1
  %conv54 = zext i8 %41 to i32
  %and55 = and i32 %conv54, 3
  %tobool56 = icmp ne i32 %and55, 0
  br i1 %tobool56, label %if.then57, label %if.end61

if.then57:                                        ; preds = %land.lhs.true48
  %42 = load %struct.global_State** %g.addr, align 8
  %43 = load %struct.Node** %n, align 8
  %i_val58 = getelementptr inbounds %struct.Node* %43, i32 0, i32 0
  %value_59 = getelementptr inbounds %struct.lua_TValue* %i_val58, i32 0, i32 0
  %gc60 = bitcast %union.Value* %value_59 to %union.GCObject**
  %44 = load %union.GCObject** %gc60, align 8
  call void @reallymarkobject(%struct.global_State* %42, %union.GCObject* %44)
  br label %if.end61

if.end61:                                         ; preds = %if.then57, %land.lhs.true48, %if.end43
  br label %if.end62

if.end62:                                         ; preds = %if.end61, %if.then24
  br label %for.inc63

for.inc63:                                        ; preds = %if.end62
  %45 = load %struct.Node** %n, align 8
  %incdec.ptr = getelementptr inbounds %struct.Node* %45, i32 1
  store %struct.Node* %incdec.ptr, %struct.Node** %n, align 8
  br label %for.cond17

for.end64:                                        ; preds = %for.cond17
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @propagatelist(%struct.global_State* %g, %union.GCObject* %l) #0 {
entry:
  %g.addr = alloca %struct.global_State*, align 8
  %l.addr = alloca %union.GCObject*, align 8
  store %struct.global_State* %g, %struct.global_State** %g.addr, align 8
  store %union.GCObject* %l, %union.GCObject** %l.addr, align 8
  %0 = load %union.GCObject** %l.addr, align 8
  %1 = load %struct.global_State** %g.addr, align 8
  %gray = getelementptr inbounds %struct.global_State* %1, i32 0, i32 18
  store %union.GCObject* %0, %union.GCObject** %gray, align 8
  %2 = load %struct.global_State** %g.addr, align 8
  call void @propagateall(%struct.global_State* %2)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @iscleared(%struct.global_State* %g, %struct.lua_TValue* %o) #0 {
entry:
  %retval = alloca i32, align 4
  %g.addr = alloca %struct.global_State*, align 8
  %o.addr = alloca %struct.lua_TValue*, align 8
  store %struct.global_State* %g, %struct.global_State** %g.addr, align 8
  store %struct.lua_TValue* %o, %struct.lua_TValue** %o.addr, align 8
  %0 = load %struct.lua_TValue** %o.addr, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %0, i32 0, i32 1
  %1 = load i32* %tt_, align 4
  %and = and i32 %1, 64
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval
  br label %return

if.else:                                          ; preds = %entry
  %2 = load %struct.lua_TValue** %o.addr, align 8
  %tt_1 = getelementptr inbounds %struct.lua_TValue* %2, i32 0, i32 1
  %3 = load i32* %tt_1, align 4
  %and2 = and i32 %3, 15
  %cmp = icmp eq i32 %and2, 4
  br i1 %cmp, label %if.then3, label %if.else14

if.then3:                                         ; preds = %if.else
  %4 = load %struct.lua_TValue** %o.addr, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %4, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %5 = load %union.GCObject** %gc, align 8
  %ts = bitcast %union.GCObject* %5 to %union.TString*
  %tobool4 = icmp ne %union.TString* %ts, null
  br i1 %tobool4, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then3
  %6 = load %struct.lua_TValue** %o.addr, align 8
  %value_5 = getelementptr inbounds %struct.lua_TValue* %6, i32 0, i32 0
  %gc6 = bitcast %union.Value* %value_5 to %union.GCObject**
  %7 = load %union.GCObject** %gc6, align 8
  %ts7 = bitcast %union.GCObject* %7 to %union.TString*
  %8 = bitcast %union.TString* %ts7 to %union.GCObject*
  %gch = bitcast %union.GCObject* %8 to %struct.GCheader*
  %marked = getelementptr inbounds %struct.GCheader* %gch, i32 0, i32 2
  %9 = load i8* %marked, align 1
  %conv = zext i8 %9 to i32
  %and8 = and i32 %conv, 3
  %tobool9 = icmp ne i32 %and8, 0
  br i1 %tobool9, label %if.then10, label %if.end

if.then10:                                        ; preds = %land.lhs.true
  %10 = load %struct.global_State** %g.addr, align 8
  %11 = load %struct.lua_TValue** %o.addr, align 8
  %value_11 = getelementptr inbounds %struct.lua_TValue* %11, i32 0, i32 0
  %gc12 = bitcast %union.Value* %value_11 to %union.GCObject**
  %12 = load %union.GCObject** %gc12, align 8
  %ts13 = bitcast %union.GCObject* %12 to %union.TString*
  %13 = bitcast %union.TString* %ts13 to %union.GCObject*
  call void @reallymarkobject(%struct.global_State* %10, %union.GCObject* %13)
  br label %if.end

if.end:                                           ; preds = %if.then10, %land.lhs.true, %if.then3
  store i32 0, i32* %retval
  br label %return

if.else14:                                        ; preds = %if.else
  %14 = load %struct.lua_TValue** %o.addr, align 8
  %value_15 = getelementptr inbounds %struct.lua_TValue* %14, i32 0, i32 0
  %gc16 = bitcast %union.Value* %value_15 to %union.GCObject**
  %15 = load %union.GCObject** %gc16, align 8
  %gch17 = bitcast %union.GCObject* %15 to %struct.GCheader*
  %marked18 = getelementptr inbounds %struct.GCheader* %gch17, i32 0, i32 2
  %16 = load i8* %marked18, align 1
  %conv19 = zext i8 %16 to i32
  %and20 = and i32 %conv19, 3
  store i32 %and20, i32* %retval
  br label %return

return:                                           ; preds = %if.else14, %if.end, %if.then
  %17 = load i32* %retval
  ret i32 %17
}

; Function Attrs: nounwind uwtable
define internal void @removeentry(%struct.Node* %n) #0 {
entry:
  %n.addr = alloca %struct.Node*, align 8
  store %struct.Node* %n, %struct.Node** %n.addr, align 8
  %0 = load %struct.Node** %n.addr, align 8
  %i_key = getelementptr inbounds %struct.Node* %0, i32 0, i32 1
  %tvk = bitcast %union.TKey* %i_key to %struct.lua_TValue*
  %tt_ = getelementptr inbounds %struct.lua_TValue* %tvk, i32 0, i32 1
  %1 = load i32* %tt_, align 4
  %and = and i32 %1, 64
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %2 = load %struct.Node** %n.addr, align 8
  %i_key1 = getelementptr inbounds %struct.Node* %2, i32 0, i32 1
  %tvk2 = bitcast %union.TKey* %i_key1 to %struct.lua_TValue*
  %value_ = getelementptr inbounds %struct.lua_TValue* %tvk2, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %3 = load %union.GCObject** %gc, align 8
  %gch = bitcast %union.GCObject* %3 to %struct.GCheader*
  %marked = getelementptr inbounds %struct.GCheader* %gch, i32 0, i32 2
  %4 = load i8* %marked, align 1
  %conv = zext i8 %4 to i32
  %and3 = and i32 %conv, 3
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %5 = load %struct.Node** %n.addr, align 8
  %i_key5 = getelementptr inbounds %struct.Node* %5, i32 0, i32 1
  %tvk6 = bitcast %union.TKey* %i_key5 to %struct.lua_TValue*
  %tt_7 = getelementptr inbounds %struct.lua_TValue* %tvk6, i32 0, i32 1
  store i32 11, i32* %tt_7, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @luaL_openlibs(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %lib = alloca %struct.luaL_Reg*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.luaL_Reg* getelementptr inbounds ([11 x %struct.luaL_Reg]* @loadedlibs, i32 0, i32 0), %struct.luaL_Reg** %lib, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load %struct.luaL_Reg** %lib, align 8
  %func = getelementptr inbounds %struct.luaL_Reg* %0, i32 0, i32 1
  %1 = load i32 (%struct.lua_State*)** %func, align 8
  %tobool = icmp ne i32 (%struct.lua_State*)* %1, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load %struct.luaL_Reg** %lib, align 8
  %name = getelementptr inbounds %struct.luaL_Reg* %3, i32 0, i32 0
  %4 = load i8** %name, align 8
  %5 = load %struct.luaL_Reg** %lib, align 8
  %func1 = getelementptr inbounds %struct.luaL_Reg* %5, i32 0, i32 1
  %6 = load i32 (%struct.lua_State*)** %func1, align 8
  call void @luaL_requiref(%struct.lua_State* %2, i8* %4, i32 (%struct.lua_State*)* %6, i32 1)
  %7 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %7, i32 -2)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %8 = load %struct.luaL_Reg** %lib, align 8
  %incdec.ptr = getelementptr inbounds %struct.luaL_Reg* %8, i32 1
  store %struct.luaL_Reg* %incdec.ptr, %struct.luaL_Reg** %lib, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %9 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @luaL_getsubtable(%struct.lua_State* %9, i32 -1001000, i8* getelementptr inbounds ([9 x i8]* @.str295, i32 0, i32 0))
  store %struct.luaL_Reg* getelementptr inbounds ([1 x %struct.luaL_Reg]* @preloadedlibs, i32 0, i32 0), %struct.luaL_Reg** %lib, align 8
  br label %for.cond2

for.cond2:                                        ; preds = %for.inc8, %for.end
  %10 = load %struct.luaL_Reg** %lib, align 8
  %func3 = getelementptr inbounds %struct.luaL_Reg* %10, i32 0, i32 1
  %11 = load i32 (%struct.lua_State*)** %func3, align 8
  %tobool4 = icmp ne i32 (%struct.lua_State*)* %11, null
  br i1 %tobool4, label %for.body5, label %for.end10

for.body5:                                        ; preds = %for.cond2
  %12 = load %struct.lua_State** %L.addr, align 8
  %13 = load %struct.luaL_Reg** %lib, align 8
  %func6 = getelementptr inbounds %struct.luaL_Reg* %13, i32 0, i32 1
  %14 = load i32 (%struct.lua_State*)** %func6, align 8
  call void @lua_pushcclosure(%struct.lua_State* %12, i32 (%struct.lua_State*)* %14, i32 0)
  %15 = load %struct.lua_State** %L.addr, align 8
  %16 = load %struct.luaL_Reg** %lib, align 8
  %name7 = getelementptr inbounds %struct.luaL_Reg* %16, i32 0, i32 0
  %17 = load i8** %name7, align 8
  call void @lua_setfield(%struct.lua_State* %15, i32 -2, i8* %17)
  br label %for.inc8

for.inc8:                                         ; preds = %for.body5
  %18 = load %struct.luaL_Reg** %lib, align 8
  %incdec.ptr9 = getelementptr inbounds %struct.luaL_Reg* %18, i32 1
  store %struct.luaL_Reg* %incdec.ptr9, %struct.luaL_Reg** %lib, align 8
  br label %for.cond2

for.end10:                                        ; preds = %for.cond2
  %19 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %19, i32 -2)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @luaopen_io(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 11)
  %1 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_setfuncs(%struct.lua_State* %1, %struct.luaL_Reg* getelementptr inbounds ([12 x %struct.luaL_Reg]* @iolib, i32 0, i32 0), i32 0)
  %2 = load %struct.lua_State** %L.addr, align 8
  call void @createmeta(%struct.lua_State* %2)
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load %struct._IO_FILE** @stdin, align 8
  call void @createstdfile(%struct.lua_State* %3, %struct._IO_FILE* %4, i8* getelementptr inbounds ([10 x i8]* @.str306, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8]* @.str1307, i32 0, i32 0))
  %5 = load %struct.lua_State** %L.addr, align 8
  %6 = load %struct._IO_FILE** @stdout, align 8
  call void @createstdfile(%struct.lua_State* %5, %struct._IO_FILE* %6, i8* getelementptr inbounds ([11 x i8]* @.str2308, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8]* @.str3309, i32 0, i32 0))
  %7 = load %struct.lua_State** %L.addr, align 8
  %8 = load %struct._IO_FILE** @stderr, align 8
  call void @createstdfile(%struct.lua_State* %7, %struct._IO_FILE* %8, i8* null, i8* getelementptr inbounds ([7 x i8]* @.str4310, i32 0, i32 0))
  ret i32 1
}

; Function Attrs: nounwind
declare i32 @setvbuf(%struct._IO_FILE*, i8*, i32, i64) #4

declare i32 @fseeko64(%struct._IO_FILE*, i64, i32) #5

declare i64 @ftello64(%struct._IO_FILE*) #5

; Function Attrs: nounwind
declare void @clearerr(%struct._IO_FILE*) #4

declare i32 @__isoc99_fscanf(%struct._IO_FILE*, i8*, ...) #5

declare i32 @ungetc(i32, %struct._IO_FILE*) #5

declare %struct._IO_FILE* @tmpfile64() #5

declare %struct._IO_FILE* @popen(i8*, i8*) #5

declare i32 @pclose(%struct._IO_FILE*) #5

declare %struct._IO_FILE* @fopen64(i8*, i8*) #5

; Function Attrs: nounwind uwtable
define internal i32 @io_close(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_type(%struct.lua_State* %0, i32 1)
  %cmp = icmp eq i32 %call, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.lua_State** %L.addr, align 8
  call void @lua_getfield(%struct.lua_State* %1, i32 -1001000, i8* getelementptr inbounds ([11 x i8]* @.str2308, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load %struct.lua_State** %L.addr, align 8
  %call1 = call %struct._IO_FILE* @tofile(%struct.lua_State* %2)
  %3 = load %struct.lua_State** %L.addr, align 8
  %call2 = call i32 @aux_close(%struct.lua_State* %3)
  ret i32 %call2
}

; Function Attrs: nounwind uwtable
define internal i32 @io_flush(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call %struct._IO_FILE* @getiofile(%struct.lua_State* %1, i8* getelementptr inbounds ([11 x i8]* @.str2308, i32 0, i32 0))
  %call1 = call i32 @fflush(%struct._IO_FILE* %call)
  %cmp = icmp eq i32 %call1, 0
  %conv = zext i1 %cmp to i32
  %call2 = call i32 @luaL_fileresult(%struct.lua_State* %0, i32 %conv, i8* null)
  ret i32 %call2
}

; Function Attrs: nounwind uwtable
define internal i32 @io_input(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @g_iofile(%struct.lua_State* %0, i8* getelementptr inbounds ([10 x i8]* @.str306, i32 0, i32 0), i8* getelementptr inbounds ([2 x i8]* @.str44350, i32 0, i32 0))
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @io_lines(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %toclose = alloca i32, align 4
  %filename = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_type(%struct.lua_State* %0, i32 1)
  %cmp = icmp eq i32 %call, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushnil(%struct.lua_State* %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i32 @lua_type(%struct.lua_State* %2, i32 1)
  %cmp2 = icmp eq i32 %call1, 0
  br i1 %cmp2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  %3 = load %struct.lua_State** %L.addr, align 8
  call void @lua_getfield(%struct.lua_State* %3, i32 -1001000, i8* getelementptr inbounds ([10 x i8]* @.str306, i32 0, i32 0))
  %4 = load %struct.lua_State** %L.addr, align 8
  call void @lua_replace(%struct.lua_State* %4, i32 1)
  %5 = load %struct.lua_State** %L.addr, align 8
  %call4 = call %struct._IO_FILE* @tofile(%struct.lua_State* %5)
  store i32 0, i32* %toclose, align 4
  br label %if.end6

if.else:                                          ; preds = %if.end
  %6 = load %struct.lua_State** %L.addr, align 8
  %call5 = call i8* @luaL_checklstring(%struct.lua_State* %6, i32 1, i64* null)
  store i8* %call5, i8** %filename, align 8
  %7 = load %struct.lua_State** %L.addr, align 8
  %8 = load i8** %filename, align 8
  call void @opencheck(%struct.lua_State* %7, i8* %8, i8* getelementptr inbounds ([2 x i8]* @.str44350, i32 0, i32 0))
  %9 = load %struct.lua_State** %L.addr, align 8
  call void @lua_replace(%struct.lua_State* %9, i32 1)
  store i32 1, i32* %toclose, align 4
  br label %if.end6

if.end6:                                          ; preds = %if.else, %if.then3
  %10 = load %struct.lua_State** %L.addr, align 8
  %11 = load i32* %toclose, align 4
  call void @aux_lines(%struct.lua_State* %10, i32 %11)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @io_open(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %filename = alloca i8*, align 8
  %mode = alloca i8*, align 8
  %p = alloca %struct.luaL_Stream*, align 8
  %md = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null)
  store i8* %call, i8** %filename, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i8* @luaL_optlstring(%struct.lua_State* %1, i32 2, i8* getelementptr inbounds ([2 x i8]* @.str44350, i32 0, i32 0), i64* null)
  store i8* %call1, i8** %mode, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %call2 = call %struct.luaL_Stream* @newfile(%struct.lua_State* %2)
  store %struct.luaL_Stream* %call2, %struct.luaL_Stream** %p, align 8
  %3 = load i8** %mode, align 8
  store i8* %3, i8** %md, align 8
  %4 = load i8** %md, align 8
  %5 = load i8* %4, align 1
  %conv = sext i8 %5 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %land.lhs.true, label %lor.rhs

land.lhs.true:                                    ; preds = %entry
  %6 = load i8** %md, align 8
  %incdec.ptr = getelementptr inbounds i8* %6, i32 1
  store i8* %incdec.ptr, i8** %md, align 8
  %7 = load i8* %6, align 1
  %conv4 = sext i8 %7 to i32
  %call5 = call i8* @strchr(i8* getelementptr inbounds ([4 x i8]* @.str47353, i32 0, i32 0), i32 %conv4) #10
  %cmp6 = icmp ne i8* %call5, null
  br i1 %cmp6, label %land.lhs.true8, label %lor.rhs

land.lhs.true8:                                   ; preds = %land.lhs.true
  %8 = load i8** %md, align 8
  %9 = load i8* %8, align 1
  %conv9 = sext i8 %9 to i32
  %cmp10 = icmp ne i32 %conv9, 43
  br i1 %cmp10, label %land.lhs.true13, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true8
  %10 = load i8** %md, align 8
  %incdec.ptr12 = getelementptr inbounds i8* %10, i32 1
  store i8* %incdec.ptr12, i8** %md, align 8
  %tobool = icmp ne i8* %incdec.ptr12, null
  br i1 %tobool, label %land.lhs.true13, label %lor.rhs

land.lhs.true13:                                  ; preds = %lor.lhs.false, %land.lhs.true8
  %11 = load i8** %md, align 8
  %12 = load i8* %11, align 1
  %conv14 = sext i8 %12 to i32
  %cmp15 = icmp ne i32 %conv14, 98
  br i1 %cmp15, label %land.lhs.true20, label %lor.lhs.false17

lor.lhs.false17:                                  ; preds = %land.lhs.true13
  %13 = load i8** %md, align 8
  %incdec.ptr18 = getelementptr inbounds i8* %13, i32 1
  store i8* %incdec.ptr18, i8** %md, align 8
  %tobool19 = icmp ne i8* %incdec.ptr18, null
  br i1 %tobool19, label %land.lhs.true20, label %lor.rhs

land.lhs.true20:                                  ; preds = %lor.lhs.false17, %land.lhs.true13
  %14 = load i8** %md, align 8
  %15 = load i8* %14, align 1
  %conv21 = sext i8 %15 to i32
  %cmp22 = icmp eq i32 %conv21, 0
  br i1 %cmp22, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.lhs.true20, %lor.lhs.false17, %lor.lhs.false, %land.lhs.true, %entry
  %16 = load %struct.lua_State** %L.addr, align 8
  %call24 = call i32 @luaL_argerror(%struct.lua_State* %16, i32 2, i8* getelementptr inbounds ([13 x i8]* @.str48354, i32 0, i32 0))
  %tobool25 = icmp ne i32 %call24, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.lhs.true20
  %17 = phi i1 [ true, %land.lhs.true20 ], [ %tobool25, %lor.rhs ]
  %lor.ext = zext i1 %17 to i32
  %18 = load i8** %filename, align 8
  %19 = load i8** %mode, align 8
  %call26 = call %struct._IO_FILE* @fopen64(i8* %18, i8* %19)
  %20 = load %struct.luaL_Stream** %p, align 8
  %f = getelementptr inbounds %struct.luaL_Stream* %20, i32 0, i32 0
  store %struct._IO_FILE* %call26, %struct._IO_FILE** %f, align 8
  %21 = load %struct.luaL_Stream** %p, align 8
  %f27 = getelementptr inbounds %struct.luaL_Stream* %21, i32 0, i32 0
  %22 = load %struct._IO_FILE** %f27, align 8
  %cmp28 = icmp eq %struct._IO_FILE* %22, null
  br i1 %cmp28, label %cond.true, label %cond.false

cond.true:                                        ; preds = %lor.end
  %23 = load %struct.lua_State** %L.addr, align 8
  %24 = load i8** %filename, align 8
  %call30 = call i32 @luaL_fileresult(%struct.lua_State* %23, i32 0, i8* %24)
  br label %cond.end

cond.false:                                       ; preds = %lor.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %call30, %cond.true ], [ 1, %cond.false ]
  ret i32 %cond
}

; Function Attrs: nounwind uwtable
define internal i32 @io_output(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @g_iofile(%struct.lua_State* %0, i8* getelementptr inbounds ([11 x i8]* @.str2308, i32 0, i32 0), i8* getelementptr inbounds ([2 x i8]* @.str45351, i32 0, i32 0))
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @io_popen(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %filename = alloca i8*, align 8
  %mode = alloca i8*, align 8
  %p = alloca %struct.luaL_Stream*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null)
  store i8* %call, i8** %filename, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i8* @luaL_optlstring(%struct.lua_State* %1, i32 2, i8* getelementptr inbounds ([2 x i8]* @.str44350, i32 0, i32 0), i64* null)
  store i8* %call1, i8** %mode, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %call2 = call %struct.luaL_Stream* @newprefile(%struct.lua_State* %2)
  store %struct.luaL_Stream* %call2, %struct.luaL_Stream** %p, align 8
  %3 = load %struct.lua_State** %L.addr, align 8
  %call3 = call i32 @fflush(%struct._IO_FILE* null)
  %4 = load i8** %filename, align 8
  %5 = load i8** %mode, align 8
  %call4 = call %struct._IO_FILE* @popen(i8* %4, i8* %5)
  %6 = load %struct.luaL_Stream** %p, align 8
  %f = getelementptr inbounds %struct.luaL_Stream* %6, i32 0, i32 0
  store %struct._IO_FILE* %call4, %struct._IO_FILE** %f, align 8
  %7 = load %struct.luaL_Stream** %p, align 8
  %closef = getelementptr inbounds %struct.luaL_Stream* %7, i32 0, i32 1
  store i32 (%struct.lua_State*)* @io_pclose, i32 (%struct.lua_State*)** %closef, align 8
  %8 = load %struct.luaL_Stream** %p, align 8
  %f5 = getelementptr inbounds %struct.luaL_Stream* %8, i32 0, i32 0
  %9 = load %struct._IO_FILE** %f5, align 8
  %cmp = icmp eq %struct._IO_FILE* %9, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %10 = load %struct.lua_State** %L.addr, align 8
  %11 = load i8** %filename, align 8
  %call6 = call i32 @luaL_fileresult(%struct.lua_State* %10, i32 0, i8* %11)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %call6, %cond.true ], [ 1, %cond.false ]
  ret i32 %cond
}

; Function Attrs: nounwind uwtable
define internal i32 @io_read(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call %struct._IO_FILE* @getiofile(%struct.lua_State* %1, i8* getelementptr inbounds ([10 x i8]* @.str306, i32 0, i32 0))
  %call1 = call i32 @g_read(%struct.lua_State* %0, %struct._IO_FILE* %call, i32 1)
  ret i32 %call1
}

; Function Attrs: nounwind uwtable
define internal i32 @io_tmpfile(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %p = alloca %struct.luaL_Stream*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call %struct.luaL_Stream* @newfile(%struct.lua_State* %0)
  store %struct.luaL_Stream* %call, %struct.luaL_Stream** %p, align 8
  %call1 = call %struct._IO_FILE* @tmpfile64()
  %1 = load %struct.luaL_Stream** %p, align 8
  %f = getelementptr inbounds %struct.luaL_Stream* %1, i32 0, i32 0
  store %struct._IO_FILE* %call1, %struct._IO_FILE** %f, align 8
  %2 = load %struct.luaL_Stream** %p, align 8
  %f2 = getelementptr inbounds %struct.luaL_Stream* %2, i32 0, i32 0
  %3 = load %struct._IO_FILE** %f2, align 8
  %cmp = icmp eq %struct._IO_FILE* %3, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %4 = load %struct.lua_State** %L.addr, align 8
  %call3 = call i32 @luaL_fileresult(%struct.lua_State* %4, i32 0, i8* null)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %call3, %cond.true ], [ 1, %cond.false ]
  ret i32 %cond
}

; Function Attrs: nounwind uwtable
define internal i32 @io_type(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %p = alloca %struct.luaL_Stream*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_checkany(%struct.lua_State* %0, i32 1)
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @luaL_testudata(%struct.lua_State* %1, i32 1, i8* getelementptr inbounds ([6 x i8]* @.str5311, i32 0, i32 0))
  %2 = bitcast i8* %call to %struct.luaL_Stream*
  store %struct.luaL_Stream* %2, %struct.luaL_Stream** %p, align 8
  %3 = load %struct.luaL_Stream** %p, align 8
  %cmp = icmp eq %struct.luaL_Stream* %3, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %4 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushnil(%struct.lua_State* %4)
  br label %if.end6

if.else:                                          ; preds = %entry
  %5 = load %struct.luaL_Stream** %p, align 8
  %closef = getelementptr inbounds %struct.luaL_Stream* %5, i32 0, i32 1
  %6 = load i32 (%struct.lua_State*)** %closef, align 8
  %cmp1 = icmp eq i32 (%struct.lua_State*)* %6, null
  br i1 %cmp1, label %if.then2, label %if.else4

if.then2:                                         ; preds = %if.else
  %7 = load %struct.lua_State** %L.addr, align 8
  %call3 = call i8* @lua_pushlstring(%struct.lua_State* %7, i8* getelementptr inbounds ([12 x i8]* @.str42348, i32 0, i32 0), i64 11)
  br label %if.end

if.else4:                                         ; preds = %if.else
  %8 = load %struct.lua_State** %L.addr, align 8
  %call5 = call i8* @lua_pushlstring(%struct.lua_State* %8, i8* getelementptr inbounds ([5 x i8]* @.str43349, i32 0, i32 0), i64 4)
  br label %if.end

if.end:                                           ; preds = %if.else4, %if.then2
  br label %if.end6

if.end6:                                          ; preds = %if.end, %if.then
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @io_write(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call %struct._IO_FILE* @getiofile(%struct.lua_State* %1, i8* getelementptr inbounds ([11 x i8]* @.str2308, i32 0, i32 0))
  %call1 = call i32 @g_write(%struct.lua_State* %0, %struct._IO_FILE* %call, i32 1)
  ret i32 %call1
}

; Function Attrs: nounwind uwtable
define internal i32 @f_flush(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call %struct._IO_FILE* @tofile(%struct.lua_State* %1)
  %call1 = call i32 @fflush(%struct._IO_FILE* %call)
  %cmp = icmp eq i32 %call1, 0
  %conv = zext i1 %cmp to i32
  %call2 = call i32 @luaL_fileresult(%struct.lua_State* %0, i32 %conv, i8* null)
  ret i32 %call2
}

; Function Attrs: nounwind uwtable
define internal i32 @f_lines(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call %struct._IO_FILE* @tofile(%struct.lua_State* %0)
  %1 = load %struct.lua_State** %L.addr, align 8
  call void @aux_lines(%struct.lua_State* %1, i32 0)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @f_read(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call %struct._IO_FILE* @tofile(%struct.lua_State* %1)
  %call1 = call i32 @g_read(%struct.lua_State* %0, %struct._IO_FILE* %call, i32 2)
  ret i32 %call1
}

; Function Attrs: nounwind uwtable
define internal i32 @f_seek(%struct.lua_State* %L) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %f = alloca %struct._IO_FILE*, align 8
  %op = alloca i32, align 4
  %p3 = alloca double, align 8
  %offset = alloca i64, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call %struct._IO_FILE* @tofile(%struct.lua_State* %0)
  store %struct._IO_FILE* %call, %struct._IO_FILE** %f, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i32 @luaL_checkoption(%struct.lua_State* %1, i32 2, i8* getelementptr inbounds ([4 x i8]* @.str25331, i32 0, i32 0), i8** getelementptr inbounds ([4 x i8*]* @f_seek.modenames, i32 0, i32 0))
  store i32 %call1, i32* %op, align 4
  %2 = load %struct.lua_State** %L.addr, align 8
  %call2 = call double @luaL_optnumber(%struct.lua_State* %2, i32 3, double 0.000000e+00)
  store double %call2, double* %p3, align 8
  %3 = load double* %p3, align 8
  %conv = fptosi double %3 to i64
  store i64 %conv, i64* %offset, align 8
  %4 = load i64* %offset, align 8
  %conv3 = sitofp i64 %4 to double
  %5 = load double* %p3, align 8
  %cmp = fcmp oeq double %conv3, %5
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %6 = load %struct.lua_State** %L.addr, align 8
  %call5 = call i32 @luaL_argerror(%struct.lua_State* %6, i32 3, i8* getelementptr inbounds ([31 x i8]* @.str27333, i32 0, i32 0))
  %tobool = icmp ne i32 %call5, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %7 = phi i1 [ true, %entry ], [ %tobool, %lor.rhs ]
  %lor.ext = zext i1 %7 to i32
  %8 = load %struct._IO_FILE** %f, align 8
  %9 = load i64* %offset, align 8
  %10 = load i32* %op, align 4
  %idxprom = sext i32 %10 to i64
  %arrayidx = getelementptr inbounds [3 x i32]* @f_seek.mode, i32 0, i64 %idxprom
  %11 = load i32* %arrayidx, align 4
  %call6 = call i32 @fseeko64(%struct._IO_FILE* %8, i64 %9, i32 %11)
  store i32 %call6, i32* %op, align 4
  %12 = load i32* %op, align 4
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then, label %if.else

if.then:                                          ; preds = %lor.end
  %13 = load %struct.lua_State** %L.addr, align 8
  %call8 = call i32 @luaL_fileresult(%struct.lua_State* %13, i32 0, i8* null)
  store i32 %call8, i32* %retval
  br label %return

if.else:                                          ; preds = %lor.end
  %14 = load %struct.lua_State** %L.addr, align 8
  %15 = load %struct._IO_FILE** %f, align 8
  %call9 = call i64 @ftello64(%struct._IO_FILE* %15)
  %conv10 = sitofp i64 %call9 to double
  call void @lua_pushnumber(%struct.lua_State* %14, double %conv10)
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %16 = load i32* %retval
  ret i32 %16
}

; Function Attrs: nounwind uwtable
define internal i32 @f_setvbuf(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %f = alloca %struct._IO_FILE*, align 8
  %op = alloca i32, align 4
  %sz = alloca i64, align 8
  %res = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call %struct._IO_FILE* @tofile(%struct.lua_State* %0)
  store %struct._IO_FILE* %call, %struct._IO_FILE** %f, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i32 @luaL_checkoption(%struct.lua_State* %1, i32 2, i8* null, i8** getelementptr inbounds ([4 x i8*]* @f_setvbuf.modenames, i32 0, i32 0))
  store i32 %call1, i32* %op, align 4
  %2 = load %struct.lua_State** %L.addr, align 8
  %call2 = call i64 @luaL_optinteger(%struct.lua_State* %2, i32 3, i64 8192)
  store i64 %call2, i64* %sz, align 8
  %3 = load %struct._IO_FILE** %f, align 8
  %4 = load i32* %op, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds [3 x i32]* @f_setvbuf.mode, i32 0, i64 %idxprom
  %5 = load i32* %arrayidx, align 4
  %6 = load i64* %sz, align 8
  %call3 = call i32 @setvbuf(%struct._IO_FILE* %3, i8* null, i32 %5, i64 %6) #1
  store i32 %call3, i32* %res, align 4
  %7 = load %struct.lua_State** %L.addr, align 8
  %8 = load i32* %res, align 4
  %cmp = icmp eq i32 %8, 0
  %conv = zext i1 %cmp to i32
  %call4 = call i32 @luaL_fileresult(%struct.lua_State* %7, i32 %conv, i8* null)
  ret i32 %call4
}

; Function Attrs: nounwind uwtable
define internal i32 @f_write(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %f = alloca %struct._IO_FILE*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call %struct._IO_FILE* @tofile(%struct.lua_State* %0)
  store %struct._IO_FILE* %call, %struct._IO_FILE** %f, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushvalue(%struct.lua_State* %1, i32 1)
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load %struct._IO_FILE** %f, align 8
  %call1 = call i32 @g_write(%struct.lua_State* %2, %struct._IO_FILE* %3, i32 2)
  ret i32 %call1
}

; Function Attrs: nounwind uwtable
define internal i32 @f_gc(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %p = alloca %struct.luaL_Stream*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @luaL_checkudata(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([6 x i8]* @.str5311, i32 0, i32 0))
  %1 = bitcast i8* %call to %struct.luaL_Stream*
  store %struct.luaL_Stream* %1, %struct.luaL_Stream** %p, align 8
  %2 = load %struct.luaL_Stream** %p, align 8
  %closef = getelementptr inbounds %struct.luaL_Stream* %2, i32 0, i32 1
  %3 = load i32 (%struct.lua_State*)** %closef, align 8
  %cmp = icmp eq i32 (%struct.lua_State*)* %3, null
  br i1 %cmp, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %4 = load %struct.luaL_Stream** %p, align 8
  %f = getelementptr inbounds %struct.luaL_Stream* %4, i32 0, i32 0
  %5 = load %struct._IO_FILE** %f, align 8
  %cmp1 = icmp ne %struct._IO_FILE* %5, null
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %6 = load %struct.lua_State** %L.addr, align 8
  %call2 = call i32 @aux_close(%struct.lua_State* %6)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @f_tostring(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %p = alloca %struct.luaL_Stream*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @luaL_checkudata(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([6 x i8]* @.str5311, i32 0, i32 0))
  %1 = bitcast i8* %call to %struct.luaL_Stream*
  store %struct.luaL_Stream* %1, %struct.luaL_Stream** %p, align 8
  %2 = load %struct.luaL_Stream** %p, align 8
  %closef = getelementptr inbounds %struct.luaL_Stream* %2, i32 0, i32 1
  %3 = load i32 (%struct.lua_State*)** %closef, align 8
  %cmp = icmp eq i32 (%struct.lua_State*)* %3, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %4 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i8* @lua_pushlstring(%struct.lua_State* %4, i8* getelementptr inbounds ([14 x i8]* @.str17323, i32 0, i32 0), i64 13)
  br label %if.end

if.else:                                          ; preds = %entry
  %5 = load %struct.lua_State** %L.addr, align 8
  %6 = load %struct.luaL_Stream** %p, align 8
  %f = getelementptr inbounds %struct.luaL_Stream* %6, i32 0, i32 0
  %7 = load %struct._IO_FILE** %f, align 8
  %call2 = call i8* (%struct.lua_State*, i8*, ...)* @lua_pushfstring(%struct.lua_State* %5, i8* getelementptr inbounds ([10 x i8]* @.str18324, i32 0, i32 0), %struct._IO_FILE* %7)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal void @createmeta(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @luaL_newmetatable(%struct.lua_State* %0, i8* getelementptr inbounds ([6 x i8]* @.str5311, i32 0, i32 0))
  %1 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushvalue(%struct.lua_State* %1, i32 -1)
  %2 = load %struct.lua_State** %L.addr, align 8
  call void @lua_setfield(%struct.lua_State* %2, i32 -2, i8* getelementptr inbounds ([8 x i8]* @.str7313, i32 0, i32 0))
  %3 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_setfuncs(%struct.lua_State* %3, %struct.luaL_Reg* getelementptr inbounds ([10 x %struct.luaL_Reg]* @flib, i32 0, i32 0), i32 0)
  %4 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %4, i32 -2)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @createstdfile(%struct.lua_State* %L, %struct._IO_FILE* %f, i8* %k, i8* %fname) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %f.addr = alloca %struct._IO_FILE*, align 8
  %k.addr = alloca i8*, align 8
  %fname.addr = alloca i8*, align 8
  %p = alloca %struct.luaL_Stream*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct._IO_FILE* %f, %struct._IO_FILE** %f.addr, align 8
  store i8* %k, i8** %k.addr, align 8
  store i8* %fname, i8** %fname.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call %struct.luaL_Stream* @newprefile(%struct.lua_State* %0)
  store %struct.luaL_Stream* %call, %struct.luaL_Stream** %p, align 8
  %1 = load %struct._IO_FILE** %f.addr, align 8
  %2 = load %struct.luaL_Stream** %p, align 8
  %f1 = getelementptr inbounds %struct.luaL_Stream* %2, i32 0, i32 0
  store %struct._IO_FILE* %1, %struct._IO_FILE** %f1, align 8
  %3 = load %struct.luaL_Stream** %p, align 8
  %closef = getelementptr inbounds %struct.luaL_Stream* %3, i32 0, i32 1
  store i32 (%struct.lua_State*)* @io_noclose, i32 (%struct.lua_State*)** %closef, align 8
  %4 = load i8** %k.addr, align 8
  %cmp = icmp ne i8* %4, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushvalue(%struct.lua_State* %5, i32 -1)
  %6 = load %struct.lua_State** %L.addr, align 8
  %7 = load i8** %k.addr, align 8
  call void @lua_setfield(%struct.lua_State* %6, i32 -1001000, i8* %7)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %8 = load %struct.lua_State** %L.addr, align 8
  %9 = load i8** %fname.addr, align 8
  call void @lua_setfield(%struct.lua_State* %8, i32 -2, i8* %9)
  ret void
}

; Function Attrs: nounwind uwtable
define internal %struct._IO_FILE* @tofile(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %p = alloca %struct.luaL_Stream*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @luaL_checkudata(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([6 x i8]* @.str5311, i32 0, i32 0))
  %1 = bitcast i8* %call to %struct.luaL_Stream*
  store %struct.luaL_Stream* %1, %struct.luaL_Stream** %p, align 8
  %2 = load %struct.luaL_Stream** %p, align 8
  %closef = getelementptr inbounds %struct.luaL_Stream* %2, i32 0, i32 1
  %3 = load i32 (%struct.lua_State*)** %closef, align 8
  %cmp = icmp eq i32 (%struct.lua_State*)* %3, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %4, i8* getelementptr inbounds ([29 x i8]* @.str20326, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load %struct.luaL_Stream** %p, align 8
  %f = getelementptr inbounds %struct.luaL_Stream* %5, i32 0, i32 0
  %6 = load %struct._IO_FILE** %f, align 8
  ret %struct._IO_FILE* %6
}

; Function Attrs: nounwind uwtable
define internal i32 @aux_close(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %p = alloca %struct.luaL_Stream*, align 8
  %cf = alloca i32 (%struct.lua_State*)*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @luaL_checkudata(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([6 x i8]* @.str5311, i32 0, i32 0))
  %1 = bitcast i8* %call to %struct.luaL_Stream*
  store %struct.luaL_Stream* %1, %struct.luaL_Stream** %p, align 8
  %2 = load %struct.luaL_Stream** %p, align 8
  %closef = getelementptr inbounds %struct.luaL_Stream* %2, i32 0, i32 1
  %3 = load i32 (%struct.lua_State*)** %closef, align 8
  store i32 (%struct.lua_State*)* %3, i32 (%struct.lua_State*)** %cf, align 8
  %4 = load %struct.luaL_Stream** %p, align 8
  %closef1 = getelementptr inbounds %struct.luaL_Stream* %4, i32 0, i32 1
  store i32 (%struct.lua_State*)* null, i32 (%struct.lua_State*)** %closef1, align 8
  %5 = load i32 (%struct.lua_State*)** %cf, align 8
  %6 = load %struct.lua_State** %L.addr, align 8
  %call2 = call i32 %5(%struct.lua_State* %6)
  ret i32 %call2
}

; Function Attrs: nounwind uwtable
define internal %struct._IO_FILE* @getiofile(%struct.lua_State* %L, i8* %findex) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %findex.addr = alloca i8*, align 8
  %p = alloca %struct.luaL_Stream*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %findex, i8** %findex.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i8** %findex.addr, align 8
  call void @lua_getfield(%struct.lua_State* %0, i32 -1001000, i8* %1)
  %2 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @lua_touserdata(%struct.lua_State* %2, i32 -1)
  %3 = bitcast i8* %call to %struct.luaL_Stream*
  store %struct.luaL_Stream* %3, %struct.luaL_Stream** %p, align 8
  %4 = load %struct.luaL_Stream** %p, align 8
  %closef = getelementptr inbounds %struct.luaL_Stream* %4, i32 0, i32 1
  %5 = load i32 (%struct.lua_State*)** %closef, align 8
  %cmp = icmp eq i32 (%struct.lua_State*)* %5, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load %struct.lua_State** %L.addr, align 8
  %7 = load i8** %findex.addr, align 8
  %add.ptr = getelementptr inbounds i8* %7, i64 4
  %call1 = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %6, i8* getelementptr inbounds ([27 x i8]* @.str41347, i32 0, i32 0), i8* %add.ptr)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %8 = load %struct.luaL_Stream** %p, align 8
  %f = getelementptr inbounds %struct.luaL_Stream* %8, i32 0, i32 0
  %9 = load %struct._IO_FILE** %f, align 8
  ret %struct._IO_FILE* %9
}

; Function Attrs: nounwind uwtable
define internal i32 @g_iofile(%struct.lua_State* %L, i8* %f, i8* %mode) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %f.addr = alloca i8*, align 8
  %mode.addr = alloca i8*, align 8
  %filename = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %f, i8** %f.addr, align 8
  store i8* %mode, i8** %mode.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_type(%struct.lua_State* %0, i32 1)
  %cmp = icmp sle i32 %call, 0
  br i1 %cmp, label %if.end4, label %if.then

if.then:                                          ; preds = %entry
  %1 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i8* @lua_tolstring(%struct.lua_State* %1, i32 1, i64* null)
  store i8* %call1, i8** %filename, align 8
  %2 = load i8** %filename, align 8
  %tobool = icmp ne i8* %2, null
  br i1 %tobool, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load i8** %filename, align 8
  %5 = load i8** %mode.addr, align 8
  call void @opencheck(%struct.lua_State* %3, i8* %4, i8* %5)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load %struct.lua_State** %L.addr, align 8
  %call3 = call %struct._IO_FILE* @tofile(%struct.lua_State* %6)
  %7 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushvalue(%struct.lua_State* %7, i32 1)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then2
  %8 = load %struct.lua_State** %L.addr, align 8
  %9 = load i8** %f.addr, align 8
  call void @lua_setfield(%struct.lua_State* %8, i32 -1001000, i8* %9)
  br label %if.end4

if.end4:                                          ; preds = %if.end, %entry
  %10 = load %struct.lua_State** %L.addr, align 8
  %11 = load i8** %f.addr, align 8
  call void @lua_getfield(%struct.lua_State* %10, i32 -1001000, i8* %11)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal void @opencheck(%struct.lua_State* %L, i8* %fname, i8* %mode) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %fname.addr = alloca i8*, align 8
  %mode.addr = alloca i8*, align 8
  %p = alloca %struct.luaL_Stream*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %fname, i8** %fname.addr, align 8
  store i8* %mode, i8** %mode.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call %struct.luaL_Stream* @newfile(%struct.lua_State* %0)
  store %struct.luaL_Stream* %call, %struct.luaL_Stream** %p, align 8
  %1 = load i8** %fname.addr, align 8
  %2 = load i8** %mode.addr, align 8
  %call1 = call %struct._IO_FILE* @fopen64(i8* %1, i8* %2)
  %3 = load %struct.luaL_Stream** %p, align 8
  %f = getelementptr inbounds %struct.luaL_Stream* %3, i32 0, i32 0
  store %struct._IO_FILE* %call1, %struct._IO_FILE** %f, align 8
  %4 = load %struct.luaL_Stream** %p, align 8
  %f2 = getelementptr inbounds %struct.luaL_Stream* %4, i32 0, i32 0
  %5 = load %struct._IO_FILE** %f2, align 8
  %cmp = icmp eq %struct._IO_FILE* %5, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load %struct.lua_State** %L.addr, align 8
  %7 = load i8** %fname.addr, align 8
  %call3 = call i32* @__errno_location() #11
  %8 = load i32* %call3, align 4
  %call4 = call i8* @strerror(i32 %8) #1
  %call5 = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %6, i8* getelementptr inbounds ([27 x i8]* @.str46352, i32 0, i32 0), i8* %7, i8* %call4)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @aux_lines(%struct.lua_State* %L, i32 %toclose) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %toclose.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %n = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %toclose, i32* %toclose.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_gettop(%struct.lua_State* %0)
  %sub = sub nsw i32 %call, 1
  store i32 %sub, i32* %n, align 4
  %1 = load i32* %n, align 4
  %cmp = icmp sle i32 %1, 17
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %2 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i32 @luaL_argerror(%struct.lua_State* %2, i32 17, i8* getelementptr inbounds ([17 x i8]* @.str32338, i32 0, i32 0))
  %tobool = icmp ne i32 %call1, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %3 = phi i1 [ true, %entry ], [ %tobool, %lor.rhs ]
  %lor.ext = zext i1 %3 to i32
  %4 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushvalue(%struct.lua_State* %4, i32 1)
  %5 = load %struct.lua_State** %L.addr, align 8
  %6 = load i32* %n, align 4
  %conv = sext i32 %6 to i64
  call void @lua_pushinteger(%struct.lua_State* %5, i64 %conv)
  %7 = load %struct.lua_State** %L.addr, align 8
  %8 = load i32* %toclose.addr, align 4
  call void @lua_pushboolean(%struct.lua_State* %7, i32 %8)
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %lor.end
  %9 = load i32* %i, align 4
  %10 = load i32* %n, align 4
  %cmp2 = icmp sle i32 %9, %10
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load %struct.lua_State** %L.addr, align 8
  %12 = load i32* %i, align 4
  %add = add nsw i32 %12, 1
  call void @lua_pushvalue(%struct.lua_State* %11, i32 %add)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %13 = load i32* %i, align 4
  %inc = add nsw i32 %13, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %14 = load %struct.lua_State** %L.addr, align 8
  %15 = load i32* %n, align 4
  %add4 = add nsw i32 3, %15
  call void @lua_pushcclosure(%struct.lua_State* %14, i32 (%struct.lua_State*)* @io_readline, i32 %add4)
  ret void
}

; Function Attrs: nounwind uwtable
define internal %struct.luaL_Stream* @newfile(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %p = alloca %struct.luaL_Stream*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call %struct.luaL_Stream* @newprefile(%struct.lua_State* %0)
  store %struct.luaL_Stream* %call, %struct.luaL_Stream** %p, align 8
  %1 = load %struct.luaL_Stream** %p, align 8
  %f = getelementptr inbounds %struct.luaL_Stream* %1, i32 0, i32 0
  store %struct._IO_FILE* null, %struct._IO_FILE** %f, align 8
  %2 = load %struct.luaL_Stream** %p, align 8
  %closef = getelementptr inbounds %struct.luaL_Stream* %2, i32 0, i32 1
  store i32 (%struct.lua_State*)* @io_fclose, i32 (%struct.lua_State*)** %closef, align 8
  %3 = load %struct.luaL_Stream** %p, align 8
  ret %struct.luaL_Stream* %3
}

; Function Attrs: nounwind uwtable
define internal %struct.luaL_Stream* @newprefile(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %p = alloca %struct.luaL_Stream*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @lua_newuserdata(%struct.lua_State* %0, i64 16)
  %1 = bitcast i8* %call to %struct.luaL_Stream*
  store %struct.luaL_Stream* %1, %struct.luaL_Stream** %p, align 8
  %2 = load %struct.luaL_Stream** %p, align 8
  %closef = getelementptr inbounds %struct.luaL_Stream* %2, i32 0, i32 1
  store i32 (%struct.lua_State*)* null, i32 (%struct.lua_State*)** %closef, align 8
  %3 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_setmetatable(%struct.lua_State* %3, i8* getelementptr inbounds ([6 x i8]* @.str5311, i32 0, i32 0))
  %4 = load %struct.luaL_Stream** %p, align 8
  ret %struct.luaL_Stream* %4
}

; Function Attrs: nounwind uwtable
define internal i32 @io_pclose(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %p = alloca %struct.luaL_Stream*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @luaL_checkudata(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([6 x i8]* @.str5311, i32 0, i32 0))
  %1 = bitcast i8* %call to %struct.luaL_Stream*
  store %struct.luaL_Stream* %1, %struct.luaL_Stream** %p, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load %struct.luaL_Stream** %p, align 8
  %f = getelementptr inbounds %struct.luaL_Stream* %4, i32 0, i32 0
  %5 = load %struct._IO_FILE** %f, align 8
  %call1 = call i32 @pclose(%struct._IO_FILE* %5)
  %call2 = call i32 @luaL_execresult(%struct.lua_State* %2, i32 %call1)
  ret i32 %call2
}

; Function Attrs: nounwind uwtable
define internal i32 @g_read(%struct.lua_State* %L, %struct._IO_FILE* %f, i32 %first) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %f.addr = alloca %struct._IO_FILE*, align 8
  %first.addr = alloca i32, align 4
  %nargs = alloca i32, align 4
  %success = alloca i32, align 4
  %n = alloca i32, align 4
  %l = alloca i64, align 8
  %p = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct._IO_FILE* %f, %struct._IO_FILE** %f.addr, align 8
  store i32 %first, i32* %first.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_gettop(%struct.lua_State* %0)
  %sub = sub nsw i32 %call, 1
  store i32 %sub, i32* %nargs, align 4
  %1 = load %struct._IO_FILE** %f.addr, align 8
  call void @clearerr(%struct._IO_FILE* %1) #1
  %2 = load i32* %nargs, align 4
  %cmp = icmp eq i32 %2, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load %struct._IO_FILE** %f.addr, align 8
  %call1 = call i32 @read_line(%struct.lua_State* %3, %struct._IO_FILE* %4, i32 1)
  store i32 %call1, i32* %success, align 4
  %5 = load i32* %first.addr, align 4
  %add = add nsw i32 %5, 1
  store i32 %add, i32* %n, align 4
  br label %if.end27

if.else:                                          ; preds = %entry
  %6 = load %struct.lua_State** %L.addr, align 8
  %7 = load i32* %nargs, align 4
  %add2 = add nsw i32 %7, 20
  call void @luaL_checkstack(%struct.lua_State* %6, i32 %add2, i8* getelementptr inbounds ([19 x i8]* @.str28334, i32 0, i32 0))
  store i32 1, i32* %success, align 4
  %8 = load i32* %first.addr, align 4
  store i32 %8, i32* %n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.else
  %9 = load i32* %nargs, align 4
  %dec = add nsw i32 %9, -1
  store i32 %dec, i32* %nargs, align 4
  %tobool = icmp ne i32 %9, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %10 = load i32* %success, align 4
  %tobool3 = icmp ne i32 %10, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %11 = phi i1 [ false, %for.cond ], [ %tobool3, %land.rhs ]
  br i1 %11, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %12 = load %struct.lua_State** %L.addr, align 8
  %13 = load i32* %n, align 4
  %call4 = call i32 @lua_type(%struct.lua_State* %12, i32 %13)
  %cmp5 = icmp eq i32 %call4, 3
  br i1 %cmp5, label %if.then6, label %if.else11

if.then6:                                         ; preds = %for.body
  %14 = load %struct.lua_State** %L.addr, align 8
  %15 = load i32* %n, align 4
  %call7 = call i64 @lua_tointegerx(%struct.lua_State* %14, i32 %15, i32* null)
  store i64 %call7, i64* %l, align 8
  %16 = load i64* %l, align 8
  %cmp8 = icmp eq i64 %16, 0
  br i1 %cmp8, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then6
  %17 = load %struct.lua_State** %L.addr, align 8
  %18 = load %struct._IO_FILE** %f.addr, align 8
  %call9 = call i32 @test_eof(%struct.lua_State* %17, %struct._IO_FILE* %18)
  br label %cond.end

cond.false:                                       ; preds = %if.then6
  %19 = load %struct.lua_State** %L.addr, align 8
  %20 = load %struct._IO_FILE** %f.addr, align 8
  %21 = load i64* %l, align 8
  %call10 = call i32 @read_chars(%struct.lua_State* %19, %struct._IO_FILE* %20, i64 %21)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %call9, %cond.true ], [ %call10, %cond.false ]
  store i32 %cond, i32* %success, align 4
  br label %if.end

if.else11:                                        ; preds = %for.body
  %22 = load %struct.lua_State** %L.addr, align 8
  %23 = load i32* %n, align 4
  %call12 = call i8* @lua_tolstring(%struct.lua_State* %22, i32 %23, i64* null)
  store i8* %call12, i8** %p, align 8
  %24 = load i8** %p, align 8
  %tobool13 = icmp ne i8* %24, null
  br i1 %tobool13, label %land.lhs.true, label %lor.rhs

land.lhs.true:                                    ; preds = %if.else11
  %25 = load i8** %p, align 8
  %arrayidx = getelementptr inbounds i8* %25, i64 0
  %26 = load i8* %arrayidx, align 1
  %conv = sext i8 %26 to i32
  %cmp14 = icmp eq i32 %conv, 42
  br i1 %cmp14, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.lhs.true, %if.else11
  %27 = load %struct.lua_State** %L.addr, align 8
  %28 = load i32* %n, align 4
  %call16 = call i32 @luaL_argerror(%struct.lua_State* %27, i32 %28, i8* getelementptr inbounds ([15 x i8]* @.str29335, i32 0, i32 0))
  %tobool17 = icmp ne i32 %call16, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.lhs.true
  %29 = phi i1 [ true, %land.lhs.true ], [ %tobool17, %lor.rhs ]
  %lor.ext = zext i1 %29 to i32
  %30 = load i8** %p, align 8
  %arrayidx18 = getelementptr inbounds i8* %30, i64 1
  %31 = load i8* %arrayidx18, align 1
  %conv19 = sext i8 %31 to i32
  switch i32 %conv19, label %sw.default [
    i32 110, label %sw.bb
    i32 108, label %sw.bb21
    i32 76, label %sw.bb23
    i32 97, label %sw.bb25
  ]

sw.bb:                                            ; preds = %lor.end
  %32 = load %struct.lua_State** %L.addr, align 8
  %33 = load %struct._IO_FILE** %f.addr, align 8
  %call20 = call i32 @read_number(%struct.lua_State* %32, %struct._IO_FILE* %33)
  store i32 %call20, i32* %success, align 4
  br label %sw.epilog

sw.bb21:                                          ; preds = %lor.end
  %34 = load %struct.lua_State** %L.addr, align 8
  %35 = load %struct._IO_FILE** %f.addr, align 8
  %call22 = call i32 @read_line(%struct.lua_State* %34, %struct._IO_FILE* %35, i32 1)
  store i32 %call22, i32* %success, align 4
  br label %sw.epilog

sw.bb23:                                          ; preds = %lor.end
  %36 = load %struct.lua_State** %L.addr, align 8
  %37 = load %struct._IO_FILE** %f.addr, align 8
  %call24 = call i32 @read_line(%struct.lua_State* %36, %struct._IO_FILE* %37, i32 0)
  store i32 %call24, i32* %success, align 4
  br label %sw.epilog

sw.bb25:                                          ; preds = %lor.end
  %38 = load %struct.lua_State** %L.addr, align 8
  %39 = load %struct._IO_FILE** %f.addr, align 8
  call void @read_all(%struct.lua_State* %38, %struct._IO_FILE* %39)
  store i32 1, i32* %success, align 4
  br label %sw.epilog

sw.default:                                       ; preds = %lor.end
  %40 = load %struct.lua_State** %L.addr, align 8
  %41 = load i32* %n, align 4
  %call26 = call i32 @luaL_argerror(%struct.lua_State* %40, i32 %41, i8* getelementptr inbounds ([15 x i8]* @.str30336, i32 0, i32 0))
  store i32 %call26, i32* %retval
  br label %return

sw.epilog:                                        ; preds = %sw.bb25, %sw.bb23, %sw.bb21, %sw.bb
  br label %if.end

if.end:                                           ; preds = %sw.epilog, %cond.end
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %42 = load i32* %n, align 4
  %inc = add nsw i32 %42, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond

for.end:                                          ; preds = %land.end
  br label %if.end27

if.end27:                                         ; preds = %for.end, %if.then
  %43 = load %struct._IO_FILE** %f.addr, align 8
  %call28 = call i32 @ferror(%struct._IO_FILE* %43) #1
  %tobool29 = icmp ne i32 %call28, 0
  br i1 %tobool29, label %if.then30, label %if.end32

if.then30:                                        ; preds = %if.end27
  %44 = load %struct.lua_State** %L.addr, align 8
  %call31 = call i32 @luaL_fileresult(%struct.lua_State* %44, i32 0, i8* null)
  store i32 %call31, i32* %retval
  br label %return

if.end32:                                         ; preds = %if.end27
  %45 = load i32* %success, align 4
  %tobool33 = icmp ne i32 %45, 0
  br i1 %tobool33, label %if.end35, label %if.then34

if.then34:                                        ; preds = %if.end32
  %46 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %46, i32 -2)
  %47 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushnil(%struct.lua_State* %47)
  br label %if.end35

if.end35:                                         ; preds = %if.then34, %if.end32
  %48 = load i32* %n, align 4
  %49 = load i32* %first.addr, align 4
  %sub36 = sub nsw i32 %48, %49
  store i32 %sub36, i32* %retval
  br label %return

return:                                           ; preds = %if.end35, %if.then30, %sw.default
  %50 = load i32* %retval
  ret i32 %50
}

; Function Attrs: nounwind uwtable
define internal i32 @g_write(%struct.lua_State* %L, %struct._IO_FILE* %f, i32 %arg) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %f.addr = alloca %struct._IO_FILE*, align 8
  %arg.addr = alloca i32, align 4
  %nargs = alloca i32, align 4
  %status = alloca i32, align 4
  %l = alloca i64, align 8
  %s = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct._IO_FILE* %f, %struct._IO_FILE** %f.addr, align 8
  store i32 %arg, i32* %arg.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_gettop(%struct.lua_State* %0)
  %1 = load i32* %arg.addr, align 4
  %sub = sub nsw i32 %call, %1
  store i32 %sub, i32* %nargs, align 4
  store i32 1, i32* %status, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32* %nargs, align 4
  %dec = add nsw i32 %2, -1
  store i32 %dec, i32* %nargs, align 4
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load i32* %arg.addr, align 4
  %call1 = call i32 @lua_type(%struct.lua_State* %3, i32 %4)
  %cmp = icmp eq i32 %call1, 3
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %5 = load i32* %status, align 4
  %tobool2 = icmp ne i32 %5, 0
  br i1 %tobool2, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then
  %6 = load %struct._IO_FILE** %f.addr, align 8
  %7 = load %struct.lua_State** %L.addr, align 8
  %8 = load i32* %arg.addr, align 4
  %call3 = call double @lua_tonumberx(%struct.lua_State* %7, i32 %8, i32* null)
  %call4 = call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %6, i8* getelementptr inbounds ([6 x i8]* @.str19325, i32 0, i32 0), double %call3)
  %cmp5 = icmp sgt i32 %call4, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then
  %9 = phi i1 [ false, %if.then ], [ %cmp5, %land.rhs ]
  %land.ext = zext i1 %9 to i32
  store i32 %land.ext, i32* %status, align 4
  br label %if.end

if.else:                                          ; preds = %for.body
  %10 = load %struct.lua_State** %L.addr, align 8
  %11 = load i32* %arg.addr, align 4
  %call6 = call i8* @luaL_checklstring(%struct.lua_State* %10, i32 %11, i64* %l)
  store i8* %call6, i8** %s, align 8
  %12 = load i32* %status, align 4
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %land.rhs8, label %land.end11

land.rhs8:                                        ; preds = %if.else
  %13 = load i8** %s, align 8
  %14 = load i64* %l, align 8
  %15 = load %struct._IO_FILE** %f.addr, align 8
  %call9 = call i64 @fwrite(i8* %13, i64 1, i64 %14, %struct._IO_FILE* %15)
  %16 = load i64* %l, align 8
  %cmp10 = icmp eq i64 %call9, %16
  br label %land.end11

land.end11:                                       ; preds = %land.rhs8, %if.else
  %17 = phi i1 [ false, %if.else ], [ %cmp10, %land.rhs8 ]
  %land.ext12 = zext i1 %17 to i32
  store i32 %land.ext12, i32* %status, align 4
  br label %if.end

if.end:                                           ; preds = %land.end11, %land.end
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %18 = load i32* %arg.addr, align 4
  %inc = add nsw i32 %18, 1
  store i32 %inc, i32* %arg.addr, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load i32* %status, align 4
  %tobool13 = icmp ne i32 %19, 0
  br i1 %tobool13, label %if.then14, label %if.else15

if.then14:                                        ; preds = %for.end
  store i32 1, i32* %retval
  br label %return

if.else15:                                        ; preds = %for.end
  %20 = load %struct.lua_State** %L.addr, align 8
  %21 = load i32* %status, align 4
  %call16 = call i32 @luaL_fileresult(%struct.lua_State* %20, i32 %21, i8* null)
  store i32 %call16, i32* %retval
  br label %return

return:                                           ; preds = %if.else15, %if.then14
  %22 = load i32* %retval
  ret i32 %22
}

; Function Attrs: nounwind uwtable
define internal i32 @io_noclose(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %p = alloca %struct.luaL_Stream*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @luaL_checkudata(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([6 x i8]* @.str5311, i32 0, i32 0))
  %1 = bitcast i8* %call to %struct.luaL_Stream*
  store %struct.luaL_Stream* %1, %struct.luaL_Stream** %p, align 8
  %2 = load %struct.luaL_Stream** %p, align 8
  %closef = getelementptr inbounds %struct.luaL_Stream* %2, i32 0, i32 1
  store i32 (%struct.lua_State*)* @io_noclose, i32 (%struct.lua_State*)** %closef, align 8
  %3 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushnil(%struct.lua_State* %3)
  %4 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i8* @lua_pushlstring(%struct.lua_State* %4, i8* getelementptr inbounds ([27 x i8]* @.str6312, i32 0, i32 0), i64 26)
  ret i32 2
}

; Function Attrs: nounwind uwtable
define internal i32 @io_readline(%struct.lua_State* %L) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %p = alloca %struct.luaL_Stream*, align 8
  %i = alloca i32, align 4
  %n = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @lua_touserdata(%struct.lua_State* %0, i32 -1001001)
  %1 = bitcast i8* %call to %struct.luaL_Stream*
  store %struct.luaL_Stream* %1, %struct.luaL_Stream** %p, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i64 @lua_tointegerx(%struct.lua_State* %2, i32 -1001002, i32* null)
  %conv = trunc i64 %call1 to i32
  store i32 %conv, i32* %n, align 4
  %3 = load %struct.luaL_Stream** %p, align 8
  %closef = getelementptr inbounds %struct.luaL_Stream* %3, i32 0, i32 1
  %4 = load i32 (%struct.lua_State*)** %closef, align 8
  %cmp = icmp eq i32 (%struct.lua_State*)* %4, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load %struct.lua_State** %L.addr, align 8
  %call3 = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %5, i8* getelementptr inbounds ([23 x i8]* @.str33339, i32 0, i32 0))
  store i32 %call3, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %6 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %6, i32 1)
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %7 = load i32* %i, align 4
  %8 = load i32* %n, align 4
  %cmp4 = icmp sle i32 %7, %8
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load %struct.lua_State** %L.addr, align 8
  %10 = load i32* %i, align 4
  %add = add nsw i32 3, %10
  %sub = sub nsw i32 -1001000, %add
  call void @lua_pushvalue(%struct.lua_State* %9, i32 %sub)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %11 = load i32* %i, align 4
  %inc = add nsw i32 %11, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %12 = load %struct.lua_State** %L.addr, align 8
  %13 = load %struct.luaL_Stream** %p, align 8
  %f = getelementptr inbounds %struct.luaL_Stream* %13, i32 0, i32 0
  %14 = load %struct._IO_FILE** %f, align 8
  %call6 = call i32 @g_read(%struct.lua_State* %12, %struct._IO_FILE* %14, i32 2)
  store i32 %call6, i32* %n, align 4
  %15 = load %struct.lua_State** %L.addr, align 8
  %16 = load i32* %n, align 4
  %sub7 = sub nsw i32 0, %16
  %call8 = call i32 @lua_type(%struct.lua_State* %15, i32 %sub7)
  %cmp9 = icmp eq i32 %call8, 0
  br i1 %cmp9, label %if.else, label %if.then11

if.then11:                                        ; preds = %for.end
  %17 = load i32* %n, align 4
  store i32 %17, i32* %retval
  br label %return

if.else:                                          ; preds = %for.end
  %18 = load i32* %n, align 4
  %cmp12 = icmp sgt i32 %18, 1
  br i1 %cmp12, label %if.then14, label %if.end19

if.then14:                                        ; preds = %if.else
  %19 = load %struct.lua_State** %L.addr, align 8
  %20 = load %struct.lua_State** %L.addr, align 8
  %21 = load i32* %n, align 4
  %sub15 = sub nsw i32 0, %21
  %add16 = add nsw i32 %sub15, 1
  %call17 = call i8* @lua_tolstring(%struct.lua_State* %20, i32 %add16, i64* null)
  %call18 = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %19, i8* getelementptr inbounds ([3 x i8]* @.str34340, i32 0, i32 0), i8* %call17)
  store i32 %call18, i32* %retval
  br label %return

if.end19:                                         ; preds = %if.else
  %22 = load %struct.lua_State** %L.addr, align 8
  %call20 = call i32 @lua_toboolean(%struct.lua_State* %22, i32 -1001003)
  %tobool = icmp ne i32 %call20, 0
  br i1 %tobool, label %if.then21, label %if.end23

if.then21:                                        ; preds = %if.end19
  %23 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %23, i32 0)
  %24 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushvalue(%struct.lua_State* %24, i32 -1001001)
  %25 = load %struct.lua_State** %L.addr, align 8
  %call22 = call i32 @aux_close(%struct.lua_State* %25)
  br label %if.end23

if.end23:                                         ; preds = %if.then21, %if.end19
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.end23, %if.then14, %if.then11, %if.then
  %26 = load i32* %retval
  ret i32 %26
}

; Function Attrs: nounwind uwtable
define internal i32 @io_fclose(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %p = alloca %struct.luaL_Stream*, align 8
  %res = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @luaL_checkudata(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([6 x i8]* @.str5311, i32 0, i32 0))
  %1 = bitcast i8* %call to %struct.luaL_Stream*
  store %struct.luaL_Stream* %1, %struct.luaL_Stream** %p, align 8
  %2 = load %struct.luaL_Stream** %p, align 8
  %f = getelementptr inbounds %struct.luaL_Stream* %2, i32 0, i32 0
  %3 = load %struct._IO_FILE** %f, align 8
  %call1 = call i32 @fclose(%struct._IO_FILE* %3)
  store i32 %call1, i32* %res, align 4
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load i32* %res, align 4
  %cmp = icmp eq i32 %5, 0
  %conv = zext i1 %cmp to i32
  %call2 = call i32 @luaL_fileresult(%struct.lua_State* %4, i32 %conv, i8* null)
  ret i32 %call2
}

; Function Attrs: nounwind uwtable
define internal i32 @read_line(%struct.lua_State* %L, %struct._IO_FILE* %f, i32 %chop) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %f.addr = alloca %struct._IO_FILE*, align 8
  %chop.addr = alloca i32, align 4
  %b = alloca %struct.luaL_Buffer, align 8
  %l = alloca i64, align 8
  %p = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct._IO_FILE* %f, %struct._IO_FILE** %f.addr, align 8
  store i32 %chop, i32* %chop.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_buffinit(%struct.lua_State* %0, %struct.luaL_Buffer* %b)
  br label %for.cond

for.cond:                                         ; preds = %if.end15, %entry
  %call = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* %b, i64 8192)
  store i8* %call, i8** %p, align 8
  %1 = load i8** %p, align 8
  %2 = load %struct._IO_FILE** %f.addr, align 8
  %call1 = call i8* @fgets(i8* %1, i32 8192, %struct._IO_FILE* %2)
  %cmp = icmp eq i8* %call1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %for.cond
  call void @luaL_pushresult(%struct.luaL_Buffer* %b)
  %3 = load %struct.lua_State** %L.addr, align 8
  %call2 = call i64 @lua_rawlen(%struct.lua_State* %3, i32 -1)
  %cmp3 = icmp ugt i64 %call2, 0
  %conv = zext i1 %cmp3 to i32
  store i32 %conv, i32* %retval
  br label %return

if.end:                                           ; preds = %for.cond
  %4 = load i8** %p, align 8
  %call4 = call i64 @strlen(i8* %4) #10
  store i64 %call4, i64* %l, align 8
  %5 = load i64* %l, align 8
  %cmp5 = icmp eq i64 %5, 0
  br i1 %cmp5, label %if.then10, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %6 = load i64* %l, align 8
  %sub = sub i64 %6, 1
  %7 = load i8** %p, align 8
  %arrayidx = getelementptr inbounds i8* %7, i64 %sub
  %8 = load i8* %arrayidx, align 1
  %conv7 = sext i8 %8 to i32
  %cmp8 = icmp ne i32 %conv7, 10
  br i1 %cmp8, label %if.then10, label %if.else

if.then10:                                        ; preds = %lor.lhs.false, %if.end
  %9 = load i64* %l, align 8
  %n = getelementptr inbounds %struct.luaL_Buffer* %b, i32 0, i32 2
  %10 = load i64* %n, align 8
  %add = add i64 %10, %9
  store i64 %add, i64* %n, align 8
  br label %if.end15

if.else:                                          ; preds = %lor.lhs.false
  %11 = load i64* %l, align 8
  %12 = load i32* %chop.addr, align 4
  %conv11 = sext i32 %12 to i64
  %sub12 = sub i64 %11, %conv11
  %n13 = getelementptr inbounds %struct.luaL_Buffer* %b, i32 0, i32 2
  %13 = load i64* %n13, align 8
  %add14 = add i64 %13, %sub12
  store i64 %add14, i64* %n13, align 8
  call void @luaL_pushresult(%struct.luaL_Buffer* %b)
  store i32 1, i32* %retval
  br label %return

if.end15:                                         ; preds = %if.then10
  br label %for.cond

return:                                           ; preds = %if.else, %if.then
  %14 = load i32* %retval
  ret i32 %14
}

; Function Attrs: nounwind uwtable
define internal i32 @test_eof(%struct.lua_State* %L, %struct._IO_FILE* %f) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %f.addr = alloca %struct._IO_FILE*, align 8
  %c = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct._IO_FILE* %f, %struct._IO_FILE** %f.addr, align 8
  %0 = load %struct._IO_FILE** %f.addr, align 8
  %call = call i32 @_IO_getc(%struct._IO_FILE* %0)
  store i32 %call, i32* %c, align 4
  %1 = load i32* %c, align 4
  %2 = load %struct._IO_FILE** %f.addr, align 8
  %call1 = call i32 @ungetc(i32 %1, %struct._IO_FILE* %2)
  %3 = load %struct.lua_State** %L.addr, align 8
  %call2 = call i8* @lua_pushlstring(%struct.lua_State* %3, i8* null, i64 0)
  %4 = load i32* %c, align 4
  %cmp = icmp ne i32 %4, -1
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define internal i32 @read_chars(%struct.lua_State* %L, %struct._IO_FILE* %f, i64 %n) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %f.addr = alloca %struct._IO_FILE*, align 8
  %n.addr = alloca i64, align 8
  %nr = alloca i64, align 8
  %p = alloca i8*, align 8
  %b = alloca %struct.luaL_Buffer, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct._IO_FILE* %f, %struct._IO_FILE** %f.addr, align 8
  store i64 %n, i64* %n.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_buffinit(%struct.lua_State* %0, %struct.luaL_Buffer* %b)
  %1 = load i64* %n.addr, align 8
  %call = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* %b, i64 %1)
  store i8* %call, i8** %p, align 8
  %2 = load i8** %p, align 8
  %3 = load i64* %n.addr, align 8
  %4 = load %struct._IO_FILE** %f.addr, align 8
  %call1 = call i64 @fread(i8* %2, i64 1, i64 %3, %struct._IO_FILE* %4)
  store i64 %call1, i64* %nr, align 8
  %5 = load i64* %nr, align 8
  %n2 = getelementptr inbounds %struct.luaL_Buffer* %b, i32 0, i32 2
  %6 = load i64* %n2, align 8
  %add = add i64 %6, %5
  store i64 %add, i64* %n2, align 8
  call void @luaL_pushresult(%struct.luaL_Buffer* %b)
  %7 = load i64* %nr, align 8
  %cmp = icmp ugt i64 %7, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define internal i32 @read_number(%struct.lua_State* %L, %struct._IO_FILE* %f) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %f.addr = alloca %struct._IO_FILE*, align 8
  %d = alloca double, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct._IO_FILE* %f, %struct._IO_FILE** %f.addr, align 8
  %0 = load %struct._IO_FILE** %f.addr, align 8
  %call = call i32 (%struct._IO_FILE*, i8*, ...)* @__isoc99_fscanf(%struct._IO_FILE* %0, i8* getelementptr inbounds ([4 x i8]* @.str31337, i32 0, i32 0), double* %d)
  %cmp = icmp eq i32 %call, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load double* %d, align 8
  call void @lua_pushnumber(%struct.lua_State* %1, double %2)
  store i32 1, i32* %retval
  br label %return

if.else:                                          ; preds = %entry
  %3 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushnil(%struct.lua_State* %3)
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %4 = load i32* %retval
  ret i32 %4
}

; Function Attrs: nounwind uwtable
define internal void @read_all(%struct.lua_State* %L, %struct._IO_FILE* %f) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %f.addr = alloca %struct._IO_FILE*, align 8
  %rlen = alloca i64, align 8
  %b = alloca %struct.luaL_Buffer, align 8
  %p = alloca i8*, align 8
  %nr = alloca i64, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct._IO_FILE* %f, %struct._IO_FILE** %f.addr, align 8
  store i64 8192, i64* %rlen, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_buffinit(%struct.lua_State* %0, %struct.luaL_Buffer* %b)
  br label %for.cond

for.cond:                                         ; preds = %if.end4, %entry
  %1 = load i64* %rlen, align 8
  %call = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* %b, i64 %1)
  store i8* %call, i8** %p, align 8
  %2 = load i8** %p, align 8
  %3 = load i64* %rlen, align 8
  %4 = load %struct._IO_FILE** %f.addr, align 8
  %call1 = call i64 @fread(i8* %2, i64 1, i64 %3, %struct._IO_FILE* %4)
  store i64 %call1, i64* %nr, align 8
  %5 = load i64* %nr, align 8
  %n = getelementptr inbounds %struct.luaL_Buffer* %b, i32 0, i32 2
  %6 = load i64* %n, align 8
  %add = add i64 %6, %5
  store i64 %add, i64* %n, align 8
  %7 = load i64* %nr, align 8
  %8 = load i64* %rlen, align 8
  %cmp = icmp ult i64 %7, %8
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %for.cond
  br label %for.end

if.else:                                          ; preds = %for.cond
  %9 = load i64* %rlen, align 8
  %cmp2 = icmp ule i64 %9, 4611686018427387903
  br i1 %cmp2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.else
  %10 = load i64* %rlen, align 8
  %mul = mul i64 %10, 2
  store i64 %mul, i64* %rlen, align 8
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.else
  br label %if.end4

if.end4:                                          ; preds = %if.end
  br label %for.cond

for.end:                                          ; preds = %if.then
  call void @luaL_pushresult(%struct.luaL_Buffer* %b)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @luaX_init(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %i = alloca i32, align 4
  %ts = alloca %union.TString*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32* %i, align 4
  %cmp = icmp slt i32 %0, 22
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load i32* %i, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [33 x i8*]* @luaX_tokens, i32 0, i64 %idxprom
  %3 = load i8** %arrayidx, align 8
  %call = call %union.TString* bitcast (%union.TString.367* (%struct.lua_State.364*, i8*)* @luaS_new to %union.TString* (%struct.lua_State*, i8*)*)(%struct.lua_State* %1, i8* %3)
  store %union.TString* %call, %union.TString** %ts, align 8
  %4 = load %union.TString** %ts, align 8
  %tsv = bitcast %union.TString* %4 to %struct.anon.0*
  %marked = getelementptr inbounds %struct.anon.0* %tsv, i32 0, i32 2
  %5 = load i8* %marked, align 1
  %conv = zext i8 %5 to i32
  %or = or i32 %conv, 32
  %conv1 = trunc i32 %or to i8
  store i8 %conv1, i8* %marked, align 1
  %6 = load i32* %i, align 4
  %add = add nsw i32 %6, 1
  %conv2 = trunc i32 %add to i8
  %7 = load %union.TString** %ts, align 8
  %tsv3 = bitcast %union.TString* %7 to %struct.anon.0*
  %extra = getelementptr inbounds %struct.anon.0* %tsv3, i32 0, i32 3
  store i8 %conv2, i8* %extra, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %8 = load i32* %i, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define hidden i8* @luaX_token2str(%struct.LexState.235* %ls, i32 %token) #0 {
entry:
  %retval = alloca i8*, align 8
  %ls.addr = alloca %struct.LexState.235*, align 8
  %token.addr = alloca i32, align 4
  %s = alloca i8*, align 8
  store %struct.LexState.235* %ls, %struct.LexState.235** %ls.addr, align 8
  store i32 %token, i32* %token.addr, align 4
  %0 = load i32* %token.addr, align 4
  %cmp = icmp slt i32 %0, 257
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i32* %token.addr, align 4
  %add = add nsw i32 %1, 1
  %idxprom = sext i32 %add to i64
  %arrayidx = getelementptr inbounds [257 x i8]* @luai_ctype_, i32 0, i64 %idxprom
  %2 = load i8* %arrayidx, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  %3 = load %struct.LexState.235** %ls.addr, align 8
  %L = getelementptr inbounds %struct.LexState.235* %3, i32 0, i32 6
  %4 = load %struct.lua_State** %L, align 8
  %5 = load i32* %token.addr, align 4
  %call = call i8* (%struct.lua_State*, i8*, ...)* bitcast (i8* (%struct.lua_State.279*, i8*, ...)* @luaO_pushfstring to i8* (%struct.lua_State*, i8*, ...)*)(%struct.lua_State* %4, i8* getelementptr inbounds ([5 x i8]* @.str357, i32 0, i32 0), i32 %5)
  br label %cond.end

cond.false:                                       ; preds = %if.then
  %6 = load %struct.LexState.235** %ls.addr, align 8
  %L1 = getelementptr inbounds %struct.LexState.235* %6, i32 0, i32 6
  %7 = load %struct.lua_State** %L1, align 8
  %8 = load i32* %token.addr, align 4
  %call2 = call i8* (%struct.lua_State*, i8*, ...)* bitcast (i8* (%struct.lua_State.279*, i8*, ...)* @luaO_pushfstring to i8* (%struct.lua_State*, i8*, ...)*)(%struct.lua_State* %7, i8* getelementptr inbounds ([9 x i8]* @.str1358, i32 0, i32 0), i32 %8)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %call, %cond.true ], [ %call2, %cond.false ]
  store i8* %cond, i8** %retval
  br label %return

if.else:                                          ; preds = %entry
  %9 = load i32* %token.addr, align 4
  %sub = sub nsw i32 %9, 257
  %idxprom3 = sext i32 %sub to i64
  %arrayidx4 = getelementptr inbounds [33 x i8*]* @luaX_tokens, i32 0, i64 %idxprom3
  %10 = load i8** %arrayidx4, align 8
  store i8* %10, i8** %s, align 8
  %11 = load i32* %token.addr, align 4
  %cmp5 = icmp slt i32 %11, 286
  br i1 %cmp5, label %if.then7, label %if.else10

if.then7:                                         ; preds = %if.else
  %12 = load %struct.LexState.235** %ls.addr, align 8
  %L8 = getelementptr inbounds %struct.LexState.235* %12, i32 0, i32 6
  %13 = load %struct.lua_State** %L8, align 8
  %14 = load i8** %s, align 8
  %call9 = call i8* (%struct.lua_State*, i8*, ...)* bitcast (i8* (%struct.lua_State.279*, i8*, ...)* @luaO_pushfstring to i8* (%struct.lua_State*, i8*, ...)*)(%struct.lua_State* %13, i8* getelementptr inbounds ([5 x i8]* @.str2359, i32 0, i32 0), i8* %14)
  store i8* %call9, i8** %retval
  br label %return

if.else10:                                        ; preds = %if.else
  %15 = load i8** %s, align 8
  store i8* %15, i8** %retval
  br label %return

return:                                           ; preds = %if.else10, %if.then7, %cond.end
  %16 = load i8** %retval
  ret i8* %16
}

; Function Attrs: noreturn nounwind uwtable
define hidden void @luaX_syntaxerror(%struct.LexState.235* %ls, i8* %msg) #6 {
entry:
  %ls.addr = alloca %struct.LexState.235*, align 8
  %msg.addr = alloca i8*, align 8
  store %struct.LexState.235* %ls, %struct.LexState.235** %ls.addr, align 8
  store i8* %msg, i8** %msg.addr, align 8
  %0 = load %struct.LexState.235** %ls.addr, align 8
  %1 = load i8** %msg.addr, align 8
  %2 = load %struct.LexState.235** %ls.addr, align 8
  %t = getelementptr inbounds %struct.LexState.235* %2, i32 0, i32 3
  %token = getelementptr inbounds %struct.Token* %t, i32 0, i32 0
  %3 = load i32* %token, align 4
  call void @lexerror(%struct.LexState.235* %0, i8* %1, i32 %3) #9
  unreachable

return:                                           ; No predecessors!
  ret void
}

; Function Attrs: nounwind uwtable
define hidden %union.TString* @luaX_newstring(%struct.LexState.235* %ls, i8* %str, i64 %l) #0 {
entry:
  %ls.addr = alloca %struct.LexState.235*, align 8
  %str.addr = alloca i8*, align 8
  %l.addr = alloca i64, align 8
  %L = alloca %struct.lua_State*, align 8
  %o = alloca %struct.lua_TValue*, align 8
  %ts = alloca %union.TString*, align 8
  %io = alloca %struct.lua_TValue*, align 8
  %x_ = alloca %union.TString*, align 8
  %io6 = alloca %struct.lua_TValue*, align 8
  store %struct.LexState.235* %ls, %struct.LexState.235** %ls.addr, align 8
  store i8* %str, i8** %str.addr, align 8
  store i64 %l, i64* %l.addr, align 8
  %0 = load %struct.LexState.235** %ls.addr, align 8
  %L1 = getelementptr inbounds %struct.LexState.235* %0, i32 0, i32 6
  %1 = load %struct.lua_State** %L1, align 8
  store %struct.lua_State* %1, %struct.lua_State** %L, align 8
  %2 = load %struct.lua_State** %L, align 8
  %3 = load i8** %str.addr, align 8
  %4 = load i64* %l.addr, align 8
  %call = call %union.TString* bitcast (%union.TString.367* (%struct.lua_State.364*, i8*, i64)* @luaS_newlstr to %union.TString* (%struct.lua_State*, i8*, i64)*)(%struct.lua_State* %2, i8* %3, i64 %4)
  store %union.TString* %call, %union.TString** %ts, align 8
  %5 = load %struct.lua_State** %L, align 8
  %top = getelementptr inbounds %struct.lua_State* %5, i32 0, i32 4
  %6 = load %struct.lua_TValue** %top, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue* %6, i32 1
  store %struct.lua_TValue* %incdec.ptr, %struct.lua_TValue** %top, align 8
  store %struct.lua_TValue* %6, %struct.lua_TValue** %io, align 8
  %7 = load %union.TString** %ts, align 8
  store %union.TString* %7, %union.TString** %x_, align 8
  %8 = load %union.TString** %x_, align 8
  %9 = bitcast %union.TString* %8 to %union.GCObject*
  %10 = load %struct.lua_TValue** %io, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %10, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  store %union.GCObject* %9, %union.GCObject** %gc, align 8
  %11 = load %union.TString** %x_, align 8
  %tsv = bitcast %union.TString* %11 to %struct.anon.0*
  %tt = getelementptr inbounds %struct.anon.0* %tsv, i32 0, i32 1
  %12 = load i8* %tt, align 1
  %conv = zext i8 %12 to i32
  %or = or i32 %conv, 64
  %13 = load %struct.lua_TValue** %io, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %13, i32 0, i32 1
  store i32 %or, i32* %tt_, align 4
  %14 = load %struct.lua_State** %L, align 8
  %15 = load %struct.LexState.235** %ls.addr, align 8
  %fs = getelementptr inbounds %struct.LexState.235* %15, i32 0, i32 5
  %16 = load %struct.FuncState.228** %fs, align 8
  %h = getelementptr inbounds %struct.FuncState.228* %16, i32 0, i32 1
  %17 = load %struct.Table** %h, align 8
  %18 = load %struct.lua_State** %L, align 8
  %top2 = getelementptr inbounds %struct.lua_State* %18, i32 0, i32 4
  %19 = load %struct.lua_TValue** %top2, align 8
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %19, i64 -1
  %call3 = call %struct.lua_TValue* @luaH_set(%struct.lua_State* %14, %struct.Table* %17, %struct.lua_TValue* %add.ptr)
  store %struct.lua_TValue* %call3, %struct.lua_TValue** %o, align 8
  %20 = load %struct.lua_TValue** %o, align 8
  %tt_4 = getelementptr inbounds %struct.lua_TValue* %20, i32 0, i32 1
  %21 = load i32* %tt_4, align 4
  %cmp = icmp eq i32 %21, 0
  br i1 %cmp, label %if.then, label %if.end12

if.then:                                          ; preds = %entry
  %22 = load %struct.lua_TValue** %o, align 8
  store %struct.lua_TValue* %22, %struct.lua_TValue** %io6, align 8
  %23 = load %struct.lua_TValue** %io6, align 8
  %value_7 = getelementptr inbounds %struct.lua_TValue* %23, i32 0, i32 0
  %b = bitcast %union.Value* %value_7 to i32*
  store i32 1, i32* %b, align 4
  %24 = load %struct.lua_TValue** %io6, align 8
  %tt_8 = getelementptr inbounds %struct.lua_TValue* %24, i32 0, i32 1
  store i32 1, i32* %tt_8, align 4
  %25 = load %struct.lua_State** %L, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %25, i32 0, i32 5
  %26 = load %struct.global_State** %l_G, align 8
  %GCdebt = getelementptr inbounds %struct.global_State* %26, i32 0, i32 3
  %27 = load i64* %GCdebt, align 8
  %cmp9 = icmp sgt i64 %27, 0
  br i1 %cmp9, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %28 = load %struct.lua_State** %L, align 8
  call void @luaC_step(%struct.lua_State* %28)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %if.end12

if.end12:                                         ; preds = %if.end, %entry
  %29 = load %struct.lua_State** %L, align 8
  %top13 = getelementptr inbounds %struct.lua_State* %29, i32 0, i32 4
  %30 = load %struct.lua_TValue** %top13, align 8
  %incdec.ptr14 = getelementptr inbounds %struct.lua_TValue* %30, i32 -1
  store %struct.lua_TValue* %incdec.ptr14, %struct.lua_TValue** %top13, align 8
  %31 = load %union.TString** %ts, align 8
  ret %union.TString* %31
}

; Function Attrs: nounwind uwtable
define hidden void @luaX_setinput(%struct.lua_State* %L, %struct.LexState.235* %ls, %struct.Zio* %z, %union.TString* %source, i32 %firstchar) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %ls.addr = alloca %struct.LexState.235*, align 8
  %z.addr = alloca %struct.Zio*, align 8
  %source.addr = alloca %union.TString*, align 8
  %firstchar.addr = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.LexState.235* %ls, %struct.LexState.235** %ls.addr, align 8
  store %struct.Zio* %z, %struct.Zio** %z.addr, align 8
  store %union.TString* %source, %union.TString** %source.addr, align 8
  store i32 %firstchar, i32* %firstchar.addr, align 4
  %0 = load %struct.LexState.235** %ls.addr, align 8
  %decpoint = getelementptr inbounds %struct.LexState.235* %0, i32 0, i32 12
  store i8 46, i8* %decpoint, align 1
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load %struct.LexState.235** %ls.addr, align 8
  %L1 = getelementptr inbounds %struct.LexState.235* %2, i32 0, i32 6
  store %struct.lua_State* %1, %struct.lua_State** %L1, align 8
  %3 = load i32* %firstchar.addr, align 4
  %4 = load %struct.LexState.235** %ls.addr, align 8
  %current = getelementptr inbounds %struct.LexState.235* %4, i32 0, i32 0
  store i32 %3, i32* %current, align 4
  %5 = load %struct.LexState.235** %ls.addr, align 8
  %lookahead = getelementptr inbounds %struct.LexState.235* %5, i32 0, i32 4
  %token = getelementptr inbounds %struct.Token* %lookahead, i32 0, i32 0
  store i32 286, i32* %token, align 4
  %6 = load %struct.Zio** %z.addr, align 8
  %7 = load %struct.LexState.235** %ls.addr, align 8
  %z2 = getelementptr inbounds %struct.LexState.235* %7, i32 0, i32 7
  store %struct.Zio* %6, %struct.Zio** %z2, align 8
  %8 = load %struct.LexState.235** %ls.addr, align 8
  %fs = getelementptr inbounds %struct.LexState.235* %8, i32 0, i32 5
  store %struct.FuncState.228* null, %struct.FuncState.228** %fs, align 8
  %9 = load %struct.LexState.235** %ls.addr, align 8
  %linenumber = getelementptr inbounds %struct.LexState.235* %9, i32 0, i32 1
  store i32 1, i32* %linenumber, align 4
  %10 = load %struct.LexState.235** %ls.addr, align 8
  %lastline = getelementptr inbounds %struct.LexState.235* %10, i32 0, i32 2
  store i32 1, i32* %lastline, align 4
  %11 = load %union.TString** %source.addr, align 8
  %12 = load %struct.LexState.235** %ls.addr, align 8
  %source3 = getelementptr inbounds %struct.LexState.235* %12, i32 0, i32 10
  store %union.TString* %11, %union.TString** %source3, align 8
  %13 = load %struct.lua_State** %L.addr, align 8
  %call = call %union.TString* bitcast (%union.TString.367* (%struct.lua_State.364*, i8*)* @luaS_new to %union.TString* (%struct.lua_State*, i8*)*)(%struct.lua_State* %13, i8* getelementptr inbounds ([5 x i8]* @.str3360, i32 0, i32 0))
  %14 = load %struct.LexState.235** %ls.addr, align 8
  %envn = getelementptr inbounds %struct.LexState.235* %14, i32 0, i32 11
  store %union.TString* %call, %union.TString** %envn, align 8
  %15 = load %struct.LexState.235** %ls.addr, align 8
  %envn4 = getelementptr inbounds %struct.LexState.235* %15, i32 0, i32 11
  %16 = load %union.TString** %envn4, align 8
  %tsv = bitcast %union.TString* %16 to %struct.anon.0*
  %marked = getelementptr inbounds %struct.anon.0* %tsv, i32 0, i32 2
  %17 = load i8* %marked, align 1
  %conv = zext i8 %17 to i32
  %or = or i32 %conv, 32
  %conv5 = trunc i32 %or to i8
  store i8 %conv5, i8* %marked, align 1
  %18 = load %struct.LexState.235** %ls.addr, align 8
  %L6 = getelementptr inbounds %struct.LexState.235* %18, i32 0, i32 6
  %19 = load %struct.lua_State** %L6, align 8
  %20 = load %struct.LexState.235** %ls.addr, align 8
  %buff = getelementptr inbounds %struct.LexState.235* %20, i32 0, i32 8
  %21 = load %struct.Mbuffer** %buff, align 8
  %buffer = getelementptr inbounds %struct.Mbuffer* %21, i32 0, i32 0
  %22 = load i8** %buffer, align 8
  %23 = load %struct.LexState.235** %ls.addr, align 8
  %buff7 = getelementptr inbounds %struct.LexState.235* %23, i32 0, i32 8
  %24 = load %struct.Mbuffer** %buff7, align 8
  %buffsize = getelementptr inbounds %struct.Mbuffer* %24, i32 0, i32 2
  %25 = load i64* %buffsize, align 8
  %mul = mul i64 %25, 1
  %call8 = call i8* @luaM_realloc_(%struct.lua_State* %19, i8* %22, i64 %mul, i64 32)
  %26 = load %struct.LexState.235** %ls.addr, align 8
  %buff9 = getelementptr inbounds %struct.LexState.235* %26, i32 0, i32 8
  %27 = load %struct.Mbuffer** %buff9, align 8
  %buffer10 = getelementptr inbounds %struct.Mbuffer* %27, i32 0, i32 0
  store i8* %call8, i8** %buffer10, align 8
  %28 = load %struct.LexState.235** %ls.addr, align 8
  %buff11 = getelementptr inbounds %struct.LexState.235* %28, i32 0, i32 8
  %29 = load %struct.Mbuffer** %buff11, align 8
  %buffsize12 = getelementptr inbounds %struct.Mbuffer* %29, i32 0, i32 2
  store i64 32, i64* %buffsize12, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @luaX_next(%struct.LexState.235* %ls) #0 {
entry:
  %ls.addr = alloca %struct.LexState.235*, align 8
  store %struct.LexState.235* %ls, %struct.LexState.235** %ls.addr, align 8
  %0 = load %struct.LexState.235** %ls.addr, align 8
  %linenumber = getelementptr inbounds %struct.LexState.235* %0, i32 0, i32 1
  %1 = load i32* %linenumber, align 4
  %2 = load %struct.LexState.235** %ls.addr, align 8
  %lastline = getelementptr inbounds %struct.LexState.235* %2, i32 0, i32 2
  store i32 %1, i32* %lastline, align 4
  %3 = load %struct.LexState.235** %ls.addr, align 8
  %lookahead = getelementptr inbounds %struct.LexState.235* %3, i32 0, i32 4
  %token = getelementptr inbounds %struct.Token* %lookahead, i32 0, i32 0
  %4 = load i32* %token, align 4
  %cmp = icmp ne i32 %4, 286
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %5 = load %struct.LexState.235** %ls.addr, align 8
  %t = getelementptr inbounds %struct.LexState.235* %5, i32 0, i32 3
  %6 = load %struct.LexState.235** %ls.addr, align 8
  %lookahead1 = getelementptr inbounds %struct.LexState.235* %6, i32 0, i32 4
  %7 = bitcast %struct.Token* %t to i8*
  %8 = bitcast %struct.Token* %lookahead1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %7, i8* %8, i64 16, i32 8, i1 false)
  %9 = load %struct.LexState.235** %ls.addr, align 8
  %lookahead2 = getelementptr inbounds %struct.LexState.235* %9, i32 0, i32 4
  %token3 = getelementptr inbounds %struct.Token* %lookahead2, i32 0, i32 0
  store i32 286, i32* %token3, align 4
  br label %if.end

if.else:                                          ; preds = %entry
  %10 = load %struct.LexState.235** %ls.addr, align 8
  %11 = load %struct.LexState.235** %ls.addr, align 8
  %t4 = getelementptr inbounds %struct.LexState.235* %11, i32 0, i32 3
  %seminfo = getelementptr inbounds %struct.Token* %t4, i32 0, i32 1
  %call = call i32 @llex(%struct.LexState.235* %10, %union.SemInfo* %seminfo)
  %12 = load %struct.LexState.235** %ls.addr, align 8
  %t5 = getelementptr inbounds %struct.LexState.235* %12, i32 0, i32 3
  %token6 = getelementptr inbounds %struct.Token* %t5, i32 0, i32 0
  store i32 %call, i32* %token6, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define hidden i32 @luaX_lookahead(%struct.LexState.235* %ls) #0 {
entry:
  %ls.addr = alloca %struct.LexState.235*, align 8
  store %struct.LexState.235* %ls, %struct.LexState.235** %ls.addr, align 8
  %0 = load %struct.LexState.235** %ls.addr, align 8
  %1 = load %struct.LexState.235** %ls.addr, align 8
  %lookahead = getelementptr inbounds %struct.LexState.235* %1, i32 0, i32 4
  %seminfo = getelementptr inbounds %struct.Token* %lookahead, i32 0, i32 1
  %call = call i32 @llex(%struct.LexState.235* %0, %union.SemInfo* %seminfo)
  %2 = load %struct.LexState.235** %ls.addr, align 8
  %lookahead1 = getelementptr inbounds %struct.LexState.235* %2, i32 0, i32 4
  %token = getelementptr inbounds %struct.Token* %lookahead1, i32 0, i32 0
  store i32 %call, i32* %token, align 4
  %3 = load %struct.LexState.235** %ls.addr, align 8
  %lookahead2 = getelementptr inbounds %struct.LexState.235* %3, i32 0, i32 4
  %token3 = getelementptr inbounds %struct.Token* %lookahead2, i32 0, i32 0
  %4 = load i32* %token3, align 4
  ret i32 %4
}

; Function Attrs: nounwind
declare %struct.lconv* @localeconv() #4

; Function Attrs: noreturn nounwind uwtable
define internal void @lexerror(%struct.LexState.235* %ls, i8* %msg, i32 %token) #6 {
entry:
  %ls.addr = alloca %struct.LexState.235*, align 8
  %msg.addr = alloca i8*, align 8
  %token.addr = alloca i32, align 4
  %buff = alloca [60 x i8], align 16
  store %struct.LexState.235* %ls, %struct.LexState.235** %ls.addr, align 8
  store i8* %msg, i8** %msg.addr, align 8
  store i32 %token, i32* %token.addr, align 4
  %arraydecay = getelementptr inbounds [60 x i8]* %buff, i32 0, i32 0
  %0 = load %struct.LexState.235** %ls.addr, align 8
  %source = getelementptr inbounds %struct.LexState.235* %0, i32 0, i32 10
  %1 = load %union.TString** %source, align 8
  %add.ptr = getelementptr inbounds %union.TString* %1, i64 1
  %2 = bitcast %union.TString* %add.ptr to i8*
  call void @luaO_chunkid(i8* %arraydecay, i8* %2, i64 60)
  %3 = load %struct.LexState.235** %ls.addr, align 8
  %L = getelementptr inbounds %struct.LexState.235* %3, i32 0, i32 6
  %4 = load %struct.lua_State** %L, align 8
  %arraydecay1 = getelementptr inbounds [60 x i8]* %buff, i32 0, i32 0
  %5 = load %struct.LexState.235** %ls.addr, align 8
  %linenumber = getelementptr inbounds %struct.LexState.235* %5, i32 0, i32 1
  %6 = load i32* %linenumber, align 4
  %7 = load i8** %msg.addr, align 8
  %call = call i8* (%struct.lua_State*, i8*, ...)* bitcast (i8* (%struct.lua_State.279*, i8*, ...)* @luaO_pushfstring to i8* (%struct.lua_State*, i8*, ...)*)(%struct.lua_State* %4, i8* getelementptr inbounds ([10 x i8]* @.str19376, i32 0, i32 0), i8* %arraydecay1, i32 %6, i8* %7)
  store i8* %call, i8** %msg.addr, align 8
  %8 = load i32* %token.addr, align 4
  %tobool = icmp ne i32 %8, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %9 = load %struct.LexState.235** %ls.addr, align 8
  %L2 = getelementptr inbounds %struct.LexState.235* %9, i32 0, i32 6
  %10 = load %struct.lua_State** %L2, align 8
  %11 = load i8** %msg.addr, align 8
  %12 = load %struct.LexState.235** %ls.addr, align 8
  %13 = load i32* %token.addr, align 4
  %call3 = call i8* @txtToken(%struct.LexState.235* %12, i32 %13)
  %call4 = call i8* (%struct.lua_State*, i8*, ...)* bitcast (i8* (%struct.lua_State.279*, i8*, ...)* @luaO_pushfstring to i8* (%struct.lua_State*, i8*, ...)*)(%struct.lua_State* %10, i8* getelementptr inbounds ([11 x i8]* @.str20377, i32 0, i32 0), i8* %11, i8* %call3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %14 = load %struct.LexState.235** %ls.addr, align 8
  %L5 = getelementptr inbounds %struct.LexState.235* %14, i32 0, i32 6
  %15 = load %struct.lua_State** %L5, align 8
  call void @luaD_throw(%struct.lua_State* %15, i32 3) #9
  unreachable

return:                                           ; No predecessors!
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @llex(%struct.LexState.235* %ls, %union.SemInfo* %seminfo) #0 {
entry:
  %retval = alloca i32, align 4
  %ls.addr = alloca %struct.LexState.235*, align 8
  %seminfo.addr = alloca %union.SemInfo*, align 8
  %sep = alloca i32, align 4
  %sep82 = alloca i32, align 4
  %ts = alloca %union.TString*, align 8
  %c = alloca i32, align 4
  store %struct.LexState.235* %ls, %struct.LexState.235** %ls.addr, align 8
  store %union.SemInfo* %seminfo, %union.SemInfo** %seminfo.addr, align 8
  %0 = load %struct.LexState.235** %ls.addr, align 8
  %buff = getelementptr inbounds %struct.LexState.235* %0, i32 0, i32 8
  %1 = load %struct.Mbuffer** %buff, align 8
  %n = getelementptr inbounds %struct.Mbuffer* %1, i32 0, i32 1
  store i64 0, i64* %n, align 8
  br label %for.cond

for.cond:                                         ; preds = %sw.epilog, %entry
  %2 = load %struct.LexState.235** %ls.addr, align 8
  %current = getelementptr inbounds %struct.LexState.235* %2, i32 0, i32 0
  %3 = load i32* %current, align 4
  switch i32 %3, label %sw.default [
    i32 10, label %sw.bb
    i32 13, label %sw.bb
    i32 32, label %sw.bb1
    i32 12, label %sw.bb1
    i32 9, label %sw.bb1
    i32 11, label %sw.bb1
    i32 45, label %sw.bb6
    i32 91, label %sw.bb81
    i32 61, label %sw.bb91
    i32 60, label %sw.bb129
    i32 62, label %sw.bb167
    i32 126, label %sw.bb205
    i32 58, label %sw.bb243
    i32 34, label %sw.bb281
    i32 39, label %sw.bb281
    i32 46, label %sw.bb283
    i32 48, label %sw.bb314
    i32 49, label %sw.bb314
    i32 50, label %sw.bb314
    i32 51, label %sw.bb314
    i32 52, label %sw.bb314
    i32 53, label %sw.bb314
    i32 54, label %sw.bb314
    i32 55, label %sw.bb314
    i32 56, label %sw.bb314
    i32 57, label %sw.bb314
    i32 -1, label %sw.bb315
  ]

sw.bb:                                            ; preds = %for.cond, %for.cond
  %4 = load %struct.LexState.235** %ls.addr, align 8
  call void @inclinenumber(%struct.LexState.235* %4)
  br label %sw.epilog

sw.bb1:                                           ; preds = %for.cond, %for.cond, %for.cond, %for.cond
  %5 = load %struct.LexState.235** %ls.addr, align 8
  %z = getelementptr inbounds %struct.LexState.235* %5, i32 0, i32 7
  %6 = load %struct.Zio** %z, align 8
  %n2 = getelementptr inbounds %struct.Zio* %6, i32 0, i32 0
  %7 = load i64* %n2, align 8
  %dec = add i64 %7, -1
  store i64 %dec, i64* %n2, align 8
  %cmp = icmp ugt i64 %7, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %sw.bb1
  %8 = load %struct.LexState.235** %ls.addr, align 8
  %z3 = getelementptr inbounds %struct.LexState.235* %8, i32 0, i32 7
  %9 = load %struct.Zio** %z3, align 8
  %p = getelementptr inbounds %struct.Zio* %9, i32 0, i32 1
  %10 = load i8** %p, align 8
  %incdec.ptr = getelementptr inbounds i8* %10, i32 1
  store i8* %incdec.ptr, i8** %p, align 8
  %11 = load i8* %10, align 1
  %conv = zext i8 %11 to i32
  br label %cond.end

cond.false:                                       ; preds = %sw.bb1
  %12 = load %struct.LexState.235** %ls.addr, align 8
  %z4 = getelementptr inbounds %struct.LexState.235* %12, i32 0, i32 7
  %13 = load %struct.Zio** %z4, align 8
  %call = call i32 @luaZ_fill(%struct.Zio* %13)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv, %cond.true ], [ %call, %cond.false ]
  %14 = load %struct.LexState.235** %ls.addr, align 8
  %current5 = getelementptr inbounds %struct.LexState.235* %14, i32 0, i32 0
  store i32 %cond, i32* %current5, align 4
  br label %sw.epilog

sw.bb6:                                           ; preds = %for.cond
  %15 = load %struct.LexState.235** %ls.addr, align 8
  %z7 = getelementptr inbounds %struct.LexState.235* %15, i32 0, i32 7
  %16 = load %struct.Zio** %z7, align 8
  %n8 = getelementptr inbounds %struct.Zio* %16, i32 0, i32 0
  %17 = load i64* %n8, align 8
  %dec9 = add i64 %17, -1
  store i64 %dec9, i64* %n8, align 8
  %cmp10 = icmp ugt i64 %17, 0
  br i1 %cmp10, label %cond.true12, label %cond.false17

cond.true12:                                      ; preds = %sw.bb6
  %18 = load %struct.LexState.235** %ls.addr, align 8
  %z13 = getelementptr inbounds %struct.LexState.235* %18, i32 0, i32 7
  %19 = load %struct.Zio** %z13, align 8
  %p14 = getelementptr inbounds %struct.Zio* %19, i32 0, i32 1
  %20 = load i8** %p14, align 8
  %incdec.ptr15 = getelementptr inbounds i8* %20, i32 1
  store i8* %incdec.ptr15, i8** %p14, align 8
  %21 = load i8* %20, align 1
  %conv16 = zext i8 %21 to i32
  br label %cond.end20

cond.false17:                                     ; preds = %sw.bb6
  %22 = load %struct.LexState.235** %ls.addr, align 8
  %z18 = getelementptr inbounds %struct.LexState.235* %22, i32 0, i32 7
  %23 = load %struct.Zio** %z18, align 8
  %call19 = call i32 @luaZ_fill(%struct.Zio* %23)
  br label %cond.end20

cond.end20:                                       ; preds = %cond.false17, %cond.true12
  %cond21 = phi i32 [ %conv16, %cond.true12 ], [ %call19, %cond.false17 ]
  %24 = load %struct.LexState.235** %ls.addr, align 8
  %current22 = getelementptr inbounds %struct.LexState.235* %24, i32 0, i32 0
  store i32 %cond21, i32* %current22, align 4
  %25 = load %struct.LexState.235** %ls.addr, align 8
  %current23 = getelementptr inbounds %struct.LexState.235* %25, i32 0, i32 0
  %26 = load i32* %current23, align 4
  %cmp24 = icmp ne i32 %26, 45
  br i1 %cmp24, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end20
  store i32 45, i32* %retval
  br label %return

if.end:                                           ; preds = %cond.end20
  %27 = load %struct.LexState.235** %ls.addr, align 8
  %z26 = getelementptr inbounds %struct.LexState.235* %27, i32 0, i32 7
  %28 = load %struct.Zio** %z26, align 8
  %n27 = getelementptr inbounds %struct.Zio* %28, i32 0, i32 0
  %29 = load i64* %n27, align 8
  %dec28 = add i64 %29, -1
  store i64 %dec28, i64* %n27, align 8
  %cmp29 = icmp ugt i64 %29, 0
  br i1 %cmp29, label %cond.true31, label %cond.false36

cond.true31:                                      ; preds = %if.end
  %30 = load %struct.LexState.235** %ls.addr, align 8
  %z32 = getelementptr inbounds %struct.LexState.235* %30, i32 0, i32 7
  %31 = load %struct.Zio** %z32, align 8
  %p33 = getelementptr inbounds %struct.Zio* %31, i32 0, i32 1
  %32 = load i8** %p33, align 8
  %incdec.ptr34 = getelementptr inbounds i8* %32, i32 1
  store i8* %incdec.ptr34, i8** %p33, align 8
  %33 = load i8* %32, align 1
  %conv35 = zext i8 %33 to i32
  br label %cond.end39

cond.false36:                                     ; preds = %if.end
  %34 = load %struct.LexState.235** %ls.addr, align 8
  %z37 = getelementptr inbounds %struct.LexState.235* %34, i32 0, i32 7
  %35 = load %struct.Zio** %z37, align 8
  %call38 = call i32 @luaZ_fill(%struct.Zio* %35)
  br label %cond.end39

cond.end39:                                       ; preds = %cond.false36, %cond.true31
  %cond40 = phi i32 [ %conv35, %cond.true31 ], [ %call38, %cond.false36 ]
  %36 = load %struct.LexState.235** %ls.addr, align 8
  %current41 = getelementptr inbounds %struct.LexState.235* %36, i32 0, i32 0
  store i32 %cond40, i32* %current41, align 4
  %37 = load %struct.LexState.235** %ls.addr, align 8
  %current42 = getelementptr inbounds %struct.LexState.235* %37, i32 0, i32 0
  %38 = load i32* %current42, align 4
  %cmp43 = icmp eq i32 %38, 91
  br i1 %cmp43, label %if.then45, label %if.end55

if.then45:                                        ; preds = %cond.end39
  %39 = load %struct.LexState.235** %ls.addr, align 8
  %call46 = call i32 @skip_sep(%struct.LexState.235* %39)
  store i32 %call46, i32* %sep, align 4
  %40 = load %struct.LexState.235** %ls.addr, align 8
  %buff47 = getelementptr inbounds %struct.LexState.235* %40, i32 0, i32 8
  %41 = load %struct.Mbuffer** %buff47, align 8
  %n48 = getelementptr inbounds %struct.Mbuffer* %41, i32 0, i32 1
  store i64 0, i64* %n48, align 8
  %42 = load i32* %sep, align 4
  %cmp49 = icmp sge i32 %42, 0
  br i1 %cmp49, label %if.then51, label %if.end54

if.then51:                                        ; preds = %if.then45
  %43 = load %struct.LexState.235** %ls.addr, align 8
  %44 = load i32* %sep, align 4
  call void @read_long_string(%struct.LexState.235* %43, %union.SemInfo* null, i32 %44)
  %45 = load %struct.LexState.235** %ls.addr, align 8
  %buff52 = getelementptr inbounds %struct.LexState.235* %45, i32 0, i32 8
  %46 = load %struct.Mbuffer** %buff52, align 8
  %n53 = getelementptr inbounds %struct.Mbuffer* %46, i32 0, i32 1
  store i64 0, i64* %n53, align 8
  br label %sw.epilog

if.end54:                                         ; preds = %if.then45
  br label %if.end55

if.end55:                                         ; preds = %if.end54, %cond.end39
  br label %while.cond

while.cond:                                       ; preds = %cond.end78, %if.end55
  %47 = load %struct.LexState.235** %ls.addr, align 8
  %current56 = getelementptr inbounds %struct.LexState.235* %47, i32 0, i32 0
  %48 = load i32* %current56, align 4
  %cmp57 = icmp eq i32 %48, 10
  br i1 %cmp57, label %land.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.cond
  %49 = load %struct.LexState.235** %ls.addr, align 8
  %current59 = getelementptr inbounds %struct.LexState.235* %49, i32 0, i32 0
  %50 = load i32* %current59, align 4
  %cmp60 = icmp eq i32 %50, 13
  br i1 %cmp60, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %lor.lhs.false
  %51 = load %struct.LexState.235** %ls.addr, align 8
  %current62 = getelementptr inbounds %struct.LexState.235* %51, i32 0, i32 0
  %52 = load i32* %current62, align 4
  %cmp63 = icmp ne i32 %52, -1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %lor.lhs.false, %while.cond
  %53 = phi i1 [ false, %lor.lhs.false ], [ false, %while.cond ], [ %cmp63, %land.rhs ]
  br i1 %53, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %54 = load %struct.LexState.235** %ls.addr, align 8
  %z65 = getelementptr inbounds %struct.LexState.235* %54, i32 0, i32 7
  %55 = load %struct.Zio** %z65, align 8
  %n66 = getelementptr inbounds %struct.Zio* %55, i32 0, i32 0
  %56 = load i64* %n66, align 8
  %dec67 = add i64 %56, -1
  store i64 %dec67, i64* %n66, align 8
  %cmp68 = icmp ugt i64 %56, 0
  br i1 %cmp68, label %cond.true70, label %cond.false75

cond.true70:                                      ; preds = %while.body
  %57 = load %struct.LexState.235** %ls.addr, align 8
  %z71 = getelementptr inbounds %struct.LexState.235* %57, i32 0, i32 7
  %58 = load %struct.Zio** %z71, align 8
  %p72 = getelementptr inbounds %struct.Zio* %58, i32 0, i32 1
  %59 = load i8** %p72, align 8
  %incdec.ptr73 = getelementptr inbounds i8* %59, i32 1
  store i8* %incdec.ptr73, i8** %p72, align 8
  %60 = load i8* %59, align 1
  %conv74 = zext i8 %60 to i32
  br label %cond.end78

cond.false75:                                     ; preds = %while.body
  %61 = load %struct.LexState.235** %ls.addr, align 8
  %z76 = getelementptr inbounds %struct.LexState.235* %61, i32 0, i32 7
  %62 = load %struct.Zio** %z76, align 8
  %call77 = call i32 @luaZ_fill(%struct.Zio* %62)
  br label %cond.end78

cond.end78:                                       ; preds = %cond.false75, %cond.true70
  %cond79 = phi i32 [ %conv74, %cond.true70 ], [ %call77, %cond.false75 ]
  %63 = load %struct.LexState.235** %ls.addr, align 8
  %current80 = getelementptr inbounds %struct.LexState.235* %63, i32 0, i32 0
  store i32 %cond79, i32* %current80, align 4
  br label %while.cond

while.end:                                        ; preds = %land.end
  br label %sw.epilog

sw.bb81:                                          ; preds = %for.cond
  %64 = load %struct.LexState.235** %ls.addr, align 8
  %call83 = call i32 @skip_sep(%struct.LexState.235* %64)
  store i32 %call83, i32* %sep82, align 4
  %65 = load i32* %sep82, align 4
  %cmp84 = icmp sge i32 %65, 0
  br i1 %cmp84, label %if.then86, label %if.else

if.then86:                                        ; preds = %sw.bb81
  %66 = load %struct.LexState.235** %ls.addr, align 8
  %67 = load %union.SemInfo** %seminfo.addr, align 8
  %68 = load i32* %sep82, align 4
  call void @read_long_string(%struct.LexState.235* %66, %union.SemInfo* %67, i32 %68)
  store i32 289, i32* %retval
  br label %return

if.else:                                          ; preds = %sw.bb81
  %69 = load i32* %sep82, align 4
  %cmp87 = icmp eq i32 %69, -1
  br i1 %cmp87, label %if.then89, label %if.else90

if.then89:                                        ; preds = %if.else
  store i32 91, i32* %retval
  br label %return

if.else90:                                        ; preds = %if.else
  %70 = load %struct.LexState.235** %ls.addr, align 8
  call void @lexerror(%struct.LexState.235* %70, i8* getelementptr inbounds ([30 x i8]* @.str4361, i32 0, i32 0), i32 289) #9
  unreachable

sw.bb91:                                          ; preds = %for.cond
  %71 = load %struct.LexState.235** %ls.addr, align 8
  %z92 = getelementptr inbounds %struct.LexState.235* %71, i32 0, i32 7
  %72 = load %struct.Zio** %z92, align 8
  %n93 = getelementptr inbounds %struct.Zio* %72, i32 0, i32 0
  %73 = load i64* %n93, align 8
  %dec94 = add i64 %73, -1
  store i64 %dec94, i64* %n93, align 8
  %cmp95 = icmp ugt i64 %73, 0
  br i1 %cmp95, label %cond.true97, label %cond.false102

cond.true97:                                      ; preds = %sw.bb91
  %74 = load %struct.LexState.235** %ls.addr, align 8
  %z98 = getelementptr inbounds %struct.LexState.235* %74, i32 0, i32 7
  %75 = load %struct.Zio** %z98, align 8
  %p99 = getelementptr inbounds %struct.Zio* %75, i32 0, i32 1
  %76 = load i8** %p99, align 8
  %incdec.ptr100 = getelementptr inbounds i8* %76, i32 1
  store i8* %incdec.ptr100, i8** %p99, align 8
  %77 = load i8* %76, align 1
  %conv101 = zext i8 %77 to i32
  br label %cond.end105

cond.false102:                                    ; preds = %sw.bb91
  %78 = load %struct.LexState.235** %ls.addr, align 8
  %z103 = getelementptr inbounds %struct.LexState.235* %78, i32 0, i32 7
  %79 = load %struct.Zio** %z103, align 8
  %call104 = call i32 @luaZ_fill(%struct.Zio* %79)
  br label %cond.end105

cond.end105:                                      ; preds = %cond.false102, %cond.true97
  %cond106 = phi i32 [ %conv101, %cond.true97 ], [ %call104, %cond.false102 ]
  %80 = load %struct.LexState.235** %ls.addr, align 8
  %current107 = getelementptr inbounds %struct.LexState.235* %80, i32 0, i32 0
  store i32 %cond106, i32* %current107, align 4
  %81 = load %struct.LexState.235** %ls.addr, align 8
  %current108 = getelementptr inbounds %struct.LexState.235* %81, i32 0, i32 0
  %82 = load i32* %current108, align 4
  %cmp109 = icmp ne i32 %82, 61
  br i1 %cmp109, label %if.then111, label %if.else112

if.then111:                                       ; preds = %cond.end105
  store i32 61, i32* %retval
  br label %return

if.else112:                                       ; preds = %cond.end105
  %83 = load %struct.LexState.235** %ls.addr, align 8
  %z113 = getelementptr inbounds %struct.LexState.235* %83, i32 0, i32 7
  %84 = load %struct.Zio** %z113, align 8
  %n114 = getelementptr inbounds %struct.Zio* %84, i32 0, i32 0
  %85 = load i64* %n114, align 8
  %dec115 = add i64 %85, -1
  store i64 %dec115, i64* %n114, align 8
  %cmp116 = icmp ugt i64 %85, 0
  br i1 %cmp116, label %cond.true118, label %cond.false123

cond.true118:                                     ; preds = %if.else112
  %86 = load %struct.LexState.235** %ls.addr, align 8
  %z119 = getelementptr inbounds %struct.LexState.235* %86, i32 0, i32 7
  %87 = load %struct.Zio** %z119, align 8
  %p120 = getelementptr inbounds %struct.Zio* %87, i32 0, i32 1
  %88 = load i8** %p120, align 8
  %incdec.ptr121 = getelementptr inbounds i8* %88, i32 1
  store i8* %incdec.ptr121, i8** %p120, align 8
  %89 = load i8* %88, align 1
  %conv122 = zext i8 %89 to i32
  br label %cond.end126

cond.false123:                                    ; preds = %if.else112
  %90 = load %struct.LexState.235** %ls.addr, align 8
  %z124 = getelementptr inbounds %struct.LexState.235* %90, i32 0, i32 7
  %91 = load %struct.Zio** %z124, align 8
  %call125 = call i32 @luaZ_fill(%struct.Zio* %91)
  br label %cond.end126

cond.end126:                                      ; preds = %cond.false123, %cond.true118
  %cond127 = phi i32 [ %conv122, %cond.true118 ], [ %call125, %cond.false123 ]
  %92 = load %struct.LexState.235** %ls.addr, align 8
  %current128 = getelementptr inbounds %struct.LexState.235* %92, i32 0, i32 0
  store i32 %cond127, i32* %current128, align 4
  store i32 281, i32* %retval
  br label %return

sw.bb129:                                         ; preds = %for.cond
  %93 = load %struct.LexState.235** %ls.addr, align 8
  %z130 = getelementptr inbounds %struct.LexState.235* %93, i32 0, i32 7
  %94 = load %struct.Zio** %z130, align 8
  %n131 = getelementptr inbounds %struct.Zio* %94, i32 0, i32 0
  %95 = load i64* %n131, align 8
  %dec132 = add i64 %95, -1
  store i64 %dec132, i64* %n131, align 8
  %cmp133 = icmp ugt i64 %95, 0
  br i1 %cmp133, label %cond.true135, label %cond.false140

cond.true135:                                     ; preds = %sw.bb129
  %96 = load %struct.LexState.235** %ls.addr, align 8
  %z136 = getelementptr inbounds %struct.LexState.235* %96, i32 0, i32 7
  %97 = load %struct.Zio** %z136, align 8
  %p137 = getelementptr inbounds %struct.Zio* %97, i32 0, i32 1
  %98 = load i8** %p137, align 8
  %incdec.ptr138 = getelementptr inbounds i8* %98, i32 1
  store i8* %incdec.ptr138, i8** %p137, align 8
  %99 = load i8* %98, align 1
  %conv139 = zext i8 %99 to i32
  br label %cond.end143

cond.false140:                                    ; preds = %sw.bb129
  %100 = load %struct.LexState.235** %ls.addr, align 8
  %z141 = getelementptr inbounds %struct.LexState.235* %100, i32 0, i32 7
  %101 = load %struct.Zio** %z141, align 8
  %call142 = call i32 @luaZ_fill(%struct.Zio* %101)
  br label %cond.end143

cond.end143:                                      ; preds = %cond.false140, %cond.true135
  %cond144 = phi i32 [ %conv139, %cond.true135 ], [ %call142, %cond.false140 ]
  %102 = load %struct.LexState.235** %ls.addr, align 8
  %current145 = getelementptr inbounds %struct.LexState.235* %102, i32 0, i32 0
  store i32 %cond144, i32* %current145, align 4
  %103 = load %struct.LexState.235** %ls.addr, align 8
  %current146 = getelementptr inbounds %struct.LexState.235* %103, i32 0, i32 0
  %104 = load i32* %current146, align 4
  %cmp147 = icmp ne i32 %104, 61
  br i1 %cmp147, label %if.then149, label %if.else150

if.then149:                                       ; preds = %cond.end143
  store i32 60, i32* %retval
  br label %return

if.else150:                                       ; preds = %cond.end143
  %105 = load %struct.LexState.235** %ls.addr, align 8
  %z151 = getelementptr inbounds %struct.LexState.235* %105, i32 0, i32 7
  %106 = load %struct.Zio** %z151, align 8
  %n152 = getelementptr inbounds %struct.Zio* %106, i32 0, i32 0
  %107 = load i64* %n152, align 8
  %dec153 = add i64 %107, -1
  store i64 %dec153, i64* %n152, align 8
  %cmp154 = icmp ugt i64 %107, 0
  br i1 %cmp154, label %cond.true156, label %cond.false161

cond.true156:                                     ; preds = %if.else150
  %108 = load %struct.LexState.235** %ls.addr, align 8
  %z157 = getelementptr inbounds %struct.LexState.235* %108, i32 0, i32 7
  %109 = load %struct.Zio** %z157, align 8
  %p158 = getelementptr inbounds %struct.Zio* %109, i32 0, i32 1
  %110 = load i8** %p158, align 8
  %incdec.ptr159 = getelementptr inbounds i8* %110, i32 1
  store i8* %incdec.ptr159, i8** %p158, align 8
  %111 = load i8* %110, align 1
  %conv160 = zext i8 %111 to i32
  br label %cond.end164

cond.false161:                                    ; preds = %if.else150
  %112 = load %struct.LexState.235** %ls.addr, align 8
  %z162 = getelementptr inbounds %struct.LexState.235* %112, i32 0, i32 7
  %113 = load %struct.Zio** %z162, align 8
  %call163 = call i32 @luaZ_fill(%struct.Zio* %113)
  br label %cond.end164

cond.end164:                                      ; preds = %cond.false161, %cond.true156
  %cond165 = phi i32 [ %conv160, %cond.true156 ], [ %call163, %cond.false161 ]
  %114 = load %struct.LexState.235** %ls.addr, align 8
  %current166 = getelementptr inbounds %struct.LexState.235* %114, i32 0, i32 0
  store i32 %cond165, i32* %current166, align 4
  store i32 283, i32* %retval
  br label %return

sw.bb167:                                         ; preds = %for.cond
  %115 = load %struct.LexState.235** %ls.addr, align 8
  %z168 = getelementptr inbounds %struct.LexState.235* %115, i32 0, i32 7
  %116 = load %struct.Zio** %z168, align 8
  %n169 = getelementptr inbounds %struct.Zio* %116, i32 0, i32 0
  %117 = load i64* %n169, align 8
  %dec170 = add i64 %117, -1
  store i64 %dec170, i64* %n169, align 8
  %cmp171 = icmp ugt i64 %117, 0
  br i1 %cmp171, label %cond.true173, label %cond.false178

cond.true173:                                     ; preds = %sw.bb167
  %118 = load %struct.LexState.235** %ls.addr, align 8
  %z174 = getelementptr inbounds %struct.LexState.235* %118, i32 0, i32 7
  %119 = load %struct.Zio** %z174, align 8
  %p175 = getelementptr inbounds %struct.Zio* %119, i32 0, i32 1
  %120 = load i8** %p175, align 8
  %incdec.ptr176 = getelementptr inbounds i8* %120, i32 1
  store i8* %incdec.ptr176, i8** %p175, align 8
  %121 = load i8* %120, align 1
  %conv177 = zext i8 %121 to i32
  br label %cond.end181

cond.false178:                                    ; preds = %sw.bb167
  %122 = load %struct.LexState.235** %ls.addr, align 8
  %z179 = getelementptr inbounds %struct.LexState.235* %122, i32 0, i32 7
  %123 = load %struct.Zio** %z179, align 8
  %call180 = call i32 @luaZ_fill(%struct.Zio* %123)
  br label %cond.end181

cond.end181:                                      ; preds = %cond.false178, %cond.true173
  %cond182 = phi i32 [ %conv177, %cond.true173 ], [ %call180, %cond.false178 ]
  %124 = load %struct.LexState.235** %ls.addr, align 8
  %current183 = getelementptr inbounds %struct.LexState.235* %124, i32 0, i32 0
  store i32 %cond182, i32* %current183, align 4
  %125 = load %struct.LexState.235** %ls.addr, align 8
  %current184 = getelementptr inbounds %struct.LexState.235* %125, i32 0, i32 0
  %126 = load i32* %current184, align 4
  %cmp185 = icmp ne i32 %126, 61
  br i1 %cmp185, label %if.then187, label %if.else188

if.then187:                                       ; preds = %cond.end181
  store i32 62, i32* %retval
  br label %return

if.else188:                                       ; preds = %cond.end181
  %127 = load %struct.LexState.235** %ls.addr, align 8
  %z189 = getelementptr inbounds %struct.LexState.235* %127, i32 0, i32 7
  %128 = load %struct.Zio** %z189, align 8
  %n190 = getelementptr inbounds %struct.Zio* %128, i32 0, i32 0
  %129 = load i64* %n190, align 8
  %dec191 = add i64 %129, -1
  store i64 %dec191, i64* %n190, align 8
  %cmp192 = icmp ugt i64 %129, 0
  br i1 %cmp192, label %cond.true194, label %cond.false199

cond.true194:                                     ; preds = %if.else188
  %130 = load %struct.LexState.235** %ls.addr, align 8
  %z195 = getelementptr inbounds %struct.LexState.235* %130, i32 0, i32 7
  %131 = load %struct.Zio** %z195, align 8
  %p196 = getelementptr inbounds %struct.Zio* %131, i32 0, i32 1
  %132 = load i8** %p196, align 8
  %incdec.ptr197 = getelementptr inbounds i8* %132, i32 1
  store i8* %incdec.ptr197, i8** %p196, align 8
  %133 = load i8* %132, align 1
  %conv198 = zext i8 %133 to i32
  br label %cond.end202

cond.false199:                                    ; preds = %if.else188
  %134 = load %struct.LexState.235** %ls.addr, align 8
  %z200 = getelementptr inbounds %struct.LexState.235* %134, i32 0, i32 7
  %135 = load %struct.Zio** %z200, align 8
  %call201 = call i32 @luaZ_fill(%struct.Zio* %135)
  br label %cond.end202

cond.end202:                                      ; preds = %cond.false199, %cond.true194
  %cond203 = phi i32 [ %conv198, %cond.true194 ], [ %call201, %cond.false199 ]
  %136 = load %struct.LexState.235** %ls.addr, align 8
  %current204 = getelementptr inbounds %struct.LexState.235* %136, i32 0, i32 0
  store i32 %cond203, i32* %current204, align 4
  store i32 282, i32* %retval
  br label %return

sw.bb205:                                         ; preds = %for.cond
  %137 = load %struct.LexState.235** %ls.addr, align 8
  %z206 = getelementptr inbounds %struct.LexState.235* %137, i32 0, i32 7
  %138 = load %struct.Zio** %z206, align 8
  %n207 = getelementptr inbounds %struct.Zio* %138, i32 0, i32 0
  %139 = load i64* %n207, align 8
  %dec208 = add i64 %139, -1
  store i64 %dec208, i64* %n207, align 8
  %cmp209 = icmp ugt i64 %139, 0
  br i1 %cmp209, label %cond.true211, label %cond.false216

cond.true211:                                     ; preds = %sw.bb205
  %140 = load %struct.LexState.235** %ls.addr, align 8
  %z212 = getelementptr inbounds %struct.LexState.235* %140, i32 0, i32 7
  %141 = load %struct.Zio** %z212, align 8
  %p213 = getelementptr inbounds %struct.Zio* %141, i32 0, i32 1
  %142 = load i8** %p213, align 8
  %incdec.ptr214 = getelementptr inbounds i8* %142, i32 1
  store i8* %incdec.ptr214, i8** %p213, align 8
  %143 = load i8* %142, align 1
  %conv215 = zext i8 %143 to i32
  br label %cond.end219

cond.false216:                                    ; preds = %sw.bb205
  %144 = load %struct.LexState.235** %ls.addr, align 8
  %z217 = getelementptr inbounds %struct.LexState.235* %144, i32 0, i32 7
  %145 = load %struct.Zio** %z217, align 8
  %call218 = call i32 @luaZ_fill(%struct.Zio* %145)
  br label %cond.end219

cond.end219:                                      ; preds = %cond.false216, %cond.true211
  %cond220 = phi i32 [ %conv215, %cond.true211 ], [ %call218, %cond.false216 ]
  %146 = load %struct.LexState.235** %ls.addr, align 8
  %current221 = getelementptr inbounds %struct.LexState.235* %146, i32 0, i32 0
  store i32 %cond220, i32* %current221, align 4
  %147 = load %struct.LexState.235** %ls.addr, align 8
  %current222 = getelementptr inbounds %struct.LexState.235* %147, i32 0, i32 0
  %148 = load i32* %current222, align 4
  %cmp223 = icmp ne i32 %148, 61
  br i1 %cmp223, label %if.then225, label %if.else226

if.then225:                                       ; preds = %cond.end219
  store i32 126, i32* %retval
  br label %return

if.else226:                                       ; preds = %cond.end219
  %149 = load %struct.LexState.235** %ls.addr, align 8
  %z227 = getelementptr inbounds %struct.LexState.235* %149, i32 0, i32 7
  %150 = load %struct.Zio** %z227, align 8
  %n228 = getelementptr inbounds %struct.Zio* %150, i32 0, i32 0
  %151 = load i64* %n228, align 8
  %dec229 = add i64 %151, -1
  store i64 %dec229, i64* %n228, align 8
  %cmp230 = icmp ugt i64 %151, 0
  br i1 %cmp230, label %cond.true232, label %cond.false237

cond.true232:                                     ; preds = %if.else226
  %152 = load %struct.LexState.235** %ls.addr, align 8
  %z233 = getelementptr inbounds %struct.LexState.235* %152, i32 0, i32 7
  %153 = load %struct.Zio** %z233, align 8
  %p234 = getelementptr inbounds %struct.Zio* %153, i32 0, i32 1
  %154 = load i8** %p234, align 8
  %incdec.ptr235 = getelementptr inbounds i8* %154, i32 1
  store i8* %incdec.ptr235, i8** %p234, align 8
  %155 = load i8* %154, align 1
  %conv236 = zext i8 %155 to i32
  br label %cond.end240

cond.false237:                                    ; preds = %if.else226
  %156 = load %struct.LexState.235** %ls.addr, align 8
  %z238 = getelementptr inbounds %struct.LexState.235* %156, i32 0, i32 7
  %157 = load %struct.Zio** %z238, align 8
  %call239 = call i32 @luaZ_fill(%struct.Zio* %157)
  br label %cond.end240

cond.end240:                                      ; preds = %cond.false237, %cond.true232
  %cond241 = phi i32 [ %conv236, %cond.true232 ], [ %call239, %cond.false237 ]
  %158 = load %struct.LexState.235** %ls.addr, align 8
  %current242 = getelementptr inbounds %struct.LexState.235* %158, i32 0, i32 0
  store i32 %cond241, i32* %current242, align 4
  store i32 284, i32* %retval
  br label %return

sw.bb243:                                         ; preds = %for.cond
  %159 = load %struct.LexState.235** %ls.addr, align 8
  %z244 = getelementptr inbounds %struct.LexState.235* %159, i32 0, i32 7
  %160 = load %struct.Zio** %z244, align 8
  %n245 = getelementptr inbounds %struct.Zio* %160, i32 0, i32 0
  %161 = load i64* %n245, align 8
  %dec246 = add i64 %161, -1
  store i64 %dec246, i64* %n245, align 8
  %cmp247 = icmp ugt i64 %161, 0
  br i1 %cmp247, label %cond.true249, label %cond.false254

cond.true249:                                     ; preds = %sw.bb243
  %162 = load %struct.LexState.235** %ls.addr, align 8
  %z250 = getelementptr inbounds %struct.LexState.235* %162, i32 0, i32 7
  %163 = load %struct.Zio** %z250, align 8
  %p251 = getelementptr inbounds %struct.Zio* %163, i32 0, i32 1
  %164 = load i8** %p251, align 8
  %incdec.ptr252 = getelementptr inbounds i8* %164, i32 1
  store i8* %incdec.ptr252, i8** %p251, align 8
  %165 = load i8* %164, align 1
  %conv253 = zext i8 %165 to i32
  br label %cond.end257

cond.false254:                                    ; preds = %sw.bb243
  %166 = load %struct.LexState.235** %ls.addr, align 8
  %z255 = getelementptr inbounds %struct.LexState.235* %166, i32 0, i32 7
  %167 = load %struct.Zio** %z255, align 8
  %call256 = call i32 @luaZ_fill(%struct.Zio* %167)
  br label %cond.end257

cond.end257:                                      ; preds = %cond.false254, %cond.true249
  %cond258 = phi i32 [ %conv253, %cond.true249 ], [ %call256, %cond.false254 ]
  %168 = load %struct.LexState.235** %ls.addr, align 8
  %current259 = getelementptr inbounds %struct.LexState.235* %168, i32 0, i32 0
  store i32 %cond258, i32* %current259, align 4
  %169 = load %struct.LexState.235** %ls.addr, align 8
  %current260 = getelementptr inbounds %struct.LexState.235* %169, i32 0, i32 0
  %170 = load i32* %current260, align 4
  %cmp261 = icmp ne i32 %170, 58
  br i1 %cmp261, label %if.then263, label %if.else264

if.then263:                                       ; preds = %cond.end257
  store i32 58, i32* %retval
  br label %return

if.else264:                                       ; preds = %cond.end257
  %171 = load %struct.LexState.235** %ls.addr, align 8
  %z265 = getelementptr inbounds %struct.LexState.235* %171, i32 0, i32 7
  %172 = load %struct.Zio** %z265, align 8
  %n266 = getelementptr inbounds %struct.Zio* %172, i32 0, i32 0
  %173 = load i64* %n266, align 8
  %dec267 = add i64 %173, -1
  store i64 %dec267, i64* %n266, align 8
  %cmp268 = icmp ugt i64 %173, 0
  br i1 %cmp268, label %cond.true270, label %cond.false275

cond.true270:                                     ; preds = %if.else264
  %174 = load %struct.LexState.235** %ls.addr, align 8
  %z271 = getelementptr inbounds %struct.LexState.235* %174, i32 0, i32 7
  %175 = load %struct.Zio** %z271, align 8
  %p272 = getelementptr inbounds %struct.Zio* %175, i32 0, i32 1
  %176 = load i8** %p272, align 8
  %incdec.ptr273 = getelementptr inbounds i8* %176, i32 1
  store i8* %incdec.ptr273, i8** %p272, align 8
  %177 = load i8* %176, align 1
  %conv274 = zext i8 %177 to i32
  br label %cond.end278

cond.false275:                                    ; preds = %if.else264
  %178 = load %struct.LexState.235** %ls.addr, align 8
  %z276 = getelementptr inbounds %struct.LexState.235* %178, i32 0, i32 7
  %179 = load %struct.Zio** %z276, align 8
  %call277 = call i32 @luaZ_fill(%struct.Zio* %179)
  br label %cond.end278

cond.end278:                                      ; preds = %cond.false275, %cond.true270
  %cond279 = phi i32 [ %conv274, %cond.true270 ], [ %call277, %cond.false275 ]
  %180 = load %struct.LexState.235** %ls.addr, align 8
  %current280 = getelementptr inbounds %struct.LexState.235* %180, i32 0, i32 0
  store i32 %cond279, i32* %current280, align 4
  store i32 285, i32* %retval
  br label %return

sw.bb281:                                         ; preds = %for.cond, %for.cond
  %181 = load %struct.LexState.235** %ls.addr, align 8
  %182 = load %struct.LexState.235** %ls.addr, align 8
  %current282 = getelementptr inbounds %struct.LexState.235* %182, i32 0, i32 0
  %183 = load i32* %current282, align 4
  %184 = load %union.SemInfo** %seminfo.addr, align 8
  call void @read_string(%struct.LexState.235* %181, i32 %183, %union.SemInfo* %184)
  store i32 289, i32* %retval
  br label %return

sw.bb283:                                         ; preds = %for.cond
  %185 = load %struct.LexState.235** %ls.addr, align 8
  %186 = load %struct.LexState.235** %ls.addr, align 8
  %current284 = getelementptr inbounds %struct.LexState.235* %186, i32 0, i32 0
  %187 = load i32* %current284, align 4
  call void @save(%struct.LexState.235* %185, i32 %187)
  %188 = load %struct.LexState.235** %ls.addr, align 8
  %z285 = getelementptr inbounds %struct.LexState.235* %188, i32 0, i32 7
  %189 = load %struct.Zio** %z285, align 8
  %n286 = getelementptr inbounds %struct.Zio* %189, i32 0, i32 0
  %190 = load i64* %n286, align 8
  %dec287 = add i64 %190, -1
  store i64 %dec287, i64* %n286, align 8
  %cmp288 = icmp ugt i64 %190, 0
  br i1 %cmp288, label %cond.true290, label %cond.false295

cond.true290:                                     ; preds = %sw.bb283
  %191 = load %struct.LexState.235** %ls.addr, align 8
  %z291 = getelementptr inbounds %struct.LexState.235* %191, i32 0, i32 7
  %192 = load %struct.Zio** %z291, align 8
  %p292 = getelementptr inbounds %struct.Zio* %192, i32 0, i32 1
  %193 = load i8** %p292, align 8
  %incdec.ptr293 = getelementptr inbounds i8* %193, i32 1
  store i8* %incdec.ptr293, i8** %p292, align 8
  %194 = load i8* %193, align 1
  %conv294 = zext i8 %194 to i32
  br label %cond.end298

cond.false295:                                    ; preds = %sw.bb283
  %195 = load %struct.LexState.235** %ls.addr, align 8
  %z296 = getelementptr inbounds %struct.LexState.235* %195, i32 0, i32 7
  %196 = load %struct.Zio** %z296, align 8
  %call297 = call i32 @luaZ_fill(%struct.Zio* %196)
  br label %cond.end298

cond.end298:                                      ; preds = %cond.false295, %cond.true290
  %cond299 = phi i32 [ %conv294, %cond.true290 ], [ %call297, %cond.false295 ]
  %197 = load %struct.LexState.235** %ls.addr, align 8
  %current300 = getelementptr inbounds %struct.LexState.235* %197, i32 0, i32 0
  store i32 %cond299, i32* %current300, align 4
  %198 = load %struct.LexState.235** %ls.addr, align 8
  %call301 = call i32 @check_next(%struct.LexState.235* %198, i8* getelementptr inbounds ([2 x i8]* @.str5362, i32 0, i32 0))
  %tobool = icmp ne i32 %call301, 0
  br i1 %tobool, label %if.then302, label %if.else307

if.then302:                                       ; preds = %cond.end298
  %199 = load %struct.LexState.235** %ls.addr, align 8
  %call303 = call i32 @check_next(%struct.LexState.235* %199, i8* getelementptr inbounds ([2 x i8]* @.str5362, i32 0, i32 0))
  %tobool304 = icmp ne i32 %call303, 0
  br i1 %tobool304, label %if.then305, label %if.else306

if.then305:                                       ; preds = %if.then302
  store i32 280, i32* %retval
  br label %return

if.else306:                                       ; preds = %if.then302
  store i32 279, i32* %retval
  br label %return

if.else307:                                       ; preds = %cond.end298
  %200 = load %struct.LexState.235** %ls.addr, align 8
  %current308 = getelementptr inbounds %struct.LexState.235* %200, i32 0, i32 0
  %201 = load i32* %current308, align 4
  %add = add nsw i32 %201, 1
  %idxprom = sext i32 %add to i64
  %arrayidx = getelementptr inbounds [257 x i8]* @luai_ctype_, i32 0, i64 %idxprom
  %202 = load i8* %arrayidx, align 1
  %conv309 = zext i8 %202 to i32
  %and = and i32 %conv309, 2
  %tobool310 = icmp ne i32 %and, 0
  br i1 %tobool310, label %if.end312, label %if.then311

if.then311:                                       ; preds = %if.else307
  store i32 46, i32* %retval
  br label %return

if.end312:                                        ; preds = %if.else307
  br label %if.end313

if.end313:                                        ; preds = %if.end312
  br label %sw.bb314

sw.bb314:                                         ; preds = %if.end313, %for.cond, %for.cond, %for.cond, %for.cond, %for.cond, %for.cond, %for.cond, %for.cond, %for.cond, %for.cond
  %203 = load %struct.LexState.235** %ls.addr, align 8
  %204 = load %union.SemInfo** %seminfo.addr, align 8
  call void @read_numeral(%struct.LexState.235* %203, %union.SemInfo* %204)
  store i32 287, i32* %retval
  br label %return

sw.bb315:                                         ; preds = %for.cond
  store i32 286, i32* %retval
  br label %return

sw.default:                                       ; preds = %for.cond
  %205 = load %struct.LexState.235** %ls.addr, align 8
  %current316 = getelementptr inbounds %struct.LexState.235* %205, i32 0, i32 0
  %206 = load i32* %current316, align 4
  %add317 = add nsw i32 %206, 1
  %idxprom318 = sext i32 %add317 to i64
  %arrayidx319 = getelementptr inbounds [257 x i8]* @luai_ctype_, i32 0, i64 %idxprom318
  %207 = load i8* %arrayidx319, align 1
  %conv320 = zext i8 %207 to i32
  %and321 = and i32 %conv320, 1
  %tobool322 = icmp ne i32 %and321, 0
  br i1 %tobool322, label %if.then323, label %if.else366

if.then323:                                       ; preds = %sw.default
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.then323
  %208 = load %struct.LexState.235** %ls.addr, align 8
  %209 = load %struct.LexState.235** %ls.addr, align 8
  %current324 = getelementptr inbounds %struct.LexState.235* %209, i32 0, i32 0
  %210 = load i32* %current324, align 4
  call void @save(%struct.LexState.235* %208, i32 %210)
  %211 = load %struct.LexState.235** %ls.addr, align 8
  %z325 = getelementptr inbounds %struct.LexState.235* %211, i32 0, i32 7
  %212 = load %struct.Zio** %z325, align 8
  %n326 = getelementptr inbounds %struct.Zio* %212, i32 0, i32 0
  %213 = load i64* %n326, align 8
  %dec327 = add i64 %213, -1
  store i64 %dec327, i64* %n326, align 8
  %cmp328 = icmp ugt i64 %213, 0
  br i1 %cmp328, label %cond.true330, label %cond.false335

cond.true330:                                     ; preds = %do.body
  %214 = load %struct.LexState.235** %ls.addr, align 8
  %z331 = getelementptr inbounds %struct.LexState.235* %214, i32 0, i32 7
  %215 = load %struct.Zio** %z331, align 8
  %p332 = getelementptr inbounds %struct.Zio* %215, i32 0, i32 1
  %216 = load i8** %p332, align 8
  %incdec.ptr333 = getelementptr inbounds i8* %216, i32 1
  store i8* %incdec.ptr333, i8** %p332, align 8
  %217 = load i8* %216, align 1
  %conv334 = zext i8 %217 to i32
  br label %cond.end338

cond.false335:                                    ; preds = %do.body
  %218 = load %struct.LexState.235** %ls.addr, align 8
  %z336 = getelementptr inbounds %struct.LexState.235* %218, i32 0, i32 7
  %219 = load %struct.Zio** %z336, align 8
  %call337 = call i32 @luaZ_fill(%struct.Zio* %219)
  br label %cond.end338

cond.end338:                                      ; preds = %cond.false335, %cond.true330
  %cond339 = phi i32 [ %conv334, %cond.true330 ], [ %call337, %cond.false335 ]
  %220 = load %struct.LexState.235** %ls.addr, align 8
  %current340 = getelementptr inbounds %struct.LexState.235* %220, i32 0, i32 0
  store i32 %cond339, i32* %current340, align 4
  br label %do.cond

do.cond:                                          ; preds = %cond.end338
  %221 = load %struct.LexState.235** %ls.addr, align 8
  %current341 = getelementptr inbounds %struct.LexState.235* %221, i32 0, i32 0
  %222 = load i32* %current341, align 4
  %add342 = add nsw i32 %222, 1
  %idxprom343 = sext i32 %add342 to i64
  %arrayidx344 = getelementptr inbounds [257 x i8]* @luai_ctype_, i32 0, i64 %idxprom343
  %223 = load i8* %arrayidx344, align 1
  %conv345 = zext i8 %223 to i32
  %and346 = and i32 %conv345, 3
  %tobool347 = icmp ne i32 %and346, 0
  br i1 %tobool347, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  %224 = load %struct.LexState.235** %ls.addr, align 8
  %225 = load %struct.LexState.235** %ls.addr, align 8
  %buff348 = getelementptr inbounds %struct.LexState.235* %225, i32 0, i32 8
  %226 = load %struct.Mbuffer** %buff348, align 8
  %buffer = getelementptr inbounds %struct.Mbuffer* %226, i32 0, i32 0
  %227 = load i8** %buffer, align 8
  %228 = load %struct.LexState.235** %ls.addr, align 8
  %buff349 = getelementptr inbounds %struct.LexState.235* %228, i32 0, i32 8
  %229 = load %struct.Mbuffer** %buff349, align 8
  %n350 = getelementptr inbounds %struct.Mbuffer* %229, i32 0, i32 1
  %230 = load i64* %n350, align 8
  %call351 = call %union.TString* @luaX_newstring(%struct.LexState.235* %224, i8* %227, i64 %230)
  store %union.TString* %call351, %union.TString** %ts, align 8
  %231 = load %union.TString** %ts, align 8
  %232 = load %union.SemInfo** %seminfo.addr, align 8
  %ts352 = bitcast %union.SemInfo* %232 to %union.TString**
  store %union.TString* %231, %union.TString** %ts352, align 8
  %233 = load %union.TString** %ts, align 8
  %tsv = bitcast %union.TString* %233 to %struct.anon.0*
  %tt = getelementptr inbounds %struct.anon.0* %tsv, i32 0, i32 1
  %234 = load i8* %tt, align 1
  %conv353 = zext i8 %234 to i32
  %cmp354 = icmp eq i32 %conv353, 4
  br i1 %cmp354, label %land.lhs.true, label %if.else365

land.lhs.true:                                    ; preds = %do.end
  %235 = load %union.TString** %ts, align 8
  %tsv356 = bitcast %union.TString* %235 to %struct.anon.0*
  %extra = getelementptr inbounds %struct.anon.0* %tsv356, i32 0, i32 3
  %236 = load i8* %extra, align 1
  %conv357 = zext i8 %236 to i32
  %cmp358 = icmp sgt i32 %conv357, 0
  br i1 %cmp358, label %if.then360, label %if.else365

if.then360:                                       ; preds = %land.lhs.true
  %237 = load %union.TString** %ts, align 8
  %tsv361 = bitcast %union.TString* %237 to %struct.anon.0*
  %extra362 = getelementptr inbounds %struct.anon.0* %tsv361, i32 0, i32 3
  %238 = load i8* %extra362, align 1
  %conv363 = zext i8 %238 to i32
  %sub = sub nsw i32 %conv363, 1
  %add364 = add nsw i32 %sub, 257
  store i32 %add364, i32* %retval
  br label %return

if.else365:                                       ; preds = %land.lhs.true, %do.end
  store i32 288, i32* %retval
  br label %return

if.else366:                                       ; preds = %sw.default
  %239 = load %struct.LexState.235** %ls.addr, align 8
  %current367 = getelementptr inbounds %struct.LexState.235* %239, i32 0, i32 0
  %240 = load i32* %current367, align 4
  store i32 %240, i32* %c, align 4
  %241 = load %struct.LexState.235** %ls.addr, align 8
  %z368 = getelementptr inbounds %struct.LexState.235* %241, i32 0, i32 7
  %242 = load %struct.Zio** %z368, align 8
  %n369 = getelementptr inbounds %struct.Zio* %242, i32 0, i32 0
  %243 = load i64* %n369, align 8
  %dec370 = add i64 %243, -1
  store i64 %dec370, i64* %n369, align 8
  %cmp371 = icmp ugt i64 %243, 0
  br i1 %cmp371, label %cond.true373, label %cond.false378

cond.true373:                                     ; preds = %if.else366
  %244 = load %struct.LexState.235** %ls.addr, align 8
  %z374 = getelementptr inbounds %struct.LexState.235* %244, i32 0, i32 7
  %245 = load %struct.Zio** %z374, align 8
  %p375 = getelementptr inbounds %struct.Zio* %245, i32 0, i32 1
  %246 = load i8** %p375, align 8
  %incdec.ptr376 = getelementptr inbounds i8* %246, i32 1
  store i8* %incdec.ptr376, i8** %p375, align 8
  %247 = load i8* %246, align 1
  %conv377 = zext i8 %247 to i32
  br label %cond.end381

cond.false378:                                    ; preds = %if.else366
  %248 = load %struct.LexState.235** %ls.addr, align 8
  %z379 = getelementptr inbounds %struct.LexState.235* %248, i32 0, i32 7
  %249 = load %struct.Zio** %z379, align 8
  %call380 = call i32 @luaZ_fill(%struct.Zio* %249)
  br label %cond.end381

cond.end381:                                      ; preds = %cond.false378, %cond.true373
  %cond382 = phi i32 [ %conv377, %cond.true373 ], [ %call380, %cond.false378 ]
  %250 = load %struct.LexState.235** %ls.addr, align 8
  %current383 = getelementptr inbounds %struct.LexState.235* %250, i32 0, i32 0
  store i32 %cond382, i32* %current383, align 4
  %251 = load i32* %c, align 4
  store i32 %251, i32* %retval
  br label %return

sw.epilog:                                        ; preds = %while.end, %if.then51, %cond.end, %sw.bb
  br label %for.cond

return:                                           ; preds = %cond.end381, %if.else365, %if.then360, %sw.bb315, %sw.bb314, %if.then311, %if.else306, %if.then305, %sw.bb281, %cond.end278, %if.then263, %cond.end240, %if.then225, %cond.end202, %if.then187, %cond.end164, %if.then149, %cond.end126, %if.then111, %if.then89, %if.then86, %if.then
  %252 = load i32* %retval
  ret i32 %252
}

; Function Attrs: nounwind uwtable
define internal i8* @txtToken(%struct.LexState.235* %ls, i32 %token) #0 {
entry:
  %retval = alloca i8*, align 8
  %ls.addr = alloca %struct.LexState.235*, align 8
  %token.addr = alloca i32, align 4
  store %struct.LexState.235* %ls, %struct.LexState.235** %ls.addr, align 8
  store i32 %token, i32* %token.addr, align 4
  %0 = load i32* %token.addr, align 4
  switch i32 %0, label %sw.default [
    i32 288, label %sw.bb
    i32 289, label %sw.bb
    i32 287, label %sw.bb
  ]

sw.bb:                                            ; preds = %entry, %entry, %entry
  %1 = load %struct.LexState.235** %ls.addr, align 8
  call void @save(%struct.LexState.235* %1, i32 0)
  %2 = load %struct.LexState.235** %ls.addr, align 8
  %L = getelementptr inbounds %struct.LexState.235* %2, i32 0, i32 6
  %3 = load %struct.lua_State** %L, align 8
  %4 = load %struct.LexState.235** %ls.addr, align 8
  %buff = getelementptr inbounds %struct.LexState.235* %4, i32 0, i32 8
  %5 = load %struct.Mbuffer** %buff, align 8
  %buffer = getelementptr inbounds %struct.Mbuffer* %5, i32 0, i32 0
  %6 = load i8** %buffer, align 8
  %call = call i8* (%struct.lua_State*, i8*, ...)* bitcast (i8* (%struct.lua_State.279*, i8*, ...)* @luaO_pushfstring to i8* (%struct.lua_State*, i8*, ...)*)(%struct.lua_State* %3, i8* getelementptr inbounds ([5 x i8]* @.str2359, i32 0, i32 0), i8* %6)
  store i8* %call, i8** %retval
  br label %return

sw.default:                                       ; preds = %entry
  %7 = load %struct.LexState.235** %ls.addr, align 8
  %8 = load i32* %token.addr, align 4
  %call1 = call i8* @luaX_token2str(%struct.LexState.235* %7, i32 %8)
  store i8* %call1, i8** %retval
  br label %return

return:                                           ; preds = %sw.default, %sw.bb
  %9 = load i8** %retval
  ret i8* %9
}

; Function Attrs: nounwind uwtable
define internal void @inclinenumber(%struct.LexState.235* %ls) #0 {
entry:
  %ls.addr = alloca %struct.LexState.235*, align 8
  %old = alloca i32, align 4
  store %struct.LexState.235* %ls, %struct.LexState.235** %ls.addr, align 8
  %0 = load %struct.LexState.235** %ls.addr, align 8
  %current = getelementptr inbounds %struct.LexState.235* %0, i32 0, i32 0
  %1 = load i32* %current, align 4
  store i32 %1, i32* %old, align 4
  %2 = load %struct.LexState.235** %ls.addr, align 8
  %z = getelementptr inbounds %struct.LexState.235* %2, i32 0, i32 7
  %3 = load %struct.Zio** %z, align 8
  %n = getelementptr inbounds %struct.Zio* %3, i32 0, i32 0
  %4 = load i64* %n, align 8
  %dec = add i64 %4, -1
  store i64 %dec, i64* %n, align 8
  %cmp = icmp ugt i64 %4, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %5 = load %struct.LexState.235** %ls.addr, align 8
  %z1 = getelementptr inbounds %struct.LexState.235* %5, i32 0, i32 7
  %6 = load %struct.Zio** %z1, align 8
  %p = getelementptr inbounds %struct.Zio* %6, i32 0, i32 1
  %7 = load i8** %p, align 8
  %incdec.ptr = getelementptr inbounds i8* %7, i32 1
  store i8* %incdec.ptr, i8** %p, align 8
  %8 = load i8* %7, align 1
  %conv = zext i8 %8 to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  %9 = load %struct.LexState.235** %ls.addr, align 8
  %z2 = getelementptr inbounds %struct.LexState.235* %9, i32 0, i32 7
  %10 = load %struct.Zio** %z2, align 8
  %call = call i32 @luaZ_fill(%struct.Zio* %10)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv, %cond.true ], [ %call, %cond.false ]
  %11 = load %struct.LexState.235** %ls.addr, align 8
  %current3 = getelementptr inbounds %struct.LexState.235* %11, i32 0, i32 0
  store i32 %cond, i32* %current3, align 4
  %12 = load %struct.LexState.235** %ls.addr, align 8
  %current4 = getelementptr inbounds %struct.LexState.235* %12, i32 0, i32 0
  %13 = load i32* %current4, align 4
  %cmp5 = icmp eq i32 %13, 10
  br i1 %cmp5, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end
  %14 = load %struct.LexState.235** %ls.addr, align 8
  %current7 = getelementptr inbounds %struct.LexState.235* %14, i32 0, i32 0
  %15 = load i32* %current7, align 4
  %cmp8 = icmp eq i32 %15, 13
  br i1 %cmp8, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.lhs.false, %cond.end
  %16 = load %struct.LexState.235** %ls.addr, align 8
  %current10 = getelementptr inbounds %struct.LexState.235* %16, i32 0, i32 0
  %17 = load i32* %current10, align 4
  %18 = load i32* %old, align 4
  %cmp11 = icmp ne i32 %17, %18
  br i1 %cmp11, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %19 = load %struct.LexState.235** %ls.addr, align 8
  %z13 = getelementptr inbounds %struct.LexState.235* %19, i32 0, i32 7
  %20 = load %struct.Zio** %z13, align 8
  %n14 = getelementptr inbounds %struct.Zio* %20, i32 0, i32 0
  %21 = load i64* %n14, align 8
  %dec15 = add i64 %21, -1
  store i64 %dec15, i64* %n14, align 8
  %cmp16 = icmp ugt i64 %21, 0
  br i1 %cmp16, label %cond.true18, label %cond.false23

cond.true18:                                      ; preds = %if.then
  %22 = load %struct.LexState.235** %ls.addr, align 8
  %z19 = getelementptr inbounds %struct.LexState.235* %22, i32 0, i32 7
  %23 = load %struct.Zio** %z19, align 8
  %p20 = getelementptr inbounds %struct.Zio* %23, i32 0, i32 1
  %24 = load i8** %p20, align 8
  %incdec.ptr21 = getelementptr inbounds i8* %24, i32 1
  store i8* %incdec.ptr21, i8** %p20, align 8
  %25 = load i8* %24, align 1
  %conv22 = zext i8 %25 to i32
  br label %cond.end26

cond.false23:                                     ; preds = %if.then
  %26 = load %struct.LexState.235** %ls.addr, align 8
  %z24 = getelementptr inbounds %struct.LexState.235* %26, i32 0, i32 7
  %27 = load %struct.Zio** %z24, align 8
  %call25 = call i32 @luaZ_fill(%struct.Zio* %27)
  br label %cond.end26

cond.end26:                                       ; preds = %cond.false23, %cond.true18
  %cond27 = phi i32 [ %conv22, %cond.true18 ], [ %call25, %cond.false23 ]
  %28 = load %struct.LexState.235** %ls.addr, align 8
  %current28 = getelementptr inbounds %struct.LexState.235* %28, i32 0, i32 0
  store i32 %cond27, i32* %current28, align 4
  br label %if.end

if.end:                                           ; preds = %cond.end26, %land.lhs.true, %lor.lhs.false
  %29 = load %struct.LexState.235** %ls.addr, align 8
  %linenumber = getelementptr inbounds %struct.LexState.235* %29, i32 0, i32 1
  %30 = load i32* %linenumber, align 4
  %inc = add nsw i32 %30, 1
  store i32 %inc, i32* %linenumber, align 4
  %cmp29 = icmp sge i32 %inc, 2147483645
  br i1 %cmp29, label %if.then31, label %if.end32

if.then31:                                        ; preds = %if.end
  %31 = load %struct.LexState.235** %ls.addr, align 8
  call void @luaX_syntaxerror(%struct.LexState.235* %31, i8* getelementptr inbounds ([25 x i8]* @.str18375, i32 0, i32 0)) #9
  unreachable

if.end32:                                         ; preds = %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @skip_sep(%struct.LexState.235* %ls) #0 {
entry:
  %ls.addr = alloca %struct.LexState.235*, align 8
  %count = alloca i32, align 4
  %s = alloca i32, align 4
  store %struct.LexState.235* %ls, %struct.LexState.235** %ls.addr, align 8
  store i32 0, i32* %count, align 4
  %0 = load %struct.LexState.235** %ls.addr, align 8
  %current = getelementptr inbounds %struct.LexState.235* %0, i32 0, i32 0
  %1 = load i32* %current, align 4
  store i32 %1, i32* %s, align 4
  %2 = load %struct.LexState.235** %ls.addr, align 8
  %3 = load %struct.LexState.235** %ls.addr, align 8
  %current1 = getelementptr inbounds %struct.LexState.235* %3, i32 0, i32 0
  %4 = load i32* %current1, align 4
  call void @save(%struct.LexState.235* %2, i32 %4)
  %5 = load %struct.LexState.235** %ls.addr, align 8
  %z = getelementptr inbounds %struct.LexState.235* %5, i32 0, i32 7
  %6 = load %struct.Zio** %z, align 8
  %n = getelementptr inbounds %struct.Zio* %6, i32 0, i32 0
  %7 = load i64* %n, align 8
  %dec = add i64 %7, -1
  store i64 %dec, i64* %n, align 8
  %cmp = icmp ugt i64 %7, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %8 = load %struct.LexState.235** %ls.addr, align 8
  %z2 = getelementptr inbounds %struct.LexState.235* %8, i32 0, i32 7
  %9 = load %struct.Zio** %z2, align 8
  %p = getelementptr inbounds %struct.Zio* %9, i32 0, i32 1
  %10 = load i8** %p, align 8
  %incdec.ptr = getelementptr inbounds i8* %10, i32 1
  store i8* %incdec.ptr, i8** %p, align 8
  %11 = load i8* %10, align 1
  %conv = zext i8 %11 to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  %12 = load %struct.LexState.235** %ls.addr, align 8
  %z3 = getelementptr inbounds %struct.LexState.235* %12, i32 0, i32 7
  %13 = load %struct.Zio** %z3, align 8
  %call = call i32 @luaZ_fill(%struct.Zio* %13)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv, %cond.true ], [ %call, %cond.false ]
  %14 = load %struct.LexState.235** %ls.addr, align 8
  %current4 = getelementptr inbounds %struct.LexState.235* %14, i32 0, i32 0
  store i32 %cond, i32* %current4, align 4
  br label %while.cond

while.cond:                                       ; preds = %cond.end22, %cond.end
  %15 = load %struct.LexState.235** %ls.addr, align 8
  %current5 = getelementptr inbounds %struct.LexState.235* %15, i32 0, i32 0
  %16 = load i32* %current5, align 4
  %cmp6 = icmp eq i32 %16, 61
  br i1 %cmp6, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %17 = load %struct.LexState.235** %ls.addr, align 8
  %18 = load %struct.LexState.235** %ls.addr, align 8
  %current8 = getelementptr inbounds %struct.LexState.235* %18, i32 0, i32 0
  %19 = load i32* %current8, align 4
  call void @save(%struct.LexState.235* %17, i32 %19)
  %20 = load %struct.LexState.235** %ls.addr, align 8
  %z9 = getelementptr inbounds %struct.LexState.235* %20, i32 0, i32 7
  %21 = load %struct.Zio** %z9, align 8
  %n10 = getelementptr inbounds %struct.Zio* %21, i32 0, i32 0
  %22 = load i64* %n10, align 8
  %dec11 = add i64 %22, -1
  store i64 %dec11, i64* %n10, align 8
  %cmp12 = icmp ugt i64 %22, 0
  br i1 %cmp12, label %cond.true14, label %cond.false19

cond.true14:                                      ; preds = %while.body
  %23 = load %struct.LexState.235** %ls.addr, align 8
  %z15 = getelementptr inbounds %struct.LexState.235* %23, i32 0, i32 7
  %24 = load %struct.Zio** %z15, align 8
  %p16 = getelementptr inbounds %struct.Zio* %24, i32 0, i32 1
  %25 = load i8** %p16, align 8
  %incdec.ptr17 = getelementptr inbounds i8* %25, i32 1
  store i8* %incdec.ptr17, i8** %p16, align 8
  %26 = load i8* %25, align 1
  %conv18 = zext i8 %26 to i32
  br label %cond.end22

cond.false19:                                     ; preds = %while.body
  %27 = load %struct.LexState.235** %ls.addr, align 8
  %z20 = getelementptr inbounds %struct.LexState.235* %27, i32 0, i32 7
  %28 = load %struct.Zio** %z20, align 8
  %call21 = call i32 @luaZ_fill(%struct.Zio* %28)
  br label %cond.end22

cond.end22:                                       ; preds = %cond.false19, %cond.true14
  %cond23 = phi i32 [ %conv18, %cond.true14 ], [ %call21, %cond.false19 ]
  %29 = load %struct.LexState.235** %ls.addr, align 8
  %current24 = getelementptr inbounds %struct.LexState.235* %29, i32 0, i32 0
  store i32 %cond23, i32* %current24, align 4
  %30 = load i32* %count, align 4
  %inc = add nsw i32 %30, 1
  store i32 %inc, i32* %count, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %31 = load %struct.LexState.235** %ls.addr, align 8
  %current25 = getelementptr inbounds %struct.LexState.235* %31, i32 0, i32 0
  %32 = load i32* %current25, align 4
  %33 = load i32* %s, align 4
  %cmp26 = icmp eq i32 %32, %33
  br i1 %cmp26, label %cond.true28, label %cond.false29

cond.true28:                                      ; preds = %while.end
  %34 = load i32* %count, align 4
  br label %cond.end31

cond.false29:                                     ; preds = %while.end
  %35 = load i32* %count, align 4
  %sub = sub nsw i32 0, %35
  %sub30 = sub nsw i32 %sub, 1
  br label %cond.end31

cond.end31:                                       ; preds = %cond.false29, %cond.true28
  %cond32 = phi i32 [ %34, %cond.true28 ], [ %sub30, %cond.false29 ]
  ret i32 %cond32
}

; Function Attrs: nounwind uwtable
define internal void @read_long_string(%struct.LexState.235* %ls, %union.SemInfo* %seminfo, i32 %sep) #0 {
entry:
  %ls.addr = alloca %struct.LexState.235*, align 8
  %seminfo.addr = alloca %union.SemInfo*, align 8
  %sep.addr = alloca i32, align 4
  store %struct.LexState.235* %ls, %struct.LexState.235** %ls.addr, align 8
  store %union.SemInfo* %seminfo, %union.SemInfo** %seminfo.addr, align 8
  store i32 %sep, i32* %sep.addr, align 4
  %0 = load %struct.LexState.235** %ls.addr, align 8
  %1 = load %struct.LexState.235** %ls.addr, align 8
  %current = getelementptr inbounds %struct.LexState.235* %1, i32 0, i32 0
  %2 = load i32* %current, align 4
  call void @save(%struct.LexState.235* %0, i32 %2)
  %3 = load %struct.LexState.235** %ls.addr, align 8
  %z = getelementptr inbounds %struct.LexState.235* %3, i32 0, i32 7
  %4 = load %struct.Zio** %z, align 8
  %n = getelementptr inbounds %struct.Zio* %4, i32 0, i32 0
  %5 = load i64* %n, align 8
  %dec = add i64 %5, -1
  store i64 %dec, i64* %n, align 8
  %cmp = icmp ugt i64 %5, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %6 = load %struct.LexState.235** %ls.addr, align 8
  %z1 = getelementptr inbounds %struct.LexState.235* %6, i32 0, i32 7
  %7 = load %struct.Zio** %z1, align 8
  %p = getelementptr inbounds %struct.Zio* %7, i32 0, i32 1
  %8 = load i8** %p, align 8
  %incdec.ptr = getelementptr inbounds i8* %8, i32 1
  store i8* %incdec.ptr, i8** %p, align 8
  %9 = load i8* %8, align 1
  %conv = zext i8 %9 to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  %10 = load %struct.LexState.235** %ls.addr, align 8
  %z2 = getelementptr inbounds %struct.LexState.235* %10, i32 0, i32 7
  %11 = load %struct.Zio** %z2, align 8
  %call = call i32 @luaZ_fill(%struct.Zio* %11)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv, %cond.true ], [ %call, %cond.false ]
  %12 = load %struct.LexState.235** %ls.addr, align 8
  %current3 = getelementptr inbounds %struct.LexState.235* %12, i32 0, i32 0
  store i32 %cond, i32* %current3, align 4
  %13 = load %struct.LexState.235** %ls.addr, align 8
  %current4 = getelementptr inbounds %struct.LexState.235* %13, i32 0, i32 0
  %14 = load i32* %current4, align 4
  %cmp5 = icmp eq i32 %14, 10
  br i1 %cmp5, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end
  %15 = load %struct.LexState.235** %ls.addr, align 8
  %current7 = getelementptr inbounds %struct.LexState.235* %15, i32 0, i32 0
  %16 = load i32* %current7, align 4
  %cmp8 = icmp eq i32 %16, 13
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %cond.end
  %17 = load %struct.LexState.235** %ls.addr, align 8
  call void @inclinenumber(%struct.LexState.235* %17)
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  br label %for.cond

for.cond:                                         ; preds = %sw.epilog, %if.end
  %18 = load %struct.LexState.235** %ls.addr, align 8
  %current10 = getelementptr inbounds %struct.LexState.235* %18, i32 0, i32 0
  %19 = load i32* %current10, align 4
  switch i32 %19, label %sw.default [
    i32 -1, label %sw.bb
    i32 93, label %sw.bb12
    i32 10, label %sw.bb35
    i32 13, label %sw.bb35
  ]

sw.bb:                                            ; preds = %for.cond
  %20 = load %struct.LexState.235** %ls.addr, align 8
  %21 = load %union.SemInfo** %seminfo.addr, align 8
  %tobool = icmp ne %union.SemInfo* %21, null
  %cond11 = select i1 %tobool, i8* getelementptr inbounds ([23 x i8]* @.str16373, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8]* @.str17374, i32 0, i32 0)
  call void @lexerror(%struct.LexState.235* %20, i8* %cond11, i32 286) #9
  unreachable

sw.bb12:                                          ; preds = %for.cond
  %22 = load %struct.LexState.235** %ls.addr, align 8
  %call13 = call i32 @skip_sep(%struct.LexState.235* %22)
  %23 = load i32* %sep.addr, align 4
  %cmp14 = icmp eq i32 %call13, %23
  br i1 %cmp14, label %if.then16, label %if.end34

if.then16:                                        ; preds = %sw.bb12
  %24 = load %struct.LexState.235** %ls.addr, align 8
  %25 = load %struct.LexState.235** %ls.addr, align 8
  %current17 = getelementptr inbounds %struct.LexState.235* %25, i32 0, i32 0
  %26 = load i32* %current17, align 4
  call void @save(%struct.LexState.235* %24, i32 %26)
  %27 = load %struct.LexState.235** %ls.addr, align 8
  %z18 = getelementptr inbounds %struct.LexState.235* %27, i32 0, i32 7
  %28 = load %struct.Zio** %z18, align 8
  %n19 = getelementptr inbounds %struct.Zio* %28, i32 0, i32 0
  %29 = load i64* %n19, align 8
  %dec20 = add i64 %29, -1
  store i64 %dec20, i64* %n19, align 8
  %cmp21 = icmp ugt i64 %29, 0
  br i1 %cmp21, label %cond.true23, label %cond.false28

cond.true23:                                      ; preds = %if.then16
  %30 = load %struct.LexState.235** %ls.addr, align 8
  %z24 = getelementptr inbounds %struct.LexState.235* %30, i32 0, i32 7
  %31 = load %struct.Zio** %z24, align 8
  %p25 = getelementptr inbounds %struct.Zio* %31, i32 0, i32 1
  %32 = load i8** %p25, align 8
  %incdec.ptr26 = getelementptr inbounds i8* %32, i32 1
  store i8* %incdec.ptr26, i8** %p25, align 8
  %33 = load i8* %32, align 1
  %conv27 = zext i8 %33 to i32
  br label %cond.end31

cond.false28:                                     ; preds = %if.then16
  %34 = load %struct.LexState.235** %ls.addr, align 8
  %z29 = getelementptr inbounds %struct.LexState.235* %34, i32 0, i32 7
  %35 = load %struct.Zio** %z29, align 8
  %call30 = call i32 @luaZ_fill(%struct.Zio* %35)
  br label %cond.end31

cond.end31:                                       ; preds = %cond.false28, %cond.true23
  %cond32 = phi i32 [ %conv27, %cond.true23 ], [ %call30, %cond.false28 ]
  %36 = load %struct.LexState.235** %ls.addr, align 8
  %current33 = getelementptr inbounds %struct.LexState.235* %36, i32 0, i32 0
  store i32 %cond32, i32* %current33, align 4
  br label %endloop

if.end34:                                         ; preds = %sw.bb12
  br label %sw.epilog

sw.bb35:                                          ; preds = %for.cond, %for.cond
  %37 = load %struct.LexState.235** %ls.addr, align 8
  call void @save(%struct.LexState.235* %37, i32 10)
  %38 = load %struct.LexState.235** %ls.addr, align 8
  call void @inclinenumber(%struct.LexState.235* %38)
  %39 = load %union.SemInfo** %seminfo.addr, align 8
  %tobool36 = icmp ne %union.SemInfo* %39, null
  br i1 %tobool36, label %if.end39, label %if.then37

if.then37:                                        ; preds = %sw.bb35
  %40 = load %struct.LexState.235** %ls.addr, align 8
  %buff = getelementptr inbounds %struct.LexState.235* %40, i32 0, i32 8
  %41 = load %struct.Mbuffer** %buff, align 8
  %n38 = getelementptr inbounds %struct.Mbuffer* %41, i32 0, i32 1
  store i64 0, i64* %n38, align 8
  br label %if.end39

if.end39:                                         ; preds = %if.then37, %sw.bb35
  br label %sw.epilog

sw.default:                                       ; preds = %for.cond
  %42 = load %union.SemInfo** %seminfo.addr, align 8
  %tobool40 = icmp ne %union.SemInfo* %42, null
  br i1 %tobool40, label %if.then41, label %if.else

if.then41:                                        ; preds = %sw.default
  %43 = load %struct.LexState.235** %ls.addr, align 8
  %44 = load %struct.LexState.235** %ls.addr, align 8
  %current42 = getelementptr inbounds %struct.LexState.235* %44, i32 0, i32 0
  %45 = load i32* %current42, align 4
  call void @save(%struct.LexState.235* %43, i32 %45)
  %46 = load %struct.LexState.235** %ls.addr, align 8
  %z43 = getelementptr inbounds %struct.LexState.235* %46, i32 0, i32 7
  %47 = load %struct.Zio** %z43, align 8
  %n44 = getelementptr inbounds %struct.Zio* %47, i32 0, i32 0
  %48 = load i64* %n44, align 8
  %dec45 = add i64 %48, -1
  store i64 %dec45, i64* %n44, align 8
  %cmp46 = icmp ugt i64 %48, 0
  br i1 %cmp46, label %cond.true48, label %cond.false53

cond.true48:                                      ; preds = %if.then41
  %49 = load %struct.LexState.235** %ls.addr, align 8
  %z49 = getelementptr inbounds %struct.LexState.235* %49, i32 0, i32 7
  %50 = load %struct.Zio** %z49, align 8
  %p50 = getelementptr inbounds %struct.Zio* %50, i32 0, i32 1
  %51 = load i8** %p50, align 8
  %incdec.ptr51 = getelementptr inbounds i8* %51, i32 1
  store i8* %incdec.ptr51, i8** %p50, align 8
  %52 = load i8* %51, align 1
  %conv52 = zext i8 %52 to i32
  br label %cond.end56

cond.false53:                                     ; preds = %if.then41
  %53 = load %struct.LexState.235** %ls.addr, align 8
  %z54 = getelementptr inbounds %struct.LexState.235* %53, i32 0, i32 7
  %54 = load %struct.Zio** %z54, align 8
  %call55 = call i32 @luaZ_fill(%struct.Zio* %54)
  br label %cond.end56

cond.end56:                                       ; preds = %cond.false53, %cond.true48
  %cond57 = phi i32 [ %conv52, %cond.true48 ], [ %call55, %cond.false53 ]
  %55 = load %struct.LexState.235** %ls.addr, align 8
  %current58 = getelementptr inbounds %struct.LexState.235* %55, i32 0, i32 0
  store i32 %cond57, i32* %current58, align 4
  br label %if.end75

if.else:                                          ; preds = %sw.default
  %56 = load %struct.LexState.235** %ls.addr, align 8
  %z59 = getelementptr inbounds %struct.LexState.235* %56, i32 0, i32 7
  %57 = load %struct.Zio** %z59, align 8
  %n60 = getelementptr inbounds %struct.Zio* %57, i32 0, i32 0
  %58 = load i64* %n60, align 8
  %dec61 = add i64 %58, -1
  store i64 %dec61, i64* %n60, align 8
  %cmp62 = icmp ugt i64 %58, 0
  br i1 %cmp62, label %cond.true64, label %cond.false69

cond.true64:                                      ; preds = %if.else
  %59 = load %struct.LexState.235** %ls.addr, align 8
  %z65 = getelementptr inbounds %struct.LexState.235* %59, i32 0, i32 7
  %60 = load %struct.Zio** %z65, align 8
  %p66 = getelementptr inbounds %struct.Zio* %60, i32 0, i32 1
  %61 = load i8** %p66, align 8
  %incdec.ptr67 = getelementptr inbounds i8* %61, i32 1
  store i8* %incdec.ptr67, i8** %p66, align 8
  %62 = load i8* %61, align 1
  %conv68 = zext i8 %62 to i32
  br label %cond.end72

cond.false69:                                     ; preds = %if.else
  %63 = load %struct.LexState.235** %ls.addr, align 8
  %z70 = getelementptr inbounds %struct.LexState.235* %63, i32 0, i32 7
  %64 = load %struct.Zio** %z70, align 8
  %call71 = call i32 @luaZ_fill(%struct.Zio* %64)
  br label %cond.end72

cond.end72:                                       ; preds = %cond.false69, %cond.true64
  %cond73 = phi i32 [ %conv68, %cond.true64 ], [ %call71, %cond.false69 ]
  %65 = load %struct.LexState.235** %ls.addr, align 8
  %current74 = getelementptr inbounds %struct.LexState.235* %65, i32 0, i32 0
  store i32 %cond73, i32* %current74, align 4
  br label %if.end75

if.end75:                                         ; preds = %cond.end72, %cond.end56
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end75, %if.end39, %if.end34
  br label %for.cond

endloop:                                          ; preds = %cond.end31
  %66 = load %union.SemInfo** %seminfo.addr, align 8
  %tobool76 = icmp ne %union.SemInfo* %66, null
  br i1 %tobool76, label %if.then77, label %if.end84

if.then77:                                        ; preds = %endloop
  %67 = load %struct.LexState.235** %ls.addr, align 8
  %68 = load %struct.LexState.235** %ls.addr, align 8
  %buff78 = getelementptr inbounds %struct.LexState.235* %68, i32 0, i32 8
  %69 = load %struct.Mbuffer** %buff78, align 8
  %buffer = getelementptr inbounds %struct.Mbuffer* %69, i32 0, i32 0
  %70 = load i8** %buffer, align 8
  %71 = load i32* %sep.addr, align 4
  %add = add nsw i32 2, %71
  %idx.ext = sext i32 %add to i64
  %add.ptr = getelementptr inbounds i8* %70, i64 %idx.ext
  %72 = load %struct.LexState.235** %ls.addr, align 8
  %buff79 = getelementptr inbounds %struct.LexState.235* %72, i32 0, i32 8
  %73 = load %struct.Mbuffer** %buff79, align 8
  %n80 = getelementptr inbounds %struct.Mbuffer* %73, i32 0, i32 1
  %74 = load i64* %n80, align 8
  %75 = load i32* %sep.addr, align 4
  %add81 = add nsw i32 2, %75
  %mul = mul nsw i32 2, %add81
  %conv82 = sext i32 %mul to i64
  %sub = sub i64 %74, %conv82
  %call83 = call %union.TString* @luaX_newstring(%struct.LexState.235* %67, i8* %add.ptr, i64 %sub)
  %76 = load %union.SemInfo** %seminfo.addr, align 8
  %ts = bitcast %union.SemInfo* %76 to %union.TString**
  store %union.TString* %call83, %union.TString** %ts, align 8
  br label %if.end84

if.end84:                                         ; preds = %if.then77, %endloop
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @read_string(%struct.LexState.235* %ls, i32 %del, %union.SemInfo* %seminfo) #0 {
entry:
  %ls.addr = alloca %struct.LexState.235*, align 8
  %del.addr = alloca i32, align 4
  %seminfo.addr = alloca %union.SemInfo*, align 8
  %c = alloca i32, align 4
  store %struct.LexState.235* %ls, %struct.LexState.235** %ls.addr, align 8
  store i32 %del, i32* %del.addr, align 4
  store %union.SemInfo* %seminfo, %union.SemInfo** %seminfo.addr, align 8
  %0 = load %struct.LexState.235** %ls.addr, align 8
  %1 = load %struct.LexState.235** %ls.addr, align 8
  %current = getelementptr inbounds %struct.LexState.235* %1, i32 0, i32 0
  %2 = load i32* %current, align 4
  call void @save(%struct.LexState.235* %0, i32 %2)
  %3 = load %struct.LexState.235** %ls.addr, align 8
  %z = getelementptr inbounds %struct.LexState.235* %3, i32 0, i32 7
  %4 = load %struct.Zio** %z, align 8
  %n = getelementptr inbounds %struct.Zio* %4, i32 0, i32 0
  %5 = load i64* %n, align 8
  %dec = add i64 %5, -1
  store i64 %dec, i64* %n, align 8
  %cmp = icmp ugt i64 %5, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %6 = load %struct.LexState.235** %ls.addr, align 8
  %z1 = getelementptr inbounds %struct.LexState.235* %6, i32 0, i32 7
  %7 = load %struct.Zio** %z1, align 8
  %p = getelementptr inbounds %struct.Zio* %7, i32 0, i32 1
  %8 = load i8** %p, align 8
  %incdec.ptr = getelementptr inbounds i8* %8, i32 1
  store i8* %incdec.ptr, i8** %p, align 8
  %9 = load i8* %8, align 1
  %conv = zext i8 %9 to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  %10 = load %struct.LexState.235** %ls.addr, align 8
  %z2 = getelementptr inbounds %struct.LexState.235* %10, i32 0, i32 7
  %11 = load %struct.Zio** %z2, align 8
  %call = call i32 @luaZ_fill(%struct.Zio* %11)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv, %cond.true ], [ %call, %cond.false ]
  %12 = load %struct.LexState.235** %ls.addr, align 8
  %current3 = getelementptr inbounds %struct.LexState.235* %12, i32 0, i32 0
  store i32 %cond, i32* %current3, align 4
  br label %while.cond

while.cond:                                       ; preds = %sw.epilog, %cond.end
  %13 = load %struct.LexState.235** %ls.addr, align 8
  %current4 = getelementptr inbounds %struct.LexState.235* %13, i32 0, i32 0
  %14 = load i32* %current4, align 4
  %15 = load i32* %del.addr, align 4
  %cmp5 = icmp ne i32 %14, %15
  br i1 %cmp5, label %while.body, label %while.end128

while.body:                                       ; preds = %while.cond
  %16 = load %struct.LexState.235** %ls.addr, align 8
  %current7 = getelementptr inbounds %struct.LexState.235* %16, i32 0, i32 0
  %17 = load i32* %current7, align 4
  switch i32 %17, label %sw.default110 [
    i32 -1, label %sw.bb
    i32 10, label %sw.bb8
    i32 13, label %sw.bb8
    i32 92, label %sw.bb9
  ]

sw.bb:                                            ; preds = %while.body
  %18 = load %struct.LexState.235** %ls.addr, align 8
  call void @lexerror(%struct.LexState.235* %18, i8* getelementptr inbounds ([18 x i8]* @.str12369, i32 0, i32 0), i32 286) #9
  unreachable

sw.bb8:                                           ; preds = %while.body, %while.body
  %19 = load %struct.LexState.235** %ls.addr, align 8
  call void @lexerror(%struct.LexState.235* %19, i8* getelementptr inbounds ([18 x i8]* @.str12369, i32 0, i32 0), i32 289) #9
  unreachable

sw.bb9:                                           ; preds = %while.body
  %20 = load %struct.LexState.235** %ls.addr, align 8
  %z10 = getelementptr inbounds %struct.LexState.235* %20, i32 0, i32 7
  %21 = load %struct.Zio** %z10, align 8
  %n11 = getelementptr inbounds %struct.Zio* %21, i32 0, i32 0
  %22 = load i64* %n11, align 8
  %dec12 = add i64 %22, -1
  store i64 %dec12, i64* %n11, align 8
  %cmp13 = icmp ugt i64 %22, 0
  br i1 %cmp13, label %cond.true15, label %cond.false20

cond.true15:                                      ; preds = %sw.bb9
  %23 = load %struct.LexState.235** %ls.addr, align 8
  %z16 = getelementptr inbounds %struct.LexState.235* %23, i32 0, i32 7
  %24 = load %struct.Zio** %z16, align 8
  %p17 = getelementptr inbounds %struct.Zio* %24, i32 0, i32 1
  %25 = load i8** %p17, align 8
  %incdec.ptr18 = getelementptr inbounds i8* %25, i32 1
  store i8* %incdec.ptr18, i8** %p17, align 8
  %26 = load i8* %25, align 1
  %conv19 = zext i8 %26 to i32
  br label %cond.end23

cond.false20:                                     ; preds = %sw.bb9
  %27 = load %struct.LexState.235** %ls.addr, align 8
  %z21 = getelementptr inbounds %struct.LexState.235* %27, i32 0, i32 7
  %28 = load %struct.Zio** %z21, align 8
  %call22 = call i32 @luaZ_fill(%struct.Zio* %28)
  br label %cond.end23

cond.end23:                                       ; preds = %cond.false20, %cond.true15
  %cond24 = phi i32 [ %conv19, %cond.true15 ], [ %call22, %cond.false20 ]
  %29 = load %struct.LexState.235** %ls.addr, align 8
  %current25 = getelementptr inbounds %struct.LexState.235* %29, i32 0, i32 0
  store i32 %cond24, i32* %current25, align 4
  %30 = load %struct.LexState.235** %ls.addr, align 8
  %current26 = getelementptr inbounds %struct.LexState.235* %30, i32 0, i32 0
  %31 = load i32* %current26, align 4
  switch i32 %31, label %sw.default [
    i32 97, label %sw.bb27
    i32 98, label %sw.bb28
    i32 102, label %sw.bb29
    i32 110, label %sw.bb30
    i32 114, label %sw.bb31
    i32 116, label %sw.bb32
    i32 118, label %sw.bb33
    i32 120, label %sw.bb34
    i32 10, label %sw.bb36
    i32 13, label %sw.bb36
    i32 92, label %sw.bb37
    i32 34, label %sw.bb37
    i32 39, label %sw.bb37
    i32 -1, label %sw.bb39
    i32 122, label %sw.bb40
  ]

sw.bb27:                                          ; preds = %cond.end23
  store i32 7, i32* %c, align 4
  br label %read_save

sw.bb28:                                          ; preds = %cond.end23
  store i32 8, i32* %c, align 4
  br label %read_save

sw.bb29:                                          ; preds = %cond.end23
  store i32 12, i32* %c, align 4
  br label %read_save

sw.bb30:                                          ; preds = %cond.end23
  store i32 10, i32* %c, align 4
  br label %read_save

sw.bb31:                                          ; preds = %cond.end23
  store i32 13, i32* %c, align 4
  br label %read_save

sw.bb32:                                          ; preds = %cond.end23
  store i32 9, i32* %c, align 4
  br label %read_save

sw.bb33:                                          ; preds = %cond.end23
  store i32 11, i32* %c, align 4
  br label %read_save

sw.bb34:                                          ; preds = %cond.end23
  %32 = load %struct.LexState.235** %ls.addr, align 8
  %call35 = call i32 @readhexaesc(%struct.LexState.235* %32)
  store i32 %call35, i32* %c, align 4
  br label %read_save

sw.bb36:                                          ; preds = %cond.end23, %cond.end23
  %33 = load %struct.LexState.235** %ls.addr, align 8
  call void @inclinenumber(%struct.LexState.235* %33)
  store i32 10, i32* %c, align 4
  br label %only_save

sw.bb37:                                          ; preds = %cond.end23, %cond.end23, %cond.end23
  %34 = load %struct.LexState.235** %ls.addr, align 8
  %current38 = getelementptr inbounds %struct.LexState.235* %34, i32 0, i32 0
  %35 = load i32* %current38, align 4
  store i32 %35, i32* %c, align 4
  br label %read_save

sw.bb39:                                          ; preds = %cond.end23
  br label %no_save

sw.bb40:                                          ; preds = %cond.end23
  %36 = load %struct.LexState.235** %ls.addr, align 8
  %z41 = getelementptr inbounds %struct.LexState.235* %36, i32 0, i32 7
  %37 = load %struct.Zio** %z41, align 8
  %n42 = getelementptr inbounds %struct.Zio* %37, i32 0, i32 0
  %38 = load i64* %n42, align 8
  %dec43 = add i64 %38, -1
  store i64 %dec43, i64* %n42, align 8
  %cmp44 = icmp ugt i64 %38, 0
  br i1 %cmp44, label %cond.true46, label %cond.false51

cond.true46:                                      ; preds = %sw.bb40
  %39 = load %struct.LexState.235** %ls.addr, align 8
  %z47 = getelementptr inbounds %struct.LexState.235* %39, i32 0, i32 7
  %40 = load %struct.Zio** %z47, align 8
  %p48 = getelementptr inbounds %struct.Zio* %40, i32 0, i32 1
  %41 = load i8** %p48, align 8
  %incdec.ptr49 = getelementptr inbounds i8* %41, i32 1
  store i8* %incdec.ptr49, i8** %p48, align 8
  %42 = load i8* %41, align 1
  %conv50 = zext i8 %42 to i32
  br label %cond.end54

cond.false51:                                     ; preds = %sw.bb40
  %43 = load %struct.LexState.235** %ls.addr, align 8
  %z52 = getelementptr inbounds %struct.LexState.235* %43, i32 0, i32 7
  %44 = load %struct.Zio** %z52, align 8
  %call53 = call i32 @luaZ_fill(%struct.Zio* %44)
  br label %cond.end54

cond.end54:                                       ; preds = %cond.false51, %cond.true46
  %cond55 = phi i32 [ %conv50, %cond.true46 ], [ %call53, %cond.false51 ]
  %45 = load %struct.LexState.235** %ls.addr, align 8
  %current56 = getelementptr inbounds %struct.LexState.235* %45, i32 0, i32 0
  store i32 %cond55, i32* %current56, align 4
  br label %while.cond57

while.cond57:                                     ; preds = %if.end, %cond.end54
  %46 = load %struct.LexState.235** %ls.addr, align 8
  %current58 = getelementptr inbounds %struct.LexState.235* %46, i32 0, i32 0
  %47 = load i32* %current58, align 4
  %add = add nsw i32 %47, 1
  %idxprom = sext i32 %add to i64
  %arrayidx = getelementptr inbounds [257 x i8]* @luai_ctype_, i32 0, i64 %idxprom
  %48 = load i8* %arrayidx, align 1
  %conv59 = zext i8 %48 to i32
  %and = and i32 %conv59, 8
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %while.body60, label %while.end

while.body60:                                     ; preds = %while.cond57
  %49 = load %struct.LexState.235** %ls.addr, align 8
  %current61 = getelementptr inbounds %struct.LexState.235* %49, i32 0, i32 0
  %50 = load i32* %current61, align 4
  %cmp62 = icmp eq i32 %50, 10
  br i1 %cmp62, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.body60
  %51 = load %struct.LexState.235** %ls.addr, align 8
  %current64 = getelementptr inbounds %struct.LexState.235* %51, i32 0, i32 0
  %52 = load i32* %current64, align 4
  %cmp65 = icmp eq i32 %52, 13
  br i1 %cmp65, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %while.body60
  %53 = load %struct.LexState.235** %ls.addr, align 8
  call void @inclinenumber(%struct.LexState.235* %53)
  br label %if.end

if.else:                                          ; preds = %lor.lhs.false
  %54 = load %struct.LexState.235** %ls.addr, align 8
  %z67 = getelementptr inbounds %struct.LexState.235* %54, i32 0, i32 7
  %55 = load %struct.Zio** %z67, align 8
  %n68 = getelementptr inbounds %struct.Zio* %55, i32 0, i32 0
  %56 = load i64* %n68, align 8
  %dec69 = add i64 %56, -1
  store i64 %dec69, i64* %n68, align 8
  %cmp70 = icmp ugt i64 %56, 0
  br i1 %cmp70, label %cond.true72, label %cond.false77

cond.true72:                                      ; preds = %if.else
  %57 = load %struct.LexState.235** %ls.addr, align 8
  %z73 = getelementptr inbounds %struct.LexState.235* %57, i32 0, i32 7
  %58 = load %struct.Zio** %z73, align 8
  %p74 = getelementptr inbounds %struct.Zio* %58, i32 0, i32 1
  %59 = load i8** %p74, align 8
  %incdec.ptr75 = getelementptr inbounds i8* %59, i32 1
  store i8* %incdec.ptr75, i8** %p74, align 8
  %60 = load i8* %59, align 1
  %conv76 = zext i8 %60 to i32
  br label %cond.end80

cond.false77:                                     ; preds = %if.else
  %61 = load %struct.LexState.235** %ls.addr, align 8
  %z78 = getelementptr inbounds %struct.LexState.235* %61, i32 0, i32 7
  %62 = load %struct.Zio** %z78, align 8
  %call79 = call i32 @luaZ_fill(%struct.Zio* %62)
  br label %cond.end80

cond.end80:                                       ; preds = %cond.false77, %cond.true72
  %cond81 = phi i32 [ %conv76, %cond.true72 ], [ %call79, %cond.false77 ]
  %63 = load %struct.LexState.235** %ls.addr, align 8
  %current82 = getelementptr inbounds %struct.LexState.235* %63, i32 0, i32 0
  store i32 %cond81, i32* %current82, align 4
  br label %if.end

if.end:                                           ; preds = %cond.end80, %if.then
  br label %while.cond57

while.end:                                        ; preds = %while.cond57
  br label %no_save

sw.default:                                       ; preds = %cond.end23
  %64 = load %struct.LexState.235** %ls.addr, align 8
  %current83 = getelementptr inbounds %struct.LexState.235* %64, i32 0, i32 0
  %65 = load i32* %current83, align 4
  %add84 = add nsw i32 %65, 1
  %idxprom85 = sext i32 %add84 to i64
  %arrayidx86 = getelementptr inbounds [257 x i8]* @luai_ctype_, i32 0, i64 %idxprom85
  %66 = load i8* %arrayidx86, align 1
  %conv87 = zext i8 %66 to i32
  %and88 = and i32 %conv87, 2
  %tobool89 = icmp ne i32 %and88, 0
  br i1 %tobool89, label %if.end92, label %if.then90

if.then90:                                        ; preds = %sw.default
  %67 = load %struct.LexState.235** %ls.addr, align 8
  %68 = load %struct.LexState.235** %ls.addr, align 8
  %current91 = getelementptr inbounds %struct.LexState.235* %68, i32 0, i32 0
  call void @escerror(%struct.LexState.235* %67, i32* %current91, i32 1, i8* getelementptr inbounds ([24 x i8]* @.str13370, i32 0, i32 0))
  br label %if.end92

if.end92:                                         ; preds = %if.then90, %sw.default
  %69 = load %struct.LexState.235** %ls.addr, align 8
  %call93 = call i32 @readdecesc(%struct.LexState.235* %69)
  store i32 %call93, i32* %c, align 4
  br label %only_save

read_save:                                        ; preds = %sw.bb37, %sw.bb34, %sw.bb33, %sw.bb32, %sw.bb31, %sw.bb30, %sw.bb29, %sw.bb28, %sw.bb27
  %70 = load %struct.LexState.235** %ls.addr, align 8
  %z94 = getelementptr inbounds %struct.LexState.235* %70, i32 0, i32 7
  %71 = load %struct.Zio** %z94, align 8
  %n95 = getelementptr inbounds %struct.Zio* %71, i32 0, i32 0
  %72 = load i64* %n95, align 8
  %dec96 = add i64 %72, -1
  store i64 %dec96, i64* %n95, align 8
  %cmp97 = icmp ugt i64 %72, 0
  br i1 %cmp97, label %cond.true99, label %cond.false104

cond.true99:                                      ; preds = %read_save
  %73 = load %struct.LexState.235** %ls.addr, align 8
  %z100 = getelementptr inbounds %struct.LexState.235* %73, i32 0, i32 7
  %74 = load %struct.Zio** %z100, align 8
  %p101 = getelementptr inbounds %struct.Zio* %74, i32 0, i32 1
  %75 = load i8** %p101, align 8
  %incdec.ptr102 = getelementptr inbounds i8* %75, i32 1
  store i8* %incdec.ptr102, i8** %p101, align 8
  %76 = load i8* %75, align 1
  %conv103 = zext i8 %76 to i32
  br label %cond.end107

cond.false104:                                    ; preds = %read_save
  %77 = load %struct.LexState.235** %ls.addr, align 8
  %z105 = getelementptr inbounds %struct.LexState.235* %77, i32 0, i32 7
  %78 = load %struct.Zio** %z105, align 8
  %call106 = call i32 @luaZ_fill(%struct.Zio* %78)
  br label %cond.end107

cond.end107:                                      ; preds = %cond.false104, %cond.true99
  %cond108 = phi i32 [ %conv103, %cond.true99 ], [ %call106, %cond.false104 ]
  %79 = load %struct.LexState.235** %ls.addr, align 8
  %current109 = getelementptr inbounds %struct.LexState.235* %79, i32 0, i32 0
  store i32 %cond108, i32* %current109, align 4
  br label %only_save

only_save:                                        ; preds = %cond.end107, %if.end92, %sw.bb36
  %80 = load %struct.LexState.235** %ls.addr, align 8
  %81 = load i32* %c, align 4
  call void @save(%struct.LexState.235* %80, i32 %81)
  br label %no_save

no_save:                                          ; preds = %only_save, %while.end, %sw.bb39
  br label %sw.epilog

sw.default110:                                    ; preds = %while.body
  %82 = load %struct.LexState.235** %ls.addr, align 8
  %83 = load %struct.LexState.235** %ls.addr, align 8
  %current111 = getelementptr inbounds %struct.LexState.235* %83, i32 0, i32 0
  %84 = load i32* %current111, align 4
  call void @save(%struct.LexState.235* %82, i32 %84)
  %85 = load %struct.LexState.235** %ls.addr, align 8
  %z112 = getelementptr inbounds %struct.LexState.235* %85, i32 0, i32 7
  %86 = load %struct.Zio** %z112, align 8
  %n113 = getelementptr inbounds %struct.Zio* %86, i32 0, i32 0
  %87 = load i64* %n113, align 8
  %dec114 = add i64 %87, -1
  store i64 %dec114, i64* %n113, align 8
  %cmp115 = icmp ugt i64 %87, 0
  br i1 %cmp115, label %cond.true117, label %cond.false122

cond.true117:                                     ; preds = %sw.default110
  %88 = load %struct.LexState.235** %ls.addr, align 8
  %z118 = getelementptr inbounds %struct.LexState.235* %88, i32 0, i32 7
  %89 = load %struct.Zio** %z118, align 8
  %p119 = getelementptr inbounds %struct.Zio* %89, i32 0, i32 1
  %90 = load i8** %p119, align 8
  %incdec.ptr120 = getelementptr inbounds i8* %90, i32 1
  store i8* %incdec.ptr120, i8** %p119, align 8
  %91 = load i8* %90, align 1
  %conv121 = zext i8 %91 to i32
  br label %cond.end125

cond.false122:                                    ; preds = %sw.default110
  %92 = load %struct.LexState.235** %ls.addr, align 8
  %z123 = getelementptr inbounds %struct.LexState.235* %92, i32 0, i32 7
  %93 = load %struct.Zio** %z123, align 8
  %call124 = call i32 @luaZ_fill(%struct.Zio* %93)
  br label %cond.end125

cond.end125:                                      ; preds = %cond.false122, %cond.true117
  %cond126 = phi i32 [ %conv121, %cond.true117 ], [ %call124, %cond.false122 ]
  %94 = load %struct.LexState.235** %ls.addr, align 8
  %current127 = getelementptr inbounds %struct.LexState.235* %94, i32 0, i32 0
  store i32 %cond126, i32* %current127, align 4
  br label %sw.epilog

sw.epilog:                                        ; preds = %cond.end125, %no_save
  br label %while.cond

while.end128:                                     ; preds = %while.cond
  %95 = load %struct.LexState.235** %ls.addr, align 8
  %96 = load %struct.LexState.235** %ls.addr, align 8
  %current129 = getelementptr inbounds %struct.LexState.235* %96, i32 0, i32 0
  %97 = load i32* %current129, align 4
  call void @save(%struct.LexState.235* %95, i32 %97)
  %98 = load %struct.LexState.235** %ls.addr, align 8
  %z130 = getelementptr inbounds %struct.LexState.235* %98, i32 0, i32 7
  %99 = load %struct.Zio** %z130, align 8
  %n131 = getelementptr inbounds %struct.Zio* %99, i32 0, i32 0
  %100 = load i64* %n131, align 8
  %dec132 = add i64 %100, -1
  store i64 %dec132, i64* %n131, align 8
  %cmp133 = icmp ugt i64 %100, 0
  br i1 %cmp133, label %cond.true135, label %cond.false140

cond.true135:                                     ; preds = %while.end128
  %101 = load %struct.LexState.235** %ls.addr, align 8
  %z136 = getelementptr inbounds %struct.LexState.235* %101, i32 0, i32 7
  %102 = load %struct.Zio** %z136, align 8
  %p137 = getelementptr inbounds %struct.Zio* %102, i32 0, i32 1
  %103 = load i8** %p137, align 8
  %incdec.ptr138 = getelementptr inbounds i8* %103, i32 1
  store i8* %incdec.ptr138, i8** %p137, align 8
  %104 = load i8* %103, align 1
  %conv139 = zext i8 %104 to i32
  br label %cond.end143

cond.false140:                                    ; preds = %while.end128
  %105 = load %struct.LexState.235** %ls.addr, align 8
  %z141 = getelementptr inbounds %struct.LexState.235* %105, i32 0, i32 7
  %106 = load %struct.Zio** %z141, align 8
  %call142 = call i32 @luaZ_fill(%struct.Zio* %106)
  br label %cond.end143

cond.end143:                                      ; preds = %cond.false140, %cond.true135
  %cond144 = phi i32 [ %conv139, %cond.true135 ], [ %call142, %cond.false140 ]
  %107 = load %struct.LexState.235** %ls.addr, align 8
  %current145 = getelementptr inbounds %struct.LexState.235* %107, i32 0, i32 0
  store i32 %cond144, i32* %current145, align 4
  %108 = load %struct.LexState.235** %ls.addr, align 8
  %109 = load %struct.LexState.235** %ls.addr, align 8
  %buff = getelementptr inbounds %struct.LexState.235* %109, i32 0, i32 8
  %110 = load %struct.Mbuffer** %buff, align 8
  %buffer = getelementptr inbounds %struct.Mbuffer* %110, i32 0, i32 0
  %111 = load i8** %buffer, align 8
  %add.ptr = getelementptr inbounds i8* %111, i64 1
  %112 = load %struct.LexState.235** %ls.addr, align 8
  %buff146 = getelementptr inbounds %struct.LexState.235* %112, i32 0, i32 8
  %113 = load %struct.Mbuffer** %buff146, align 8
  %n147 = getelementptr inbounds %struct.Mbuffer* %113, i32 0, i32 1
  %114 = load i64* %n147, align 8
  %sub = sub i64 %114, 2
  %call148 = call %union.TString* @luaX_newstring(%struct.LexState.235* %108, i8* %add.ptr, i64 %sub)
  %115 = load %union.SemInfo** %seminfo.addr, align 8
  %ts = bitcast %union.SemInfo* %115 to %union.TString**
  store %union.TString* %call148, %union.TString** %ts, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @save(%struct.LexState.235* %ls, i32 %c) #0 {
entry:
  %ls.addr = alloca %struct.LexState.235*, align 8
  %c.addr = alloca i32, align 4
  %b = alloca %struct.Mbuffer*, align 8
  %newsize = alloca i64, align 8
  store %struct.LexState.235* %ls, %struct.LexState.235** %ls.addr, align 8
  store i32 %c, i32* %c.addr, align 4
  %0 = load %struct.LexState.235** %ls.addr, align 8
  %buff = getelementptr inbounds %struct.LexState.235* %0, i32 0, i32 8
  %1 = load %struct.Mbuffer** %buff, align 8
  store %struct.Mbuffer* %1, %struct.Mbuffer** %b, align 8
  %2 = load %struct.Mbuffer** %b, align 8
  %n = getelementptr inbounds %struct.Mbuffer* %2, i32 0, i32 1
  %3 = load i64* %n, align 8
  %add = add i64 %3, 1
  %4 = load %struct.Mbuffer** %b, align 8
  %buffsize = getelementptr inbounds %struct.Mbuffer* %4, i32 0, i32 2
  %5 = load i64* %buffsize, align 8
  %cmp = icmp ugt i64 %add, %5
  br i1 %cmp, label %if.then, label %if.end13

if.then:                                          ; preds = %entry
  %6 = load %struct.Mbuffer** %b, align 8
  %buffsize1 = getelementptr inbounds %struct.Mbuffer* %6, i32 0, i32 2
  %7 = load i64* %buffsize1, align 8
  %cmp2 = icmp uge i64 %7, 9223372036854775806
  br i1 %cmp2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %8 = load %struct.LexState.235** %ls.addr, align 8
  call void @lexerror(%struct.LexState.235* %8, i8* getelementptr inbounds ([25 x i8]* @.str11368, i32 0, i32 0), i32 0) #9
  unreachable

if.end:                                           ; preds = %if.then
  %9 = load %struct.Mbuffer** %b, align 8
  %buffsize4 = getelementptr inbounds %struct.Mbuffer* %9, i32 0, i32 2
  %10 = load i64* %buffsize4, align 8
  %mul = mul i64 %10, 2
  store i64 %mul, i64* %newsize, align 8
  %11 = load i64* %newsize, align 8
  %add5 = add i64 %11, 1
  %cmp6 = icmp ugt i64 %add5, -3
  br i1 %cmp6, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %12 = load %struct.LexState.235** %ls.addr, align 8
  %L = getelementptr inbounds %struct.LexState.235* %12, i32 0, i32 6
  %13 = load %struct.lua_State** %L, align 8
  call void @luaM_toobig(%struct.lua_State* %13) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.false:                                       ; preds = %if.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %14
  %cond = phi i32 [ 0, %14 ], [ 0, %cond.false ]
  %15 = load %struct.LexState.235** %ls.addr, align 8
  %L7 = getelementptr inbounds %struct.LexState.235* %15, i32 0, i32 6
  %16 = load %struct.lua_State** %L7, align 8
  %17 = load %struct.Mbuffer** %b, align 8
  %buffer = getelementptr inbounds %struct.Mbuffer* %17, i32 0, i32 0
  %18 = load i8** %buffer, align 8
  %19 = load %struct.Mbuffer** %b, align 8
  %buffsize8 = getelementptr inbounds %struct.Mbuffer* %19, i32 0, i32 2
  %20 = load i64* %buffsize8, align 8
  %mul9 = mul i64 %20, 1
  %21 = load i64* %newsize, align 8
  %mul10 = mul i64 %21, 1
  %call = call i8* @luaM_realloc_(%struct.lua_State* %16, i8* %18, i64 %mul9, i64 %mul10)
  %22 = load %struct.Mbuffer** %b, align 8
  %buffer11 = getelementptr inbounds %struct.Mbuffer* %22, i32 0, i32 0
  store i8* %call, i8** %buffer11, align 8
  %23 = load i64* %newsize, align 8
  %24 = load %struct.Mbuffer** %b, align 8
  %buffsize12 = getelementptr inbounds %struct.Mbuffer* %24, i32 0, i32 2
  store i64 %23, i64* %buffsize12, align 8
  br label %if.end13

if.end13:                                         ; preds = %cond.end, %entry
  %25 = load i32* %c.addr, align 4
  %conv = trunc i32 %25 to i8
  %26 = load %struct.Mbuffer** %b, align 8
  %n14 = getelementptr inbounds %struct.Mbuffer* %26, i32 0, i32 1
  %27 = load i64* %n14, align 8
  %inc = add i64 %27, 1
  store i64 %inc, i64* %n14, align 8
  %28 = load %struct.Mbuffer** %b, align 8
  %buffer15 = getelementptr inbounds %struct.Mbuffer* %28, i32 0, i32 0
  %29 = load i8** %buffer15, align 8
  %arrayidx = getelementptr inbounds i8* %29, i64 %27
  store i8 %conv, i8* %arrayidx, align 1
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @check_next(%struct.LexState.235* %ls, i8* %set) #0 {
entry:
  %retval = alloca i32, align 4
  %ls.addr = alloca %struct.LexState.235*, align 8
  %set.addr = alloca i8*, align 8
  store %struct.LexState.235* %ls, %struct.LexState.235** %ls.addr, align 8
  store i8* %set, i8** %set.addr, align 8
  %0 = load %struct.LexState.235** %ls.addr, align 8
  %current = getelementptr inbounds %struct.LexState.235* %0, i32 0, i32 0
  %1 = load i32* %current, align 4
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load i8** %set.addr, align 8
  %3 = load %struct.LexState.235** %ls.addr, align 8
  %current1 = getelementptr inbounds %struct.LexState.235* %3, i32 0, i32 0
  %4 = load i32* %current1, align 4
  %call = call i8* @strchr(i8* %2, i32 %4) #10
  %tobool = icmp ne i8* %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 0, i32* %retval
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %5 = load %struct.LexState.235** %ls.addr, align 8
  %6 = load %struct.LexState.235** %ls.addr, align 8
  %current2 = getelementptr inbounds %struct.LexState.235* %6, i32 0, i32 0
  %7 = load i32* %current2, align 4
  call void @save(%struct.LexState.235* %5, i32 %7)
  %8 = load %struct.LexState.235** %ls.addr, align 8
  %z = getelementptr inbounds %struct.LexState.235* %8, i32 0, i32 7
  %9 = load %struct.Zio** %z, align 8
  %n = getelementptr inbounds %struct.Zio* %9, i32 0, i32 0
  %10 = load i64* %n, align 8
  %dec = add i64 %10, -1
  store i64 %dec, i64* %n, align 8
  %cmp3 = icmp ugt i64 %10, 0
  br i1 %cmp3, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %11 = load %struct.LexState.235** %ls.addr, align 8
  %z4 = getelementptr inbounds %struct.LexState.235* %11, i32 0, i32 7
  %12 = load %struct.Zio** %z4, align 8
  %p = getelementptr inbounds %struct.Zio* %12, i32 0, i32 1
  %13 = load i8** %p, align 8
  %incdec.ptr = getelementptr inbounds i8* %13, i32 1
  store i8* %incdec.ptr, i8** %p, align 8
  %14 = load i8* %13, align 1
  %conv = zext i8 %14 to i32
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %15 = load %struct.LexState.235** %ls.addr, align 8
  %z5 = getelementptr inbounds %struct.LexState.235* %15, i32 0, i32 7
  %16 = load %struct.Zio** %z5, align 8
  %call6 = call i32 @luaZ_fill(%struct.Zio* %16)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv, %cond.true ], [ %call6, %cond.false ]
  %17 = load %struct.LexState.235** %ls.addr, align 8
  %current7 = getelementptr inbounds %struct.LexState.235* %17, i32 0, i32 0
  store i32 %cond, i32* %current7, align 4
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %cond.end, %if.then
  %18 = load i32* %retval
  ret i32 %18
}

; Function Attrs: nounwind uwtable
define internal void @read_numeral(%struct.LexState.235* %ls, %union.SemInfo* %seminfo) #0 {
entry:
  %ls.addr = alloca %struct.LexState.235*, align 8
  %seminfo.addr = alloca %union.SemInfo*, align 8
  %expo = alloca i8*, align 8
  %first = alloca i32, align 4
  store %struct.LexState.235* %ls, %struct.LexState.235** %ls.addr, align 8
  store %union.SemInfo* %seminfo, %union.SemInfo** %seminfo.addr, align 8
  store i8* getelementptr inbounds ([3 x i8]* @.str6363, i32 0, i32 0), i8** %expo, align 8
  %0 = load %struct.LexState.235** %ls.addr, align 8
  %current = getelementptr inbounds %struct.LexState.235* %0, i32 0, i32 0
  %1 = load i32* %current, align 4
  store i32 %1, i32* %first, align 4
  %2 = load %struct.LexState.235** %ls.addr, align 8
  %3 = load %struct.LexState.235** %ls.addr, align 8
  %current1 = getelementptr inbounds %struct.LexState.235* %3, i32 0, i32 0
  %4 = load i32* %current1, align 4
  call void @save(%struct.LexState.235* %2, i32 %4)
  %5 = load %struct.LexState.235** %ls.addr, align 8
  %z = getelementptr inbounds %struct.LexState.235* %5, i32 0, i32 7
  %6 = load %struct.Zio** %z, align 8
  %n = getelementptr inbounds %struct.Zio* %6, i32 0, i32 0
  %7 = load i64* %n, align 8
  %dec = add i64 %7, -1
  store i64 %dec, i64* %n, align 8
  %cmp = icmp ugt i64 %7, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %8 = load %struct.LexState.235** %ls.addr, align 8
  %z2 = getelementptr inbounds %struct.LexState.235* %8, i32 0, i32 7
  %9 = load %struct.Zio** %z2, align 8
  %p = getelementptr inbounds %struct.Zio* %9, i32 0, i32 1
  %10 = load i8** %p, align 8
  %incdec.ptr = getelementptr inbounds i8* %10, i32 1
  store i8* %incdec.ptr, i8** %p, align 8
  %11 = load i8* %10, align 1
  %conv = zext i8 %11 to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  %12 = load %struct.LexState.235** %ls.addr, align 8
  %z3 = getelementptr inbounds %struct.LexState.235* %12, i32 0, i32 7
  %13 = load %struct.Zio** %z3, align 8
  %call = call i32 @luaZ_fill(%struct.Zio* %13)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv, %cond.true ], [ %call, %cond.false ]
  %14 = load %struct.LexState.235** %ls.addr, align 8
  %current4 = getelementptr inbounds %struct.LexState.235* %14, i32 0, i32 0
  store i32 %cond, i32* %current4, align 4
  %15 = load i32* %first, align 4
  %cmp5 = icmp eq i32 %15, 48
  br i1 %cmp5, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %cond.end
  %16 = load %struct.LexState.235** %ls.addr, align 8
  %call7 = call i32 @check_next(%struct.LexState.235* %16, i8* getelementptr inbounds ([3 x i8]* @.str7364, i32 0, i32 0))
  %tobool = icmp ne i32 %call7, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store i8* getelementptr inbounds ([3 x i8]* @.str8365, i32 0, i32 0), i8** %expo, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %cond.end
  br label %for.cond

for.cond:                                         ; preds = %if.end37, %if.end
  %17 = load %struct.LexState.235** %ls.addr, align 8
  %18 = load i8** %expo, align 8
  %call8 = call i32 @check_next(%struct.LexState.235* %17, i8* %18)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %for.cond
  %19 = load %struct.LexState.235** %ls.addr, align 8
  %call11 = call i32 @check_next(%struct.LexState.235* %19, i8* getelementptr inbounds ([3 x i8]* @.str9366, i32 0, i32 0))
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %for.cond
  %20 = load %struct.LexState.235** %ls.addr, align 8
  %current13 = getelementptr inbounds %struct.LexState.235* %20, i32 0, i32 0
  %21 = load i32* %current13, align 4
  %add = add nsw i32 %21, 1
  %idxprom = sext i32 %add to i64
  %arrayidx = getelementptr inbounds [257 x i8]* @luai_ctype_, i32 0, i64 %idxprom
  %22 = load i8* %arrayidx, align 1
  %conv14 = zext i8 %22 to i32
  %and = and i32 %conv14, 16
  %tobool15 = icmp ne i32 %and, 0
  br i1 %tobool15, label %if.then19, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end12
  %23 = load %struct.LexState.235** %ls.addr, align 8
  %current16 = getelementptr inbounds %struct.LexState.235* %23, i32 0, i32 0
  %24 = load i32* %current16, align 4
  %cmp17 = icmp eq i32 %24, 46
  br i1 %cmp17, label %if.then19, label %if.else

if.then19:                                        ; preds = %lor.lhs.false, %if.end12
  %25 = load %struct.LexState.235** %ls.addr, align 8
  %26 = load %struct.LexState.235** %ls.addr, align 8
  %current20 = getelementptr inbounds %struct.LexState.235* %26, i32 0, i32 0
  %27 = load i32* %current20, align 4
  call void @save(%struct.LexState.235* %25, i32 %27)
  %28 = load %struct.LexState.235** %ls.addr, align 8
  %z21 = getelementptr inbounds %struct.LexState.235* %28, i32 0, i32 7
  %29 = load %struct.Zio** %z21, align 8
  %n22 = getelementptr inbounds %struct.Zio* %29, i32 0, i32 0
  %30 = load i64* %n22, align 8
  %dec23 = add i64 %30, -1
  store i64 %dec23, i64* %n22, align 8
  %cmp24 = icmp ugt i64 %30, 0
  br i1 %cmp24, label %cond.true26, label %cond.false31

cond.true26:                                      ; preds = %if.then19
  %31 = load %struct.LexState.235** %ls.addr, align 8
  %z27 = getelementptr inbounds %struct.LexState.235* %31, i32 0, i32 7
  %32 = load %struct.Zio** %z27, align 8
  %p28 = getelementptr inbounds %struct.Zio* %32, i32 0, i32 1
  %33 = load i8** %p28, align 8
  %incdec.ptr29 = getelementptr inbounds i8* %33, i32 1
  store i8* %incdec.ptr29, i8** %p28, align 8
  %34 = load i8* %33, align 1
  %conv30 = zext i8 %34 to i32
  br label %cond.end34

cond.false31:                                     ; preds = %if.then19
  %35 = load %struct.LexState.235** %ls.addr, align 8
  %z32 = getelementptr inbounds %struct.LexState.235* %35, i32 0, i32 7
  %36 = load %struct.Zio** %z32, align 8
  %call33 = call i32 @luaZ_fill(%struct.Zio* %36)
  br label %cond.end34

cond.end34:                                       ; preds = %cond.false31, %cond.true26
  %cond35 = phi i32 [ %conv30, %cond.true26 ], [ %call33, %cond.false31 ]
  %37 = load %struct.LexState.235** %ls.addr, align 8
  %current36 = getelementptr inbounds %struct.LexState.235* %37, i32 0, i32 0
  store i32 %cond35, i32* %current36, align 4
  br label %if.end37

if.else:                                          ; preds = %lor.lhs.false
  br label %for.end

if.end37:                                         ; preds = %cond.end34
  br label %for.cond

for.end:                                          ; preds = %if.else
  %38 = load %struct.LexState.235** %ls.addr, align 8
  call void @save(%struct.LexState.235* %38, i32 0)
  %39 = load %struct.LexState.235** %ls.addr, align 8
  %40 = load %struct.LexState.235** %ls.addr, align 8
  %decpoint = getelementptr inbounds %struct.LexState.235* %40, i32 0, i32 12
  %41 = load i8* %decpoint, align 1
  call void @buffreplace(%struct.LexState.235* %39, i8 signext 46, i8 signext %41)
  %42 = load %struct.LexState.235** %ls.addr, align 8
  %buff = getelementptr inbounds %struct.LexState.235* %42, i32 0, i32 8
  %43 = load %struct.Mbuffer** %buff, align 8
  %buffer = getelementptr inbounds %struct.Mbuffer* %43, i32 0, i32 0
  %44 = load i8** %buffer, align 8
  %45 = load %struct.LexState.235** %ls.addr, align 8
  %buff38 = getelementptr inbounds %struct.LexState.235* %45, i32 0, i32 8
  %46 = load %struct.Mbuffer** %buff38, align 8
  %n39 = getelementptr inbounds %struct.Mbuffer* %46, i32 0, i32 1
  %47 = load i64* %n39, align 8
  %sub = sub i64 %47, 1
  %48 = load %union.SemInfo** %seminfo.addr, align 8
  %r = bitcast %union.SemInfo* %48 to double*
  %call40 = call i32 @luaO_str2d(i8* %44, i64 %sub, double* %r)
  %tobool41 = icmp ne i32 %call40, 0
  br i1 %tobool41, label %if.end43, label %if.then42

if.then42:                                        ; preds = %for.end
  %49 = load %struct.LexState.235** %ls.addr, align 8
  %50 = load %union.SemInfo** %seminfo.addr, align 8
  call void @trydecpoint(%struct.LexState.235* %49, %union.SemInfo* %50)
  br label %if.end43

if.end43:                                         ; preds = %if.then42, %for.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @readhexaesc(%struct.LexState.235* %ls) #0 {
entry:
  %ls.addr = alloca %struct.LexState.235*, align 8
  %c = alloca [3 x i32], align 4
  %i = alloca i32, align 4
  %r = alloca i32, align 4
  store %struct.LexState.235* %ls, %struct.LexState.235** %ls.addr, align 8
  store i32 0, i32* %r, align 4
  %arrayidx = getelementptr inbounds [3 x i32]* %c, i32 0, i64 0
  store i32 120, i32* %arrayidx, align 4
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32* %i, align 4
  %cmp = icmp slt i32 %0, 3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load %struct.LexState.235** %ls.addr, align 8
  %z = getelementptr inbounds %struct.LexState.235* %1, i32 0, i32 7
  %2 = load %struct.Zio** %z, align 8
  %n = getelementptr inbounds %struct.Zio* %2, i32 0, i32 0
  %3 = load i64* %n, align 8
  %dec = add i64 %3, -1
  store i64 %dec, i64* %n, align 8
  %cmp1 = icmp ugt i64 %3, 0
  br i1 %cmp1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  %4 = load %struct.LexState.235** %ls.addr, align 8
  %z2 = getelementptr inbounds %struct.LexState.235* %4, i32 0, i32 7
  %5 = load %struct.Zio** %z2, align 8
  %p = getelementptr inbounds %struct.Zio* %5, i32 0, i32 1
  %6 = load i8** %p, align 8
  %incdec.ptr = getelementptr inbounds i8* %6, i32 1
  store i8* %incdec.ptr, i8** %p, align 8
  %7 = load i8* %6, align 1
  %conv = zext i8 %7 to i32
  br label %cond.end

cond.false:                                       ; preds = %for.body
  %8 = load %struct.LexState.235** %ls.addr, align 8
  %z3 = getelementptr inbounds %struct.LexState.235* %8, i32 0, i32 7
  %9 = load %struct.Zio** %z3, align 8
  %call = call i32 @luaZ_fill(%struct.Zio* %9)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv, %cond.true ], [ %call, %cond.false ]
  %10 = load %struct.LexState.235** %ls.addr, align 8
  %current = getelementptr inbounds %struct.LexState.235* %10, i32 0, i32 0
  store i32 %cond, i32* %current, align 4
  %11 = load i32* %i, align 4
  %idxprom = sext i32 %11 to i64
  %arrayidx4 = getelementptr inbounds [3 x i32]* %c, i32 0, i64 %idxprom
  store i32 %cond, i32* %arrayidx4, align 4
  %12 = load i32* %i, align 4
  %idxprom5 = sext i32 %12 to i64
  %arrayidx6 = getelementptr inbounds [3 x i32]* %c, i32 0, i64 %idxprom5
  %13 = load i32* %arrayidx6, align 4
  %add = add nsw i32 %13, 1
  %idxprom7 = sext i32 %add to i64
  %arrayidx8 = getelementptr inbounds [257 x i8]* @luai_ctype_, i32 0, i64 %idxprom7
  %14 = load i8* %arrayidx8, align 1
  %conv9 = zext i8 %14 to i32
  %and = and i32 %conv9, 16
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  %15 = load %struct.LexState.235** %ls.addr, align 8
  %arraydecay = getelementptr inbounds [3 x i32]* %c, i32 0, i32 0
  %16 = load i32* %i, align 4
  %add10 = add nsw i32 %16, 1
  call void @escerror(%struct.LexState.235* %15, i32* %arraydecay, i32 %add10, i8* getelementptr inbounds ([27 x i8]* @.str15372, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end
  %17 = load i32* %r, align 4
  %shl = shl i32 %17, 4
  %18 = load i32* %i, align 4
  %idxprom11 = sext i32 %18 to i64
  %arrayidx12 = getelementptr inbounds [3 x i32]* %c, i32 0, i64 %idxprom11
  %19 = load i32* %arrayidx12, align 4
  %call13 = call i32 @luaO_hexavalue(i32 %19)
  %add14 = add nsw i32 %shl, %call13
  store i32 %add14, i32* %r, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %20 = load i32* %i, align 4
  %inc = add nsw i32 %20, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %21 = load i32* %r, align 4
  ret i32 %21
}

; Function Attrs: nounwind uwtable
define internal void @escerror(%struct.LexState.235* %ls, i32* %c, i32 %n, i8* %msg) #0 {
entry:
  %ls.addr = alloca %struct.LexState.235*, align 8
  %c.addr = alloca i32*, align 8
  %n.addr = alloca i32, align 4
  %msg.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  store %struct.LexState.235* %ls, %struct.LexState.235** %ls.addr, align 8
  store i32* %c, i32** %c.addr, align 8
  store i32 %n, i32* %n.addr, align 4
  store i8* %msg, i8** %msg.addr, align 8
  %0 = load %struct.LexState.235** %ls.addr, align 8
  %buff = getelementptr inbounds %struct.LexState.235* %0, i32 0, i32 8
  %1 = load %struct.Mbuffer** %buff, align 8
  %n1 = getelementptr inbounds %struct.Mbuffer* %1, i32 0, i32 1
  store i64 0, i64* %n1, align 8
  %2 = load %struct.LexState.235** %ls.addr, align 8
  call void @save(%struct.LexState.235* %2, i32 92)
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %3 = load i32* %i, align 4
  %4 = load i32* %n.addr, align 4
  %cmp = icmp slt i32 %3, %4
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %5 = load i32* %i, align 4
  %idxprom = sext i32 %5 to i64
  %6 = load i32** %c.addr, align 8
  %arrayidx = getelementptr inbounds i32* %6, i64 %idxprom
  %7 = load i32* %arrayidx, align 4
  %cmp2 = icmp ne i32 %7, -1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %8 = phi i1 [ false, %for.cond ], [ %cmp2, %land.rhs ]
  br i1 %8, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %9 = load %struct.LexState.235** %ls.addr, align 8
  %10 = load i32* %i, align 4
  %idxprom3 = sext i32 %10 to i64
  %11 = load i32** %c.addr, align 8
  %arrayidx4 = getelementptr inbounds i32* %11, i64 %idxprom3
  %12 = load i32* %arrayidx4, align 4
  call void @save(%struct.LexState.235* %9, i32 %12)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %13 = load i32* %i, align 4
  %inc = add nsw i32 %13, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %land.end
  %14 = load %struct.LexState.235** %ls.addr, align 8
  %15 = load i8** %msg.addr, align 8
  call void @lexerror(%struct.LexState.235* %14, i8* %15, i32 289) #9
  unreachable

return:                                           ; No predecessors!
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @readdecesc(%struct.LexState.235* %ls) #0 {
entry:
  %ls.addr = alloca %struct.LexState.235*, align 8
  %c = alloca [3 x i32], align 4
  %i = alloca i32, align 4
  %r = alloca i32, align 4
  store %struct.LexState.235* %ls, %struct.LexState.235** %ls.addr, align 8
  store i32 0, i32* %r, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32* %i, align 4
  %cmp = icmp slt i32 %0, 3
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %1 = load %struct.LexState.235** %ls.addr, align 8
  %current = getelementptr inbounds %struct.LexState.235* %1, i32 0, i32 0
  %2 = load i32* %current, align 4
  %add = add nsw i32 %2, 1
  %idxprom = sext i32 %add to i64
  %arrayidx = getelementptr inbounds [257 x i8]* @luai_ctype_, i32 0, i64 %idxprom
  %3 = load i8* %arrayidx, align 1
  %conv = zext i8 %3 to i32
  %and = and i32 %conv, 2
  %tobool = icmp ne i32 %and, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %4 = phi i1 [ false, %for.cond ], [ %tobool, %land.rhs ]
  br i1 %4, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %5 = load %struct.LexState.235** %ls.addr, align 8
  %current1 = getelementptr inbounds %struct.LexState.235* %5, i32 0, i32 0
  %6 = load i32* %current1, align 4
  %7 = load i32* %i, align 4
  %idxprom2 = sext i32 %7 to i64
  %arrayidx3 = getelementptr inbounds [3 x i32]* %c, i32 0, i64 %idxprom2
  store i32 %6, i32* %arrayidx3, align 4
  %8 = load i32* %r, align 4
  %mul = mul nsw i32 10, %8
  %9 = load i32* %i, align 4
  %idxprom4 = sext i32 %9 to i64
  %arrayidx5 = getelementptr inbounds [3 x i32]* %c, i32 0, i64 %idxprom4
  %10 = load i32* %arrayidx5, align 4
  %add6 = add nsw i32 %mul, %10
  %sub = sub nsw i32 %add6, 48
  store i32 %sub, i32* %r, align 4
  %11 = load %struct.LexState.235** %ls.addr, align 8
  %z = getelementptr inbounds %struct.LexState.235* %11, i32 0, i32 7
  %12 = load %struct.Zio** %z, align 8
  %n = getelementptr inbounds %struct.Zio* %12, i32 0, i32 0
  %13 = load i64* %n, align 8
  %dec = add i64 %13, -1
  store i64 %dec, i64* %n, align 8
  %cmp7 = icmp ugt i64 %13, 0
  br i1 %cmp7, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  %14 = load %struct.LexState.235** %ls.addr, align 8
  %z9 = getelementptr inbounds %struct.LexState.235* %14, i32 0, i32 7
  %15 = load %struct.Zio** %z9, align 8
  %p = getelementptr inbounds %struct.Zio* %15, i32 0, i32 1
  %16 = load i8** %p, align 8
  %incdec.ptr = getelementptr inbounds i8* %16, i32 1
  store i8* %incdec.ptr, i8** %p, align 8
  %17 = load i8* %16, align 1
  %conv10 = zext i8 %17 to i32
  br label %cond.end

cond.false:                                       ; preds = %for.body
  %18 = load %struct.LexState.235** %ls.addr, align 8
  %z11 = getelementptr inbounds %struct.LexState.235* %18, i32 0, i32 7
  %19 = load %struct.Zio** %z11, align 8
  %call = call i32 @luaZ_fill(%struct.Zio* %19)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv10, %cond.true ], [ %call, %cond.false ]
  %20 = load %struct.LexState.235** %ls.addr, align 8
  %current12 = getelementptr inbounds %struct.LexState.235* %20, i32 0, i32 0
  store i32 %cond, i32* %current12, align 4
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %21 = load i32* %i, align 4
  %inc = add nsw i32 %21, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %land.end
  %22 = load i32* %r, align 4
  %cmp13 = icmp sgt i32 %22, 255
  br i1 %cmp13, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  %23 = load %struct.LexState.235** %ls.addr, align 8
  %arraydecay = getelementptr inbounds [3 x i32]* %c, i32 0, i32 0
  %24 = load i32* %i, align 4
  call void @escerror(%struct.LexState.235* %23, i32* %arraydecay, i32 %24, i8* getelementptr inbounds ([25 x i8]* @.str14371, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %for.end
  %25 = load i32* %r, align 4
  ret i32 %25
}

; Function Attrs: nounwind uwtable
define internal void @buffreplace(%struct.LexState.235* %ls, i8 signext %from, i8 signext %to) #0 {
entry:
  %ls.addr = alloca %struct.LexState.235*, align 8
  %from.addr = alloca i8, align 1
  %to.addr = alloca i8, align 1
  %n = alloca i64, align 8
  %p = alloca i8*, align 8
  store %struct.LexState.235* %ls, %struct.LexState.235** %ls.addr, align 8
  store i8 %from, i8* %from.addr, align 1
  store i8 %to, i8* %to.addr, align 1
  %0 = load %struct.LexState.235** %ls.addr, align 8
  %buff = getelementptr inbounds %struct.LexState.235* %0, i32 0, i32 8
  %1 = load %struct.Mbuffer** %buff, align 8
  %n1 = getelementptr inbounds %struct.Mbuffer* %1, i32 0, i32 1
  %2 = load i64* %n1, align 8
  store i64 %2, i64* %n, align 8
  %3 = load %struct.LexState.235** %ls.addr, align 8
  %buff2 = getelementptr inbounds %struct.LexState.235* %3, i32 0, i32 8
  %4 = load %struct.Mbuffer** %buff2, align 8
  %buffer = getelementptr inbounds %struct.Mbuffer* %4, i32 0, i32 0
  %5 = load i8** %buffer, align 8
  store i8* %5, i8** %p, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %6 = load i64* %n, align 8
  %dec = add i64 %6, -1
  store i64 %dec, i64* %n, align 8
  %tobool = icmp ne i64 %6, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %7 = load i64* %n, align 8
  %8 = load i8** %p, align 8
  %arrayidx = getelementptr inbounds i8* %8, i64 %7
  %9 = load i8* %arrayidx, align 1
  %conv = sext i8 %9 to i32
  %10 = load i8* %from.addr, align 1
  %conv3 = sext i8 %10 to i32
  %cmp = icmp eq i32 %conv, %conv3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %11 = load i8* %to.addr, align 1
  %12 = load i64* %n, align 8
  %13 = load i8** %p, align 8
  %arrayidx5 = getelementptr inbounds i8* %13, i64 %12
  store i8 %11, i8* %arrayidx5, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @trydecpoint(%struct.LexState.235* %ls, %union.SemInfo* %seminfo) #0 {
entry:
  %ls.addr = alloca %struct.LexState.235*, align 8
  %seminfo.addr = alloca %union.SemInfo*, align 8
  %old = alloca i8, align 1
  store %struct.LexState.235* %ls, %struct.LexState.235** %ls.addr, align 8
  store %union.SemInfo* %seminfo, %union.SemInfo** %seminfo.addr, align 8
  %0 = load %struct.LexState.235** %ls.addr, align 8
  %decpoint = getelementptr inbounds %struct.LexState.235* %0, i32 0, i32 12
  %1 = load i8* %decpoint, align 1
  store i8 %1, i8* %old, align 1
  %call = call %struct.lconv* @localeconv() #1
  %decimal_point = getelementptr inbounds %struct.lconv* %call, i32 0, i32 0
  %2 = load i8** %decimal_point, align 8
  %arrayidx = getelementptr inbounds i8* %2, i64 0
  %3 = load i8* %arrayidx, align 1
  %4 = load %struct.LexState.235** %ls.addr, align 8
  %decpoint1 = getelementptr inbounds %struct.LexState.235* %4, i32 0, i32 12
  store i8 %3, i8* %decpoint1, align 1
  %5 = load %struct.LexState.235** %ls.addr, align 8
  %6 = load i8* %old, align 1
  %7 = load %struct.LexState.235** %ls.addr, align 8
  %decpoint2 = getelementptr inbounds %struct.LexState.235* %7, i32 0, i32 12
  %8 = load i8* %decpoint2, align 1
  call void @buffreplace(%struct.LexState.235* %5, i8 signext %6, i8 signext %8)
  %9 = load %struct.LexState.235** %ls.addr, align 8
  %buff = getelementptr inbounds %struct.LexState.235* %9, i32 0, i32 8
  %10 = load %struct.Mbuffer** %buff, align 8
  %buffer = getelementptr inbounds %struct.Mbuffer* %10, i32 0, i32 0
  %11 = load i8** %buffer, align 8
  %12 = load %struct.LexState.235** %ls.addr, align 8
  %buff3 = getelementptr inbounds %struct.LexState.235* %12, i32 0, i32 8
  %13 = load %struct.Mbuffer** %buff3, align 8
  %n = getelementptr inbounds %struct.Mbuffer* %13, i32 0, i32 1
  %14 = load i64* %n, align 8
  %sub = sub i64 %14, 1
  %15 = load %union.SemInfo** %seminfo.addr, align 8
  %r = bitcast %union.SemInfo* %15 to double*
  %call4 = call i32 @luaO_str2d(i8* %11, i64 %sub, double* %r)
  %tobool = icmp ne i32 %call4, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %16 = load %struct.LexState.235** %ls.addr, align 8
  %17 = load %struct.LexState.235** %ls.addr, align 8
  %decpoint5 = getelementptr inbounds %struct.LexState.235* %17, i32 0, i32 12
  %18 = load i8* %decpoint5, align 1
  call void @buffreplace(%struct.LexState.235* %16, i8 signext %18, i8 signext 46)
  %19 = load %struct.LexState.235** %ls.addr, align 8
  call void @lexerror(%struct.LexState.235* %19, i8* getelementptr inbounds ([17 x i8]* @.str10367, i32 0, i32 0), i32 287) #9
  unreachable

if.end:                                           ; preds = %entry
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @luaopen_math(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 27)
  %1 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_setfuncs(%struct.lua_State* %1, %struct.luaL_Reg* getelementptr inbounds ([28 x %struct.luaL_Reg]* @mathlib, i32 0, i32 0), i32 0)
  %2 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushnumber(%struct.lua_State* %2, double 0x400921FB54442D18)
  %3 = load %struct.lua_State** %L.addr, align 8
  call void @lua_setfield(%struct.lua_State* %3, i32 -2, i8* getelementptr inbounds ([3 x i8]* @.str413, i32 0, i32 0))
  %4 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushnumber(%struct.lua_State* %4, double 0x7FF0000000000000)
  %5 = load %struct.lua_State** %L.addr, align 8
  call void @lua_setfield(%struct.lua_State* %5, i32 -2, i8* getelementptr inbounds ([5 x i8]* @.str1414, i32 0, i32 0))
  ret i32 1
}

; Function Attrs: nounwind
declare double @tan(double) #4

; Function Attrs: nounwind
declare double @tanh(double) #4

; Function Attrs: nounwind
declare double @sqrt(double) #4

; Function Attrs: nounwind
declare double @sin(double) #4

; Function Attrs: nounwind
declare double @sinh(double) #4

; Function Attrs: nounwind
declare void @srand(i32) #4

; Function Attrs: nounwind
declare i32 @rand() #4

; Function Attrs: nounwind readnone
declare double @floor(double) #3

; Function Attrs: nounwind
declare double @pow(double, double) #4

; Function Attrs: nounwind
declare double @modf(double, double*) #4

; Function Attrs: nounwind
declare double @log(double) #4

; Function Attrs: nounwind
declare double @log10(double) #4

; Function Attrs: nounwind
declare double @ldexp(double, i32) #4

; Function Attrs: nounwind
declare double @frexp(double, i32*) #4

; Function Attrs: nounwind
declare double @fmod(double, double) #4

; Function Attrs: nounwind
declare double @exp(double) #4

; Function Attrs: nounwind
declare double @cos(double) #4

; Function Attrs: nounwind
declare double @cosh(double) #4

; Function Attrs: nounwind readnone
declare double @ceil(double) #3

; Function Attrs: nounwind
declare double @atan(double) #4

; Function Attrs: nounwind
declare double @atan2(double, double) #4

; Function Attrs: nounwind
declare double @asin(double) #4

; Function Attrs: nounwind
declare double @acos(double) #4

; Function Attrs: nounwind readnone
declare double @fabs(double) #3

; Function Attrs: nounwind uwtable
define internal i32 @math_abs(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call double @luaL_checknumber(%struct.lua_State* %1, i32 1)
  %call1 = call double @fabs(double %call) #11
  call void @lua_pushnumber(%struct.lua_State* %0, double %call1)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @math_acos(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call double @luaL_checknumber(%struct.lua_State* %1, i32 1)
  %call1 = call double @acos(double %call) #1
  call void @lua_pushnumber(%struct.lua_State* %0, double %call1)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @math_asin(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call double @luaL_checknumber(%struct.lua_State* %1, i32 1)
  %call1 = call double @asin(double %call) #1
  call void @lua_pushnumber(%struct.lua_State* %0, double %call1)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @math_atan2(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call double @luaL_checknumber(%struct.lua_State* %1, i32 1)
  %2 = load %struct.lua_State** %L.addr, align 8
  %call1 = call double @luaL_checknumber(%struct.lua_State* %2, i32 2)
  %call2 = call double @atan2(double %call, double %call1) #1
  call void @lua_pushnumber(%struct.lua_State* %0, double %call2)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @math_atan(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call double @luaL_checknumber(%struct.lua_State* %1, i32 1)
  %call1 = call double @atan(double %call) #1
  call void @lua_pushnumber(%struct.lua_State* %0, double %call1)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @math_ceil(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call double @luaL_checknumber(%struct.lua_State* %1, i32 1)
  %call1 = call double @ceil(double %call) #11
  call void @lua_pushnumber(%struct.lua_State* %0, double %call1)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @math_cosh(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call double @luaL_checknumber(%struct.lua_State* %1, i32 1)
  %call1 = call double @cosh(double %call) #1
  call void @lua_pushnumber(%struct.lua_State* %0, double %call1)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @math_cos(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call double @luaL_checknumber(%struct.lua_State* %1, i32 1)
  %call1 = call double @cos(double %call) #1
  call void @lua_pushnumber(%struct.lua_State* %0, double %call1)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @math_deg(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call double @luaL_checknumber(%struct.lua_State* %1, i32 1)
  %div = fdiv double %call, 0x3F91DF46A2529D39
  call void @lua_pushnumber(%struct.lua_State* %0, double %div)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @math_exp(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call double @luaL_checknumber(%struct.lua_State* %1, i32 1)
  %call1 = call double @exp(double %call) #1
  call void @lua_pushnumber(%struct.lua_State* %0, double %call1)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @math_floor(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call double @luaL_checknumber(%struct.lua_State* %1, i32 1)
  %call1 = call double @floor(double %call) #11
  call void @lua_pushnumber(%struct.lua_State* %0, double %call1)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @math_fmod(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call double @luaL_checknumber(%struct.lua_State* %1, i32 1)
  %2 = load %struct.lua_State** %L.addr, align 8
  %call1 = call double @luaL_checknumber(%struct.lua_State* %2, i32 2)
  %call2 = call double @fmod(double %call, double %call1) #1
  call void @lua_pushnumber(%struct.lua_State* %0, double %call2)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @math_frexp(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %e = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call double @luaL_checknumber(%struct.lua_State* %1, i32 1)
  %call1 = call double @frexp(double %call, i32* %e) #1
  call void @lua_pushnumber(%struct.lua_State* %0, double %call1)
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load i32* %e, align 4
  %conv = sext i32 %3 to i64
  call void @lua_pushinteger(%struct.lua_State* %2, i64 %conv)
  ret i32 2
}

; Function Attrs: nounwind uwtable
define internal i32 @math_ldexp(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %x = alloca double, align 8
  %ep = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call double @luaL_checknumber(%struct.lua_State* %0, i32 1)
  store double %call, double* %x, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i64 @luaL_checkinteger(%struct.lua_State* %1, i32 2)
  %conv = trunc i64 %call1 to i32
  store i32 %conv, i32* %ep, align 4
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load double* %x, align 8
  %4 = load i32* %ep, align 4
  %call2 = call double @ldexp(double %3, i32 %4) #1
  call void @lua_pushnumber(%struct.lua_State* %2, double %call2)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @math_log(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %x = alloca double, align 8
  %res = alloca double, align 8
  %base = alloca double, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call double @luaL_checknumber(%struct.lua_State* %0, i32 1)
  store double %call, double* %x, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i32 @lua_type(%struct.lua_State* %1, i32 2)
  %cmp = icmp sle i32 %call1, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load double* %x, align 8
  %call2 = call double @log(double %2) #1
  store double %call2, double* %res, align 8
  br label %if.end10

if.else:                                          ; preds = %entry
  %3 = load %struct.lua_State** %L.addr, align 8
  %call3 = call double @luaL_checknumber(%struct.lua_State* %3, i32 2)
  store double %call3, double* %base, align 8
  %4 = load double* %base, align 8
  %cmp4 = fcmp oeq double %4, 1.000000e+01
  br i1 %cmp4, label %if.then5, label %if.else7

if.then5:                                         ; preds = %if.else
  %5 = load double* %x, align 8
  %call6 = call double @log10(double %5) #1
  store double %call6, double* %res, align 8
  br label %if.end

if.else7:                                         ; preds = %if.else
  %6 = load double* %x, align 8
  %call8 = call double @log(double %6) #1
  %7 = load double* %base, align 8
  %call9 = call double @log(double %7) #1
  %div = fdiv double %call8, %call9
  store double %div, double* %res, align 8
  br label %if.end

if.end:                                           ; preds = %if.else7, %if.then5
  br label %if.end10

if.end10:                                         ; preds = %if.end, %if.then
  %8 = load %struct.lua_State** %L.addr, align 8
  %9 = load double* %res, align 8
  call void @lua_pushnumber(%struct.lua_State* %8, double %9)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @math_max(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %n = alloca i32, align 4
  %dmax = alloca double, align 8
  %i = alloca i32, align 4
  %d = alloca double, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_gettop(%struct.lua_State* %0)
  store i32 %call, i32* %n, align 4
  %1 = load %struct.lua_State** %L.addr, align 8
  %call1 = call double @luaL_checknumber(%struct.lua_State* %1, i32 1)
  store double %call1, double* %dmax, align 8
  store i32 2, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32* %i, align 4
  %3 = load i32* %n, align 4
  %cmp = icmp sle i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load i32* %i, align 4
  %call2 = call double @luaL_checknumber(%struct.lua_State* %4, i32 %5)
  store double %call2, double* %d, align 8
  %6 = load double* %d, align 8
  %7 = load double* %dmax, align 8
  %cmp3 = fcmp ogt double %6, %7
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %8 = load double* %d, align 8
  store double %8, double* %dmax, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %9 = load i32* %i, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %10 = load %struct.lua_State** %L.addr, align 8
  %11 = load double* %dmax, align 8
  call void @lua_pushnumber(%struct.lua_State* %10, double %11)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @math_min(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %n = alloca i32, align 4
  %dmin = alloca double, align 8
  %i = alloca i32, align 4
  %d = alloca double, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_gettop(%struct.lua_State* %0)
  store i32 %call, i32* %n, align 4
  %1 = load %struct.lua_State** %L.addr, align 8
  %call1 = call double @luaL_checknumber(%struct.lua_State* %1, i32 1)
  store double %call1, double* %dmin, align 8
  store i32 2, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32* %i, align 4
  %3 = load i32* %n, align 4
  %cmp = icmp sle i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load i32* %i, align 4
  %call2 = call double @luaL_checknumber(%struct.lua_State* %4, i32 %5)
  store double %call2, double* %d, align 8
  %6 = load double* %d, align 8
  %7 = load double* %dmin, align 8
  %cmp3 = fcmp olt double %6, %7
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %8 = load double* %d, align 8
  store double %8, double* %dmin, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %9 = load i32* %i, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %10 = load %struct.lua_State** %L.addr, align 8
  %11 = load double* %dmin, align 8
  call void @lua_pushnumber(%struct.lua_State* %10, double %11)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @math_modf(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %ip = alloca double, align 8
  %fp = alloca double, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call double @luaL_checknumber(%struct.lua_State* %0, i32 1)
  %call1 = call double @modf(double %call, double* %ip) #1
  store double %call1, double* %fp, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load double* %ip, align 8
  call void @lua_pushnumber(%struct.lua_State* %1, double %2)
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load double* %fp, align 8
  call void @lua_pushnumber(%struct.lua_State* %3, double %4)
  ret i32 2
}

; Function Attrs: nounwind uwtable
define internal i32 @math_pow(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %x = alloca double, align 8
  %y = alloca double, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call double @luaL_checknumber(%struct.lua_State* %0, i32 1)
  store double %call, double* %x, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call1 = call double @luaL_checknumber(%struct.lua_State* %1, i32 2)
  store double %call1, double* %y, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load double* %x, align 8
  %4 = load double* %y, align 8
  %call2 = call double @pow(double %3, double %4) #1
  call void @lua_pushnumber(%struct.lua_State* %2, double %call2)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @math_rad(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call double @luaL_checknumber(%struct.lua_State* %1, i32 1)
  %mul = fmul double %call, 0x3F91DF46A2529D39
  call void @lua_pushnumber(%struct.lua_State* %0, double %mul)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @math_random(%struct.lua_State* %L) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %r = alloca double, align 8
  %u = alloca double, align 8
  %l = alloca double, align 8
  %u9 = alloca double, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %call = call i32 @rand() #1
  %rem = srem i32 %call, 2147483647
  %conv = sitofp i32 %rem to double
  %div = fdiv double %conv, 0x41DFFFFFFFC00000
  store double %div, double* %r, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i32 @lua_gettop(%struct.lua_State* %0)
  switch i32 %call1, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb2
    i32 2, label %sw.bb7
  ]

sw.bb:                                            ; preds = %entry
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load double* %r, align 8
  call void @lua_pushnumber(%struct.lua_State* %1, double %2)
  br label %sw.epilog

sw.bb2:                                           ; preds = %entry
  %3 = load %struct.lua_State** %L.addr, align 8
  %call3 = call double @luaL_checknumber(%struct.lua_State* %3, i32 1)
  store double %call3, double* %u, align 8
  %4 = load double* %u, align 8
  %cmp = fcmp ole double 1.000000e+00, %4
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %sw.bb2
  %5 = load %struct.lua_State** %L.addr, align 8
  %call5 = call i32 @luaL_argerror(%struct.lua_State* %5, i32 1, i8* getelementptr inbounds ([18 x i8]* @.str29442, i32 0, i32 0))
  %tobool = icmp ne i32 %call5, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %sw.bb2
  %6 = phi i1 [ true, %sw.bb2 ], [ %tobool, %lor.rhs ]
  %lor.ext = zext i1 %6 to i32
  %7 = load %struct.lua_State** %L.addr, align 8
  %8 = load double* %r, align 8
  %9 = load double* %u, align 8
  %mul = fmul double %8, %9
  %call6 = call double @floor(double %mul) #11
  %add = fadd double %call6, 1.000000e+00
  call void @lua_pushnumber(%struct.lua_State* %7, double %add)
  br label %sw.epilog

sw.bb7:                                           ; preds = %entry
  %10 = load %struct.lua_State** %L.addr, align 8
  %call8 = call double @luaL_checknumber(%struct.lua_State* %10, i32 1)
  store double %call8, double* %l, align 8
  %11 = load %struct.lua_State** %L.addr, align 8
  %call10 = call double @luaL_checknumber(%struct.lua_State* %11, i32 2)
  store double %call10, double* %u9, align 8
  %12 = load double* %l, align 8
  %13 = load double* %u9, align 8
  %cmp11 = fcmp ole double %12, %13
  br i1 %cmp11, label %lor.end16, label %lor.rhs13

lor.rhs13:                                        ; preds = %sw.bb7
  %14 = load %struct.lua_State** %L.addr, align 8
  %call14 = call i32 @luaL_argerror(%struct.lua_State* %14, i32 2, i8* getelementptr inbounds ([18 x i8]* @.str29442, i32 0, i32 0))
  %tobool15 = icmp ne i32 %call14, 0
  br label %lor.end16

lor.end16:                                        ; preds = %lor.rhs13, %sw.bb7
  %15 = phi i1 [ true, %sw.bb7 ], [ %tobool15, %lor.rhs13 ]
  %lor.ext17 = zext i1 %15 to i32
  %16 = load %struct.lua_State** %L.addr, align 8
  %17 = load double* %r, align 8
  %18 = load double* %u9, align 8
  %19 = load double* %l, align 8
  %sub = fsub double %18, %19
  %add18 = fadd double %sub, 1.000000e+00
  %mul19 = fmul double %17, %add18
  %call20 = call double @floor(double %mul19) #11
  %20 = load double* %l, align 8
  %add21 = fadd double %call20, %20
  call void @lua_pushnumber(%struct.lua_State* %16, double %add21)
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %21 = load %struct.lua_State** %L.addr, align 8
  %call22 = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %21, i8* getelementptr inbounds ([26 x i8]* @.str30443, i32 0, i32 0))
  store i32 %call22, i32* %retval
  br label %return

sw.epilog:                                        ; preds = %lor.end16, %lor.end, %sw.bb
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %sw.epilog, %sw.default
  %22 = load i32* %retval
  ret i32 %22
}

; Function Attrs: nounwind uwtable
define internal i32 @math_randomseed(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @luaL_checkunsigned(%struct.lua_State* %0, i32 1)
  call void @srand(i32 %call) #1
  %call1 = call i32 @rand() #1
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @math_sinh(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call double @luaL_checknumber(%struct.lua_State* %1, i32 1)
  %call1 = call double @sinh(double %call) #1
  call void @lua_pushnumber(%struct.lua_State* %0, double %call1)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @math_sin(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call double @luaL_checknumber(%struct.lua_State* %1, i32 1)
  %call1 = call double @sin(double %call) #1
  call void @lua_pushnumber(%struct.lua_State* %0, double %call1)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @math_sqrt(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call double @luaL_checknumber(%struct.lua_State* %1, i32 1)
  %call1 = call double @sqrt(double %call) #1
  call void @lua_pushnumber(%struct.lua_State* %0, double %call1)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @math_tanh(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call double @luaL_checknumber(%struct.lua_State* %1, i32 1)
  %call1 = call double @tanh(double %call) #1
  call void @lua_pushnumber(%struct.lua_State* %0, double %call1)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @math_tan(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call double @luaL_checknumber(%struct.lua_State* %1, i32 1)
  %call1 = call double @tan(double %call) #1
  call void @lua_pushnumber(%struct.lua_State* %0, double %call1)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define hidden i8* @luaM_growaux_(%struct.lua_State* %L, i8* %block, i32* %size, i64 %size_elems, i32 %limit, i8* %what) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %block.addr = alloca i8*, align 8
  %size.addr = alloca i32*, align 8
  %size_elems.addr = alloca i64, align 8
  %limit.addr = alloca i32, align 4
  %what.addr = alloca i8*, align 8
  %newblock = alloca i8*, align 8
  %newsize = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %block, i8** %block.addr, align 8
  store i32* %size, i32** %size.addr, align 8
  store i64 %size_elems, i64* %size_elems.addr, align 8
  store i32 %limit, i32* %limit.addr, align 4
  store i8* %what, i8** %what.addr, align 8
  %0 = load i32** %size.addr, align 8
  %1 = load i32* %0, align 4
  %2 = load i32* %limit.addr, align 4
  %div = sdiv i32 %2, 2
  %cmp = icmp sge i32 %1, %div
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load i32** %size.addr, align 8
  %4 = load i32* %3, align 4
  %5 = load i32* %limit.addr, align 4
  %cmp1 = icmp sge i32 %4, %5
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %6 = load %struct.lua_State** %L.addr, align 8
  %7 = load i8** %what.addr, align 8
  %8 = load i32* %limit.addr, align 4
  call void (%struct.lua_State*, i8*, ...)* @luaG_runerror(%struct.lua_State* %6, i8* getelementptr inbounds ([26 x i8]* @.str446, i32 0, i32 0), i8* %7, i32 %8) #9
  unreachable

if.end:                                           ; preds = %if.then
  %9 = load i32* %limit.addr, align 4
  store i32 %9, i32* %newsize, align 4
  br label %if.end6

if.else:                                          ; preds = %entry
  %10 = load i32** %size.addr, align 8
  %11 = load i32* %10, align 4
  %mul = mul nsw i32 %11, 2
  store i32 %mul, i32* %newsize, align 4
  %12 = load i32* %newsize, align 4
  %cmp3 = icmp slt i32 %12, 4
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.else
  store i32 4, i32* %newsize, align 4
  br label %if.end5

if.end5:                                          ; preds = %if.then4, %if.else
  br label %if.end6

if.end6:                                          ; preds = %if.end5, %if.end
  %13 = load i32* %newsize, align 4
  %add = add nsw i32 %13, 1
  %conv = sext i32 %add to i64
  %14 = load i64* %size_elems.addr, align 8
  %div7 = udiv i64 -3, %14
  %cmp8 = icmp ugt i64 %conv, %div7
  br i1 %cmp8, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end6
  %15 = load %struct.lua_State** %L.addr, align 8
  call void @luaM_toobig(%struct.lua_State* %15) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.false:                                       ; preds = %if.end6
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %16
  %cond = phi i32 [ 0, %16 ], [ 0, %cond.false ]
  %17 = load %struct.lua_State** %L.addr, align 8
  %18 = load i8** %block.addr, align 8
  %19 = load i32** %size.addr, align 8
  %20 = load i32* %19, align 4
  %conv10 = sext i32 %20 to i64
  %21 = load i64* %size_elems.addr, align 8
  %mul11 = mul i64 %conv10, %21
  %22 = load i32* %newsize, align 4
  %conv12 = sext i32 %22 to i64
  %23 = load i64* %size_elems.addr, align 8
  %mul13 = mul i64 %conv12, %23
  %call = call i8* @luaM_realloc_(%struct.lua_State* %17, i8* %18, i64 %mul11, i64 %mul13)
  store i8* %call, i8** %newblock, align 8
  %24 = load i32* %newsize, align 4
  %25 = load i32** %size.addr, align 8
  store i32 %24, i32* %25, align 4
  %26 = load i8** %newblock, align 8
  ret i8* %26
}

; Function Attrs: noreturn nounwind uwtable
define hidden void @luaM_toobig(%struct.lua_State* %L) #6 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  call void (%struct.lua_State*, i8*, ...)* @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([39 x i8]* @.str1447, i32 0, i32 0)) #9
  unreachable

return:                                           ; No predecessors!
  ret void
}

; Function Attrs: nounwind uwtable
define hidden i8* @luaM_realloc_(%struct.lua_State* %L, i8* %block, i64 %osize, i64 %nsize) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %block.addr = alloca i8*, align 8
  %osize.addr = alloca i64, align 8
  %nsize.addr = alloca i64, align 8
  %newblock = alloca i8*, align 8
  %g = alloca %struct.global_State*, align 8
  %realosize = alloca i64, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %block, i8** %block.addr, align 8
  store i64 %osize, i64* %osize.addr, align 8
  store i64 %nsize, i64* %nsize.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %0, i32 0, i32 5
  %1 = load %struct.global_State** %l_G, align 8
  store %struct.global_State* %1, %struct.global_State** %g, align 8
  %2 = load i8** %block.addr, align 8
  %tobool = icmp ne i8* %2, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load i64* %osize.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %3, %cond.true ], [ 0, %cond.false ]
  store i64 %cond, i64* %realosize, align 8
  %4 = load %struct.global_State** %g, align 8
  %frealloc = getelementptr inbounds %struct.global_State* %4, i32 0, i32 0
  %5 = load i8* (i8*, i8*, i64, i64)** %frealloc, align 8
  %6 = load %struct.global_State** %g, align 8
  %ud = getelementptr inbounds %struct.global_State* %6, i32 0, i32 1
  %7 = load i8** %ud, align 8
  %8 = load i8** %block.addr, align 8
  %9 = load i64* %osize.addr, align 8
  %10 = load i64* %nsize.addr, align 8
  %call = call i8* %5(i8* %7, i8* %8, i64 %9, i64 %10)
  store i8* %call, i8** %newblock, align 8
  %11 = load i8** %newblock, align 8
  %cmp = icmp eq i8* %11, null
  br i1 %cmp, label %land.lhs.true, label %if.end10

land.lhs.true:                                    ; preds = %cond.end
  %12 = load i64* %nsize.addr, align 8
  %cmp1 = icmp ugt i64 %12, 0
  br i1 %cmp1, label %if.then, label %if.end10

if.then:                                          ; preds = %land.lhs.true
  %13 = load %struct.global_State** %g, align 8
  %gcrunning = getelementptr inbounds %struct.global_State* %13, i32 0, i32 12
  %14 = load i8* %gcrunning, align 1
  %tobool2 = icmp ne i8 %14, 0
  br i1 %tobool2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %15 = load %struct.lua_State** %L.addr, align 8
  call void @luaC_fullgc(%struct.lua_State* %15, i32 1)
  %16 = load %struct.global_State** %g, align 8
  %frealloc4 = getelementptr inbounds %struct.global_State* %16, i32 0, i32 0
  %17 = load i8* (i8*, i8*, i64, i64)** %frealloc4, align 8
  %18 = load %struct.global_State** %g, align 8
  %ud5 = getelementptr inbounds %struct.global_State* %18, i32 0, i32 1
  %19 = load i8** %ud5, align 8
  %20 = load i8** %block.addr, align 8
  %21 = load i64* %osize.addr, align 8
  %22 = load i64* %nsize.addr, align 8
  %call6 = call i8* %17(i8* %19, i8* %20, i64 %21, i64 %22)
  store i8* %call6, i8** %newblock, align 8
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.then
  %23 = load i8** %newblock, align 8
  %cmp7 = icmp eq i8* %23, null
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end
  %24 = load %struct.lua_State** %L.addr, align 8
  call void @luaD_throw(%struct.lua_State* %24, i32 4) #9
  unreachable

if.end9:                                          ; preds = %if.end
  br label %if.end10

if.end10:                                         ; preds = %if.end9, %land.lhs.true, %cond.end
  %25 = load %struct.global_State** %g, align 8
  %GCdebt = getelementptr inbounds %struct.global_State* %25, i32 0, i32 3
  %26 = load i64* %GCdebt, align 8
  %27 = load i64* %nsize.addr, align 8
  %add = add i64 %26, %27
  %28 = load i64* %realosize, align 8
  %sub = sub i64 %add, %28
  %29 = load %struct.global_State** %g, align 8
  %GCdebt11 = getelementptr inbounds %struct.global_State* %29, i32 0, i32 3
  store i64 %sub, i64* %GCdebt11, align 8
  %30 = load i8** %newblock, align 8
  ret i8* %30
}

; Function Attrs: nounwind uwtable
define i32 @luaopen_package(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @luaL_getsubtable(%struct.lua_State* %0, i32 -1001000, i8* getelementptr inbounds ([7 x i8]* @.str454, i32 0, i32 0))
  %1 = load %struct.lua_State** %L.addr, align 8
  call void @lua_createtable(%struct.lua_State* %1, i32 0, i32 1)
  %2 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushcclosure(%struct.lua_State* %2, i32 (%struct.lua_State*)* @gctm, i32 0)
  %3 = load %struct.lua_State** %L.addr, align 8
  call void @lua_setfield(%struct.lua_State* %3, i32 -2, i8* getelementptr inbounds ([5 x i8]* @.str1455, i32 0, i32 0))
  %4 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i32 @lua_setmetatable(%struct.lua_State* %4, i32 -2)
  %5 = load %struct.lua_State** %L.addr, align 8
  call void @lua_createtable(%struct.lua_State* %5, i32 0, i32 2)
  %6 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_setfuncs(%struct.lua_State* %6, %struct.luaL_Reg* getelementptr inbounds ([3 x %struct.luaL_Reg]* @pk_funcs, i32 0, i32 0), i32 0)
  %7 = load %struct.lua_State** %L.addr, align 8
  call void @createsearcherstable(%struct.lua_State* %7)
  %8 = load %struct.lua_State** %L.addr, align 8
  call void @lua_setfield(%struct.lua_State* %8, i32 -2, i8* getelementptr inbounds ([10 x i8]* @.str2456, i32 0, i32 0))
  %9 = load %struct.lua_State** %L.addr, align 8
  call void @setpath(%struct.lua_State* %9, i8* getelementptr inbounds ([5 x i8]* @.str3457, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8]* @.str4458, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8]* @.str5459, i32 0, i32 0), i8* getelementptr inbounds ([138 x i8]* @.str6460, i32 0, i32 0))
  %10 = load %struct.lua_State** %L.addr, align 8
  call void @setpath(%struct.lua_State* %10, i8* getelementptr inbounds ([6 x i8]* @.str7461, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8]* @.str8462, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8]* @.str9463, i32 0, i32 0), i8* getelementptr inbounds ([69 x i8]* @.str10464, i32 0, i32 0))
  %11 = load %struct.lua_State** %L.addr, align 8
  %call2 = call i8* @lua_pushlstring(%struct.lua_State* %11, i8* getelementptr inbounds ([11 x i8]* @.str11465, i32 0, i32 0), i64 10)
  %12 = load %struct.lua_State** %L.addr, align 8
  call void @lua_setfield(%struct.lua_State* %12, i32 -2, i8* getelementptr inbounds ([7 x i8]* @.str12466, i32 0, i32 0))
  %13 = load %struct.lua_State** %L.addr, align 8
  %call3 = call i32 @luaL_getsubtable(%struct.lua_State* %13, i32 -1001000, i8* getelementptr inbounds ([8 x i8]* @.str13467, i32 0, i32 0))
  %14 = load %struct.lua_State** %L.addr, align 8
  call void @lua_setfield(%struct.lua_State* %14, i32 -2, i8* getelementptr inbounds ([7 x i8]* @.str14468, i32 0, i32 0))
  %15 = load %struct.lua_State** %L.addr, align 8
  %call4 = call i32 @luaL_getsubtable(%struct.lua_State* %15, i32 -1001000, i8* getelementptr inbounds ([9 x i8]* @.str15469, i32 0, i32 0))
  %16 = load %struct.lua_State** %L.addr, align 8
  call void @lua_setfield(%struct.lua_State* %16, i32 -2, i8* getelementptr inbounds ([8 x i8]* @.str16470, i32 0, i32 0))
  %17 = load %struct.lua_State** %L.addr, align 8
  call void @lua_rawgeti(%struct.lua_State* %17, i32 -1001000, i32 2)
  %18 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushvalue(%struct.lua_State* %18, i32 -2)
  %19 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_setfuncs(%struct.lua_State* %19, %struct.luaL_Reg* getelementptr inbounds ([2 x %struct.luaL_Reg]* @ll_funcs, i32 0, i32 0), i32 1)
  %20 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %20, i32 -2)
  ret i32 1
}

; Function Attrs: nounwind
declare i8* @getenv(i8*) #4

; Function Attrs: nounwind
declare i8* @dlsym(i8*, i8*) #4

; Function Attrs: nounwind
declare i8* @dlerror() #4

; Function Attrs: nounwind
declare i8* @dlopen(i8*, i32) #4

; Function Attrs: nounwind
declare i32 @dlclose(i8*) #4

; Function Attrs: nounwind uwtable
define internal i32 @ll_loadlib(%struct.lua_State* %L) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %path = alloca i8*, align 8
  %init = alloca i8*, align 8
  %stat = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null)
  store i8* %call, i8** %path, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i8* @luaL_checklstring(%struct.lua_State* %1, i32 2, i64* null)
  store i8* %call1, i8** %init, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load i8** %path, align 8
  %4 = load i8** %init, align 8
  %call2 = call i32 @ll_loadfunc(%struct.lua_State* %2, i8* %3, i8* %4)
  store i32 %call2, i32* %stat, align 4
  %5 = load i32* %stat, align 4
  %cmp = icmp eq i32 %5, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval
  br label %return

if.else:                                          ; preds = %entry
  %6 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushnil(%struct.lua_State* %6)
  %7 = load %struct.lua_State** %L.addr, align 8
  call void @lua_insert(%struct.lua_State* %7, i32 -2)
  %8 = load %struct.lua_State** %L.addr, align 8
  %9 = load i32* %stat, align 4
  %cmp3 = icmp eq i32 %9, 1
  %cond = select i1 %cmp3, i8* getelementptr inbounds ([5 x i8]* @.str39493, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8]* @.str40494, i32 0, i32 0)
  %call4 = call i8* @lua_pushstring(%struct.lua_State* %8, i8* %cond)
  store i32 3, i32* %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %10 = load i32* %retval
  ret i32 %10
}

; Function Attrs: nounwind uwtable
define internal i32 @ll_searchpath(%struct.lua_State* %L) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %f = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @luaL_checklstring(%struct.lua_State* %1, i32 1, i64* null)
  %2 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i8* @luaL_checklstring(%struct.lua_State* %2, i32 2, i64* null)
  %3 = load %struct.lua_State** %L.addr, align 8
  %call2 = call i8* @luaL_optlstring(%struct.lua_State* %3, i32 3, i8* getelementptr inbounds ([2 x i8]* @.str27481, i32 0, i32 0), i64* null)
  %4 = load %struct.lua_State** %L.addr, align 8
  %call3 = call i8* @luaL_optlstring(%struct.lua_State* %4, i32 4, i8* getelementptr inbounds ([2 x i8]* @.str24478, i32 0, i32 0), i64* null)
  %call4 = call i8* @searchpath(%struct.lua_State* %0, i8* %call, i8* %call1, i8* %call2, i8* %call3)
  store i8* %call4, i8** %f, align 8
  %5 = load i8** %f, align 8
  %cmp = icmp ne i8* %5, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval
  br label %return

if.else:                                          ; preds = %entry
  %6 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushnil(%struct.lua_State* %6)
  %7 = load %struct.lua_State** %L.addr, align 8
  call void @lua_insert(%struct.lua_State* %7, i32 -2)
  store i32 2, i32* %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %8 = load i32* %retval
  ret i32 %8
}

; Function Attrs: nounwind uwtable
define internal i32 @ll_require(%struct.lua_State* %L) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %name = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null)
  store i8* %call, i8** %name, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %1, i32 1)
  %2 = load %struct.lua_State** %L.addr, align 8
  call void @lua_getfield(%struct.lua_State* %2, i32 -1001000, i8* getelementptr inbounds ([8 x i8]* @.str13467, i32 0, i32 0))
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load i8** %name, align 8
  call void @lua_getfield(%struct.lua_State* %3, i32 2, i8* %4)
  %5 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i32 @lua_toboolean(%struct.lua_State* %5, i32 -1)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %6 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %6, i32 -2)
  %7 = load %struct.lua_State** %L.addr, align 8
  %8 = load i8** %name, align 8
  call void @findloader(%struct.lua_State* %7, i8* %8)
  %9 = load %struct.lua_State** %L.addr, align 8
  %10 = load i8** %name, align 8
  %call2 = call i8* @lua_pushstring(%struct.lua_State* %9, i8* %10)
  %11 = load %struct.lua_State** %L.addr, align 8
  call void @lua_insert(%struct.lua_State* %11, i32 -2)
  %12 = load %struct.lua_State** %L.addr, align 8
  call void @lua_callk(%struct.lua_State* %12, i32 2, i32 1, i32 0, i32 (%struct.lua_State*)* null)
  %13 = load %struct.lua_State** %L.addr, align 8
  %call3 = call i32 @lua_type(%struct.lua_State* %13, i32 -1)
  %cmp = icmp eq i32 %call3, 0
  br i1 %cmp, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end
  %14 = load %struct.lua_State** %L.addr, align 8
  %15 = load i8** %name, align 8
  call void @lua_setfield(%struct.lua_State* %14, i32 2, i8* %15)
  br label %if.end5

if.end5:                                          ; preds = %if.then4, %if.end
  %16 = load %struct.lua_State** %L.addr, align 8
  %17 = load i8** %name, align 8
  call void @lua_getfield(%struct.lua_State* %16, i32 2, i8* %17)
  %18 = load %struct.lua_State** %L.addr, align 8
  %call6 = call i32 @lua_type(%struct.lua_State* %18, i32 -1)
  %cmp7 = icmp eq i32 %call6, 0
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end5
  %19 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushboolean(%struct.lua_State* %19, i32 1)
  %20 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushvalue(%struct.lua_State* %20, i32 -1)
  %21 = load %struct.lua_State** %L.addr, align 8
  %22 = load i8** %name, align 8
  call void @lua_setfield(%struct.lua_State* %21, i32 2, i8* %22)
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %if.end5
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %if.end9, %if.then
  %23 = load i32* %retval
  ret i32 %23
}

; Function Attrs: nounwind uwtable
define internal i32 @searcher_preload(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %name = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null)
  store i8* %call, i8** %name, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  call void @lua_getfield(%struct.lua_State* %1, i32 -1001000, i8* getelementptr inbounds ([9 x i8]* @.str15469, i32 0, i32 0))
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load i8** %name, align 8
  call void @lua_getfield(%struct.lua_State* %2, i32 -1, i8* %3)
  %4 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i32 @lua_type(%struct.lua_State* %4, i32 -1)
  %cmp = icmp eq i32 %call1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load %struct.lua_State** %L.addr, align 8
  %6 = load i8** %name, align 8
  %call2 = call i8* (%struct.lua_State*, i8*, ...)* @lua_pushfstring(%struct.lua_State* %5, i8* getelementptr inbounds ([33 x i8]* @.str36490, i32 0, i32 0), i8* %6)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @searcher_Lua(%struct.lua_State* %L) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %filename = alloca i8*, align 8
  %name = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null)
  store i8* %call, i8** %name, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load i8** %name, align 8
  %call1 = call i8* @findfile(%struct.lua_State* %1, i8* %2, i8* getelementptr inbounds ([5 x i8]* @.str3457, i32 0, i32 0), i8* getelementptr inbounds ([2 x i8]* @.str24478, i32 0, i32 0))
  store i8* %call1, i8** %filename, align 8
  %3 = load i8** %filename, align 8
  %cmp = icmp eq i8* %3, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load %struct.lua_State** %L.addr, align 8
  %6 = load i8** %filename, align 8
  %call2 = call i32 @luaL_loadfilex(%struct.lua_State* %5, i8* %6, i8* null)
  %cmp3 = icmp eq i32 %call2, 0
  %conv = zext i1 %cmp3 to i32
  %7 = load i8** %filename, align 8
  %call4 = call i32 @checkload(%struct.lua_State* %4, i32 %conv, i8* %7)
  store i32 %call4, i32* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load i32* %retval
  ret i32 %8
}

; Function Attrs: nounwind uwtable
define internal i32 @searcher_C(%struct.lua_State* %L) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %name = alloca i8*, align 8
  %filename = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null)
  store i8* %call, i8** %name, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load i8** %name, align 8
  %call1 = call i8* @findfile(%struct.lua_State* %1, i8* %2, i8* getelementptr inbounds ([6 x i8]* @.str7461, i32 0, i32 0), i8* getelementptr inbounds ([2 x i8]* @.str24478, i32 0, i32 0))
  store i8* %call1, i8** %filename, align 8
  %3 = load i8** %filename, align 8
  %cmp = icmp eq i8* %3, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load %struct.lua_State** %L.addr, align 8
  %6 = load i8** %filename, align 8
  %7 = load i8** %name, align 8
  %call2 = call i32 @loadfunc(%struct.lua_State* %5, i8* %6, i8* %7)
  %cmp3 = icmp eq i32 %call2, 0
  %conv = zext i1 %cmp3 to i32
  %8 = load i8** %filename, align 8
  %call4 = call i32 @checkload(%struct.lua_State* %4, i32 %conv, i8* %8)
  store i32 %call4, i32* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %9 = load i32* %retval
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define internal i32 @searcher_Croot(%struct.lua_State* %L) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %filename = alloca i8*, align 8
  %name = alloca i8*, align 8
  %p = alloca i8*, align 8
  %stat = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null)
  store i8* %call, i8** %name, align 8
  %1 = load i8** %name, align 8
  %call1 = call i8* @strchr(i8* %1, i32 46) #10
  store i8* %call1, i8** %p, align 8
  %2 = load i8** %p, align 8
  %cmp = icmp eq i8* %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load i8** %name, align 8
  %5 = load i8** %p, align 8
  %6 = load i8** %name, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %5 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %6 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %call2 = call i8* @lua_pushlstring(%struct.lua_State* %3, i8* %4, i64 %sub.ptr.sub)
  %7 = load %struct.lua_State** %L.addr, align 8
  %8 = load %struct.lua_State** %L.addr, align 8
  %call3 = call i8* @lua_tolstring(%struct.lua_State* %8, i32 -1, i64* null)
  %call4 = call i8* @findfile(%struct.lua_State* %7, i8* %call3, i8* getelementptr inbounds ([6 x i8]* @.str7461, i32 0, i32 0), i8* getelementptr inbounds ([2 x i8]* @.str24478, i32 0, i32 0))
  store i8* %call4, i8** %filename, align 8
  %9 = load i8** %filename, align 8
  %cmp5 = icmp eq i8* %9, null
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  store i32 1, i32* %retval
  br label %return

if.end7:                                          ; preds = %if.end
  %10 = load %struct.lua_State** %L.addr, align 8
  %11 = load i8** %filename, align 8
  %12 = load i8** %name, align 8
  %call8 = call i32 @loadfunc(%struct.lua_State* %10, i8* %11, i8* %12)
  store i32 %call8, i32* %stat, align 4
  %cmp9 = icmp ne i32 %call8, 0
  br i1 %cmp9, label %if.then10, label %if.end15

if.then10:                                        ; preds = %if.end7
  %13 = load i32* %stat, align 4
  %cmp11 = icmp ne i32 %13, 2
  br i1 %cmp11, label %if.then12, label %if.else

if.then12:                                        ; preds = %if.then10
  %14 = load %struct.lua_State** %L.addr, align 8
  %15 = load i8** %filename, align 8
  %call13 = call i32 @checkload(%struct.lua_State* %14, i32 0, i8* %15)
  store i32 %call13, i32* %retval
  br label %return

if.else:                                          ; preds = %if.then10
  %16 = load %struct.lua_State** %L.addr, align 8
  %17 = load i8** %name, align 8
  %18 = load i8** %filename, align 8
  %call14 = call i8* (%struct.lua_State*, i8*, ...)* @lua_pushfstring(%struct.lua_State* %16, i8* getelementptr inbounds ([30 x i8]* @.str25479, i32 0, i32 0), i8* %17, i8* %18)
  store i32 1, i32* %retval
  br label %return

if.end15:                                         ; preds = %if.end7
  %19 = load %struct.lua_State** %L.addr, align 8
  %20 = load i8** %filename, align 8
  %call16 = call i8* @lua_pushstring(%struct.lua_State* %19, i8* %20)
  store i32 2, i32* %retval
  br label %return

return:                                           ; preds = %if.end15, %if.else, %if.then12, %if.then6, %if.then
  %21 = load i32* %retval
  ret i32 %21
}

; Function Attrs: nounwind uwtable
define internal i32 @gctm(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %n = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @luaL_len(%struct.lua_State* %0, i32 1)
  store i32 %call, i32* %n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32* %n, align 4
  %cmp = icmp sge i32 %1, 1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load i32* %n, align 4
  call void @lua_rawgeti(%struct.lua_State* %2, i32 1, i32 %3)
  %4 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i8* @lua_touserdata(%struct.lua_State* %4, i32 -1)
  call void @ll_unloadlib(i8* %call1)
  %5 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %5, i32 -2)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %6 = load i32* %n, align 4
  %dec = add nsw i32 %6, -1
  store i32 %dec, i32* %n, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal void @createsearcherstable(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %i = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  call void @lua_createtable(%struct.lua_State* %0, i32 4, i32 0)
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32* %i, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds [5 x i32 (%struct.lua_State*)*]* @createsearcherstable.searchers, i32 0, i64 %idxprom
  %2 = load i32 (%struct.lua_State*)** %arrayidx, align 8
  %cmp = icmp ne i32 (%struct.lua_State*)* %2, null
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushvalue(%struct.lua_State* %3, i32 -2)
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load i32* %i, align 4
  %idxprom1 = sext i32 %5 to i64
  %arrayidx2 = getelementptr inbounds [5 x i32 (%struct.lua_State*)*]* @createsearcherstable.searchers, i32 0, i64 %idxprom1
  %6 = load i32 (%struct.lua_State*)** %arrayidx2, align 8
  call void @lua_pushcclosure(%struct.lua_State* %4, i32 (%struct.lua_State*)* %6, i32 1)
  %7 = load %struct.lua_State** %L.addr, align 8
  %8 = load i32* %i, align 4
  %add = add nsw i32 %8, 1
  call void @lua_rawseti(%struct.lua_State* %7, i32 -2, i32 %add)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %9 = load i32* %i, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @setpath(%struct.lua_State* %L, i8* %fieldname, i8* %envname1, i8* %envname2, i8* %def) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %fieldname.addr = alloca i8*, align 8
  %envname1.addr = alloca i8*, align 8
  %envname2.addr = alloca i8*, align 8
  %def.addr = alloca i8*, align 8
  %path = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %fieldname, i8** %fieldname.addr, align 8
  store i8* %envname1, i8** %envname1.addr, align 8
  store i8* %envname2, i8** %envname2.addr, align 8
  store i8* %def, i8** %def.addr, align 8
  %0 = load i8** %envname1.addr, align 8
  %call = call i8* @getenv(i8* %0) #1
  store i8* %call, i8** %path, align 8
  %1 = load i8** %path, align 8
  %cmp = icmp eq i8* %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i8** %envname2.addr, align 8
  %call1 = call i8* @getenv(i8* %2) #1
  store i8* %call1, i8** %path, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i8** %path, align 8
  %cmp2 = icmp eq i8* %3, null
  br i1 %cmp2, label %if.then4, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %4 = load %struct.lua_State** %L.addr, align 8
  %call3 = call i32 @noenv(%struct.lua_State* %4)
  %tobool = icmp ne i32 %call3, 0
  br i1 %tobool, label %if.then4, label %if.else

if.then4:                                         ; preds = %lor.lhs.false, %if.end
  %5 = load %struct.lua_State** %L.addr, align 8
  %6 = load i8** %def.addr, align 8
  %call5 = call i8* @lua_pushstring(%struct.lua_State* %5, i8* %6)
  br label %if.end8

if.else:                                          ; preds = %lor.lhs.false
  %7 = load %struct.lua_State** %L.addr, align 8
  %8 = load i8** %path, align 8
  %call6 = call i8* @luaL_gsub(%struct.lua_State* %7, i8* %8, i8* getelementptr inbounds ([3 x i8]* @.str20474, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8]* @.str21475, i32 0, i32 0))
  store i8* %call6, i8** %path, align 8
  %9 = load %struct.lua_State** %L.addr, align 8
  %10 = load i8** %path, align 8
  %11 = load i8** %def.addr, align 8
  %call7 = call i8* @luaL_gsub(%struct.lua_State* %9, i8* %10, i8* getelementptr inbounds ([2 x i8]* @.str22476, i32 0, i32 0), i8* %11)
  %12 = load %struct.lua_State** %L.addr, align 8
  call void @lua_remove(%struct.lua_State* %12, i32 -2)
  br label %if.end8

if.end8:                                          ; preds = %if.else, %if.then4
  %13 = load %struct.lua_State** %L.addr, align 8
  %14 = load i8** %fieldname.addr, align 8
  call void @lua_setfield(%struct.lua_State* %13, i32 -2, i8* %14)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @ll_loadfunc(%struct.lua_State* %L, i8* %path, i8* %sym) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %path.addr = alloca i8*, align 8
  %sym.addr = alloca i8*, align 8
  %reg = alloca i8*, align 8
  %f = alloca i32 (%struct.lua_State*)*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %path, i8** %path.addr, align 8
  store i8* %sym, i8** %sym.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i8** %path.addr, align 8
  %call = call i8* @ll_checkclib(%struct.lua_State* %0, i8* %1)
  store i8* %call, i8** %reg, align 8
  %2 = load i8** %reg, align 8
  %cmp = icmp eq i8* %2, null
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load i8** %path.addr, align 8
  %5 = load i8** %sym.addr, align 8
  %6 = load i8* %5, align 1
  %conv = sext i8 %6 to i32
  %cmp1 = icmp eq i32 %conv, 42
  %conv2 = zext i1 %cmp1 to i32
  %call3 = call i8* @ll_load(%struct.lua_State* %3, i8* %4, i32 %conv2)
  store i8* %call3, i8** %reg, align 8
  %7 = load i8** %reg, align 8
  %cmp4 = icmp eq i8* %7, null
  br i1 %cmp4, label %if.then6, label %if.end

if.then6:                                         ; preds = %if.then
  store i32 1, i32* %retval
  br label %return

if.end:                                           ; preds = %if.then
  %8 = load %struct.lua_State** %L.addr, align 8
  %9 = load i8** %path.addr, align 8
  %10 = load i8** %reg, align 8
  call void @ll_addtoclib(%struct.lua_State* %8, i8* %9, i8* %10)
  br label %if.end7

if.end7:                                          ; preds = %if.end, %entry
  %11 = load i8** %sym.addr, align 8
  %12 = load i8* %11, align 1
  %conv8 = sext i8 %12 to i32
  %cmp9 = icmp eq i32 %conv8, 42
  br i1 %cmp9, label %if.then11, label %if.else

if.then11:                                        ; preds = %if.end7
  %13 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushboolean(%struct.lua_State* %13, i32 1)
  store i32 0, i32* %retval
  br label %return

if.else:                                          ; preds = %if.end7
  %14 = load %struct.lua_State** %L.addr, align 8
  %15 = load i8** %reg, align 8
  %16 = load i8** %sym.addr, align 8
  %call12 = call i32 (%struct.lua_State*)* (%struct.lua_State*, i8*, i8*)* @ll_sym(%struct.lua_State* %14, i8* %15, i8* %16)
  store i32 (%struct.lua_State*)* %call12, i32 (%struct.lua_State*)** %f, align 8
  %17 = load i32 (%struct.lua_State*)** %f, align 8
  %cmp13 = icmp eq i32 (%struct.lua_State*)* %17, null
  br i1 %cmp13, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.else
  store i32 2, i32* %retval
  br label %return

if.end16:                                         ; preds = %if.else
  %18 = load %struct.lua_State** %L.addr, align 8
  %19 = load i32 (%struct.lua_State*)** %f, align 8
  call void @lua_pushcclosure(%struct.lua_State* %18, i32 (%struct.lua_State*)* %19, i32 0)
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.end16, %if.then15, %if.then11, %if.then6
  %20 = load i32* %retval
  ret i32 %20
}

; Function Attrs: nounwind uwtable
define internal i8* @searchpath(%struct.lua_State* %L, i8* %name, i8* %path, i8* %sep, i8* %dirsep) #0 {
entry:
  %retval = alloca i8*, align 8
  %L.addr = alloca %struct.lua_State*, align 8
  %name.addr = alloca i8*, align 8
  %path.addr = alloca i8*, align 8
  %sep.addr = alloca i8*, align 8
  %dirsep.addr = alloca i8*, align 8
  %msg = alloca %struct.luaL_Buffer, align 8
  %filename = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %name, i8** %name.addr, align 8
  store i8* %path, i8** %path.addr, align 8
  store i8* %sep, i8** %sep.addr, align 8
  store i8* %dirsep, i8** %dirsep.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_buffinit(%struct.lua_State* %0, %struct.luaL_Buffer* %msg)
  %1 = load i8** %sep.addr, align 8
  %2 = load i8* %1, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load i8** %name.addr, align 8
  %5 = load i8** %sep.addr, align 8
  %6 = load i8** %dirsep.addr, align 8
  %call = call i8* @luaL_gsub(%struct.lua_State* %3, i8* %4, i8* %5, i8* %6)
  store i8* %call, i8** %name.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  br label %while.cond

while.cond:                                       ; preds = %if.end9, %if.end
  %7 = load %struct.lua_State** %L.addr, align 8
  %8 = load i8** %path.addr, align 8
  %call2 = call i8* @pushnexttemplate(%struct.lua_State* %7, i8* %8)
  store i8* %call2, i8** %path.addr, align 8
  %cmp3 = icmp ne i8* %call2, null
  br i1 %cmp3, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %9 = load %struct.lua_State** %L.addr, align 8
  %10 = load %struct.lua_State** %L.addr, align 8
  %call5 = call i8* @lua_tolstring(%struct.lua_State* %10, i32 -1, i64* null)
  %11 = load i8** %name.addr, align 8
  %call6 = call i8* @luaL_gsub(%struct.lua_State* %9, i8* %call5, i8* getelementptr inbounds ([2 x i8]* @.str32486, i32 0, i32 0), i8* %11)
  store i8* %call6, i8** %filename, align 8
  %12 = load %struct.lua_State** %L.addr, align 8
  call void @lua_remove(%struct.lua_State* %12, i32 -2)
  %13 = load i8** %filename, align 8
  %call7 = call i32 @readable(i8* %13)
  %tobool = icmp ne i32 %call7, 0
  br i1 %tobool, label %if.then8, label %if.end9

if.then8:                                         ; preds = %while.body
  %14 = load i8** %filename, align 8
  store i8* %14, i8** %retval
  br label %return

if.end9:                                          ; preds = %while.body
  %15 = load %struct.lua_State** %L.addr, align 8
  %16 = load i8** %filename, align 8
  %call10 = call i8* (%struct.lua_State*, i8*, ...)* @lua_pushfstring(%struct.lua_State* %15, i8* getelementptr inbounds ([15 x i8]* @.str33487, i32 0, i32 0), i8* %16)
  %17 = load %struct.lua_State** %L.addr, align 8
  call void @lua_remove(%struct.lua_State* %17, i32 -2)
  call void @luaL_addvalue(%struct.luaL_Buffer* %msg)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  call void @luaL_pushresult(%struct.luaL_Buffer* %msg)
  store i8* null, i8** %retval
  br label %return

return:                                           ; preds = %while.end, %if.then8
  %18 = load i8** %retval
  ret i8* %18
}

; Function Attrs: nounwind uwtable
define internal void @findloader(%struct.lua_State* %L, i8* %name) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %name.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %msg = alloca %struct.luaL_Buffer, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %name, i8** %name.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_buffinit(%struct.lua_State* %0, %struct.luaL_Buffer* %msg)
  %1 = load %struct.lua_State** %L.addr, align 8
  call void @lua_getfield(%struct.lua_State* %1, i32 -1001001, i8* getelementptr inbounds ([10 x i8]* @.str2456, i32 0, i32 0))
  %2 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_type(%struct.lua_State* %2, i32 3)
  %cmp = icmp eq i32 %call, 5
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %3 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %3, i8* getelementptr inbounds ([36 x i8]* @.str18472, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load i32* %i, align 4
  call void @lua_rawgeti(%struct.lua_State* %4, i32 3, i32 %5)
  %6 = load %struct.lua_State** %L.addr, align 8
  %call2 = call i32 @lua_type(%struct.lua_State* %6, i32 -1)
  %cmp3 = icmp eq i32 %call2, 0
  br i1 %cmp3, label %if.then4, label %if.end7

if.then4:                                         ; preds = %for.cond
  %7 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %7, i32 -2)
  call void @luaL_pushresult(%struct.luaL_Buffer* %msg)
  %8 = load %struct.lua_State** %L.addr, align 8
  %9 = load i8** %name.addr, align 8
  %10 = load %struct.lua_State** %L.addr, align 8
  %call5 = call i8* @lua_tolstring(%struct.lua_State* %10, i32 -1, i64* null)
  %call6 = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %8, i8* getelementptr inbounds ([25 x i8]* @.str19473, i32 0, i32 0), i8* %9, i8* %call5)
  br label %if.end7

if.end7:                                          ; preds = %if.then4, %for.cond
  %11 = load %struct.lua_State** %L.addr, align 8
  %12 = load i8** %name.addr, align 8
  %call8 = call i8* @lua_pushstring(%struct.lua_State* %11, i8* %12)
  %13 = load %struct.lua_State** %L.addr, align 8
  call void @lua_callk(%struct.lua_State* %13, i32 1, i32 2, i32 0, i32 (%struct.lua_State*)* null)
  %14 = load %struct.lua_State** %L.addr, align 8
  %call9 = call i32 @lua_type(%struct.lua_State* %14, i32 -2)
  %cmp10 = icmp eq i32 %call9, 6
  br i1 %cmp10, label %if.then11, label %if.else

if.then11:                                        ; preds = %if.end7
  ret void

if.else:                                          ; preds = %if.end7
  %15 = load %struct.lua_State** %L.addr, align 8
  %call12 = call i32 @lua_isstring(%struct.lua_State* %15, i32 -2)
  %tobool = icmp ne i32 %call12, 0
  br i1 %tobool, label %if.then13, label %if.else14

if.then13:                                        ; preds = %if.else
  %16 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %16, i32 -2)
  call void @luaL_addvalue(%struct.luaL_Buffer* %msg)
  br label %if.end15

if.else14:                                        ; preds = %if.else
  %17 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %17, i32 -3)
  br label %if.end15

if.end15:                                         ; preds = %if.else14, %if.then13
  br label %if.end16

if.end16:                                         ; preds = %if.end15
  br label %for.inc

for.inc:                                          ; preds = %if.end16
  %18 = load i32* %i, align 4
  %inc = add nsw i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond
}

; Function Attrs: nounwind uwtable
define internal i8* @findfile(%struct.lua_State* %L, i8* %name, i8* %pname, i8* %dirsep) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %name.addr = alloca i8*, align 8
  %pname.addr = alloca i8*, align 8
  %dirsep.addr = alloca i8*, align 8
  %path = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %name, i8** %name.addr, align 8
  store i8* %pname, i8** %pname.addr, align 8
  store i8* %dirsep, i8** %dirsep.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i8** %pname.addr, align 8
  call void @lua_getfield(%struct.lua_State* %0, i32 -1001001, i8* %1)
  %2 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @lua_tolstring(%struct.lua_State* %2, i32 -1, i64* null)
  store i8* %call, i8** %path, align 8
  %3 = load i8** %path, align 8
  %cmp = icmp eq i8* %3, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load i8** %pname.addr, align 8
  %call1 = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %4, i8* getelementptr inbounds ([30 x i8]* @.str31485, i32 0, i32 0), i8* %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load %struct.lua_State** %L.addr, align 8
  %7 = load i8** %name.addr, align 8
  %8 = load i8** %path, align 8
  %9 = load i8** %dirsep.addr, align 8
  %call2 = call i8* @searchpath(%struct.lua_State* %6, i8* %7, i8* %8, i8* getelementptr inbounds ([2 x i8]* @.str27481, i32 0, i32 0), i8* %9)
  ret i8* %call2
}

; Function Attrs: nounwind uwtable
define internal i32 @checkload(%struct.lua_State* %L, i32 %stat, i8* %filename) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %stat.addr = alloca i32, align 4
  %filename.addr = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %stat, i32* %stat.addr, align 4
  store i8* %filename, i8** %filename.addr, align 8
  %0 = load i32* %stat.addr, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load i8** %filename.addr, align 8
  %call = call i8* @lua_pushstring(%struct.lua_State* %1, i8* %2)
  store i32 2, i32* %retval
  br label %return

if.else:                                          ; preds = %entry
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i8* @lua_tolstring(%struct.lua_State* %4, i32 1, i64* null)
  %5 = load i8** %filename.addr, align 8
  %6 = load %struct.lua_State** %L.addr, align 8
  %call2 = call i8* @lua_tolstring(%struct.lua_State* %6, i32 -1, i64* null)
  %call3 = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %3, i8* getelementptr inbounds ([46 x i8]* @.str26480, i32 0, i32 0), i8* %call1, i8* %5, i8* %call2)
  store i32 %call3, i32* %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %7 = load i32* %retval
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal i32 @loadfunc(%struct.lua_State* %L, i8* %filename, i8* %modname) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %filename.addr = alloca i8*, align 8
  %modname.addr = alloca i8*, align 8
  %funcname = alloca i8*, align 8
  %mark = alloca i8*, align 8
  %stat = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %filename, i8** %filename.addr, align 8
  store i8* %modname, i8** %modname.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i8** %modname.addr, align 8
  %call = call i8* @luaL_gsub(%struct.lua_State* %0, i8* %1, i8* getelementptr inbounds ([2 x i8]* @.str27481, i32 0, i32 0), i8* getelementptr inbounds ([2 x i8]* @.str28482, i32 0, i32 0))
  store i8* %call, i8** %modname.addr, align 8
  %2 = load i8** %modname.addr, align 8
  %3 = load i8* getelementptr inbounds ([2 x i8]* @.str29483, i32 0, i32 0), align 1
  %conv = sext i8 %3 to i32
  %call1 = call i8* @strchr(i8* %2, i32 %conv) #10
  store i8* %call1, i8** %mark, align 8
  %4 = load i8** %mark, align 8
  %tobool = icmp ne i8* %4, null
  br i1 %tobool, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %5 = load %struct.lua_State** %L.addr, align 8
  %6 = load i8** %modname.addr, align 8
  %7 = load i8** %mark, align 8
  %8 = load i8** %modname.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %7 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %8 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %call2 = call i8* @lua_pushlstring(%struct.lua_State* %5, i8* %6, i64 %sub.ptr.sub)
  store i8* %call2, i8** %funcname, align 8
  %9 = load %struct.lua_State** %L.addr, align 8
  %10 = load i8** %funcname, align 8
  %call3 = call i8* (%struct.lua_State*, i8*, ...)* @lua_pushfstring(%struct.lua_State* %9, i8* getelementptr inbounds ([11 x i8]* @.str30484, i32 0, i32 0), i8* %10)
  store i8* %call3, i8** %funcname, align 8
  %11 = load %struct.lua_State** %L.addr, align 8
  %12 = load i8** %filename.addr, align 8
  %13 = load i8** %funcname, align 8
  %call4 = call i32 @ll_loadfunc(%struct.lua_State* %11, i8* %12, i8* %13)
  store i32 %call4, i32* %stat, align 4
  %14 = load i32* %stat, align 4
  %cmp = icmp ne i32 %14, 2
  br i1 %cmp, label %if.then6, label %if.end

if.then6:                                         ; preds = %if.then
  %15 = load i32* %stat, align 4
  store i32 %15, i32* %retval
  br label %return

if.end:                                           ; preds = %if.then
  %16 = load i8** %mark, align 8
  %add.ptr = getelementptr inbounds i8* %16, i64 1
  store i8* %add.ptr, i8** %modname.addr, align 8
  br label %if.end7

if.end7:                                          ; preds = %if.end, %entry
  %17 = load %struct.lua_State** %L.addr, align 8
  %18 = load i8** %modname.addr, align 8
  %call8 = call i8* (%struct.lua_State*, i8*, ...)* @lua_pushfstring(%struct.lua_State* %17, i8* getelementptr inbounds ([11 x i8]* @.str30484, i32 0, i32 0), i8* %18)
  store i8* %call8, i8** %funcname, align 8
  %19 = load %struct.lua_State** %L.addr, align 8
  %20 = load i8** %filename.addr, align 8
  %21 = load i8** %funcname, align 8
  %call9 = call i32 @ll_loadfunc(%struct.lua_State* %19, i8* %20, i8* %21)
  store i32 %call9, i32* %retval
  br label %return

return:                                           ; preds = %if.end7, %if.then6
  %22 = load i32* %retval
  ret i32 %22
}

; Function Attrs: nounwind uwtable
define internal void @ll_unloadlib(i8* %lib) #0 {
entry:
  %lib.addr = alloca i8*, align 8
  store i8* %lib, i8** %lib.addr, align 8
  %0 = load i8** %lib.addr, align 8
  %call = call i32 @dlclose(i8* %0) #1
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @noenv(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %b = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  call void @lua_getfield(%struct.lua_State* %0, i32 -1001000, i8* getelementptr inbounds ([10 x i8]* @.str23477, i32 0, i32 0))
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_toboolean(%struct.lua_State* %1, i32 -1)
  store i32 %call, i32* %b, align 4
  %2 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %2, i32 -2)
  %3 = load i32* %b, align 4
  ret i32 %3
}

; Function Attrs: nounwind uwtable
define internal i8* @ll_checkclib(%struct.lua_State* %L, i8* %path) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %path.addr = alloca i8*, align 8
  %plib = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %path, i8** %path.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  call void @lua_getfield(%struct.lua_State* %0, i32 -1001000, i8* getelementptr inbounds ([7 x i8]* @.str454, i32 0, i32 0))
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load i8** %path.addr, align 8
  call void @lua_getfield(%struct.lua_State* %1, i32 -1, i8* %2)
  %3 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @lua_touserdata(%struct.lua_State* %3, i32 -1)
  store i8* %call, i8** %plib, align 8
  %4 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %4, i32 -3)
  %5 = load i8** %plib, align 8
  ret i8* %5
}

; Function Attrs: nounwind uwtable
define internal i8* @ll_load(%struct.lua_State* %L, i8* %path, i32 %seeglb) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %path.addr = alloca i8*, align 8
  %seeglb.addr = alloca i32, align 4
  %lib = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %path, i8** %path.addr, align 8
  store i32 %seeglb, i32* %seeglb.addr, align 4
  %0 = load i8** %path.addr, align 8
  %1 = load i32* %seeglb.addr, align 4
  %tobool = icmp ne i32 %1, 0
  %cond = select i1 %tobool, i32 256, i32 0
  %or = or i32 2, %cond
  %call = call i8* @dlopen(i8* %0, i32 %or) #1
  store i8* %call, i8** %lib, align 8
  %2 = load i8** %lib, align 8
  %cmp = icmp eq i8* %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i8* @dlerror() #1
  %call2 = call i8* @lua_pushstring(%struct.lua_State* %3, i8* %call1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load i8** %lib, align 8
  ret i8* %4
}

; Function Attrs: nounwind uwtable
define internal void @ll_addtoclib(%struct.lua_State* %L, i8* %path, i8* %plib) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %path.addr = alloca i8*, align 8
  %plib.addr = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %path, i8** %path.addr, align 8
  store i8* %plib, i8** %plib.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  call void @lua_getfield(%struct.lua_State* %0, i32 -1001000, i8* getelementptr inbounds ([7 x i8]* @.str454, i32 0, i32 0))
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load i8** %plib.addr, align 8
  call void @lua_pushlightuserdata(%struct.lua_State* %1, i8* %2)
  %3 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushvalue(%struct.lua_State* %3, i32 -1)
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load i8** %path.addr, align 8
  call void @lua_setfield(%struct.lua_State* %4, i32 -3, i8* %5)
  %6 = load %struct.lua_State** %L.addr, align 8
  %7 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @luaL_len(%struct.lua_State* %7, i32 -2)
  %add = add nsw i32 %call, 1
  call void @lua_rawseti(%struct.lua_State* %6, i32 -2, i32 %add)
  %8 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %8, i32 -2)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 (%struct.lua_State*)* @ll_sym(%struct.lua_State* %L, i8* %lib, i8* %sym) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %lib.addr = alloca i8*, align 8
  %sym.addr = alloca i8*, align 8
  %f = alloca i32 (%struct.lua_State*)*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %lib, i8** %lib.addr, align 8
  store i8* %sym, i8** %sym.addr, align 8
  %0 = load i8** %lib.addr, align 8
  %1 = load i8** %sym.addr, align 8
  %call = call i8* @dlsym(i8* %0, i8* %1) #1
  %2 = bitcast i8* %call to i32 (%struct.lua_State*)*
  store i32 (%struct.lua_State*)* %2, i32 (%struct.lua_State*)** %f, align 8
  %3 = load i32 (%struct.lua_State*)** %f, align 8
  %cmp = icmp eq i32 (%struct.lua_State*)* %3, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i8* @dlerror() #1
  %call2 = call i8* @lua_pushstring(%struct.lua_State* %4, i8* %call1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load i32 (%struct.lua_State*)** %f, align 8
  ret i32 (%struct.lua_State*)* %5
}

; Function Attrs: nounwind uwtable
define internal i8* @pushnexttemplate(%struct.lua_State* %L, i8* %path) #0 {
entry:
  %retval = alloca i8*, align 8
  %L.addr = alloca %struct.lua_State*, align 8
  %path.addr = alloca i8*, align 8
  %l = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %path, i8** %path.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load i8** %path.addr, align 8
  %1 = load i8* %0, align 1
  %conv = sext i8 %1 to i32
  %2 = load i8* getelementptr inbounds ([2 x i8]* @.str35489, i32 0, i32 0), align 1
  %conv1 = sext i8 %2 to i32
  %cmp = icmp eq i32 %conv, %conv1
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load i8** %path.addr, align 8
  %incdec.ptr = getelementptr inbounds i8* %3, i32 1
  store i8* %incdec.ptr, i8** %path.addr, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %4 = load i8** %path.addr, align 8
  %5 = load i8* %4, align 1
  %conv3 = sext i8 %5 to i32
  %cmp4 = icmp eq i32 %conv3, 0
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %while.end
  store i8* null, i8** %retval
  br label %return

if.end:                                           ; preds = %while.end
  %6 = load i8** %path.addr, align 8
  %7 = load i8* getelementptr inbounds ([2 x i8]* @.str35489, i32 0, i32 0), align 1
  %conv6 = sext i8 %7 to i32
  %call = call i8* @strchr(i8* %6, i32 %conv6) #10
  store i8* %call, i8** %l, align 8
  %8 = load i8** %l, align 8
  %cmp7 = icmp eq i8* %8, null
  br i1 %cmp7, label %if.then9, label %if.end11

if.then9:                                         ; preds = %if.end
  %9 = load i8** %path.addr, align 8
  %10 = load i8** %path.addr, align 8
  %call10 = call i64 @strlen(i8* %10) #10
  %add.ptr = getelementptr inbounds i8* %9, i64 %call10
  store i8* %add.ptr, i8** %l, align 8
  br label %if.end11

if.end11:                                         ; preds = %if.then9, %if.end
  %11 = load %struct.lua_State** %L.addr, align 8
  %12 = load i8** %path.addr, align 8
  %13 = load i8** %l, align 8
  %14 = load i8** %path.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %13 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %14 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %call12 = call i8* @lua_pushlstring(%struct.lua_State* %11, i8* %12, i64 %sub.ptr.sub)
  %15 = load i8** %l, align 8
  store i8* %15, i8** %retval
  br label %return

return:                                           ; preds = %if.end11, %if.then
  %16 = load i8** %retval
  ret i8* %16
}

; Function Attrs: nounwind uwtable
define internal i32 @readable(i8* %filename) #0 {
entry:
  %retval = alloca i32, align 4
  %filename.addr = alloca i8*, align 8
  %f = alloca %struct._IO_FILE*, align 8
  store i8* %filename, i8** %filename.addr, align 8
  %0 = load i8** %filename.addr, align 8
  %call = call %struct._IO_FILE* @fopen(i8* %0, i8* getelementptr inbounds ([2 x i8]* @.str34488, i32 0, i32 0))
  store %struct._IO_FILE* %call, %struct._IO_FILE** %f, align 8
  %1 = load %struct._IO_FILE** %f, align 8
  %cmp = icmp eq %struct._IO_FILE* %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct._IO_FILE** %f, align 8
  %call1 = call i32 @fclose(%struct._IO_FILE* %2)
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load i32* %retval
  ret i32 %3
}

; Function Attrs: nounwind uwtable
define hidden i32 @luaO_int2fb(i32 %x) #0 {
entry:
  %retval = alloca i32, align 4
  %x.addr = alloca i32, align 4
  %e = alloca i32, align 4
  store i32 %x, i32* %x.addr, align 4
  store i32 0, i32* %e, align 4
  %0 = load i32* %x.addr, align 4
  %cmp = icmp ult i32 %0, 8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i32* %x.addr, align 4
  store i32 %1, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %2 = load i32* %x.addr, align 4
  %cmp1 = icmp uge i32 %2, 16
  br i1 %cmp1, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load i32* %x.addr, align 4
  %add = add i32 %3, 1
  %shr = lshr i32 %add, 1
  store i32 %shr, i32* %x.addr, align 4
  %4 = load i32* %e, align 4
  %inc = add nsw i32 %4, 1
  store i32 %inc, i32* %e, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %5 = load i32* %e, align 4
  %add2 = add nsw i32 %5, 1
  %shl = shl i32 %add2, 3
  %6 = load i32* %x.addr, align 4
  %sub = sub nsw i32 %6, 8
  %or = or i32 %shl, %sub
  store i32 %or, i32* %retval
  br label %return

return:                                           ; preds = %while.end, %if.then
  %7 = load i32* %retval
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define hidden i32 @luaO_fb2int(i32 %x) #0 {
entry:
  %retval = alloca i32, align 4
  %x.addr = alloca i32, align 4
  %e = alloca i32, align 4
  store i32 %x, i32* %x.addr, align 4
  %0 = load i32* %x.addr, align 4
  %shr = ashr i32 %0, 3
  %and = and i32 %shr, 31
  store i32 %and, i32* %e, align 4
  %1 = load i32* %e, align 4
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load i32* %x.addr, align 4
  store i32 %2, i32* %retval
  br label %return

if.else:                                          ; preds = %entry
  %3 = load i32* %x.addr, align 4
  %and1 = and i32 %3, 7
  %add = add nsw i32 %and1, 8
  %4 = load i32* %e, align 4
  %sub = sub nsw i32 %4, 1
  %shl = shl i32 %add, %sub
  store i32 %shl, i32* %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %5 = load i32* %retval
  ret i32 %5
}

; Function Attrs: nounwind uwtable
define hidden i32 @luaO_ceillog2(i32 %x) #0 {
entry:
  %x.addr = alloca i32, align 4
  %l = alloca i32, align 4
  store i32 %x, i32* %x.addr, align 4
  store i32 0, i32* %l, align 4
  %0 = load i32* %x.addr, align 4
  %dec = add i32 %0, -1
  store i32 %dec, i32* %x.addr, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %1 = load i32* %x.addr, align 4
  %cmp = icmp uge i32 %1, 256
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load i32* %l, align 4
  %add = add nsw i32 %2, 8
  store i32 %add, i32* %l, align 4
  %3 = load i32* %x.addr, align 4
  %shr = lshr i32 %3, 8
  store i32 %shr, i32* %x.addr, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %4 = load i32* %l, align 4
  %5 = load i32* %x.addr, align 4
  %idxprom = zext i32 %5 to i64
  %arrayidx = getelementptr inbounds [256 x i8]* @luaO_ceillog2.log_2, i32 0, i64 %idxprom
  %6 = load i8* %arrayidx, align 1
  %conv = zext i8 %6 to i32
  %add1 = add nsw i32 %4, %conv
  ret i32 %add1
}

; Function Attrs: nounwind uwtable
define hidden double @luaO_arith(i32 %op, double %v1, double %v2) #0 {
entry:
  %retval = alloca double, align 8
  %op.addr = alloca i32, align 4
  %v1.addr = alloca double, align 8
  %v2.addr = alloca double, align 8
  store i32 %op, i32* %op.addr, align 4
  store double %v1, double* %v1.addr, align 8
  store double %v2, double* %v2.addr, align 8
  %0 = load i32* %op.addr, align 4
  switch i32 %0, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb1
    i32 2, label %sw.bb2
    i32 3, label %sw.bb3
    i32 4, label %sw.bb4
    i32 5, label %sw.bb8
    i32 6, label %sw.bb10
  ]

sw.bb:                                            ; preds = %entry
  %1 = load double* %v1.addr, align 8
  %2 = load double* %v2.addr, align 8
  %add = fadd double %1, %2
  store double %add, double* %retval
  br label %return

sw.bb1:                                           ; preds = %entry
  %3 = load double* %v1.addr, align 8
  %4 = load double* %v2.addr, align 8
  %sub = fsub double %3, %4
  store double %sub, double* %retval
  br label %return

sw.bb2:                                           ; preds = %entry
  %5 = load double* %v1.addr, align 8
  %6 = load double* %v2.addr, align 8
  %mul = fmul double %5, %6
  store double %mul, double* %retval
  br label %return

sw.bb3:                                           ; preds = %entry
  %7 = load double* %v1.addr, align 8
  %8 = load double* %v2.addr, align 8
  %div = fdiv double %7, %8
  store double %div, double* %retval
  br label %return

sw.bb4:                                           ; preds = %entry
  %9 = load double* %v1.addr, align 8
  %10 = load double* %v1.addr, align 8
  %11 = load double* %v2.addr, align 8
  %div5 = fdiv double %10, %11
  %call = call double @floor(double %div5) #11
  %12 = load double* %v2.addr, align 8
  %mul6 = fmul double %call, %12
  %sub7 = fsub double %9, %mul6
  store double %sub7, double* %retval
  br label %return

sw.bb8:                                           ; preds = %entry
  %13 = load double* %v1.addr, align 8
  %14 = load double* %v2.addr, align 8
  %call9 = call double @pow(double %13, double %14) #1
  store double %call9, double* %retval
  br label %return

sw.bb10:                                          ; preds = %entry
  %15 = load double* %v1.addr, align 8
  %sub11 = fsub double -0.000000e+00, %15
  store double %sub11, double* %retval
  br label %return

sw.default:                                       ; preds = %entry
  store double 0.000000e+00, double* %retval
  br label %return

return:                                           ; preds = %sw.default, %sw.bb10, %sw.bb8, %sw.bb4, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb
  %16 = load double* %retval
  ret double %16
}

; Function Attrs: nounwind uwtable
define hidden i32 @luaO_hexavalue(i32 %c) #0 {
entry:
  %retval = alloca i32, align 4
  %c.addr = alloca i32, align 4
  store i32 %c, i32* %c.addr, align 4
  %0 = load i32* %c.addr, align 4
  %add = add nsw i32 %0, 1
  %idxprom = sext i32 %add to i64
  %arrayidx = getelementptr inbounds [257 x i8]* @luai_ctype_, i32 0, i64 %idxprom
  %1 = load i8* %arrayidx, align 1
  %conv = zext i8 %1 to i32
  %and = and i32 %conv, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load i32* %c.addr, align 4
  %sub = sub nsw i32 %2, 48
  store i32 %sub, i32* %retval
  br label %return

if.else:                                          ; preds = %entry
  %3 = load i32* %c.addr, align 4
  %or = or i32 %3, 32
  %sub1 = sub nsw i32 %or, 97
  %add2 = add nsw i32 %sub1, 10
  store i32 %add2, i32* %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %4 = load i32* %retval
  ret i32 %4
}

; Function Attrs: nounwind uwtable
define hidden i32 @luaO_str2d(i8* %s, i64 %len, double* %result) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %result.addr = alloca double*, align 8
  %endptr = alloca i8*, align 8
  store i8* %s, i8** %s.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store double* %result, double** %result.addr, align 8
  %0 = load i8** %s.addr, align 8
  %call = call i8* @strpbrk(i8* %0, i8* getelementptr inbounds ([3 x i8]* @.str499, i32 0, i32 0)) #10
  %tobool = icmp ne i8* %call, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval
  br label %return

if.else:                                          ; preds = %entry
  %1 = load i8** %s.addr, align 8
  %call1 = call i8* @strpbrk(i8* %1, i8* getelementptr inbounds ([3 x i8]* @.str1500, i32 0, i32 0)) #10
  %tobool2 = icmp ne i8* %call1, null
  br i1 %tobool2, label %if.then3, label %if.else5

if.then3:                                         ; preds = %if.else
  %2 = load i8** %s.addr, align 8
  %call4 = call double @strtod(i8* %2, i8** %endptr) #1
  %3 = load double** %result.addr, align 8
  store double %call4, double* %3, align 8
  br label %if.end

if.else5:                                         ; preds = %if.else
  %4 = load i8** %s.addr, align 8
  %call6 = call double @strtod(i8* %4, i8** %endptr) #1
  %5 = load double** %result.addr, align 8
  store double %call6, double* %5, align 8
  br label %if.end

if.end:                                           ; preds = %if.else5, %if.then3
  br label %if.end7

if.end7:                                          ; preds = %if.end
  %6 = load i8** %endptr, align 8
  %7 = load i8** %s.addr, align 8
  %cmp = icmp eq i8* %6, %7
  br i1 %cmp, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end7
  store i32 0, i32* %retval
  br label %return

if.end9:                                          ; preds = %if.end7
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end9
  %8 = load i8** %endptr, align 8
  %9 = load i8* %8, align 1
  %conv = zext i8 %9 to i32
  %add = add nsw i32 %conv, 1
  %idxprom = sext i32 %add to i64
  %arrayidx = getelementptr inbounds [257 x i8]* @luai_ctype_, i32 0, i64 %idxprom
  %10 = load i8* %arrayidx, align 1
  %conv10 = zext i8 %10 to i32
  %and = and i32 %conv10, 8
  %tobool11 = icmp ne i32 %and, 0
  br i1 %tobool11, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %11 = load i8** %endptr, align 8
  %incdec.ptr = getelementptr inbounds i8* %11, i32 1
  store i8* %incdec.ptr, i8** %endptr, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %12 = load i8** %endptr, align 8
  %13 = load i8** %s.addr, align 8
  %14 = load i64* %len.addr, align 8
  %add.ptr = getelementptr inbounds i8* %13, i64 %14
  %cmp12 = icmp eq i8* %12, %add.ptr
  %conv13 = zext i1 %cmp12 to i32
  store i32 %conv13, i32* %retval
  br label %return

return:                                           ; preds = %while.end, %if.then8, %if.then
  %15 = load i32* %retval
  ret i32 %15
}

; Function Attrs: nounwind readonly
declare i8* @strpbrk(i8*, i8*) #2

; Function Attrs: nounwind
declare double @strtod(i8*, i8**) #4

; Function Attrs: nounwind uwtable
define hidden i8* @luaO_pushvfstring(%struct.lua_State.279* %L, i8* %fmt, %struct.__va_list_tag* %argp) #0 {
entry:
  %L.addr = alloca %struct.lua_State.279*, align 8
  %fmt.addr = alloca i8*, align 8
  %argp.addr = alloca %struct.__va_list_tag*, align 8
  %n = alloca i32, align 4
  %e = alloca i8*, align 8
  %s = alloca i8*, align 8
  %buff = alloca i8, align 1
  %io = alloca %struct.lua_TValue.263*, align 8
  %io41 = alloca %struct.lua_TValue.263*, align 8
  %buff56 = alloca [40 x i8], align 16
  %l = alloca i32, align 4
  store %struct.lua_State.279* %L, %struct.lua_State.279** %L.addr, align 8
  store i8* %fmt, i8** %fmt.addr, align 8
  store %struct.__va_list_tag* %argp, %struct.__va_list_tag** %argp.addr, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond

for.cond:                                         ; preds = %sw.epilog, %entry
  %0 = load i8** %fmt.addr, align 8
  %call = call i8* @strchr(i8* %0, i32 37) #10
  store i8* %call, i8** %e, align 8
  %1 = load i8** %e, align 8
  %cmp = icmp eq i8* %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %for.cond
  br label %for.end

if.end:                                           ; preds = %for.cond
  %2 = load %struct.lua_State.279** %L.addr, align 8
  %stack_last = getelementptr inbounds %struct.lua_State.279* %2, i32 0, i32 8
  %3 = load %struct.lua_TValue.263** %stack_last, align 8
  %4 = load %struct.lua_State.279** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State.279* %4, i32 0, i32 4
  %5 = load %struct.lua_TValue.263** %top, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.lua_TValue.263* %3 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.lua_TValue.263* %5 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 16
  %cmp1 = icmp sle i64 %sub.ptr.div, 2
  br i1 %cmp1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.end
  %6 = load %struct.lua_State.279** %L.addr, align 8
  call void bitcast (void (%struct.lua_State*, i32)* @luaD_growstack to void (%struct.lua_State.279*, i32)*)(%struct.lua_State.279* %6, i32 2)
  br label %if.end3

if.else:                                          ; preds = %if.end
  br label %if.end3

if.end3:                                          ; preds = %if.else, %if.then2
  %7 = load %struct.lua_State.279** %L.addr, align 8
  %8 = load i8** %fmt.addr, align 8
  %9 = load i8** %e, align 8
  %10 = load i8** %fmt.addr, align 8
  %sub.ptr.lhs.cast4 = ptrtoint i8* %9 to i64
  %sub.ptr.rhs.cast5 = ptrtoint i8* %10 to i64
  %sub.ptr.sub6 = sub i64 %sub.ptr.lhs.cast4, %sub.ptr.rhs.cast5
  call void @pushstr(%struct.lua_State.279* %7, i8* %8, i64 %sub.ptr.sub6)
  %11 = load i8** %e, align 8
  %add.ptr = getelementptr inbounds i8* %11, i64 1
  %12 = load i8* %add.ptr, align 1
  %conv = sext i8 %12 to i32
  switch i32 %conv, label %sw.default [
    i32 115, label %sw.bb
    i32 99, label %sw.bb12
    i32 100, label %sw.bb25
    i32 102, label %sw.bb40
    i32 112, label %sw.bb55
    i32 37, label %sw.bb71
  ]

sw.bb:                                            ; preds = %if.end3
  %13 = load %struct.__va_list_tag** %argp.addr, align 8
  %gp_offset_p = getelementptr inbounds %struct.__va_list_tag* %13, i32 0, i32 0
  %gp_offset = load i32* %gp_offset_p
  %fits_in_gp = icmp ule i32 %gp_offset, 40
  br i1 %fits_in_gp, label %vaarg.in_reg, label %vaarg.in_mem

vaarg.in_reg:                                     ; preds = %sw.bb
  %14 = getelementptr inbounds %struct.__va_list_tag* %13, i32 0, i32 3
  %reg_save_area = load i8** %14
  %15 = getelementptr i8* %reg_save_area, i32 %gp_offset
  %16 = bitcast i8* %15 to i8**
  %17 = add i32 %gp_offset, 8
  store i32 %17, i32* %gp_offset_p
  br label %vaarg.end

vaarg.in_mem:                                     ; preds = %sw.bb
  %overflow_arg_area_p = getelementptr inbounds %struct.__va_list_tag* %13, i32 0, i32 2
  %overflow_arg_area = load i8** %overflow_arg_area_p
  %18 = bitcast i8* %overflow_arg_area to i8**
  %overflow_arg_area.next = getelementptr i8* %overflow_arg_area, i32 8
  store i8* %overflow_arg_area.next, i8** %overflow_arg_area_p
  br label %vaarg.end

vaarg.end:                                        ; preds = %vaarg.in_mem, %vaarg.in_reg
  %vaarg.addr = phi i8** [ %16, %vaarg.in_reg ], [ %18, %vaarg.in_mem ]
  %19 = load i8** %vaarg.addr
  store i8* %19, i8** %s, align 8
  %20 = load i8** %s, align 8
  %cmp7 = icmp eq i8* %20, null
  br i1 %cmp7, label %if.then9, label %if.end10

if.then9:                                         ; preds = %vaarg.end
  store i8* getelementptr inbounds ([7 x i8]* @.str2501, i32 0, i32 0), i8** %s, align 8
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %vaarg.end
  %21 = load %struct.lua_State.279** %L.addr, align 8
  %22 = load i8** %s, align 8
  %23 = load i8** %s, align 8
  %call11 = call i64 @strlen(i8* %23) #10
  call void @pushstr(%struct.lua_State.279* %21, i8* %22, i64 %call11)
  br label %sw.epilog

sw.bb12:                                          ; preds = %if.end3
  %24 = load %struct.__va_list_tag** %argp.addr, align 8
  %gp_offset_p13 = getelementptr inbounds %struct.__va_list_tag* %24, i32 0, i32 0
  %gp_offset14 = load i32* %gp_offset_p13
  %fits_in_gp15 = icmp ule i32 %gp_offset14, 40
  br i1 %fits_in_gp15, label %vaarg.in_reg16, label %vaarg.in_mem18

vaarg.in_reg16:                                   ; preds = %sw.bb12
  %25 = getelementptr inbounds %struct.__va_list_tag* %24, i32 0, i32 3
  %reg_save_area17 = load i8** %25
  %26 = getelementptr i8* %reg_save_area17, i32 %gp_offset14
  %27 = bitcast i8* %26 to i32*
  %28 = add i32 %gp_offset14, 8
  store i32 %28, i32* %gp_offset_p13
  br label %vaarg.end22

vaarg.in_mem18:                                   ; preds = %sw.bb12
  %overflow_arg_area_p19 = getelementptr inbounds %struct.__va_list_tag* %24, i32 0, i32 2
  %overflow_arg_area20 = load i8** %overflow_arg_area_p19
  %29 = bitcast i8* %overflow_arg_area20 to i32*
  %overflow_arg_area.next21 = getelementptr i8* %overflow_arg_area20, i32 8
  store i8* %overflow_arg_area.next21, i8** %overflow_arg_area_p19
  br label %vaarg.end22

vaarg.end22:                                      ; preds = %vaarg.in_mem18, %vaarg.in_reg16
  %vaarg.addr23 = phi i32* [ %27, %vaarg.in_reg16 ], [ %29, %vaarg.in_mem18 ]
  %30 = load i32* %vaarg.addr23
  %conv24 = trunc i32 %30 to i8
  store i8 %conv24, i8* %buff, align 1
  %31 = load %struct.lua_State.279** %L.addr, align 8
  call void @pushstr(%struct.lua_State.279* %31, i8* %buff, i64 1)
  br label %sw.epilog

sw.bb25:                                          ; preds = %if.end3
  %32 = load %struct.lua_State.279** %L.addr, align 8
  %top26 = getelementptr inbounds %struct.lua_State.279* %32, i32 0, i32 4
  %33 = load %struct.lua_TValue.263** %top26, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue.263* %33, i32 1
  store %struct.lua_TValue.263* %incdec.ptr, %struct.lua_TValue.263** %top26, align 8
  store %struct.lua_TValue.263* %33, %struct.lua_TValue.263** %io, align 8
  %34 = load %struct.__va_list_tag** %argp.addr, align 8
  %gp_offset_p27 = getelementptr inbounds %struct.__va_list_tag* %34, i32 0, i32 0
  %gp_offset28 = load i32* %gp_offset_p27
  %fits_in_gp29 = icmp ule i32 %gp_offset28, 40
  br i1 %fits_in_gp29, label %vaarg.in_reg30, label %vaarg.in_mem32

vaarg.in_reg30:                                   ; preds = %sw.bb25
  %35 = getelementptr inbounds %struct.__va_list_tag* %34, i32 0, i32 3
  %reg_save_area31 = load i8** %35
  %36 = getelementptr i8* %reg_save_area31, i32 %gp_offset28
  %37 = bitcast i8* %36 to i32*
  %38 = add i32 %gp_offset28, 8
  store i32 %38, i32* %gp_offset_p27
  br label %vaarg.end36

vaarg.in_mem32:                                   ; preds = %sw.bb25
  %overflow_arg_area_p33 = getelementptr inbounds %struct.__va_list_tag* %34, i32 0, i32 2
  %overflow_arg_area34 = load i8** %overflow_arg_area_p33
  %39 = bitcast i8* %overflow_arg_area34 to i32*
  %overflow_arg_area.next35 = getelementptr i8* %overflow_arg_area34, i32 8
  store i8* %overflow_arg_area.next35, i8** %overflow_arg_area_p33
  br label %vaarg.end36

vaarg.end36:                                      ; preds = %vaarg.in_mem32, %vaarg.in_reg30
  %vaarg.addr37 = phi i32* [ %37, %vaarg.in_reg30 ], [ %39, %vaarg.in_mem32 ]
  %40 = load i32* %vaarg.addr37
  %conv38 = sitofp i32 %40 to double
  %41 = load %struct.lua_TValue.263** %io, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue.263* %41, i32 0, i32 0
  %n39 = bitcast %union.Value.281* %value_ to double*
  store double %conv38, double* %n39, align 8
  %42 = load %struct.lua_TValue.263** %io, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue.263* %42, i32 0, i32 1
  store i32 3, i32* %tt_, align 4
  br label %sw.epilog

sw.bb40:                                          ; preds = %if.end3
  %43 = load %struct.lua_State.279** %L.addr, align 8
  %top42 = getelementptr inbounds %struct.lua_State.279* %43, i32 0, i32 4
  %44 = load %struct.lua_TValue.263** %top42, align 8
  %incdec.ptr43 = getelementptr inbounds %struct.lua_TValue.263* %44, i32 1
  store %struct.lua_TValue.263* %incdec.ptr43, %struct.lua_TValue.263** %top42, align 8
  store %struct.lua_TValue.263* %44, %struct.lua_TValue.263** %io41, align 8
  %45 = load %struct.__va_list_tag** %argp.addr, align 8
  %fp_offset_p = getelementptr inbounds %struct.__va_list_tag* %45, i32 0, i32 1
  %fp_offset = load i32* %fp_offset_p
  %fits_in_fp = icmp ule i32 %fp_offset, 160
  br i1 %fits_in_fp, label %vaarg.in_reg44, label %vaarg.in_mem46

vaarg.in_reg44:                                   ; preds = %sw.bb40
  %46 = getelementptr inbounds %struct.__va_list_tag* %45, i32 0, i32 3
  %reg_save_area45 = load i8** %46
  %47 = getelementptr i8* %reg_save_area45, i32 %fp_offset
  %48 = bitcast i8* %47 to double*
  %49 = add i32 %fp_offset, 16
  store i32 %49, i32* %fp_offset_p
  br label %vaarg.end50

vaarg.in_mem46:                                   ; preds = %sw.bb40
  %overflow_arg_area_p47 = getelementptr inbounds %struct.__va_list_tag* %45, i32 0, i32 2
  %overflow_arg_area48 = load i8** %overflow_arg_area_p47
  %50 = bitcast i8* %overflow_arg_area48 to double*
  %overflow_arg_area.next49 = getelementptr i8* %overflow_arg_area48, i32 8
  store i8* %overflow_arg_area.next49, i8** %overflow_arg_area_p47
  br label %vaarg.end50

vaarg.end50:                                      ; preds = %vaarg.in_mem46, %vaarg.in_reg44
  %vaarg.addr51 = phi double* [ %48, %vaarg.in_reg44 ], [ %50, %vaarg.in_mem46 ]
  %51 = load double* %vaarg.addr51
  %52 = load %struct.lua_TValue.263** %io41, align 8
  %value_52 = getelementptr inbounds %struct.lua_TValue.263* %52, i32 0, i32 0
  %n53 = bitcast %union.Value.281* %value_52 to double*
  store double %51, double* %n53, align 8
  %53 = load %struct.lua_TValue.263** %io41, align 8
  %tt_54 = getelementptr inbounds %struct.lua_TValue.263* %53, i32 0, i32 1
  store i32 3, i32* %tt_54, align 4
  br label %sw.epilog

sw.bb55:                                          ; preds = %if.end3
  %arraydecay = getelementptr inbounds [40 x i8]* %buff56, i32 0, i32 0
  %54 = load %struct.__va_list_tag** %argp.addr, align 8
  %gp_offset_p57 = getelementptr inbounds %struct.__va_list_tag* %54, i32 0, i32 0
  %gp_offset58 = load i32* %gp_offset_p57
  %fits_in_gp59 = icmp ule i32 %gp_offset58, 40
  br i1 %fits_in_gp59, label %vaarg.in_reg60, label %vaarg.in_mem62

vaarg.in_reg60:                                   ; preds = %sw.bb55
  %55 = getelementptr inbounds %struct.__va_list_tag* %54, i32 0, i32 3
  %reg_save_area61 = load i8** %55
  %56 = getelementptr i8* %reg_save_area61, i32 %gp_offset58
  %57 = bitcast i8* %56 to i8**
  %58 = add i32 %gp_offset58, 8
  store i32 %58, i32* %gp_offset_p57
  br label %vaarg.end66

vaarg.in_mem62:                                   ; preds = %sw.bb55
  %overflow_arg_area_p63 = getelementptr inbounds %struct.__va_list_tag* %54, i32 0, i32 2
  %overflow_arg_area64 = load i8** %overflow_arg_area_p63
  %59 = bitcast i8* %overflow_arg_area64 to i8**
  %overflow_arg_area.next65 = getelementptr i8* %overflow_arg_area64, i32 8
  store i8* %overflow_arg_area.next65, i8** %overflow_arg_area_p63
  br label %vaarg.end66

vaarg.end66:                                      ; preds = %vaarg.in_mem62, %vaarg.in_reg60
  %vaarg.addr67 = phi i8** [ %57, %vaarg.in_reg60 ], [ %59, %vaarg.in_mem62 ]
  %60 = load i8** %vaarg.addr67
  %call68 = call i32 (i8*, i8*, ...)* @sprintf(i8* %arraydecay, i8* getelementptr inbounds ([3 x i8]* @.str3502, i32 0, i32 0), i8* %60) #1
  store i32 %call68, i32* %l, align 4
  %61 = load %struct.lua_State.279** %L.addr, align 8
  %arraydecay69 = getelementptr inbounds [40 x i8]* %buff56, i32 0, i32 0
  %62 = load i32* %l, align 4
  %conv70 = sext i32 %62 to i64
  call void @pushstr(%struct.lua_State.279* %61, i8* %arraydecay69, i64 %conv70)
  br label %sw.epilog

sw.bb71:                                          ; preds = %if.end3
  %63 = load %struct.lua_State.279** %L.addr, align 8
  call void @pushstr(%struct.lua_State.279* %63, i8* getelementptr inbounds ([2 x i8]* @.str4503, i32 0, i32 0), i64 1)
  br label %sw.epilog

sw.default:                                       ; preds = %if.end3
  %64 = load %struct.lua_State.279** %L.addr, align 8
  %65 = load i8** %e, align 8
  %add.ptr72 = getelementptr inbounds i8* %65, i64 1
  %66 = load i8* %add.ptr72, align 1
  %conv73 = sext i8 %66 to i32
  call void (%struct.lua_State.279*, i8*, ...)* bitcast (void (%struct.lua_State*, i8*, ...)* @luaG_runerror to void (%struct.lua_State.279*, i8*, ...)*)(%struct.lua_State.279* %64, i8* getelementptr inbounds ([43 x i8]* @.str5504, i32 0, i32 0), i32 %conv73) #9
  unreachable

sw.epilog:                                        ; preds = %sw.bb71, %vaarg.end66, %vaarg.end50, %vaarg.end36, %vaarg.end22, %if.end10
  %67 = load i32* %n, align 4
  %add = add nsw i32 %67, 2
  store i32 %add, i32* %n, align 4
  %68 = load i8** %e, align 8
  %add.ptr74 = getelementptr inbounds i8* %68, i64 2
  store i8* %add.ptr74, i8** %fmt.addr, align 8
  br label %for.cond

for.end:                                          ; preds = %if.then
  %69 = load %struct.lua_State.279** %L.addr, align 8
  %stack_last75 = getelementptr inbounds %struct.lua_State.279* %69, i32 0, i32 8
  %70 = load %struct.lua_TValue.263** %stack_last75, align 8
  %71 = load %struct.lua_State.279** %L.addr, align 8
  %top76 = getelementptr inbounds %struct.lua_State.279* %71, i32 0, i32 4
  %72 = load %struct.lua_TValue.263** %top76, align 8
  %sub.ptr.lhs.cast77 = ptrtoint %struct.lua_TValue.263* %70 to i64
  %sub.ptr.rhs.cast78 = ptrtoint %struct.lua_TValue.263* %72 to i64
  %sub.ptr.sub79 = sub i64 %sub.ptr.lhs.cast77, %sub.ptr.rhs.cast78
  %sub.ptr.div80 = sdiv exact i64 %sub.ptr.sub79, 16
  %cmp81 = icmp sle i64 %sub.ptr.div80, 1
  br i1 %cmp81, label %if.then83, label %if.else84

if.then83:                                        ; preds = %for.end
  %73 = load %struct.lua_State.279** %L.addr, align 8
  call void bitcast (void (%struct.lua_State*, i32)* @luaD_growstack to void (%struct.lua_State.279*, i32)*)(%struct.lua_State.279* %73, i32 1)
  br label %if.end85

if.else84:                                        ; preds = %for.end
  br label %if.end85

if.end85:                                         ; preds = %if.else84, %if.then83
  %74 = load %struct.lua_State.279** %L.addr, align 8
  %75 = load i8** %fmt.addr, align 8
  %76 = load i8** %fmt.addr, align 8
  %call86 = call i64 @strlen(i8* %76) #10
  call void @pushstr(%struct.lua_State.279* %74, i8* %75, i64 %call86)
  %77 = load i32* %n, align 4
  %cmp87 = icmp sgt i32 %77, 0
  br i1 %cmp87, label %if.then89, label %if.end91

if.then89:                                        ; preds = %if.end85
  %78 = load %struct.lua_State.279** %L.addr, align 8
  %79 = load i32* %n, align 4
  %add90 = add nsw i32 %79, 1
  call void bitcast (void (%struct.lua_State.364*, i32)* @luaV_concat to void (%struct.lua_State.279*, i32)*)(%struct.lua_State.279* %78, i32 %add90)
  br label %if.end91

if.end91:                                         ; preds = %if.then89, %if.end85
  %80 = load %struct.lua_State.279** %L.addr, align 8
  %top92 = getelementptr inbounds %struct.lua_State.279* %80, i32 0, i32 4
  %81 = load %struct.lua_TValue.263** %top92, align 8
  %add.ptr93 = getelementptr inbounds %struct.lua_TValue.263* %81, i64 -1
  %value_94 = getelementptr inbounds %struct.lua_TValue.263* %add.ptr93, i32 0, i32 0
  %gc = bitcast %union.Value.281* %value_94 to %union.GCObject.280**
  %82 = load %union.GCObject.280** %gc, align 8
  %ts = bitcast %union.GCObject.280* %82 to %union.TString.269*
  %add.ptr95 = getelementptr inbounds %union.TString.269* %ts, i64 1
  %83 = bitcast %union.TString.269* %add.ptr95 to i8*
  ret i8* %83
}

; Function Attrs: nounwind
declare i32 @sprintf(i8*, i8*, ...) #4

; Function Attrs: nounwind uwtable
define hidden i8* @luaO_pushfstring(%struct.lua_State.279* %L, i8* %fmt, ...) #0 {
entry:
  %L.addr = alloca %struct.lua_State.279*, align 8
  %fmt.addr = alloca i8*, align 8
  %msg = alloca i8*, align 8
  %argp = alloca [1 x %struct.__va_list_tag], align 16
  store %struct.lua_State.279* %L, %struct.lua_State.279** %L.addr, align 8
  store i8* %fmt, i8** %fmt.addr, align 8
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag]* %argp, i32 0, i32 0
  %arraydecay1 = bitcast %struct.__va_list_tag* %arraydecay to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  %0 = load %struct.lua_State.279** %L.addr, align 8
  %1 = load i8** %fmt.addr, align 8
  %arraydecay2 = getelementptr inbounds [1 x %struct.__va_list_tag]* %argp, i32 0, i32 0
  %call = call i8* @luaO_pushvfstring(%struct.lua_State.279* %0, i8* %1, %struct.__va_list_tag* %arraydecay2)
  store i8* %call, i8** %msg, align 8
  %arraydecay3 = getelementptr inbounds [1 x %struct.__va_list_tag]* %argp, i32 0, i32 0
  %arraydecay34 = bitcast %struct.__va_list_tag* %arraydecay3 to i8*
  call void @llvm.va_end(i8* %arraydecay34)
  %2 = load i8** %msg, align 8
  ret i8* %2
}

; Function Attrs: nounwind uwtable
define hidden void @luaO_chunkid(i8* %out, i8* %source, i64 %bufflen) #0 {
entry:
  %out.addr = alloca i8*, align 8
  %source.addr = alloca i8*, align 8
  %bufflen.addr = alloca i64, align 8
  %l = alloca i64, align 8
  %nl = alloca i8*, align 8
  store i8* %out, i8** %out.addr, align 8
  store i8* %source, i8** %source.addr, align 8
  store i64 %bufflen, i64* %bufflen.addr, align 8
  %0 = load i8** %source.addr, align 8
  %call = call i64 @strlen(i8* %0) #10
  store i64 %call, i64* %l, align 8
  %1 = load i8** %source.addr, align 8
  %2 = load i8* %1, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp eq i32 %conv, 61
  br i1 %cmp, label %if.then, label %if.else9

if.then:                                          ; preds = %entry
  %3 = load i64* %l, align 8
  %4 = load i64* %bufflen.addr, align 8
  %cmp2 = icmp ule i64 %3, %4
  br i1 %cmp2, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.then
  %5 = load i8** %out.addr, align 8
  %6 = load i8** %source.addr, align 8
  %add.ptr = getelementptr inbounds i8* %6, i64 1
  %7 = load i64* %l, align 8
  %mul = mul i64 %7, 1
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %5, i8* %add.ptr, i64 %mul, i32 1, i1 false)
  br label %if.end

if.else:                                          ; preds = %if.then
  %8 = load i8** %out.addr, align 8
  %9 = load i8** %source.addr, align 8
  %add.ptr5 = getelementptr inbounds i8* %9, i64 1
  %10 = load i64* %bufflen.addr, align 8
  %sub = sub i64 %10, 1
  %mul6 = mul i64 %sub, 1
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %8, i8* %add.ptr5, i64 %mul6, i32 1, i1 false)
  %11 = load i64* %bufflen.addr, align 8
  %sub7 = sub i64 %11, 1
  %12 = load i8** %out.addr, align 8
  %add.ptr8 = getelementptr inbounds i8* %12, i64 %sub7
  store i8* %add.ptr8, i8** %out.addr, align 8
  %13 = load i8** %out.addr, align 8
  store i8 0, i8* %13, align 1
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then4
  br label %if.end52

if.else9:                                         ; preds = %entry
  %14 = load i8** %source.addr, align 8
  %15 = load i8* %14, align 1
  %conv10 = sext i8 %15 to i32
  %cmp11 = icmp eq i32 %conv10, 64
  br i1 %cmp11, label %if.then13, label %if.else27

if.then13:                                        ; preds = %if.else9
  %16 = load i64* %l, align 8
  %17 = load i64* %bufflen.addr, align 8
  %cmp14 = icmp ule i64 %16, %17
  br i1 %cmp14, label %if.then16, label %if.else19

if.then16:                                        ; preds = %if.then13
  %18 = load i8** %out.addr, align 8
  %19 = load i8** %source.addr, align 8
  %add.ptr17 = getelementptr inbounds i8* %19, i64 1
  %20 = load i64* %l, align 8
  %mul18 = mul i64 %20, 1
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %18, i8* %add.ptr17, i64 %mul18, i32 1, i1 false)
  br label %if.end26

if.else19:                                        ; preds = %if.then13
  %21 = load i8** %out.addr, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %21, i8* getelementptr inbounds ([4 x i8]* @.str6505, i32 0, i32 0), i64 3, i32 1, i1 false)
  %22 = load i8** %out.addr, align 8
  %add.ptr20 = getelementptr inbounds i8* %22, i64 3
  store i8* %add.ptr20, i8** %out.addr, align 8
  %23 = load i64* %bufflen.addr, align 8
  %sub21 = sub i64 %23, 3
  store i64 %sub21, i64* %bufflen.addr, align 8
  %24 = load i8** %out.addr, align 8
  %25 = load i8** %source.addr, align 8
  %add.ptr22 = getelementptr inbounds i8* %25, i64 1
  %26 = load i64* %l, align 8
  %add.ptr23 = getelementptr inbounds i8* %add.ptr22, i64 %26
  %27 = load i64* %bufflen.addr, align 8
  %idx.neg = sub i64 0, %27
  %add.ptr24 = getelementptr inbounds i8* %add.ptr23, i64 %idx.neg
  %28 = load i64* %bufflen.addr, align 8
  %mul25 = mul i64 %28, 1
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %24, i8* %add.ptr24, i64 %mul25, i32 1, i1 false)
  br label %if.end26

if.end26:                                         ; preds = %if.else19, %if.then16
  br label %if.end51

if.else27:                                        ; preds = %if.else9
  %29 = load i8** %source.addr, align 8
  %call28 = call i8* @strchr(i8* %29, i32 10) #10
  store i8* %call28, i8** %nl, align 8
  %30 = load i8** %out.addr, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %30, i8* getelementptr inbounds ([10 x i8]* @.str7506, i32 0, i32 0), i64 9, i32 1, i1 false)
  %31 = load i8** %out.addr, align 8
  %add.ptr29 = getelementptr inbounds i8* %31, i64 9
  store i8* %add.ptr29, i8** %out.addr, align 8
  %32 = load i64* %bufflen.addr, align 8
  %sub30 = sub i64 %32, 15
  store i64 %sub30, i64* %bufflen.addr, align 8
  %33 = load i64* %l, align 8
  %34 = load i64* %bufflen.addr, align 8
  %cmp31 = icmp ult i64 %33, %34
  br i1 %cmp31, label %land.lhs.true, label %if.else38

land.lhs.true:                                    ; preds = %if.else27
  %35 = load i8** %nl, align 8
  %cmp33 = icmp eq i8* %35, null
  br i1 %cmp33, label %if.then35, label %if.else38

if.then35:                                        ; preds = %land.lhs.true
  %36 = load i8** %out.addr, align 8
  %37 = load i8** %source.addr, align 8
  %38 = load i64* %l, align 8
  %mul36 = mul i64 %38, 1
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %36, i8* %37, i64 %mul36, i32 1, i1 false)
  %39 = load i64* %l, align 8
  %40 = load i8** %out.addr, align 8
  %add.ptr37 = getelementptr inbounds i8* %40, i64 %39
  store i8* %add.ptr37, i8** %out.addr, align 8
  br label %if.end50

if.else38:                                        ; preds = %land.lhs.true, %if.else27
  %41 = load i8** %nl, align 8
  %cmp39 = icmp ne i8* %41, null
  br i1 %cmp39, label %if.then41, label %if.end42

if.then41:                                        ; preds = %if.else38
  %42 = load i8** %nl, align 8
  %43 = load i8** %source.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %42 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %43 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, i64* %l, align 8
  br label %if.end42

if.end42:                                         ; preds = %if.then41, %if.else38
  %44 = load i64* %l, align 8
  %45 = load i64* %bufflen.addr, align 8
  %cmp43 = icmp ugt i64 %44, %45
  br i1 %cmp43, label %if.then45, label %if.end46

if.then45:                                        ; preds = %if.end42
  %46 = load i64* %bufflen.addr, align 8
  store i64 %46, i64* %l, align 8
  br label %if.end46

if.end46:                                         ; preds = %if.then45, %if.end42
  %47 = load i8** %out.addr, align 8
  %48 = load i8** %source.addr, align 8
  %49 = load i64* %l, align 8
  %mul47 = mul i64 %49, 1
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %47, i8* %48, i64 %mul47, i32 1, i1 false)
  %50 = load i64* %l, align 8
  %51 = load i8** %out.addr, align 8
  %add.ptr48 = getelementptr inbounds i8* %51, i64 %50
  store i8* %add.ptr48, i8** %out.addr, align 8
  %52 = load i8** %out.addr, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %52, i8* getelementptr inbounds ([4 x i8]* @.str6505, i32 0, i32 0), i64 3, i32 1, i1 false)
  %53 = load i8** %out.addr, align 8
  %add.ptr49 = getelementptr inbounds i8* %53, i64 3
  store i8* %add.ptr49, i8** %out.addr, align 8
  br label %if.end50

if.end50:                                         ; preds = %if.end46, %if.then35
  %54 = load i8** %out.addr, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %54, i8* getelementptr inbounds ([3 x i8]* @.str8507, i32 0, i32 0), i64 3, i32 1, i1 false)
  br label %if.end51

if.end51:                                         ; preds = %if.end50, %if.end26
  br label %if.end52

if.end52:                                         ; preds = %if.end51, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @pushstr(%struct.lua_State.279* %L, i8* %str, i64 %l) #0 {
entry:
  %L.addr = alloca %struct.lua_State.279*, align 8
  %str.addr = alloca i8*, align 8
  %l.addr = alloca i64, align 8
  %io = alloca %struct.lua_TValue.263*, align 8
  %x_ = alloca %union.TString.269*, align 8
  store %struct.lua_State.279* %L, %struct.lua_State.279** %L.addr, align 8
  store i8* %str, i8** %str.addr, align 8
  store i64 %l, i64* %l.addr, align 8
  %0 = load %struct.lua_State.279** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State.279* %0, i32 0, i32 4
  %1 = load %struct.lua_TValue.263** %top, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue.263* %1, i32 1
  store %struct.lua_TValue.263* %incdec.ptr, %struct.lua_TValue.263** %top, align 8
  store %struct.lua_TValue.263* %1, %struct.lua_TValue.263** %io, align 8
  %2 = load %struct.lua_State.279** %L.addr, align 8
  %3 = load i8** %str.addr, align 8
  %4 = load i64* %l.addr, align 8
  %call = call %union.TString.269* bitcast (%union.TString.367* (%struct.lua_State.364*, i8*, i64)* @luaS_newlstr to %union.TString.269* (%struct.lua_State.279*, i8*, i64)*)(%struct.lua_State.279* %2, i8* %3, i64 %4)
  store %union.TString.269* %call, %union.TString.269** %x_, align 8
  %5 = load %union.TString.269** %x_, align 8
  %6 = bitcast %union.TString.269* %5 to %union.GCObject.280*
  %7 = load %struct.lua_TValue.263** %io, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue.263* %7, i32 0, i32 0
  %gc = bitcast %union.Value.281* %value_ to %union.GCObject.280**
  store %union.GCObject.280* %6, %union.GCObject.280** %gc, align 8
  %8 = load %union.TString.269** %x_, align 8
  %tsv = bitcast %union.TString.269* %8 to %struct.anon.268*
  %tt = getelementptr inbounds %struct.anon.268* %tsv, i32 0, i32 1
  %9 = load i8* %tt, align 1
  %conv = zext i8 %9 to i32
  %or = or i32 %conv, 64
  %10 = load %struct.lua_TValue.263** %io, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue.263* %10, i32 0, i32 1
  store i32 %or, i32* %tt_, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @luaopen_os(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 11)
  %1 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_setfuncs(%struct.lua_State* %1, %struct.luaL_Reg* getelementptr inbounds ([12 x %struct.luaL_Reg]* @syslib, i32 0, i32 0), i32 0)
  ret i32 1
}

; Function Attrs: nounwind
declare i8* @strcpy(i8*, i8*) #4

declare i32 @mkstemp(i8*) #5

declare i32 @close(i32) #5

; Function Attrs: nounwind
declare i64 @time(i64*) #4

; Function Attrs: nounwind
declare i64 @mktime(%struct.tm*) #4

; Function Attrs: nounwind
declare i8* @setlocale(i32, i8*) #4

; Function Attrs: nounwind
declare i32 @rename(i8*, i8*) #4

; Function Attrs: nounwind
declare i32 @remove(i8*) #4

; Function Attrs: noreturn nounwind
declare void @exit(i32) #7

declare i32 @system(i8*) #5

; Function Attrs: nounwind readnone
declare double @difftime(i64, i64) #3

; Function Attrs: nounwind
declare %struct.tm* @gmtime_r(i64*, %struct.tm*) #4

; Function Attrs: nounwind
declare %struct.tm* @localtime_r(i64*, %struct.tm*) #4

; Function Attrs: nounwind
declare i64 @strftime(i8*, i64, i8*, %struct.tm*) #4

; Function Attrs: nounwind
declare i64 @clock() #4

; Function Attrs: nounwind uwtable
define internal i32 @os_clock(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i64 @clock() #1
  %conv = sitofp i64 %call to double
  %div = fdiv double %conv, 1.000000e+06
  call void @lua_pushnumber(%struct.lua_State* %0, double %div)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @os_date(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %s = alloca i8*, align 8
  %t = alloca i64, align 8
  %tmr = alloca %struct.tm, align 8
  %stm = alloca %struct.tm*, align 8
  %cc = alloca [4 x i8], align 1
  %b = alloca %struct.luaL_Buffer, align 8
  %reslen = alloca i64, align 8
  %buff = alloca [200 x i8], align 16
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @luaL_optlstring(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([3 x i8]* @.str26588, i32 0, i32 0), i64* null)
  store i8* %call, i8** %s, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i32 @lua_type(%struct.lua_State* %1, i32 2)
  %cmp = icmp sle i32 %call1, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %call2 = call i64 @time(i64* null) #1
  br label %cond.end

cond.false:                                       ; preds = %entry
  %2 = load %struct.lua_State** %L.addr, align 8
  %call3 = call double @luaL_checknumber(%struct.lua_State* %2, i32 2)
  %conv = fptosi double %call3 to i64
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call2, %cond.true ], [ %conv, %cond.false ]
  store i64 %cond, i64* %t, align 8
  %3 = load i8** %s, align 8
  %4 = load i8* %3, align 1
  %conv4 = sext i8 %4 to i32
  %cmp5 = icmp eq i32 %conv4, 33
  br i1 %cmp5, label %if.then, label %if.else

if.then:                                          ; preds = %cond.end
  %call7 = call %struct.tm* @gmtime_r(i64* %t, %struct.tm* %tmr) #1
  store %struct.tm* %call7, %struct.tm** %stm, align 8
  %5 = load i8** %s, align 8
  %incdec.ptr = getelementptr inbounds i8* %5, i32 1
  store i8* %incdec.ptr, i8** %s, align 8
  br label %if.end

if.else:                                          ; preds = %cond.end
  %call8 = call %struct.tm* @localtime_r(i64* %t, %struct.tm* %tmr) #1
  store %struct.tm* %call8, %struct.tm** %stm, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %6 = load %struct.tm** %stm, align 8
  %cmp9 = icmp eq %struct.tm* %6, null
  br i1 %cmp9, label %if.then11, label %if.else12

if.then11:                                        ; preds = %if.end
  %7 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushnil(%struct.lua_State* %7)
  br label %if.end41

if.else12:                                        ; preds = %if.end
  %8 = load i8** %s, align 8
  %call13 = call i32 @strcmp(i8* %8, i8* getelementptr inbounds ([3 x i8]* @.str27589, i32 0, i32 0)) #10
  %cmp14 = icmp eq i32 %call13, 0
  br i1 %cmp14, label %if.then16, label %if.else20

if.then16:                                        ; preds = %if.else12
  %9 = load %struct.lua_State** %L.addr, align 8
  call void @lua_createtable(%struct.lua_State* %9, i32 0, i32 9)
  %10 = load %struct.lua_State** %L.addr, align 8
  %11 = load %struct.tm** %stm, align 8
  %tm_sec = getelementptr inbounds %struct.tm* %11, i32 0, i32 0
  %12 = load i32* %tm_sec, align 4
  call void @setfield(%struct.lua_State* %10, i8* getelementptr inbounds ([4 x i8]* @.str13575, i32 0, i32 0), i32 %12)
  %13 = load %struct.lua_State** %L.addr, align 8
  %14 = load %struct.tm** %stm, align 8
  %tm_min = getelementptr inbounds %struct.tm* %14, i32 0, i32 1
  %15 = load i32* %tm_min, align 4
  call void @setfield(%struct.lua_State* %13, i8* getelementptr inbounds ([4 x i8]* @.str14576, i32 0, i32 0), i32 %15)
  %16 = load %struct.lua_State** %L.addr, align 8
  %17 = load %struct.tm** %stm, align 8
  %tm_hour = getelementptr inbounds %struct.tm* %17, i32 0, i32 2
  %18 = load i32* %tm_hour, align 4
  call void @setfield(%struct.lua_State* %16, i8* getelementptr inbounds ([5 x i8]* @.str15577, i32 0, i32 0), i32 %18)
  %19 = load %struct.lua_State** %L.addr, align 8
  %20 = load %struct.tm** %stm, align 8
  %tm_mday = getelementptr inbounds %struct.tm* %20, i32 0, i32 3
  %21 = load i32* %tm_mday, align 4
  call void @setfield(%struct.lua_State* %19, i8* getelementptr inbounds ([4 x i8]* @.str16578, i32 0, i32 0), i32 %21)
  %22 = load %struct.lua_State** %L.addr, align 8
  %23 = load %struct.tm** %stm, align 8
  %tm_mon = getelementptr inbounds %struct.tm* %23, i32 0, i32 4
  %24 = load i32* %tm_mon, align 4
  %add = add nsw i32 %24, 1
  call void @setfield(%struct.lua_State* %22, i8* getelementptr inbounds ([6 x i8]* @.str17579, i32 0, i32 0), i32 %add)
  %25 = load %struct.lua_State** %L.addr, align 8
  %26 = load %struct.tm** %stm, align 8
  %tm_year = getelementptr inbounds %struct.tm* %26, i32 0, i32 5
  %27 = load i32* %tm_year, align 4
  %add17 = add nsw i32 %27, 1900
  call void @setfield(%struct.lua_State* %25, i8* getelementptr inbounds ([5 x i8]* @.str18580, i32 0, i32 0), i32 %add17)
  %28 = load %struct.lua_State** %L.addr, align 8
  %29 = load %struct.tm** %stm, align 8
  %tm_wday = getelementptr inbounds %struct.tm* %29, i32 0, i32 6
  %30 = load i32* %tm_wday, align 4
  %add18 = add nsw i32 %30, 1
  call void @setfield(%struct.lua_State* %28, i8* getelementptr inbounds ([5 x i8]* @.str28590, i32 0, i32 0), i32 %add18)
  %31 = load %struct.lua_State** %L.addr, align 8
  %32 = load %struct.tm** %stm, align 8
  %tm_yday = getelementptr inbounds %struct.tm* %32, i32 0, i32 7
  %33 = load i32* %tm_yday, align 4
  %add19 = add nsw i32 %33, 1
  call void @setfield(%struct.lua_State* %31, i8* getelementptr inbounds ([5 x i8]* @.str29591, i32 0, i32 0), i32 %add19)
  %34 = load %struct.lua_State** %L.addr, align 8
  %35 = load %struct.tm** %stm, align 8
  %tm_isdst = getelementptr inbounds %struct.tm* %35, i32 0, i32 8
  %36 = load i32* %tm_isdst, align 4
  call void @setboolfield(%struct.lua_State* %34, i8* getelementptr inbounds ([6 x i8]* @.str19581, i32 0, i32 0), i32 %36)
  br label %if.end40

if.else20:                                        ; preds = %if.else12
  %arrayidx = getelementptr inbounds [4 x i8]* %cc, i32 0, i64 0
  store i8 37, i8* %arrayidx, align 1
  %37 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_buffinit(%struct.lua_State* %37, %struct.luaL_Buffer* %b)
  br label %while.cond

while.cond:                                       ; preds = %if.end39, %if.else20
  %38 = load i8** %s, align 8
  %39 = load i8* %38, align 1
  %tobool = icmp ne i8 %39, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %40 = load i8** %s, align 8
  %41 = load i8* %40, align 1
  %conv21 = sext i8 %41 to i32
  %cmp22 = icmp ne i32 %conv21, 37
  br i1 %cmp22, label %if.then24, label %if.else33

if.then24:                                        ; preds = %while.body
  %n = getelementptr inbounds %struct.luaL_Buffer* %b, i32 0, i32 2
  %42 = load i64* %n, align 8
  %size = getelementptr inbounds %struct.luaL_Buffer* %b, i32 0, i32 1
  %43 = load i64* %size, align 8
  %cmp25 = icmp ult i64 %42, %43
  br i1 %cmp25, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.then24
  %call27 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* %b, i64 1)
  %tobool28 = icmp ne i8* %call27, null
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.then24
  %44 = phi i1 [ true, %if.then24 ], [ %tobool28, %lor.rhs ]
  %lor.ext = zext i1 %44 to i32
  %45 = load i8** %s, align 8
  %incdec.ptr29 = getelementptr inbounds i8* %45, i32 1
  store i8* %incdec.ptr29, i8** %s, align 8
  %46 = load i8* %45, align 1
  %n30 = getelementptr inbounds %struct.luaL_Buffer* %b, i32 0, i32 2
  %47 = load i64* %n30, align 8
  %inc = add i64 %47, 1
  store i64 %inc, i64* %n30, align 8
  %b31 = getelementptr inbounds %struct.luaL_Buffer* %b, i32 0, i32 0
  %48 = load i8** %b31, align 8
  %arrayidx32 = getelementptr inbounds i8* %48, i64 %47
  store i8 %46, i8* %arrayidx32, align 1
  br label %if.end39

if.else33:                                        ; preds = %while.body
  %49 = load %struct.lua_State** %L.addr, align 8
  %50 = load i8** %s, align 8
  %add.ptr = getelementptr inbounds i8* %50, i64 1
  %arraydecay = getelementptr inbounds [4 x i8]* %cc, i32 0, i32 0
  %call34 = call i8* @checkoption(%struct.lua_State* %49, i8* %add.ptr, i8* %arraydecay)
  store i8* %call34, i8** %s, align 8
  %arraydecay35 = getelementptr inbounds [200 x i8]* %buff, i32 0, i32 0
  %arraydecay36 = getelementptr inbounds [4 x i8]* %cc, i32 0, i32 0
  %51 = load %struct.tm** %stm, align 8
  %call37 = call i64 @strftime(i8* %arraydecay35, i64 200, i8* %arraydecay36, %struct.tm* %51) #1
  store i64 %call37, i64* %reslen, align 8
  %arraydecay38 = getelementptr inbounds [200 x i8]* %buff, i32 0, i32 0
  %52 = load i64* %reslen, align 8
  call void @luaL_addlstring(%struct.luaL_Buffer* %b, i8* %arraydecay38, i64 %52)
  br label %if.end39

if.end39:                                         ; preds = %if.else33, %lor.end
  br label %while.cond

while.end:                                        ; preds = %while.cond
  call void @luaL_pushresult(%struct.luaL_Buffer* %b)
  br label %if.end40

if.end40:                                         ; preds = %while.end, %if.then16
  br label %if.end41

if.end41:                                         ; preds = %if.end40, %if.then11
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @os_difftime(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call double @luaL_checknumber(%struct.lua_State* %1, i32 1)
  %conv = fptosi double %call to i64
  %2 = load %struct.lua_State** %L.addr, align 8
  %call1 = call double @luaL_optnumber(%struct.lua_State* %2, i32 2, double 0.000000e+00)
  %conv2 = fptosi double %call1 to i64
  %call3 = call double @difftime(i64 %conv, i64 %conv2) #11
  call void @lua_pushnumber(%struct.lua_State* %0, double %call3)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @os_execute(%struct.lua_State* %L) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %cmd = alloca i8*, align 8
  %stat = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @luaL_optlstring(%struct.lua_State* %0, i32 1, i8* null, i64* null)
  store i8* %call, i8** %cmd, align 8
  %1 = load i8** %cmd, align 8
  %call1 = call i32 @system(i8* %1)
  store i32 %call1, i32* %stat, align 4
  %2 = load i8** %cmd, align 8
  %cmp = icmp ne i8* %2, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load i32* %stat, align 4
  %call2 = call i32 @luaL_execresult(%struct.lua_State* %3, i32 %4)
  store i32 %call2, i32* %retval
  br label %return

if.else:                                          ; preds = %entry
  %5 = load %struct.lua_State** %L.addr, align 8
  %6 = load i32* %stat, align 4
  call void @lua_pushboolean(%struct.lua_State* %5, i32 %6)
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %7 = load i32* %retval
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal i32 @os_exit(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %status = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_type(%struct.lua_State* %0, i32 1)
  %cmp = icmp eq i32 %call, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i32 @lua_toboolean(%struct.lua_State* %1, i32 1)
  %tobool = icmp ne i32 %call1, 0
  %cond = select i1 %tobool, i32 0, i32 1
  store i32 %cond, i32* %status, align 4
  br label %if.end

if.else:                                          ; preds = %entry
  %2 = load %struct.lua_State** %L.addr, align 8
  %call2 = call i64 @luaL_optinteger(%struct.lua_State* %2, i32 1, i64 0)
  %conv = trunc i64 %call2 to i32
  store i32 %conv, i32* %status, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %3 = load %struct.lua_State** %L.addr, align 8
  %call3 = call i32 @lua_toboolean(%struct.lua_State* %3, i32 2)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  %4 = load %struct.lua_State** %L.addr, align 8
  call void bitcast (void (%struct.lua_State.343*)* @lua_close to void (%struct.lua_State*)*)(%struct.lua_State* %4)
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %if.end
  %5 = load %struct.lua_State** %L.addr, align 8
  %tobool7 = icmp ne %struct.lua_State* %5, null
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end6
  %6 = load i32* %status, align 4
  call void @exit(i32 %6) #12
  unreachable

if.end9:                                          ; preds = %if.end6
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @os_getenv(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @luaL_checklstring(%struct.lua_State* %1, i32 1, i64* null)
  %call1 = call i8* @getenv(i8* %call) #1
  %call2 = call i8* @lua_pushstring(%struct.lua_State* %0, i8* %call1)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @os_remove(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %filename = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null)
  store i8* %call, i8** %filename, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load i8** %filename, align 8
  %call1 = call i32 @remove(i8* %2) #1
  %cmp = icmp eq i32 %call1, 0
  %conv = zext i1 %cmp to i32
  %3 = load i8** %filename, align 8
  %call2 = call i32 @luaL_fileresult(%struct.lua_State* %1, i32 %conv, i8* %3)
  ret i32 %call2
}

; Function Attrs: nounwind uwtable
define internal i32 @os_rename(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %fromname = alloca i8*, align 8
  %toname = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null)
  store i8* %call, i8** %fromname, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i8* @luaL_checklstring(%struct.lua_State* %1, i32 2, i64* null)
  store i8* %call1, i8** %toname, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load i8** %fromname, align 8
  %4 = load i8** %toname, align 8
  %call2 = call i32 @rename(i8* %3, i8* %4) #1
  %cmp = icmp eq i32 %call2, 0
  %conv = zext i1 %cmp to i32
  %call3 = call i32 @luaL_fileresult(%struct.lua_State* %2, i32 %conv, i8* null)
  ret i32 %call3
}

; Function Attrs: nounwind uwtable
define internal i32 @os_setlocale(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %l = alloca i8*, align 8
  %op = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @luaL_optlstring(%struct.lua_State* %0, i32 1, i8* null, i64* null)
  store i8* %call, i8** %l, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i32 @luaL_checkoption(%struct.lua_State* %1, i32 2, i8* getelementptr inbounds ([4 x i8]* @.str21583, i32 0, i32 0), i8** getelementptr inbounds ([7 x i8*]* @os_setlocale.catnames, i32 0, i32 0))
  store i32 %call1, i32* %op, align 4
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load i32* %op, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds [6 x i32]* @os_setlocale.cat, i32 0, i64 %idxprom
  %4 = load i32* %arrayidx, align 4
  %5 = load i8** %l, align 8
  %call2 = call i8* @setlocale(i32 %4, i8* %5) #1
  %call3 = call i8* @lua_pushstring(%struct.lua_State* %2, i8* %call2)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @os_time(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %t = alloca i64, align 8
  %ts = alloca %struct.tm, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_type(%struct.lua_State* %0, i32 1)
  %cmp = icmp sle i32 %call, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call1 = call i64 @time(i64* null) #1
  store i64 %call1, i64* %t, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %1 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_checktype(%struct.lua_State* %1, i32 1, i32 5)
  %2 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %2, i32 1)
  %3 = load %struct.lua_State** %L.addr, align 8
  %call2 = call i32 @getfield(%struct.lua_State* %3, i8* getelementptr inbounds ([4 x i8]* @.str13575, i32 0, i32 0), i32 0)
  %tm_sec = getelementptr inbounds %struct.tm* %ts, i32 0, i32 0
  store i32 %call2, i32* %tm_sec, align 4
  %4 = load %struct.lua_State** %L.addr, align 8
  %call3 = call i32 @getfield(%struct.lua_State* %4, i8* getelementptr inbounds ([4 x i8]* @.str14576, i32 0, i32 0), i32 0)
  %tm_min = getelementptr inbounds %struct.tm* %ts, i32 0, i32 1
  store i32 %call3, i32* %tm_min, align 4
  %5 = load %struct.lua_State** %L.addr, align 8
  %call4 = call i32 @getfield(%struct.lua_State* %5, i8* getelementptr inbounds ([5 x i8]* @.str15577, i32 0, i32 0), i32 12)
  %tm_hour = getelementptr inbounds %struct.tm* %ts, i32 0, i32 2
  store i32 %call4, i32* %tm_hour, align 4
  %6 = load %struct.lua_State** %L.addr, align 8
  %call5 = call i32 @getfield(%struct.lua_State* %6, i8* getelementptr inbounds ([4 x i8]* @.str16578, i32 0, i32 0), i32 -1)
  %tm_mday = getelementptr inbounds %struct.tm* %ts, i32 0, i32 3
  store i32 %call5, i32* %tm_mday, align 4
  %7 = load %struct.lua_State** %L.addr, align 8
  %call6 = call i32 @getfield(%struct.lua_State* %7, i8* getelementptr inbounds ([6 x i8]* @.str17579, i32 0, i32 0), i32 -1)
  %sub = sub nsw i32 %call6, 1
  %tm_mon = getelementptr inbounds %struct.tm* %ts, i32 0, i32 4
  store i32 %sub, i32* %tm_mon, align 4
  %8 = load %struct.lua_State** %L.addr, align 8
  %call7 = call i32 @getfield(%struct.lua_State* %8, i8* getelementptr inbounds ([5 x i8]* @.str18580, i32 0, i32 0), i32 -1)
  %sub8 = sub nsw i32 %call7, 1900
  %tm_year = getelementptr inbounds %struct.tm* %ts, i32 0, i32 5
  store i32 %sub8, i32* %tm_year, align 4
  %9 = load %struct.lua_State** %L.addr, align 8
  %call9 = call i32 @getboolfield(%struct.lua_State* %9, i8* getelementptr inbounds ([6 x i8]* @.str19581, i32 0, i32 0))
  %tm_isdst = getelementptr inbounds %struct.tm* %ts, i32 0, i32 8
  store i32 %call9, i32* %tm_isdst, align 4
  %call10 = call i64 @mktime(%struct.tm* %ts) #1
  store i64 %call10, i64* %t, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %10 = load i64* %t, align 8
  %cmp11 = icmp eq i64 %10, -1
  br i1 %cmp11, label %if.then12, label %if.else13

if.then12:                                        ; preds = %if.end
  %11 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushnil(%struct.lua_State* %11)
  br label %if.end14

if.else13:                                        ; preds = %if.end
  %12 = load %struct.lua_State** %L.addr, align 8
  %13 = load i64* %t, align 8
  %conv = sitofp i64 %13 to double
  call void @lua_pushnumber(%struct.lua_State* %12, double %conv)
  br label %if.end14

if.end14:                                         ; preds = %if.else13, %if.then12
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @os_tmpname(%struct.lua_State* %L) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %buff = alloca [32 x i8], align 16
  %err = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %arraydecay = getelementptr inbounds [32 x i8]* %buff, i32 0, i32 0
  %call = call i8* @strcpy(i8* %arraydecay, i8* getelementptr inbounds ([16 x i8]* @.str11573, i32 0, i32 0)) #1
  %arraydecay1 = getelementptr inbounds [32 x i8]* %buff, i32 0, i32 0
  %call2 = call i32 @mkstemp(i8* %arraydecay1)
  store i32 %call2, i32* %err, align 4
  %0 = load i32* %err, align 4
  %cmp = icmp ne i32 %0, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i32* %err, align 4
  %call3 = call i32 @close(i32 %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i32* %err, align 4
  %cmp4 = icmp eq i32 %2, -1
  %conv = zext i1 %cmp4 to i32
  store i32 %conv, i32* %err, align 4
  %3 = load i32* %err, align 4
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %4 = load %struct.lua_State** %L.addr, align 8
  %call6 = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %4, i8* getelementptr inbounds ([37 x i8]* @.str12574, i32 0, i32 0))
  store i32 %call6, i32* %retval
  br label %return

if.end7:                                          ; preds = %if.end
  %5 = load %struct.lua_State** %L.addr, align 8
  %arraydecay8 = getelementptr inbounds [32 x i8]* %buff, i32 0, i32 0
  %call9 = call i8* @lua_pushstring(%struct.lua_State* %5, i8* %arraydecay8)
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %if.end7, %if.then5
  %6 = load i32* %retval
  ret i32 %6
}

; Function Attrs: nounwind uwtable
define internal void @setfield(%struct.lua_State* %L, i8* %key, i32 %value) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %key.addr = alloca i8*, align 8
  %value.addr = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %key, i8** %key.addr, align 8
  store i32 %value, i32* %value.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %value.addr, align 4
  %conv = sext i32 %1 to i64
  call void @lua_pushinteger(%struct.lua_State* %0, i64 %conv)
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load i8** %key.addr, align 8
  call void @lua_setfield(%struct.lua_State* %2, i32 -2, i8* %3)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @setboolfield(%struct.lua_State* %L, i8* %key, i32 %value) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %key.addr = alloca i8*, align 8
  %value.addr = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %key, i8** %key.addr, align 8
  store i32 %value, i32* %value.addr, align 4
  %0 = load i32* %value.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load i32* %value.addr, align 4
  call void @lua_pushboolean(%struct.lua_State* %1, i32 %2)
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load i8** %key.addr, align 8
  call void @lua_setfield(%struct.lua_State* %3, i32 -2, i8* %4)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal i8* @checkoption(%struct.lua_State* %L, i8* %conv, i8* %buff) #0 {
entry:
  %retval = alloca i8*, align 8
  %L.addr = alloca %struct.lua_State*, align 8
  %conv.addr = alloca i8*, align 8
  %buff.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %conv, i8** %conv.addr, align 8
  store i8* %buff, i8** %buff.addr, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32* %i, align 4
  %conv1 = zext i32 %0 to i64
  %cmp = icmp ult i64 %conv1, 6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load i8** %conv.addr, align 8
  %2 = load i8* %1, align 1
  %conv3 = sext i8 %2 to i32
  %cmp4 = icmp ne i32 %conv3, 0
  br i1 %cmp4, label %land.lhs.true, label %if.end36

land.lhs.true:                                    ; preds = %for.body
  %3 = load i32* %i, align 4
  %idxprom = zext i32 %3 to i64
  %arrayidx = getelementptr inbounds [6 x i8*]* @checkoption.options, i32 0, i64 %idxprom
  %4 = load i8** %arrayidx, align 8
  %5 = load i8** %conv.addr, align 8
  %6 = load i8* %5, align 1
  %conv6 = sext i8 %6 to i32
  %call = call i8* @strchr(i8* %4, i32 %conv6) #10
  %cmp7 = icmp ne i8* %call, null
  br i1 %cmp7, label %if.then, label %if.end36

if.then:                                          ; preds = %land.lhs.true
  %7 = load i8** %conv.addr, align 8
  %8 = load i8* %7, align 1
  %9 = load i8** %buff.addr, align 8
  %arrayidx9 = getelementptr inbounds i8* %9, i64 1
  store i8 %8, i8* %arrayidx9, align 1
  %10 = load i32* %i, align 4
  %add = add i32 %10, 1
  %idxprom10 = zext i32 %add to i64
  %arrayidx11 = getelementptr inbounds [6 x i8*]* @checkoption.options, i32 0, i64 %idxprom10
  %11 = load i8** %arrayidx11, align 8
  %12 = load i8* %11, align 1
  %conv12 = sext i8 %12 to i32
  %cmp13 = icmp eq i32 %conv12, 0
  br i1 %cmp13, label %if.then15, label %if.else

if.then15:                                        ; preds = %if.then
  %13 = load i8** %buff.addr, align 8
  %arrayidx16 = getelementptr inbounds i8* %13, i64 2
  store i8 0, i8* %arrayidx16, align 1
  %14 = load i8** %conv.addr, align 8
  %add.ptr = getelementptr inbounds i8* %14, i64 1
  store i8* %add.ptr, i8** %retval
  br label %return

if.else:                                          ; preds = %if.then
  %15 = load i8** %conv.addr, align 8
  %add.ptr17 = getelementptr inbounds i8* %15, i64 1
  %16 = load i8* %add.ptr17, align 1
  %conv18 = sext i8 %16 to i32
  %cmp19 = icmp ne i32 %conv18, 0
  br i1 %cmp19, label %land.lhs.true21, label %if.end

land.lhs.true21:                                  ; preds = %if.else
  %17 = load i32* %i, align 4
  %add22 = add i32 %17, 1
  %idxprom23 = zext i32 %add22 to i64
  %arrayidx24 = getelementptr inbounds [6 x i8*]* @checkoption.options, i32 0, i64 %idxprom23
  %18 = load i8** %arrayidx24, align 8
  %19 = load i8** %conv.addr, align 8
  %add.ptr25 = getelementptr inbounds i8* %19, i64 1
  %20 = load i8* %add.ptr25, align 1
  %conv26 = sext i8 %20 to i32
  %call27 = call i8* @strchr(i8* %18, i32 %conv26) #10
  %cmp28 = icmp ne i8* %call27, null
  br i1 %cmp28, label %if.then30, label %if.end

if.then30:                                        ; preds = %land.lhs.true21
  %21 = load i8** %conv.addr, align 8
  %add.ptr31 = getelementptr inbounds i8* %21, i64 1
  %22 = load i8* %add.ptr31, align 1
  %23 = load i8** %buff.addr, align 8
  %arrayidx32 = getelementptr inbounds i8* %23, i64 2
  store i8 %22, i8* %arrayidx32, align 1
  %24 = load i8** %buff.addr, align 8
  %arrayidx33 = getelementptr inbounds i8* %24, i64 3
  store i8 0, i8* %arrayidx33, align 1
  %25 = load i8** %conv.addr, align 8
  %add.ptr34 = getelementptr inbounds i8* %25, i64 2
  store i8* %add.ptr34, i8** %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true21, %if.else
  br label %if.end35

if.end35:                                         ; preds = %if.end
  br label %if.end36

if.end36:                                         ; preds = %if.end35, %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end36
  %26 = load i32* %i, align 4
  %add37 = add i32 %26, 2
  store i32 %add37, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %27 = load %struct.lua_State** %L.addr, align 8
  %28 = load %struct.lua_State** %L.addr, align 8
  %29 = load i8** %conv.addr, align 8
  %call38 = call i8* (%struct.lua_State*, i8*, ...)* @lua_pushfstring(%struct.lua_State* %28, i8* getelementptr inbounds ([36 x i8]* @.str36598, i32 0, i32 0), i8* %29)
  %call39 = call i32 @luaL_argerror(%struct.lua_State* %27, i32 1, i8* %call38)
  %30 = load i8** %conv.addr, align 8
  store i8* %30, i8** %retval
  br label %return

return:                                           ; preds = %for.end, %if.then30, %if.then15
  %31 = load i8** %retval
  ret i8* %31
}

; Function Attrs: nounwind uwtable
define internal i32 @getfield(%struct.lua_State* %L, i8* %key, i32 %d) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %key.addr = alloca i8*, align 8
  %d.addr = alloca i32, align 4
  %res = alloca i32, align 4
  %isnum = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %key, i8** %key.addr, align 8
  store i32 %d, i32* %d.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i8** %key.addr, align 8
  call void @lua_getfield(%struct.lua_State* %0, i32 -1, i8* %1)
  %2 = load %struct.lua_State** %L.addr, align 8
  %call = call i64 @lua_tointegerx(%struct.lua_State* %2, i32 -1, i32* %isnum)
  %conv = trunc i64 %call to i32
  store i32 %conv, i32* %res, align 4
  %3 = load i32* %isnum, align 4
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.end4, label %if.then

if.then:                                          ; preds = %entry
  %4 = load i32* %d.addr, align 4
  %cmp = icmp slt i32 %4, 0
  br i1 %cmp, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %5 = load %struct.lua_State** %L.addr, align 8
  %6 = load i8** %key.addr, align 8
  %call3 = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %5, i8* getelementptr inbounds ([33 x i8]* @.str20582, i32 0, i32 0), i8* %6)
  store i32 %call3, i32* %retval
  br label %return

if.end:                                           ; preds = %if.then
  %7 = load i32* %d.addr, align 4
  store i32 %7, i32* %res, align 4
  br label %if.end4

if.end4:                                          ; preds = %if.end, %entry
  %8 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %8, i32 -2)
  %9 = load i32* %res, align 4
  store i32 %9, i32* %retval
  br label %return

return:                                           ; preds = %if.end4, %if.then2
  %10 = load i32* %retval
  ret i32 %10
}

; Function Attrs: nounwind uwtable
define internal i32 @getboolfield(%struct.lua_State* %L, i8* %key) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %key.addr = alloca i8*, align 8
  %res = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %key, i8** %key.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i8** %key.addr, align 8
  call void @lua_getfield(%struct.lua_State* %0, i32 -1, i8* %1)
  %2 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_type(%struct.lua_State* %2, i32 -1)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %3 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i32 @lua_toboolean(%struct.lua_State* %3, i32 -1)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ -1, %cond.true ], [ %call1, %cond.false ]
  store i32 %cond, i32* %res, align 4
  %4 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %4, i32 -2)
  %5 = load i32* %res, align 4
  ret i32 %5
}

; Function Attrs: nounwind uwtable
define hidden %union.Closure.157* @luaY_parser(%struct.lua_State.154* %L, %struct.Zio.308* %z, %struct.Mbuffer* %buff, %struct.Dyndata.313* %dyd, i8* %name, i32 %firstchar) #0 {
entry:
  %L.addr = alloca %struct.lua_State.154*, align 8
  %z.addr = alloca %struct.Zio.308*, align 8
  %buff.addr = alloca %struct.Mbuffer*, align 8
  %dyd.addr = alloca %struct.Dyndata.313*, align 8
  %name.addr = alloca i8*, align 8
  %firstchar.addr = alloca i32, align 4
  %lexstate = alloca %struct.LexState.321, align 8
  %funcstate = alloca %struct.FuncState.320, align 8
  %cl = alloca %union.Closure.157*, align 8
  %io = alloca %struct.lua_TValue.137*, align 8
  store %struct.lua_State.154* %L, %struct.lua_State.154** %L.addr, align 8
  store %struct.Zio.308* %z, %struct.Zio.308** %z.addr, align 8
  store %struct.Mbuffer* %buff, %struct.Mbuffer** %buff.addr, align 8
  store %struct.Dyndata.313* %dyd, %struct.Dyndata.313** %dyd.addr, align 8
  store i8* %name, i8** %name.addr, align 8
  store i32 %firstchar, i32* %firstchar.addr, align 4
  %0 = load %struct.lua_State.154** %L.addr, align 8
  %call = call %union.Closure.157* @luaF_newLclosure(%struct.lua_State.154* %0, i32 1)
  store %union.Closure.157* %call, %union.Closure.157** %cl, align 8
  %1 = load %struct.lua_State.154** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State.154* %1, i32 0, i32 4
  %2 = load %struct.lua_TValue.137** %top, align 8
  store %struct.lua_TValue.137* %2, %struct.lua_TValue.137** %io, align 8
  %3 = load %union.Closure.157** %cl, align 8
  %4 = bitcast %union.Closure.157* %3 to %union.GCObject.155*
  %5 = load %struct.lua_TValue.137** %io, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue.137* %5, i32 0, i32 0
  %gc = bitcast %union.Value.136* %value_ to %union.GCObject.155**
  store %union.GCObject.155* %4, %union.GCObject.155** %gc, align 8
  %6 = load %struct.lua_TValue.137** %io, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue.137* %6, i32 0, i32 1
  store i32 70, i32* %tt_, align 4
  %7 = load %struct.lua_State.154** %L.addr, align 8
  %top1 = getelementptr inbounds %struct.lua_State.154* %7, i32 0, i32 4
  %8 = load %struct.lua_TValue.137** %top1, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue.137* %8, i32 1
  store %struct.lua_TValue.137* %incdec.ptr, %struct.lua_TValue.137** %top1, align 8
  %9 = load %struct.lua_State.154** %L.addr, align 8
  %stack_last = getelementptr inbounds %struct.lua_State.154* %9, i32 0, i32 8
  %10 = load %struct.lua_TValue.137** %stack_last, align 8
  %11 = load %struct.lua_State.154** %L.addr, align 8
  %top2 = getelementptr inbounds %struct.lua_State.154* %11, i32 0, i32 4
  %12 = load %struct.lua_TValue.137** %top2, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.lua_TValue.137* %10 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.lua_TValue.137* %12 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 16
  %cmp = icmp sle i64 %sub.ptr.div, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %13 = load %struct.lua_State.154** %L.addr, align 8
  call void bitcast (void (%struct.lua_State*, i32)* @luaD_growstack to void (%struct.lua_State.154*, i32)*)(%struct.lua_State.154* %13, i32 0)
  br label %if.end

if.else:                                          ; preds = %entry
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %14 = load %struct.lua_State.154** %L.addr, align 8
  %call3 = call %struct.Proto.160* @luaF_newproto(%struct.lua_State.154* %14)
  %15 = load %union.Closure.157** %cl, align 8
  %l = bitcast %union.Closure.157* %15 to %struct.LClosure.324*
  %p = getelementptr inbounds %struct.LClosure.324* %l, i32 0, i32 5
  store %struct.Proto.160* %call3, %struct.Proto.160** %p, align 8
  %f = getelementptr inbounds %struct.FuncState.320* %funcstate, i32 0, i32 0
  store %struct.Proto.160* %call3, %struct.Proto.160** %f, align 8
  %16 = load %struct.lua_State.154** %L.addr, align 8
  %17 = load i8** %name.addr, align 8
  %call4 = call %union.TString.143* bitcast (%union.TString.367* (%struct.lua_State.364*, i8*)* @luaS_new to %union.TString.143* (%struct.lua_State.154*, i8*)*)(%struct.lua_State.154* %16, i8* %17)
  %f5 = getelementptr inbounds %struct.FuncState.320* %funcstate, i32 0, i32 0
  %18 = load %struct.Proto.160** %f5, align 8
  %source = getelementptr inbounds %struct.Proto.160* %18, i32 0, i32 10
  store %union.TString.143* %call4, %union.TString.143** %source, align 8
  %19 = load %struct.Mbuffer** %buff.addr, align 8
  %buff6 = getelementptr inbounds %struct.LexState.321* %lexstate, i32 0, i32 8
  store %struct.Mbuffer* %19, %struct.Mbuffer** %buff6, align 8
  %20 = load %struct.Dyndata.313** %dyd.addr, align 8
  %dyd7 = getelementptr inbounds %struct.LexState.321* %lexstate, i32 0, i32 9
  store %struct.Dyndata.313* %20, %struct.Dyndata.313** %dyd7, align 8
  %21 = load %struct.Dyndata.313** %dyd.addr, align 8
  %label = getelementptr inbounds %struct.Dyndata.313* %21, i32 0, i32 2
  %n = getelementptr inbounds %struct.Labellist.312* %label, i32 0, i32 1
  store i32 0, i32* %n, align 4
  %22 = load %struct.Dyndata.313** %dyd.addr, align 8
  %gt = getelementptr inbounds %struct.Dyndata.313* %22, i32 0, i32 1
  %n8 = getelementptr inbounds %struct.Labellist.312* %gt, i32 0, i32 1
  store i32 0, i32* %n8, align 4
  %23 = load %struct.Dyndata.313** %dyd.addr, align 8
  %actvar = getelementptr inbounds %struct.Dyndata.313* %23, i32 0, i32 0
  %n9 = getelementptr inbounds %struct.anon.6* %actvar, i32 0, i32 1
  store i32 0, i32* %n9, align 4
  %24 = load %struct.lua_State.154** %L.addr, align 8
  %25 = load %struct.Zio.308** %z.addr, align 8
  %f10 = getelementptr inbounds %struct.FuncState.320* %funcstate, i32 0, i32 0
  %26 = load %struct.Proto.160** %f10, align 8
  %source11 = getelementptr inbounds %struct.Proto.160* %26, i32 0, i32 10
  %27 = load %union.TString.143** %source11, align 8
  %28 = load i32* %firstchar.addr, align 4
  call void bitcast (void (%struct.lua_State*, %struct.LexState.235*, %struct.Zio*, %union.TString*, i32)* @luaX_setinput to void (%struct.lua_State.154*, %struct.LexState.321*, %struct.Zio.308*, %union.TString.143*, i32)*)(%struct.lua_State.154* %24, %struct.LexState.321* %lexstate, %struct.Zio.308* %25, %union.TString.143* %27, i32 %28)
  call void @mainfunc(%struct.LexState.321* %lexstate, %struct.FuncState.320* %funcstate)
  %29 = load %union.Closure.157** %cl, align 8
  ret %union.Closure.157* %29
}

; Function Attrs: nounwind uwtable
define internal void @mainfunc(%struct.LexState.321* %ls, %struct.FuncState.320* %fs) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %fs.addr = alloca %struct.FuncState.320*, align 8
  %bl = alloca %struct.BlockCnt, align 8
  %v = alloca %struct.expdesc, align 8
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store %struct.FuncState.320* %fs, %struct.FuncState.320** %fs.addr, align 8
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %1 = load %struct.FuncState.320** %fs.addr, align 8
  call void @open_func(%struct.LexState.321* %0, %struct.FuncState.320* %1, %struct.BlockCnt* %bl)
  %2 = load %struct.FuncState.320** %fs.addr, align 8
  %f = getelementptr inbounds %struct.FuncState.320* %2, i32 0, i32 0
  %3 = load %struct.Proto.160** %f, align 8
  %is_vararg = getelementptr inbounds %struct.Proto.160* %3, i32 0, i32 21
  store i8 1, i8* %is_vararg, align 1
  call void @init_exp(%struct.expdesc* %v, i32 7, i32 0)
  %4 = load %struct.FuncState.320** %fs.addr, align 8
  %5 = load %struct.LexState.321** %ls.addr, align 8
  %envn = getelementptr inbounds %struct.LexState.321* %5, i32 0, i32 11
  %6 = load %union.TString.143** %envn, align 8
  %call = call i32 @newupvalue(%struct.FuncState.320* %4, %union.TString.143* %6, %struct.expdesc* %v)
  %7 = load %struct.LexState.321** %ls.addr, align 8
  call void bitcast (void (%struct.LexState.235*)* @luaX_next to void (%struct.LexState.321*)*)(%struct.LexState.321* %7)
  %8 = load %struct.LexState.321** %ls.addr, align 8
  call void @statlist(%struct.LexState.321* %8)
  %9 = load %struct.LexState.321** %ls.addr, align 8
  call void @check(%struct.LexState.321* %9, i32 286)
  %10 = load %struct.LexState.321** %ls.addr, align 8
  call void @close_func(%struct.LexState.321* %10)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @open_func(%struct.LexState.321* %ls, %struct.FuncState.320* %fs, %struct.BlockCnt* %bl) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %fs.addr = alloca %struct.FuncState.320*, align 8
  %bl.addr = alloca %struct.BlockCnt*, align 8
  %L = alloca %struct.lua_State.154*, align 8
  %f = alloca %struct.Proto.160*, align 8
  %io = alloca %struct.lua_TValue.137*, align 8
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store %struct.FuncState.320* %fs, %struct.FuncState.320** %fs.addr, align 8
  store %struct.BlockCnt* %bl, %struct.BlockCnt** %bl.addr, align 8
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %L1 = getelementptr inbounds %struct.LexState.321* %0, i32 0, i32 6
  %1 = load %struct.lua_State.154** %L1, align 8
  store %struct.lua_State.154* %1, %struct.lua_State.154** %L, align 8
  %2 = load %struct.LexState.321** %ls.addr, align 8
  %fs2 = getelementptr inbounds %struct.LexState.321* %2, i32 0, i32 5
  %3 = load %struct.FuncState.320** %fs2, align 8
  %4 = load %struct.FuncState.320** %fs.addr, align 8
  %prev = getelementptr inbounds %struct.FuncState.320* %4, i32 0, i32 2
  store %struct.FuncState.320* %3, %struct.FuncState.320** %prev, align 8
  %5 = load %struct.LexState.321** %ls.addr, align 8
  %6 = load %struct.FuncState.320** %fs.addr, align 8
  %ls3 = getelementptr inbounds %struct.FuncState.320* %6, i32 0, i32 3
  store %struct.LexState.321* %5, %struct.LexState.321** %ls3, align 8
  %7 = load %struct.FuncState.320** %fs.addr, align 8
  %8 = load %struct.LexState.321** %ls.addr, align 8
  %fs4 = getelementptr inbounds %struct.LexState.321* %8, i32 0, i32 5
  store %struct.FuncState.320* %7, %struct.FuncState.320** %fs4, align 8
  %9 = load %struct.FuncState.320** %fs.addr, align 8
  %pc = getelementptr inbounds %struct.FuncState.320* %9, i32 0, i32 5
  store i32 0, i32* %pc, align 4
  %10 = load %struct.FuncState.320** %fs.addr, align 8
  %lasttarget = getelementptr inbounds %struct.FuncState.320* %10, i32 0, i32 6
  store i32 0, i32* %lasttarget, align 4
  %11 = load %struct.FuncState.320** %fs.addr, align 8
  %jpc = getelementptr inbounds %struct.FuncState.320* %11, i32 0, i32 7
  store i32 -1, i32* %jpc, align 4
  %12 = load %struct.FuncState.320** %fs.addr, align 8
  %freereg = getelementptr inbounds %struct.FuncState.320* %12, i32 0, i32 14
  store i8 0, i8* %freereg, align 1
  %13 = load %struct.FuncState.320** %fs.addr, align 8
  %nk = getelementptr inbounds %struct.FuncState.320* %13, i32 0, i32 8
  store i32 0, i32* %nk, align 4
  %14 = load %struct.FuncState.320** %fs.addr, align 8
  %np = getelementptr inbounds %struct.FuncState.320* %14, i32 0, i32 9
  store i32 0, i32* %np, align 4
  %15 = load %struct.FuncState.320** %fs.addr, align 8
  %nups = getelementptr inbounds %struct.FuncState.320* %15, i32 0, i32 13
  store i8 0, i8* %nups, align 1
  %16 = load %struct.FuncState.320** %fs.addr, align 8
  %nlocvars = getelementptr inbounds %struct.FuncState.320* %16, i32 0, i32 11
  store i16 0, i16* %nlocvars, align 2
  %17 = load %struct.FuncState.320** %fs.addr, align 8
  %nactvar = getelementptr inbounds %struct.FuncState.320* %17, i32 0, i32 12
  store i8 0, i8* %nactvar, align 1
  %18 = load %struct.LexState.321** %ls.addr, align 8
  %dyd = getelementptr inbounds %struct.LexState.321* %18, i32 0, i32 9
  %19 = load %struct.Dyndata.313** %dyd, align 8
  %actvar = getelementptr inbounds %struct.Dyndata.313* %19, i32 0, i32 0
  %n = getelementptr inbounds %struct.anon.6* %actvar, i32 0, i32 1
  %20 = load i32* %n, align 4
  %21 = load %struct.FuncState.320** %fs.addr, align 8
  %firstlocal = getelementptr inbounds %struct.FuncState.320* %21, i32 0, i32 10
  store i32 %20, i32* %firstlocal, align 4
  %22 = load %struct.FuncState.320** %fs.addr, align 8
  %bl5 = getelementptr inbounds %struct.FuncState.320* %22, i32 0, i32 4
  store %struct.BlockCnt* null, %struct.BlockCnt** %bl5, align 8
  %23 = load %struct.FuncState.320** %fs.addr, align 8
  %f6 = getelementptr inbounds %struct.FuncState.320* %23, i32 0, i32 0
  %24 = load %struct.Proto.160** %f6, align 8
  store %struct.Proto.160* %24, %struct.Proto.160** %f, align 8
  %25 = load %struct.LexState.321** %ls.addr, align 8
  %source = getelementptr inbounds %struct.LexState.321* %25, i32 0, i32 10
  %26 = load %union.TString.143** %source, align 8
  %27 = load %struct.Proto.160** %f, align 8
  %source7 = getelementptr inbounds %struct.Proto.160* %27, i32 0, i32 10
  store %union.TString.143* %26, %union.TString.143** %source7, align 8
  %28 = load %struct.Proto.160** %f, align 8
  %maxstacksize = getelementptr inbounds %struct.Proto.160* %28, i32 0, i32 22
  store i8 2, i8* %maxstacksize, align 1
  %29 = load %struct.lua_State.154** %L, align 8
  %call = call %struct.Table.147* bitcast (%struct.Table* (%struct.lua_State*)* @luaH_new to %struct.Table.147* (%struct.lua_State.154*)*)(%struct.lua_State.154* %29)
  %30 = load %struct.FuncState.320** %fs.addr, align 8
  %h = getelementptr inbounds %struct.FuncState.320* %30, i32 0, i32 1
  store %struct.Table.147* %call, %struct.Table.147** %h, align 8
  %31 = load %struct.lua_State.154** %L, align 8
  %top = getelementptr inbounds %struct.lua_State.154* %31, i32 0, i32 4
  %32 = load %struct.lua_TValue.137** %top, align 8
  store %struct.lua_TValue.137* %32, %struct.lua_TValue.137** %io, align 8
  %33 = load %struct.FuncState.320** %fs.addr, align 8
  %h8 = getelementptr inbounds %struct.FuncState.320* %33, i32 0, i32 1
  %34 = load %struct.Table.147** %h8, align 8
  %35 = bitcast %struct.Table.147* %34 to %union.GCObject.155*
  %36 = load %struct.lua_TValue.137** %io, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue.137* %36, i32 0, i32 0
  %gc = bitcast %union.Value.136* %value_ to %union.GCObject.155**
  store %union.GCObject.155* %35, %union.GCObject.155** %gc, align 8
  %37 = load %struct.lua_TValue.137** %io, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue.137* %37, i32 0, i32 1
  store i32 69, i32* %tt_, align 4
  %38 = load %struct.lua_State.154** %L, align 8
  %top9 = getelementptr inbounds %struct.lua_State.154* %38, i32 0, i32 4
  %39 = load %struct.lua_TValue.137** %top9, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue.137* %39, i32 1
  store %struct.lua_TValue.137* %incdec.ptr, %struct.lua_TValue.137** %top9, align 8
  %40 = load %struct.lua_State.154** %L, align 8
  %stack_last = getelementptr inbounds %struct.lua_State.154* %40, i32 0, i32 8
  %41 = load %struct.lua_TValue.137** %stack_last, align 8
  %42 = load %struct.lua_State.154** %L, align 8
  %top10 = getelementptr inbounds %struct.lua_State.154* %42, i32 0, i32 4
  %43 = load %struct.lua_TValue.137** %top10, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.lua_TValue.137* %41 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.lua_TValue.137* %43 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 16
  %cmp = icmp sle i64 %sub.ptr.div, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %44 = load %struct.lua_State.154** %L, align 8
  call void bitcast (void (%struct.lua_State*, i32)* @luaD_growstack to void (%struct.lua_State.154*, i32)*)(%struct.lua_State.154* %44, i32 0)
  br label %if.end

if.else:                                          ; preds = %entry
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %45 = load %struct.FuncState.320** %fs.addr, align 8
  %46 = load %struct.BlockCnt** %bl.addr, align 8
  call void @enterblock(%struct.FuncState.320* %45, %struct.BlockCnt* %46, i8 zeroext 0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @init_exp(%struct.expdesc* %e, i32 %k, i32 %i) #0 {
entry:
  %e.addr = alloca %struct.expdesc*, align 8
  %k.addr = alloca i32, align 4
  %i.addr = alloca i32, align 4
  store %struct.expdesc* %e, %struct.expdesc** %e.addr, align 8
  store i32 %k, i32* %k.addr, align 4
  store i32 %i, i32* %i.addr, align 4
  %0 = load %struct.expdesc** %e.addr, align 8
  %t = getelementptr inbounds %struct.expdesc* %0, i32 0, i32 2
  store i32 -1, i32* %t, align 4
  %1 = load %struct.expdesc** %e.addr, align 8
  %f = getelementptr inbounds %struct.expdesc* %1, i32 0, i32 3
  store i32 -1, i32* %f, align 4
  %2 = load i32* %k.addr, align 4
  %3 = load %struct.expdesc** %e.addr, align 8
  %k1 = getelementptr inbounds %struct.expdesc* %3, i32 0, i32 0
  store i32 %2, i32* %k1, align 4
  %4 = load i32* %i.addr, align 4
  %5 = load %struct.expdesc** %e.addr, align 8
  %u = getelementptr inbounds %struct.expdesc* %5, i32 0, i32 1
  %info = bitcast %union.anon.7* %u to i32*
  store i32 %4, i32* %info, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @newupvalue(%struct.FuncState.320* %fs, %union.TString.143* %name, %struct.expdesc* %v) #0 {
entry:
  %fs.addr = alloca %struct.FuncState.320*, align 8
  %name.addr = alloca %union.TString.143*, align 8
  %v.addr = alloca %struct.expdesc*, align 8
  %f = alloca %struct.Proto.160*, align 8
  %oldsize = alloca i32, align 4
  store %struct.FuncState.320* %fs, %struct.FuncState.320** %fs.addr, align 8
  store %union.TString.143* %name, %union.TString.143** %name.addr, align 8
  store %struct.expdesc* %v, %struct.expdesc** %v.addr, align 8
  %0 = load %struct.FuncState.320** %fs.addr, align 8
  %f1 = getelementptr inbounds %struct.FuncState.320* %0, i32 0, i32 0
  %1 = load %struct.Proto.160** %f1, align 8
  store %struct.Proto.160* %1, %struct.Proto.160** %f, align 8
  %2 = load %struct.Proto.160** %f, align 8
  %sizeupvalues = getelementptr inbounds %struct.Proto.160* %2, i32 0, i32 11
  %3 = load i32* %sizeupvalues, align 4
  store i32 %3, i32* %oldsize, align 4
  %4 = load %struct.FuncState.320** %fs.addr, align 8
  %5 = load %struct.FuncState.320** %fs.addr, align 8
  %nups = getelementptr inbounds %struct.FuncState.320* %5, i32 0, i32 13
  %6 = load i8* %nups, align 1
  %conv = zext i8 %6 to i32
  %add = add nsw i32 %conv, 1
  call void @checklimit(%struct.FuncState.320* %4, i32 %add, i32 255, i8* getelementptr inbounds ([9 x i8]* @.str28629, i32 0, i32 0))
  %7 = load %struct.FuncState.320** %fs.addr, align 8
  %nups2 = getelementptr inbounds %struct.FuncState.320* %7, i32 0, i32 13
  %8 = load i8* %nups2, align 1
  %conv3 = zext i8 %8 to i32
  %add4 = add nsw i32 %conv3, 1
  %9 = load %struct.Proto.160** %f, align 8
  %sizeupvalues5 = getelementptr inbounds %struct.Proto.160* %9, i32 0, i32 11
  %10 = load i32* %sizeupvalues5, align 4
  %cmp = icmp sgt i32 %add4, %10
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %11 = load %struct.FuncState.320** %fs.addr, align 8
  %ls = getelementptr inbounds %struct.FuncState.320* %11, i32 0, i32 3
  %12 = load %struct.LexState.321** %ls, align 8
  %L = getelementptr inbounds %struct.LexState.321* %12, i32 0, i32 6
  %13 = load %struct.lua_State.154** %L, align 8
  %14 = load %struct.Proto.160** %f, align 8
  %upvalues = getelementptr inbounds %struct.Proto.160* %14, i32 0, i32 8
  %15 = load %struct.Upvaldesc.159** %upvalues, align 8
  %16 = bitcast %struct.Upvaldesc.159* %15 to i8*
  %17 = load %struct.Proto.160** %f, align 8
  %sizeupvalues7 = getelementptr inbounds %struct.Proto.160* %17, i32 0, i32 11
  %call = call i8* bitcast (i8* (%struct.lua_State*, i8*, i32*, i64, i32, i8*)* @luaM_growaux_ to i8* (%struct.lua_State.154*, i8*, i32*, i64, i32, i8*)*)(%struct.lua_State.154* %13, i8* %16, i32* %sizeupvalues7, i64 16, i32 255, i8* getelementptr inbounds ([9 x i8]* @.str28629, i32 0, i32 0))
  %18 = bitcast i8* %call to %struct.Upvaldesc.159*
  %19 = load %struct.Proto.160** %f, align 8
  %upvalues8 = getelementptr inbounds %struct.Proto.160* %19, i32 0, i32 8
  store %struct.Upvaldesc.159* %18, %struct.Upvaldesc.159** %upvalues8, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %20 = load i32* %oldsize, align 4
  %21 = load %struct.Proto.160** %f, align 8
  %sizeupvalues9 = getelementptr inbounds %struct.Proto.160* %21, i32 0, i32 11
  %22 = load i32* %sizeupvalues9, align 4
  %cmp10 = icmp slt i32 %20, %22
  br i1 %cmp10, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %23 = load i32* %oldsize, align 4
  %inc = add nsw i32 %23, 1
  store i32 %inc, i32* %oldsize, align 4
  %idxprom = sext i32 %23 to i64
  %24 = load %struct.Proto.160** %f, align 8
  %upvalues12 = getelementptr inbounds %struct.Proto.160* %24, i32 0, i32 8
  %25 = load %struct.Upvaldesc.159** %upvalues12, align 8
  %arrayidx = getelementptr inbounds %struct.Upvaldesc.159* %25, i64 %idxprom
  %name13 = getelementptr inbounds %struct.Upvaldesc.159* %arrayidx, i32 0, i32 0
  store %union.TString.143* null, %union.TString.143** %name13, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %26 = load %struct.expdesc** %v.addr, align 8
  %k = getelementptr inbounds %struct.expdesc* %26, i32 0, i32 0
  %27 = load i32* %k, align 4
  %cmp14 = icmp eq i32 %27, 7
  %conv15 = zext i1 %cmp14 to i32
  %conv16 = trunc i32 %conv15 to i8
  %28 = load %struct.FuncState.320** %fs.addr, align 8
  %nups17 = getelementptr inbounds %struct.FuncState.320* %28, i32 0, i32 13
  %29 = load i8* %nups17, align 1
  %idxprom18 = zext i8 %29 to i64
  %30 = load %struct.Proto.160** %f, align 8
  %upvalues19 = getelementptr inbounds %struct.Proto.160* %30, i32 0, i32 8
  %31 = load %struct.Upvaldesc.159** %upvalues19, align 8
  %arrayidx20 = getelementptr inbounds %struct.Upvaldesc.159* %31, i64 %idxprom18
  %instack = getelementptr inbounds %struct.Upvaldesc.159* %arrayidx20, i32 0, i32 1
  store i8 %conv16, i8* %instack, align 1
  %32 = load %struct.expdesc** %v.addr, align 8
  %u = getelementptr inbounds %struct.expdesc* %32, i32 0, i32 1
  %info = bitcast %union.anon.7* %u to i32*
  %33 = load i32* %info, align 4
  %conv21 = trunc i32 %33 to i8
  %34 = load %struct.FuncState.320** %fs.addr, align 8
  %nups22 = getelementptr inbounds %struct.FuncState.320* %34, i32 0, i32 13
  %35 = load i8* %nups22, align 1
  %idxprom23 = zext i8 %35 to i64
  %36 = load %struct.Proto.160** %f, align 8
  %upvalues24 = getelementptr inbounds %struct.Proto.160* %36, i32 0, i32 8
  %37 = load %struct.Upvaldesc.159** %upvalues24, align 8
  %arrayidx25 = getelementptr inbounds %struct.Upvaldesc.159* %37, i64 %idxprom23
  %idx = getelementptr inbounds %struct.Upvaldesc.159* %arrayidx25, i32 0, i32 2
  store i8 %conv21, i8* %idx, align 1
  %38 = load %union.TString.143** %name.addr, align 8
  %39 = load %struct.FuncState.320** %fs.addr, align 8
  %nups26 = getelementptr inbounds %struct.FuncState.320* %39, i32 0, i32 13
  %40 = load i8* %nups26, align 1
  %idxprom27 = zext i8 %40 to i64
  %41 = load %struct.Proto.160** %f, align 8
  %upvalues28 = getelementptr inbounds %struct.Proto.160* %41, i32 0, i32 8
  %42 = load %struct.Upvaldesc.159** %upvalues28, align 8
  %arrayidx29 = getelementptr inbounds %struct.Upvaldesc.159* %42, i64 %idxprom27
  %name30 = getelementptr inbounds %struct.Upvaldesc.159* %arrayidx29, i32 0, i32 0
  store %union.TString.143* %38, %union.TString.143** %name30, align 8
  %43 = load %union.TString.143** %name.addr, align 8
  %44 = bitcast %union.TString.143* %43 to %union.GCObject.155*
  %gch = bitcast %union.GCObject.155* %44 to %struct.GCheader.325*
  %marked = getelementptr inbounds %struct.GCheader.325* %gch, i32 0, i32 2
  %45 = load i8* %marked, align 1
  %conv31 = zext i8 %45 to i32
  %and = and i32 %conv31, 3
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end40

land.lhs.true:                                    ; preds = %while.end
  %46 = load %struct.Proto.160** %f, align 8
  %47 = bitcast %struct.Proto.160* %46 to %union.GCObject.155*
  %gch32 = bitcast %union.GCObject.155* %47 to %struct.GCheader.325*
  %marked33 = getelementptr inbounds %struct.GCheader.325* %gch32, i32 0, i32 2
  %48 = load i8* %marked33, align 1
  %conv34 = zext i8 %48 to i32
  %and35 = and i32 %conv34, 4
  %tobool36 = icmp ne i32 %and35, 0
  br i1 %tobool36, label %if.then37, label %if.end40

if.then37:                                        ; preds = %land.lhs.true
  %49 = load %struct.FuncState.320** %fs.addr, align 8
  %ls38 = getelementptr inbounds %struct.FuncState.320* %49, i32 0, i32 3
  %50 = load %struct.LexState.321** %ls38, align 8
  %L39 = getelementptr inbounds %struct.LexState.321* %50, i32 0, i32 6
  %51 = load %struct.lua_State.154** %L39, align 8
  %52 = load %struct.Proto.160** %f, align 8
  %53 = bitcast %struct.Proto.160* %52 to %union.GCObject.155*
  %54 = load %union.TString.143** %name.addr, align 8
  %55 = bitcast %union.TString.143* %54 to %union.GCObject.155*
  call void bitcast (void (%struct.lua_State*, %union.GCObject*, %union.GCObject*)* @luaC_barrier_ to void (%struct.lua_State.154*, %union.GCObject.155*, %union.GCObject.155*)*)(%struct.lua_State.154* %51, %union.GCObject.155* %53, %union.GCObject.155* %55)
  br label %if.end40

if.end40:                                         ; preds = %if.then37, %land.lhs.true, %while.end
  %56 = load %struct.FuncState.320** %fs.addr, align 8
  %nups41 = getelementptr inbounds %struct.FuncState.320* %56, i32 0, i32 13
  %57 = load i8* %nups41, align 1
  %inc42 = add i8 %57, 1
  store i8 %inc42, i8* %nups41, align 1
  %conv43 = zext i8 %57 to i32
  ret i32 %conv43
}

; Function Attrs: nounwind uwtable
define internal void @statlist(%struct.LexState.321* %ls) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %call = call i32 @block_follow(%struct.LexState.321* %0, i32 1)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load %struct.LexState.321** %ls.addr, align 8
  %t = getelementptr inbounds %struct.LexState.321* %1, i32 0, i32 3
  %token = getelementptr inbounds %struct.Token* %t, i32 0, i32 0
  %2 = load i32* %token, align 4
  %cmp = icmp eq i32 %2, 274
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %3 = load %struct.LexState.321** %ls.addr, align 8
  call void @statement(%struct.LexState.321* %3)
  br label %while.end

if.end:                                           ; preds = %while.body
  %4 = load %struct.LexState.321** %ls.addr, align 8
  call void @statement(%struct.LexState.321* %4)
  br label %while.cond

while.end:                                        ; preds = %if.then, %while.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @check(%struct.LexState.321* %ls, i32 %c) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %c.addr = alloca i32, align 4
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store i32 %c, i32* %c.addr, align 4
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %t = getelementptr inbounds %struct.LexState.321* %0, i32 0, i32 3
  %token = getelementptr inbounds %struct.Token* %t, i32 0, i32 0
  %1 = load i32* %token, align 4
  %2 = load i32* %c.addr, align 4
  %cmp = icmp ne i32 %1, %2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load %struct.LexState.321** %ls.addr, align 8
  %4 = load i32* %c.addr, align 4
  call void @error_expected(%struct.LexState.321* %3, i32 %4) #9
  unreachable

if.end:                                           ; preds = %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @close_func(%struct.LexState.321* %ls) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %L = alloca %struct.lua_State.154*, align 8
  %fs = alloca %struct.FuncState.320*, align 8
  %f = alloca %struct.Proto.160*, align 8
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %L1 = getelementptr inbounds %struct.LexState.321* %0, i32 0, i32 6
  %1 = load %struct.lua_State.154** %L1, align 8
  store %struct.lua_State.154* %1, %struct.lua_State.154** %L, align 8
  %2 = load %struct.LexState.321** %ls.addr, align 8
  %fs2 = getelementptr inbounds %struct.LexState.321* %2, i32 0, i32 5
  %3 = load %struct.FuncState.320** %fs2, align 8
  store %struct.FuncState.320* %3, %struct.FuncState.320** %fs, align 8
  %4 = load %struct.FuncState.320** %fs, align 8
  %f3 = getelementptr inbounds %struct.FuncState.320* %4, i32 0, i32 0
  %5 = load %struct.Proto.160** %f3, align 8
  store %struct.Proto.160* %5, %struct.Proto.160** %f, align 8
  %6 = load %struct.FuncState.320** %fs, align 8
  call void bitcast (void (%struct.FuncState*, i32, i32)* @luaK_ret to void (%struct.FuncState.320*, i32, i32)*)(%struct.FuncState.320* %6, i32 0, i32 0)
  %7 = load %struct.FuncState.320** %fs, align 8
  call void @leaveblock(%struct.FuncState.320* %7)
  %8 = load %struct.FuncState.320** %fs, align 8
  %pc = getelementptr inbounds %struct.FuncState.320* %8, i32 0, i32 5
  %9 = load i32* %pc, align 4
  %add = add nsw i32 %9, 1
  %conv = sext i32 %add to i64
  %cmp = icmp ugt i64 %conv, 4611686018427387903
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %10 = load %struct.lua_State.154** %L, align 8
  call void bitcast (void (%struct.lua_State*)* @luaM_toobig to void (%struct.lua_State.154*)*)(%struct.lua_State.154* %10) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %11
  %cond = phi i32 [ 0, %11 ], [ 0, %cond.false ]
  %12 = load %struct.lua_State.154** %L, align 8
  %13 = load %struct.Proto.160** %f, align 8
  %code = getelementptr inbounds %struct.Proto.160* %13, i32 0, i32 4
  %14 = load i32** %code, align 8
  %15 = bitcast i32* %14 to i8*
  %16 = load %struct.Proto.160** %f, align 8
  %sizecode = getelementptr inbounds %struct.Proto.160* %16, i32 0, i32 13
  %17 = load i32* %sizecode, align 4
  %conv5 = sext i32 %17 to i64
  %mul = mul i64 %conv5, 4
  %18 = load %struct.FuncState.320** %fs, align 8
  %pc6 = getelementptr inbounds %struct.FuncState.320* %18, i32 0, i32 5
  %19 = load i32* %pc6, align 4
  %conv7 = sext i32 %19 to i64
  %mul8 = mul i64 %conv7, 4
  %call = call i8* bitcast (i8* (%struct.lua_State*, i8*, i64, i64)* @luaM_realloc_ to i8* (%struct.lua_State.154*, i8*, i64, i64)*)(%struct.lua_State.154* %12, i8* %15, i64 %mul, i64 %mul8)
  %20 = bitcast i8* %call to i32*
  %21 = load %struct.Proto.160** %f, align 8
  %code9 = getelementptr inbounds %struct.Proto.160* %21, i32 0, i32 4
  store i32* %20, i32** %code9, align 8
  %22 = load %struct.FuncState.320** %fs, align 8
  %pc10 = getelementptr inbounds %struct.FuncState.320* %22, i32 0, i32 5
  %23 = load i32* %pc10, align 4
  %24 = load %struct.Proto.160** %f, align 8
  %sizecode11 = getelementptr inbounds %struct.Proto.160* %24, i32 0, i32 13
  store i32 %23, i32* %sizecode11, align 4
  %25 = load %struct.FuncState.320** %fs, align 8
  %pc12 = getelementptr inbounds %struct.FuncState.320* %25, i32 0, i32 5
  %26 = load i32* %pc12, align 4
  %add13 = add nsw i32 %26, 1
  %conv14 = sext i32 %add13 to i64
  %cmp15 = icmp ugt i64 %conv14, 4611686018427387903
  br i1 %cmp15, label %cond.true17, label %cond.false18

cond.true17:                                      ; preds = %cond.end
  %27 = load %struct.lua_State.154** %L, align 8
  call void bitcast (void (%struct.lua_State*)* @luaM_toobig to void (%struct.lua_State.154*)*)(%struct.lua_State.154* %27) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end19

cond.false18:                                     ; preds = %cond.end
  br label %cond.end19

cond.end19:                                       ; preds = %cond.false18, %28
  %cond20 = phi i32 [ 0, %28 ], [ 0, %cond.false18 ]
  %29 = load %struct.lua_State.154** %L, align 8
  %30 = load %struct.Proto.160** %f, align 8
  %lineinfo = getelementptr inbounds %struct.Proto.160* %30, i32 0, i32 6
  %31 = load i32** %lineinfo, align 8
  %32 = bitcast i32* %31 to i8*
  %33 = load %struct.Proto.160** %f, align 8
  %sizelineinfo = getelementptr inbounds %struct.Proto.160* %33, i32 0, i32 14
  %34 = load i32* %sizelineinfo, align 4
  %conv21 = sext i32 %34 to i64
  %mul22 = mul i64 %conv21, 4
  %35 = load %struct.FuncState.320** %fs, align 8
  %pc23 = getelementptr inbounds %struct.FuncState.320* %35, i32 0, i32 5
  %36 = load i32* %pc23, align 4
  %conv24 = sext i32 %36 to i64
  %mul25 = mul i64 %conv24, 4
  %call26 = call i8* bitcast (i8* (%struct.lua_State*, i8*, i64, i64)* @luaM_realloc_ to i8* (%struct.lua_State.154*, i8*, i64, i64)*)(%struct.lua_State.154* %29, i8* %32, i64 %mul22, i64 %mul25)
  %37 = bitcast i8* %call26 to i32*
  %38 = load %struct.Proto.160** %f, align 8
  %lineinfo27 = getelementptr inbounds %struct.Proto.160* %38, i32 0, i32 6
  store i32* %37, i32** %lineinfo27, align 8
  %39 = load %struct.FuncState.320** %fs, align 8
  %pc28 = getelementptr inbounds %struct.FuncState.320* %39, i32 0, i32 5
  %40 = load i32* %pc28, align 4
  %41 = load %struct.Proto.160** %f, align 8
  %sizelineinfo29 = getelementptr inbounds %struct.Proto.160* %41, i32 0, i32 14
  store i32 %40, i32* %sizelineinfo29, align 4
  %42 = load %struct.FuncState.320** %fs, align 8
  %nk = getelementptr inbounds %struct.FuncState.320* %42, i32 0, i32 8
  %43 = load i32* %nk, align 4
  %add30 = add nsw i32 %43, 1
  %conv31 = sext i32 %add30 to i64
  %cmp32 = icmp ugt i64 %conv31, 1152921504606846975
  br i1 %cmp32, label %cond.true34, label %cond.false35

cond.true34:                                      ; preds = %cond.end19
  %44 = load %struct.lua_State.154** %L, align 8
  call void bitcast (void (%struct.lua_State*)* @luaM_toobig to void (%struct.lua_State.154*)*)(%struct.lua_State.154* %44) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end36

cond.false35:                                     ; preds = %cond.end19
  br label %cond.end36

cond.end36:                                       ; preds = %cond.false35, %45
  %cond37 = phi i32 [ 0, %45 ], [ 0, %cond.false35 ]
  %46 = load %struct.lua_State.154** %L, align 8
  %47 = load %struct.Proto.160** %f, align 8
  %k = getelementptr inbounds %struct.Proto.160* %47, i32 0, i32 3
  %48 = load %struct.lua_TValue.137** %k, align 8
  %49 = bitcast %struct.lua_TValue.137* %48 to i8*
  %50 = load %struct.Proto.160** %f, align 8
  %sizek = getelementptr inbounds %struct.Proto.160* %50, i32 0, i32 12
  %51 = load i32* %sizek, align 4
  %conv38 = sext i32 %51 to i64
  %mul39 = mul i64 %conv38, 16
  %52 = load %struct.FuncState.320** %fs, align 8
  %nk40 = getelementptr inbounds %struct.FuncState.320* %52, i32 0, i32 8
  %53 = load i32* %nk40, align 4
  %conv41 = sext i32 %53 to i64
  %mul42 = mul i64 %conv41, 16
  %call43 = call i8* bitcast (i8* (%struct.lua_State*, i8*, i64, i64)* @luaM_realloc_ to i8* (%struct.lua_State.154*, i8*, i64, i64)*)(%struct.lua_State.154* %46, i8* %49, i64 %mul39, i64 %mul42)
  %54 = bitcast i8* %call43 to %struct.lua_TValue.137*
  %55 = load %struct.Proto.160** %f, align 8
  %k44 = getelementptr inbounds %struct.Proto.160* %55, i32 0, i32 3
  store %struct.lua_TValue.137* %54, %struct.lua_TValue.137** %k44, align 8
  %56 = load %struct.FuncState.320** %fs, align 8
  %nk45 = getelementptr inbounds %struct.FuncState.320* %56, i32 0, i32 8
  %57 = load i32* %nk45, align 4
  %58 = load %struct.Proto.160** %f, align 8
  %sizek46 = getelementptr inbounds %struct.Proto.160* %58, i32 0, i32 12
  store i32 %57, i32* %sizek46, align 4
  %59 = load %struct.FuncState.320** %fs, align 8
  %np = getelementptr inbounds %struct.FuncState.320* %59, i32 0, i32 9
  %60 = load i32* %np, align 4
  %add47 = add nsw i32 %60, 1
  %conv48 = sext i32 %add47 to i64
  %cmp49 = icmp ugt i64 %conv48, 2305843009213693951
  br i1 %cmp49, label %cond.true51, label %cond.false52

cond.true51:                                      ; preds = %cond.end36
  %61 = load %struct.lua_State.154** %L, align 8
  call void bitcast (void (%struct.lua_State*)* @luaM_toobig to void (%struct.lua_State.154*)*)(%struct.lua_State.154* %61) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end53

cond.false52:                                     ; preds = %cond.end36
  br label %cond.end53

cond.end53:                                       ; preds = %cond.false52, %62
  %cond54 = phi i32 [ 0, %62 ], [ 0, %cond.false52 ]
  %63 = load %struct.lua_State.154** %L, align 8
  %64 = load %struct.Proto.160** %f, align 8
  %p = getelementptr inbounds %struct.Proto.160* %64, i32 0, i32 5
  %65 = load %struct.Proto.160*** %p, align 8
  %66 = bitcast %struct.Proto.160** %65 to i8*
  %67 = load %struct.Proto.160** %f, align 8
  %sizep = getelementptr inbounds %struct.Proto.160* %67, i32 0, i32 15
  %68 = load i32* %sizep, align 4
  %conv55 = sext i32 %68 to i64
  %mul56 = mul i64 %conv55, 8
  %69 = load %struct.FuncState.320** %fs, align 8
  %np57 = getelementptr inbounds %struct.FuncState.320* %69, i32 0, i32 9
  %70 = load i32* %np57, align 4
  %conv58 = sext i32 %70 to i64
  %mul59 = mul i64 %conv58, 8
  %call60 = call i8* bitcast (i8* (%struct.lua_State*, i8*, i64, i64)* @luaM_realloc_ to i8* (%struct.lua_State.154*, i8*, i64, i64)*)(%struct.lua_State.154* %63, i8* %66, i64 %mul56, i64 %mul59)
  %71 = bitcast i8* %call60 to %struct.Proto.160**
  %72 = load %struct.Proto.160** %f, align 8
  %p61 = getelementptr inbounds %struct.Proto.160* %72, i32 0, i32 5
  store %struct.Proto.160** %71, %struct.Proto.160*** %p61, align 8
  %73 = load %struct.FuncState.320** %fs, align 8
  %np62 = getelementptr inbounds %struct.FuncState.320* %73, i32 0, i32 9
  %74 = load i32* %np62, align 4
  %75 = load %struct.Proto.160** %f, align 8
  %sizep63 = getelementptr inbounds %struct.Proto.160* %75, i32 0, i32 15
  store i32 %74, i32* %sizep63, align 4
  %76 = load %struct.FuncState.320** %fs, align 8
  %nlocvars = getelementptr inbounds %struct.FuncState.320* %76, i32 0, i32 11
  %77 = load i16* %nlocvars, align 2
  %conv64 = sext i16 %77 to i32
  %add65 = add nsw i32 %conv64, 1
  %conv66 = sext i32 %add65 to i64
  %cmp67 = icmp ugt i64 %conv66, 1152921504606846975
  br i1 %cmp67, label %cond.true69, label %cond.false70

cond.true69:                                      ; preds = %cond.end53
  %78 = load %struct.lua_State.154** %L, align 8
  call void bitcast (void (%struct.lua_State*)* @luaM_toobig to void (%struct.lua_State.154*)*)(%struct.lua_State.154* %78) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end71

cond.false70:                                     ; preds = %cond.end53
  br label %cond.end71

cond.end71:                                       ; preds = %cond.false70, %79
  %cond72 = phi i32 [ 0, %79 ], [ 0, %cond.false70 ]
  %80 = load %struct.lua_State.154** %L, align 8
  %81 = load %struct.Proto.160** %f, align 8
  %locvars = getelementptr inbounds %struct.Proto.160* %81, i32 0, i32 7
  %82 = load %struct.LocVar.158** %locvars, align 8
  %83 = bitcast %struct.LocVar.158* %82 to i8*
  %84 = load %struct.Proto.160** %f, align 8
  %sizelocvars = getelementptr inbounds %struct.Proto.160* %84, i32 0, i32 16
  %85 = load i32* %sizelocvars, align 4
  %conv73 = sext i32 %85 to i64
  %mul74 = mul i64 %conv73, 16
  %86 = load %struct.FuncState.320** %fs, align 8
  %nlocvars75 = getelementptr inbounds %struct.FuncState.320* %86, i32 0, i32 11
  %87 = load i16* %nlocvars75, align 2
  %conv76 = sext i16 %87 to i64
  %mul77 = mul i64 %conv76, 16
  %call78 = call i8* bitcast (i8* (%struct.lua_State*, i8*, i64, i64)* @luaM_realloc_ to i8* (%struct.lua_State.154*, i8*, i64, i64)*)(%struct.lua_State.154* %80, i8* %83, i64 %mul74, i64 %mul77)
  %88 = bitcast i8* %call78 to %struct.LocVar.158*
  %89 = load %struct.Proto.160** %f, align 8
  %locvars79 = getelementptr inbounds %struct.Proto.160* %89, i32 0, i32 7
  store %struct.LocVar.158* %88, %struct.LocVar.158** %locvars79, align 8
  %90 = load %struct.FuncState.320** %fs, align 8
  %nlocvars80 = getelementptr inbounds %struct.FuncState.320* %90, i32 0, i32 11
  %91 = load i16* %nlocvars80, align 2
  %conv81 = sext i16 %91 to i32
  %92 = load %struct.Proto.160** %f, align 8
  %sizelocvars82 = getelementptr inbounds %struct.Proto.160* %92, i32 0, i32 16
  store i32 %conv81, i32* %sizelocvars82, align 4
  %93 = load %struct.FuncState.320** %fs, align 8
  %nups = getelementptr inbounds %struct.FuncState.320* %93, i32 0, i32 13
  %94 = load i8* %nups, align 1
  %conv83 = zext i8 %94 to i32
  %add84 = add nsw i32 %conv83, 1
  %conv85 = sext i32 %add84 to i64
  %cmp86 = icmp ugt i64 %conv85, 1152921504606846975
  br i1 %cmp86, label %cond.true88, label %cond.false89

cond.true88:                                      ; preds = %cond.end71
  %95 = load %struct.lua_State.154** %L, align 8
  call void bitcast (void (%struct.lua_State*)* @luaM_toobig to void (%struct.lua_State.154*)*)(%struct.lua_State.154* %95) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end90

cond.false89:                                     ; preds = %cond.end71
  br label %cond.end90

cond.end90:                                       ; preds = %cond.false89, %96
  %cond91 = phi i32 [ 0, %96 ], [ 0, %cond.false89 ]
  %97 = load %struct.lua_State.154** %L, align 8
  %98 = load %struct.Proto.160** %f, align 8
  %upvalues = getelementptr inbounds %struct.Proto.160* %98, i32 0, i32 8
  %99 = load %struct.Upvaldesc.159** %upvalues, align 8
  %100 = bitcast %struct.Upvaldesc.159* %99 to i8*
  %101 = load %struct.Proto.160** %f, align 8
  %sizeupvalues = getelementptr inbounds %struct.Proto.160* %101, i32 0, i32 11
  %102 = load i32* %sizeupvalues, align 4
  %conv92 = sext i32 %102 to i64
  %mul93 = mul i64 %conv92, 16
  %103 = load %struct.FuncState.320** %fs, align 8
  %nups94 = getelementptr inbounds %struct.FuncState.320* %103, i32 0, i32 13
  %104 = load i8* %nups94, align 1
  %conv95 = zext i8 %104 to i64
  %mul96 = mul i64 %conv95, 16
  %call97 = call i8* bitcast (i8* (%struct.lua_State*, i8*, i64, i64)* @luaM_realloc_ to i8* (%struct.lua_State.154*, i8*, i64, i64)*)(%struct.lua_State.154* %97, i8* %100, i64 %mul93, i64 %mul96)
  %105 = bitcast i8* %call97 to %struct.Upvaldesc.159*
  %106 = load %struct.Proto.160** %f, align 8
  %upvalues98 = getelementptr inbounds %struct.Proto.160* %106, i32 0, i32 8
  store %struct.Upvaldesc.159* %105, %struct.Upvaldesc.159** %upvalues98, align 8
  %107 = load %struct.FuncState.320** %fs, align 8
  %nups99 = getelementptr inbounds %struct.FuncState.320* %107, i32 0, i32 13
  %108 = load i8* %nups99, align 1
  %conv100 = zext i8 %108 to i32
  %109 = load %struct.Proto.160** %f, align 8
  %sizeupvalues101 = getelementptr inbounds %struct.Proto.160* %109, i32 0, i32 11
  store i32 %conv100, i32* %sizeupvalues101, align 4
  %110 = load %struct.FuncState.320** %fs, align 8
  %prev = getelementptr inbounds %struct.FuncState.320* %110, i32 0, i32 2
  %111 = load %struct.FuncState.320** %prev, align 8
  %112 = load %struct.LexState.321** %ls.addr, align 8
  %fs102 = getelementptr inbounds %struct.LexState.321* %112, i32 0, i32 5
  store %struct.FuncState.320* %111, %struct.FuncState.320** %fs102, align 8
  %113 = load %struct.LexState.321** %ls.addr, align 8
  call void @anchor_token(%struct.LexState.321* %113)
  %114 = load %struct.lua_State.154** %L, align 8
  %top = getelementptr inbounds %struct.lua_State.154* %114, i32 0, i32 4
  %115 = load %struct.lua_TValue.137** %top, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue.137* %115, i32 -1
  store %struct.lua_TValue.137* %incdec.ptr, %struct.lua_TValue.137** %top, align 8
  %116 = load %struct.lua_State.154** %L, align 8
  %l_G = getelementptr inbounds %struct.lua_State.154* %116, i32 0, i32 5
  %117 = load %struct.global_State.148** %l_G, align 8
  %GCdebt = getelementptr inbounds %struct.global_State.148* %117, i32 0, i32 3
  %118 = load i64* %GCdebt, align 8
  %cmp103 = icmp sgt i64 %118, 0
  br i1 %cmp103, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end90
  %119 = load %struct.lua_State.154** %L, align 8
  call void bitcast (void (%struct.lua_State*)* @luaC_step to void (%struct.lua_State.154*)*)(%struct.lua_State.154* %119)
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end90
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @enterblock(%struct.FuncState.320* %fs, %struct.BlockCnt* %bl, i8 zeroext %isloop) #0 {
entry:
  %fs.addr = alloca %struct.FuncState.320*, align 8
  %bl.addr = alloca %struct.BlockCnt*, align 8
  %isloop.addr = alloca i8, align 1
  store %struct.FuncState.320* %fs, %struct.FuncState.320** %fs.addr, align 8
  store %struct.BlockCnt* %bl, %struct.BlockCnt** %bl.addr, align 8
  store i8 %isloop, i8* %isloop.addr, align 1
  %0 = load i8* %isloop.addr, align 1
  %1 = load %struct.BlockCnt** %bl.addr, align 8
  %isloop1 = getelementptr inbounds %struct.BlockCnt* %1, i32 0, i32 5
  store i8 %0, i8* %isloop1, align 1
  %2 = load %struct.FuncState.320** %fs.addr, align 8
  %nactvar = getelementptr inbounds %struct.FuncState.320* %2, i32 0, i32 12
  %3 = load i8* %nactvar, align 1
  %4 = load %struct.BlockCnt** %bl.addr, align 8
  %nactvar2 = getelementptr inbounds %struct.BlockCnt* %4, i32 0, i32 3
  store i8 %3, i8* %nactvar2, align 1
  %5 = load %struct.FuncState.320** %fs.addr, align 8
  %ls = getelementptr inbounds %struct.FuncState.320* %5, i32 0, i32 3
  %6 = load %struct.LexState.321** %ls, align 8
  %dyd = getelementptr inbounds %struct.LexState.321* %6, i32 0, i32 9
  %7 = load %struct.Dyndata.313** %dyd, align 8
  %label = getelementptr inbounds %struct.Dyndata.313* %7, i32 0, i32 2
  %n = getelementptr inbounds %struct.Labellist.312* %label, i32 0, i32 1
  %8 = load i32* %n, align 4
  %conv = trunc i32 %8 to i16
  %9 = load %struct.BlockCnt** %bl.addr, align 8
  %firstlabel = getelementptr inbounds %struct.BlockCnt* %9, i32 0, i32 1
  store i16 %conv, i16* %firstlabel, align 2
  %10 = load %struct.FuncState.320** %fs.addr, align 8
  %ls3 = getelementptr inbounds %struct.FuncState.320* %10, i32 0, i32 3
  %11 = load %struct.LexState.321** %ls3, align 8
  %dyd4 = getelementptr inbounds %struct.LexState.321* %11, i32 0, i32 9
  %12 = load %struct.Dyndata.313** %dyd4, align 8
  %gt = getelementptr inbounds %struct.Dyndata.313* %12, i32 0, i32 1
  %n5 = getelementptr inbounds %struct.Labellist.312* %gt, i32 0, i32 1
  %13 = load i32* %n5, align 4
  %conv6 = trunc i32 %13 to i16
  %14 = load %struct.BlockCnt** %bl.addr, align 8
  %firstgoto = getelementptr inbounds %struct.BlockCnt* %14, i32 0, i32 2
  store i16 %conv6, i16* %firstgoto, align 2
  %15 = load %struct.BlockCnt** %bl.addr, align 8
  %upval = getelementptr inbounds %struct.BlockCnt* %15, i32 0, i32 4
  store i8 0, i8* %upval, align 1
  %16 = load %struct.FuncState.320** %fs.addr, align 8
  %bl7 = getelementptr inbounds %struct.FuncState.320* %16, i32 0, i32 4
  %17 = load %struct.BlockCnt** %bl7, align 8
  %18 = load %struct.BlockCnt** %bl.addr, align 8
  %previous = getelementptr inbounds %struct.BlockCnt* %18, i32 0, i32 0
  store %struct.BlockCnt* %17, %struct.BlockCnt** %previous, align 8
  %19 = load %struct.BlockCnt** %bl.addr, align 8
  %20 = load %struct.FuncState.320** %fs.addr, align 8
  %bl8 = getelementptr inbounds %struct.FuncState.320* %20, i32 0, i32 4
  store %struct.BlockCnt* %19, %struct.BlockCnt** %bl8, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @checklimit(%struct.FuncState.320* %fs, i32 %v, i32 %l, i8* %what) #0 {
entry:
  %fs.addr = alloca %struct.FuncState.320*, align 8
  %v.addr = alloca i32, align 4
  %l.addr = alloca i32, align 4
  %what.addr = alloca i8*, align 8
  store %struct.FuncState.320* %fs, %struct.FuncState.320** %fs.addr, align 8
  store i32 %v, i32* %v.addr, align 4
  store i32 %l, i32* %l.addr, align 4
  store i8* %what, i8** %what.addr, align 8
  %0 = load i32* %v.addr, align 4
  %1 = load i32* %l.addr, align 4
  %cmp = icmp sgt i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.FuncState.320** %fs.addr, align 8
  %3 = load i32* %l.addr, align 4
  %4 = load i8** %what.addr, align 8
  call void @errorlimit(%struct.FuncState.320* %2, i32 %3, i8* %4) #9
  unreachable

if.end:                                           ; preds = %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @block_follow(%struct.LexState.321* %ls, i32 %withuntil) #0 {
entry:
  %retval = alloca i32, align 4
  %ls.addr = alloca %struct.LexState.321*, align 8
  %withuntil.addr = alloca i32, align 4
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store i32 %withuntil, i32* %withuntil.addr, align 4
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %t = getelementptr inbounds %struct.LexState.321* %0, i32 0, i32 3
  %token = getelementptr inbounds %struct.Token* %t, i32 0, i32 0
  %1 = load i32* %token, align 4
  switch i32 %1, label %sw.default [
    i32 260, label %sw.bb
    i32 261, label %sw.bb
    i32 262, label %sw.bb
    i32 286, label %sw.bb
    i32 277, label %sw.bb1
  ]

sw.bb:                                            ; preds = %entry, %entry, %entry, %entry
  store i32 1, i32* %retval
  br label %return

sw.bb1:                                           ; preds = %entry
  %2 = load i32* %withuntil.addr, align 4
  store i32 %2, i32* %retval
  br label %return

sw.default:                                       ; preds = %entry
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %sw.default, %sw.bb1, %sw.bb
  %3 = load i32* %retval
  ret i32 %3
}

; Function Attrs: nounwind uwtable
define internal void @statement(%struct.LexState.321* %ls) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %line = alloca i32, align 4
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %linenumber = getelementptr inbounds %struct.LexState.321* %0, i32 0, i32 1
  %1 = load i32* %linenumber, align 4
  store i32 %1, i32* %line, align 4
  %2 = load %struct.LexState.321** %ls.addr, align 8
  call void @enterlevel(%struct.LexState.321* %2)
  %3 = load %struct.LexState.321** %ls.addr, align 8
  %t = getelementptr inbounds %struct.LexState.321* %3, i32 0, i32 3
  %token = getelementptr inbounds %struct.Token* %t, i32 0, i32 0
  %4 = load i32* %token, align 4
  switch i32 %4, label %sw.default [
    i32 59, label %sw.bb
    i32 267, label %sw.bb1
    i32 278, label %sw.bb2
    i32 259, label %sw.bb3
    i32 264, label %sw.bb4
    i32 273, label %sw.bb5
    i32 265, label %sw.bb6
    i32 269, label %sw.bb7
    i32 285, label %sw.bb8
    i32 274, label %sw.bb10
    i32 258, label %sw.bb11
    i32 266, label %sw.bb11
  ]

sw.bb:                                            ; preds = %entry
  %5 = load %struct.LexState.321** %ls.addr, align 8
  call void bitcast (void (%struct.LexState.235*)* @luaX_next to void (%struct.LexState.321*)*)(%struct.LexState.321* %5)
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  %6 = load %struct.LexState.321** %ls.addr, align 8
  %7 = load i32* %line, align 4
  call void @ifstat(%struct.LexState.321* %6, i32 %7)
  br label %sw.epilog

sw.bb2:                                           ; preds = %entry
  %8 = load %struct.LexState.321** %ls.addr, align 8
  %9 = load i32* %line, align 4
  call void @whilestat(%struct.LexState.321* %8, i32 %9)
  br label %sw.epilog

sw.bb3:                                           ; preds = %entry
  %10 = load %struct.LexState.321** %ls.addr, align 8
  call void bitcast (void (%struct.LexState.235*)* @luaX_next to void (%struct.LexState.321*)*)(%struct.LexState.321* %10)
  %11 = load %struct.LexState.321** %ls.addr, align 8
  call void @block(%struct.LexState.321* %11)
  %12 = load %struct.LexState.321** %ls.addr, align 8
  %13 = load i32* %line, align 4
  call void @check_match(%struct.LexState.321* %12, i32 262, i32 259, i32 %13)
  br label %sw.epilog

sw.bb4:                                           ; preds = %entry
  %14 = load %struct.LexState.321** %ls.addr, align 8
  %15 = load i32* %line, align 4
  call void @forstat(%struct.LexState.321* %14, i32 %15)
  br label %sw.epilog

sw.bb5:                                           ; preds = %entry
  %16 = load %struct.LexState.321** %ls.addr, align 8
  %17 = load i32* %line, align 4
  call void @repeatstat(%struct.LexState.321* %16, i32 %17)
  br label %sw.epilog

sw.bb6:                                           ; preds = %entry
  %18 = load %struct.LexState.321** %ls.addr, align 8
  %19 = load i32* %line, align 4
  call void @funcstat(%struct.LexState.321* %18, i32 %19)
  br label %sw.epilog

sw.bb7:                                           ; preds = %entry
  %20 = load %struct.LexState.321** %ls.addr, align 8
  call void bitcast (void (%struct.LexState.235*)* @luaX_next to void (%struct.LexState.321*)*)(%struct.LexState.321* %20)
  %21 = load %struct.LexState.321** %ls.addr, align 8
  %call = call i32 @testnext(%struct.LexState.321* %21, i32 265)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb7
  %22 = load %struct.LexState.321** %ls.addr, align 8
  call void @localfunc(%struct.LexState.321* %22)
  br label %if.end

if.else:                                          ; preds = %sw.bb7
  %23 = load %struct.LexState.321** %ls.addr, align 8
  call void @localstat(%struct.LexState.321* %23)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  br label %sw.epilog

sw.bb8:                                           ; preds = %entry
  %24 = load %struct.LexState.321** %ls.addr, align 8
  call void bitcast (void (%struct.LexState.235*)* @luaX_next to void (%struct.LexState.321*)*)(%struct.LexState.321* %24)
  %25 = load %struct.LexState.321** %ls.addr, align 8
  %26 = load %struct.LexState.321** %ls.addr, align 8
  %call9 = call %union.TString.143* @str_checkname(%struct.LexState.321* %26)
  %27 = load i32* %line, align 4
  call void @labelstat(%struct.LexState.321* %25, %union.TString.143* %call9, i32 %27)
  br label %sw.epilog

sw.bb10:                                          ; preds = %entry
  %28 = load %struct.LexState.321** %ls.addr, align 8
  call void bitcast (void (%struct.LexState.235*)* @luaX_next to void (%struct.LexState.321*)*)(%struct.LexState.321* %28)
  %29 = load %struct.LexState.321** %ls.addr, align 8
  call void @retstat(%struct.LexState.321* %29)
  br label %sw.epilog

sw.bb11:                                          ; preds = %entry, %entry
  %30 = load %struct.LexState.321** %ls.addr, align 8
  %31 = load %struct.LexState.321** %ls.addr, align 8
  %fs = getelementptr inbounds %struct.LexState.321* %31, i32 0, i32 5
  %32 = load %struct.FuncState.320** %fs, align 8
  %call12 = call i32 bitcast (i32 (%struct.FuncState*)* @luaK_jump to i32 (%struct.FuncState.320*)*)(%struct.FuncState.320* %32)
  call void @gotostat(%struct.LexState.321* %30, i32 %call12)
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %33 = load %struct.LexState.321** %ls.addr, align 8
  call void @exprstat(%struct.LexState.321* %33)
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb11, %sw.bb10, %sw.bb8, %if.end, %sw.bb6, %sw.bb5, %sw.bb4, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb
  %34 = load %struct.LexState.321** %ls.addr, align 8
  %fs13 = getelementptr inbounds %struct.LexState.321* %34, i32 0, i32 5
  %35 = load %struct.FuncState.320** %fs13, align 8
  %nactvar = getelementptr inbounds %struct.FuncState.320* %35, i32 0, i32 12
  %36 = load i8* %nactvar, align 1
  %37 = load %struct.LexState.321** %ls.addr, align 8
  %fs14 = getelementptr inbounds %struct.LexState.321* %37, i32 0, i32 5
  %38 = load %struct.FuncState.320** %fs14, align 8
  %freereg = getelementptr inbounds %struct.FuncState.320* %38, i32 0, i32 14
  store i8 %36, i8* %freereg, align 1
  %39 = load %struct.LexState.321** %ls.addr, align 8
  %L = getelementptr inbounds %struct.LexState.321* %39, i32 0, i32 6
  %40 = load %struct.lua_State.154** %L, align 8
  %nCcalls = getelementptr inbounds %struct.lua_State.154* %40, i32 0, i32 12
  %41 = load i16* %nCcalls, align 2
  %dec = add i16 %41, -1
  store i16 %dec, i16* %nCcalls, align 2
  ret void
}

; Function Attrs: noreturn nounwind uwtable
define internal void @error_expected(%struct.LexState.321* %ls, i32 %token) #6 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %token.addr = alloca i32, align 4
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store i32 %token, i32* %token.addr, align 4
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %1 = load %struct.LexState.321** %ls.addr, align 8
  %L = getelementptr inbounds %struct.LexState.321* %1, i32 0, i32 6
  %2 = load %struct.lua_State.154** %L, align 8
  %3 = load %struct.LexState.321** %ls.addr, align 8
  %4 = load i32* %token.addr, align 4
  %call = call i8* bitcast (i8* (%struct.LexState.235*, i32)* @luaX_token2str to i8* (%struct.LexState.321*, i32)*)(%struct.LexState.321* %3, i32 %4)
  %call1 = call i8* (%struct.lua_State.154*, i8*, ...)* bitcast (i8* (%struct.lua_State.279*, i8*, ...)* @luaO_pushfstring to i8* (%struct.lua_State.154*, i8*, ...)*)(%struct.lua_State.154* %2, i8* getelementptr inbounds ([12 x i8]* @.str5606, i32 0, i32 0), i8* %call)
  call void bitcast (void (%struct.LexState.235*, i8*)* @luaX_syntaxerror to void (%struct.LexState.321*, i8*)*)(%struct.LexState.321* %0, i8* %call1) #9
  unreachable

return:                                           ; No predecessors!
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @leaveblock(%struct.FuncState.320* %fs) #0 {
entry:
  %fs.addr = alloca %struct.FuncState.320*, align 8
  %bl = alloca %struct.BlockCnt*, align 8
  %ls = alloca %struct.LexState.321*, align 8
  %j = alloca i32, align 4
  store %struct.FuncState.320* %fs, %struct.FuncState.320** %fs.addr, align 8
  %0 = load %struct.FuncState.320** %fs.addr, align 8
  %bl1 = getelementptr inbounds %struct.FuncState.320* %0, i32 0, i32 4
  %1 = load %struct.BlockCnt** %bl1, align 8
  store %struct.BlockCnt* %1, %struct.BlockCnt** %bl, align 8
  %2 = load %struct.FuncState.320** %fs.addr, align 8
  %ls2 = getelementptr inbounds %struct.FuncState.320* %2, i32 0, i32 3
  %3 = load %struct.LexState.321** %ls2, align 8
  store %struct.LexState.321* %3, %struct.LexState.321** %ls, align 8
  %4 = load %struct.BlockCnt** %bl, align 8
  %previous = getelementptr inbounds %struct.BlockCnt* %4, i32 0, i32 0
  %5 = load %struct.BlockCnt** %previous, align 8
  %tobool = icmp ne %struct.BlockCnt* %5, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %6 = load %struct.BlockCnt** %bl, align 8
  %upval = getelementptr inbounds %struct.BlockCnt* %6, i32 0, i32 4
  %7 = load i8* %upval, align 1
  %conv = zext i8 %7 to i32
  %tobool3 = icmp ne i32 %conv, 0
  br i1 %tobool3, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %8 = load %struct.FuncState.320** %fs.addr, align 8
  %call = call i32 bitcast (i32 (%struct.FuncState*)* @luaK_jump to i32 (%struct.FuncState.320*)*)(%struct.FuncState.320* %8)
  store i32 %call, i32* %j, align 4
  %9 = load %struct.FuncState.320** %fs.addr, align 8
  %10 = load i32* %j, align 4
  %11 = load %struct.BlockCnt** %bl, align 8
  %nactvar = getelementptr inbounds %struct.BlockCnt* %11, i32 0, i32 3
  %12 = load i8* %nactvar, align 1
  %conv4 = zext i8 %12 to i32
  call void bitcast (void (%struct.FuncState*, i32, i32)* @luaK_patchclose to void (%struct.FuncState.320*, i32, i32)*)(%struct.FuncState.320* %9, i32 %10, i32 %conv4)
  %13 = load %struct.FuncState.320** %fs.addr, align 8
  %14 = load i32* %j, align 4
  call void bitcast (void (%struct.FuncState*, i32)* @luaK_patchtohere to void (%struct.FuncState.320*, i32)*)(%struct.FuncState.320* %13, i32 %14)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %15 = load %struct.BlockCnt** %bl, align 8
  %isloop = getelementptr inbounds %struct.BlockCnt* %15, i32 0, i32 5
  %16 = load i8* %isloop, align 1
  %tobool5 = icmp ne i8 %16, 0
  br i1 %tobool5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  %17 = load %struct.LexState.321** %ls, align 8
  call void @breaklabel(%struct.LexState.321* %17)
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %if.end
  %18 = load %struct.BlockCnt** %bl, align 8
  %previous8 = getelementptr inbounds %struct.BlockCnt* %18, i32 0, i32 0
  %19 = load %struct.BlockCnt** %previous8, align 8
  %20 = load %struct.FuncState.320** %fs.addr, align 8
  %bl9 = getelementptr inbounds %struct.FuncState.320* %20, i32 0, i32 4
  store %struct.BlockCnt* %19, %struct.BlockCnt** %bl9, align 8
  %21 = load %struct.FuncState.320** %fs.addr, align 8
  %22 = load %struct.BlockCnt** %bl, align 8
  %nactvar10 = getelementptr inbounds %struct.BlockCnt* %22, i32 0, i32 3
  %23 = load i8* %nactvar10, align 1
  %conv11 = zext i8 %23 to i32
  call void @removevars(%struct.FuncState.320* %21, i32 %conv11)
  %24 = load %struct.FuncState.320** %fs.addr, align 8
  %nactvar12 = getelementptr inbounds %struct.FuncState.320* %24, i32 0, i32 12
  %25 = load i8* %nactvar12, align 1
  %26 = load %struct.FuncState.320** %fs.addr, align 8
  %freereg = getelementptr inbounds %struct.FuncState.320* %26, i32 0, i32 14
  store i8 %25, i8* %freereg, align 1
  %27 = load %struct.BlockCnt** %bl, align 8
  %firstlabel = getelementptr inbounds %struct.BlockCnt* %27, i32 0, i32 1
  %28 = load i16* %firstlabel, align 2
  %conv13 = sext i16 %28 to i32
  %29 = load %struct.LexState.321** %ls, align 8
  %dyd = getelementptr inbounds %struct.LexState.321* %29, i32 0, i32 9
  %30 = load %struct.Dyndata.313** %dyd, align 8
  %label = getelementptr inbounds %struct.Dyndata.313* %30, i32 0, i32 2
  %n = getelementptr inbounds %struct.Labellist.312* %label, i32 0, i32 1
  store i32 %conv13, i32* %n, align 4
  %31 = load %struct.BlockCnt** %bl, align 8
  %previous14 = getelementptr inbounds %struct.BlockCnt* %31, i32 0, i32 0
  %32 = load %struct.BlockCnt** %previous14, align 8
  %tobool15 = icmp ne %struct.BlockCnt* %32, null
  br i1 %tobool15, label %if.then16, label %if.else

if.then16:                                        ; preds = %if.end7
  %33 = load %struct.FuncState.320** %fs.addr, align 8
  %34 = load %struct.BlockCnt** %bl, align 8
  call void @movegotosout(%struct.FuncState.320* %33, %struct.BlockCnt* %34)
  br label %if.end26

if.else:                                          ; preds = %if.end7
  %35 = load %struct.BlockCnt** %bl, align 8
  %firstgoto = getelementptr inbounds %struct.BlockCnt* %35, i32 0, i32 2
  %36 = load i16* %firstgoto, align 2
  %conv17 = sext i16 %36 to i32
  %37 = load %struct.LexState.321** %ls, align 8
  %dyd18 = getelementptr inbounds %struct.LexState.321* %37, i32 0, i32 9
  %38 = load %struct.Dyndata.313** %dyd18, align 8
  %gt = getelementptr inbounds %struct.Dyndata.313* %38, i32 0, i32 1
  %n19 = getelementptr inbounds %struct.Labellist.312* %gt, i32 0, i32 1
  %39 = load i32* %n19, align 4
  %cmp = icmp slt i32 %conv17, %39
  br i1 %cmp, label %if.then21, label %if.end25

if.then21:                                        ; preds = %if.else
  %40 = load %struct.LexState.321** %ls, align 8
  %41 = load %struct.BlockCnt** %bl, align 8
  %firstgoto22 = getelementptr inbounds %struct.BlockCnt* %41, i32 0, i32 2
  %42 = load i16* %firstgoto22, align 2
  %idxprom = sext i16 %42 to i64
  %43 = load %struct.LexState.321** %ls, align 8
  %dyd23 = getelementptr inbounds %struct.LexState.321* %43, i32 0, i32 9
  %44 = load %struct.Dyndata.313** %dyd23, align 8
  %gt24 = getelementptr inbounds %struct.Dyndata.313* %44, i32 0, i32 1
  %arr = getelementptr inbounds %struct.Labellist.312* %gt24, i32 0, i32 0
  %45 = load %struct.Labeldesc.311** %arr, align 8
  %arrayidx = getelementptr inbounds %struct.Labeldesc.311* %45, i64 %idxprom
  call void @undefgoto(%struct.LexState.321* %40, %struct.Labeldesc.311* %arrayidx) #9
  unreachable

if.end25:                                         ; preds = %if.else
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %if.then16
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @anchor_token(%struct.LexState.321* %ls) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %ts = alloca %union.TString.143*, align 8
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %t = getelementptr inbounds %struct.LexState.321* %0, i32 0, i32 3
  %token = getelementptr inbounds %struct.Token* %t, i32 0, i32 0
  %1 = load i32* %token, align 4
  %cmp = icmp eq i32 %1, 288
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load %struct.LexState.321** %ls.addr, align 8
  %t1 = getelementptr inbounds %struct.LexState.321* %2, i32 0, i32 3
  %token2 = getelementptr inbounds %struct.Token* %t1, i32 0, i32 0
  %3 = load i32* %token2, align 4
  %cmp3 = icmp eq i32 %3, 289
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %4 = load %struct.LexState.321** %ls.addr, align 8
  %t4 = getelementptr inbounds %struct.LexState.321* %4, i32 0, i32 3
  %seminfo = getelementptr inbounds %struct.Token* %t4, i32 0, i32 1
  %ts5 = bitcast %union.SemInfo* %seminfo to %union.TString.143**
  %5 = load %union.TString.143** %ts5, align 8
  store %union.TString.143* %5, %union.TString.143** %ts, align 8
  %6 = load %struct.LexState.321** %ls.addr, align 8
  %7 = load %union.TString.143** %ts, align 8
  %add.ptr = getelementptr inbounds %union.TString.143* %7, i64 1
  %8 = bitcast %union.TString.143* %add.ptr to i8*
  %9 = load %union.TString.143** %ts, align 8
  %tsv = bitcast %union.TString.143* %9 to %struct.anon.0.142*
  %len = getelementptr inbounds %struct.anon.0.142* %tsv, i32 0, i32 5
  %10 = load i64* %len, align 8
  %call = call %union.TString.143* bitcast (%union.TString* (%struct.LexState.235*, i8*, i64)* @luaX_newstring to %union.TString.143* (%struct.LexState.321*, i8*, i64)*)(%struct.LexState.321* %6, i8* %8, i64 %10)
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  ret void
}

; Function Attrs: noreturn nounwind uwtable
define internal void @errorlimit(%struct.FuncState.320* %fs, i32 %limit, i8* %what) #6 {
entry:
  %fs.addr = alloca %struct.FuncState.320*, align 8
  %limit.addr = alloca i32, align 4
  %what.addr = alloca i8*, align 8
  %L = alloca %struct.lua_State.154*, align 8
  %msg = alloca i8*, align 8
  %line = alloca i32, align 4
  %where = alloca i8*, align 8
  store %struct.FuncState.320* %fs, %struct.FuncState.320** %fs.addr, align 8
  store i32 %limit, i32* %limit.addr, align 4
  store i8* %what, i8** %what.addr, align 8
  %0 = load %struct.FuncState.320** %fs.addr, align 8
  %ls = getelementptr inbounds %struct.FuncState.320* %0, i32 0, i32 3
  %1 = load %struct.LexState.321** %ls, align 8
  %L1 = getelementptr inbounds %struct.LexState.321* %1, i32 0, i32 6
  %2 = load %struct.lua_State.154** %L1, align 8
  store %struct.lua_State.154* %2, %struct.lua_State.154** %L, align 8
  %3 = load %struct.FuncState.320** %fs.addr, align 8
  %f = getelementptr inbounds %struct.FuncState.320* %3, i32 0, i32 0
  %4 = load %struct.Proto.160** %f, align 8
  %linedefined = getelementptr inbounds %struct.Proto.160* %4, i32 0, i32 17
  %5 = load i32* %linedefined, align 4
  store i32 %5, i32* %line, align 4
  %6 = load i32* %line, align 4
  %cmp = icmp eq i32 %6, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %7 = load %struct.lua_State.154** %L, align 8
  %8 = load i32* %line, align 4
  %call = call i8* (%struct.lua_State.154*, i8*, ...)* bitcast (i8* (%struct.lua_State.279*, i8*, ...)* @luaO_pushfstring to i8* (%struct.lua_State.154*, i8*, ...)*)(%struct.lua_State.154* %7, i8* getelementptr inbounds ([20 x i8]* @.str15616, i32 0, i32 0), i32 %8)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ getelementptr inbounds ([14 x i8]* @.str14615, i32 0, i32 0), %cond.true ], [ %call, %cond.false ]
  store i8* %cond, i8** %where, align 8
  %9 = load %struct.lua_State.154** %L, align 8
  %10 = load i8** %what.addr, align 8
  %11 = load i32* %limit.addr, align 4
  %12 = load i8** %where, align 8
  %call2 = call i8* (%struct.lua_State.154*, i8*, ...)* bitcast (i8* (%struct.lua_State.279*, i8*, ...)* @luaO_pushfstring to i8* (%struct.lua_State.154*, i8*, ...)*)(%struct.lua_State.154* %9, i8* getelementptr inbounds ([32 x i8]* @.str16617, i32 0, i32 0), i8* %10, i32 %11, i8* %12)
  store i8* %call2, i8** %msg, align 8
  %13 = load %struct.FuncState.320** %fs.addr, align 8
  %ls3 = getelementptr inbounds %struct.FuncState.320* %13, i32 0, i32 3
  %14 = load %struct.LexState.321** %ls3, align 8
  %15 = load i8** %msg, align 8
  call void bitcast (void (%struct.LexState.235*, i8*)* @luaX_syntaxerror to void (%struct.LexState.321*, i8*)*)(%struct.LexState.321* %14, i8* %15) #9
  unreachable

return:                                           ; No predecessors!
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @enterlevel(%struct.LexState.321* %ls) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %L = alloca %struct.lua_State.154*, align 8
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %L1 = getelementptr inbounds %struct.LexState.321* %0, i32 0, i32 6
  %1 = load %struct.lua_State.154** %L1, align 8
  store %struct.lua_State.154* %1, %struct.lua_State.154** %L, align 8
  %2 = load %struct.lua_State.154** %L, align 8
  %nCcalls = getelementptr inbounds %struct.lua_State.154* %2, i32 0, i32 12
  %3 = load i16* %nCcalls, align 2
  %inc = add i16 %3, 1
  store i16 %inc, i16* %nCcalls, align 2
  %4 = load %struct.LexState.321** %ls.addr, align 8
  %fs = getelementptr inbounds %struct.LexState.321* %4, i32 0, i32 5
  %5 = load %struct.FuncState.320** %fs, align 8
  %6 = load %struct.lua_State.154** %L, align 8
  %nCcalls2 = getelementptr inbounds %struct.lua_State.154* %6, i32 0, i32 12
  %7 = load i16* %nCcalls2, align 2
  %conv = zext i16 %7 to i32
  call void @checklimit(%struct.FuncState.320* %5, i32 %conv, i32 200, i8* getelementptr inbounds ([9 x i8]* @.str7608, i32 0, i32 0))
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @ifstat(%struct.LexState.321* %ls, i32 %line) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %line.addr = alloca i32, align 4
  %fs = alloca %struct.FuncState.320*, align 8
  %escapelist = alloca i32, align 4
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store i32 %line, i32* %line.addr, align 4
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %fs1 = getelementptr inbounds %struct.LexState.321* %0, i32 0, i32 5
  %1 = load %struct.FuncState.320** %fs1, align 8
  store %struct.FuncState.320* %1, %struct.FuncState.320** %fs, align 8
  store i32 -1, i32* %escapelist, align 4
  %2 = load %struct.LexState.321** %ls.addr, align 8
  call void @test_then_block(%struct.LexState.321* %2, i32* %escapelist)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %3 = load %struct.LexState.321** %ls.addr, align 8
  %t = getelementptr inbounds %struct.LexState.321* %3, i32 0, i32 3
  %token = getelementptr inbounds %struct.Token* %t, i32 0, i32 0
  %4 = load i32* %token, align 4
  %cmp = icmp eq i32 %4, 261
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %5 = load %struct.LexState.321** %ls.addr, align 8
  call void @test_then_block(%struct.LexState.321* %5, i32* %escapelist)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %6 = load %struct.LexState.321** %ls.addr, align 8
  %call = call i32 @testnext(%struct.LexState.321* %6, i32 260)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %while.end
  %7 = load %struct.LexState.321** %ls.addr, align 8
  call void @block(%struct.LexState.321* %7)
  br label %if.end

if.end:                                           ; preds = %if.then, %while.end
  %8 = load %struct.LexState.321** %ls.addr, align 8
  %9 = load i32* %line.addr, align 4
  call void @check_match(%struct.LexState.321* %8, i32 262, i32 267, i32 %9)
  %10 = load %struct.FuncState.320** %fs, align 8
  %11 = load i32* %escapelist, align 4
  call void bitcast (void (%struct.FuncState*, i32)* @luaK_patchtohere to void (%struct.FuncState.320*, i32)*)(%struct.FuncState.320* %10, i32 %11)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @whilestat(%struct.LexState.321* %ls, i32 %line) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %line.addr = alloca i32, align 4
  %fs = alloca %struct.FuncState.320*, align 8
  %whileinit = alloca i32, align 4
  %condexit = alloca i32, align 4
  %bl = alloca %struct.BlockCnt, align 8
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store i32 %line, i32* %line.addr, align 4
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %fs1 = getelementptr inbounds %struct.LexState.321* %0, i32 0, i32 5
  %1 = load %struct.FuncState.320** %fs1, align 8
  store %struct.FuncState.320* %1, %struct.FuncState.320** %fs, align 8
  %2 = load %struct.LexState.321** %ls.addr, align 8
  call void bitcast (void (%struct.LexState.235*)* @luaX_next to void (%struct.LexState.321*)*)(%struct.LexState.321* %2)
  %3 = load %struct.FuncState.320** %fs, align 8
  %call = call i32 bitcast (i32 (%struct.FuncState*)* @luaK_getlabel to i32 (%struct.FuncState.320*)*)(%struct.FuncState.320* %3)
  store i32 %call, i32* %whileinit, align 4
  %4 = load %struct.LexState.321** %ls.addr, align 8
  %call2 = call i32 @cond(%struct.LexState.321* %4)
  store i32 %call2, i32* %condexit, align 4
  %5 = load %struct.FuncState.320** %fs, align 8
  call void @enterblock(%struct.FuncState.320* %5, %struct.BlockCnt* %bl, i8 zeroext 1)
  %6 = load %struct.LexState.321** %ls.addr, align 8
  call void @checknext(%struct.LexState.321* %6, i32 259)
  %7 = load %struct.LexState.321** %ls.addr, align 8
  call void @block(%struct.LexState.321* %7)
  %8 = load %struct.FuncState.320** %fs, align 8
  %9 = load %struct.FuncState.320** %fs, align 8
  %call3 = call i32 bitcast (i32 (%struct.FuncState*)* @luaK_jump to i32 (%struct.FuncState.320*)*)(%struct.FuncState.320* %9)
  %10 = load i32* %whileinit, align 4
  call void bitcast (void (%struct.FuncState*, i32, i32)* @luaK_patchlist to void (%struct.FuncState.320*, i32, i32)*)(%struct.FuncState.320* %8, i32 %call3, i32 %10)
  %11 = load %struct.LexState.321** %ls.addr, align 8
  %12 = load i32* %line.addr, align 4
  call void @check_match(%struct.LexState.321* %11, i32 262, i32 278, i32 %12)
  %13 = load %struct.FuncState.320** %fs, align 8
  call void @leaveblock(%struct.FuncState.320* %13)
  %14 = load %struct.FuncState.320** %fs, align 8
  %15 = load i32* %condexit, align 4
  call void bitcast (void (%struct.FuncState*, i32)* @luaK_patchtohere to void (%struct.FuncState.320*, i32)*)(%struct.FuncState.320* %14, i32 %15)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @block(%struct.LexState.321* %ls) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %fs = alloca %struct.FuncState.320*, align 8
  %bl = alloca %struct.BlockCnt, align 8
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %fs1 = getelementptr inbounds %struct.LexState.321* %0, i32 0, i32 5
  %1 = load %struct.FuncState.320** %fs1, align 8
  store %struct.FuncState.320* %1, %struct.FuncState.320** %fs, align 8
  %2 = load %struct.FuncState.320** %fs, align 8
  call void @enterblock(%struct.FuncState.320* %2, %struct.BlockCnt* %bl, i8 zeroext 0)
  %3 = load %struct.LexState.321** %ls.addr, align 8
  call void @statlist(%struct.LexState.321* %3)
  %4 = load %struct.FuncState.320** %fs, align 8
  call void @leaveblock(%struct.FuncState.320* %4)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @check_match(%struct.LexState.321* %ls, i32 %what, i32 %who, i32 %where) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %what.addr = alloca i32, align 4
  %who.addr = alloca i32, align 4
  %where.addr = alloca i32, align 4
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store i32 %what, i32* %what.addr, align 4
  store i32 %who, i32* %who.addr, align 4
  store i32 %where, i32* %where.addr, align 4
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %1 = load i32* %what.addr, align 4
  %call = call i32 @testnext(%struct.LexState.321* %0, i32 %1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32* %where.addr, align 4
  %3 = load %struct.LexState.321** %ls.addr, align 8
  %linenumber = getelementptr inbounds %struct.LexState.321* %3, i32 0, i32 1
  %4 = load i32* %linenumber, align 4
  %cmp = icmp eq i32 %2, %4
  br i1 %cmp, label %if.then1, label %if.else

if.then1:                                         ; preds = %if.then
  %5 = load %struct.LexState.321** %ls.addr, align 8
  %6 = load i32* %what.addr, align 4
  call void @error_expected(%struct.LexState.321* %5, i32 %6) #9
  unreachable

if.else:                                          ; preds = %if.then
  %7 = load %struct.LexState.321** %ls.addr, align 8
  %8 = load %struct.LexState.321** %ls.addr, align 8
  %L = getelementptr inbounds %struct.LexState.321* %8, i32 0, i32 6
  %9 = load %struct.lua_State.154** %L, align 8
  %10 = load %struct.LexState.321** %ls.addr, align 8
  %11 = load i32* %what.addr, align 4
  %call2 = call i8* bitcast (i8* (%struct.LexState.235*, i32)* @luaX_token2str to i8* (%struct.LexState.321*, i32)*)(%struct.LexState.321* %10, i32 %11)
  %12 = load %struct.LexState.321** %ls.addr, align 8
  %13 = load i32* %who.addr, align 4
  %call3 = call i8* bitcast (i8* (%struct.LexState.235*, i32)* @luaX_token2str to i8* (%struct.LexState.321*, i32)*)(%struct.LexState.321* %12, i32 %13)
  %14 = load i32* %where.addr, align 4
  %call4 = call i8* (%struct.lua_State.154*, i8*, ...)* bitcast (i8* (%struct.lua_State.279*, i8*, ...)* @luaO_pushfstring to i8* (%struct.lua_State.154*, i8*, ...)*)(%struct.lua_State.154* %9, i8* getelementptr inbounds ([37 x i8]* @.str27628, i32 0, i32 0), i8* %call2, i8* %call3, i32 %14)
  call void bitcast (void (%struct.LexState.235*, i8*)* @luaX_syntaxerror to void (%struct.LexState.321*, i8*)*)(%struct.LexState.321* %7, i8* %call4) #9
  unreachable

if.end:                                           ; preds = %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @forstat(%struct.LexState.321* %ls, i32 %line) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %line.addr = alloca i32, align 4
  %fs = alloca %struct.FuncState.320*, align 8
  %varname = alloca %union.TString.143*, align 8
  %bl = alloca %struct.BlockCnt, align 8
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store i32 %line, i32* %line.addr, align 4
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %fs1 = getelementptr inbounds %struct.LexState.321* %0, i32 0, i32 5
  %1 = load %struct.FuncState.320** %fs1, align 8
  store %struct.FuncState.320* %1, %struct.FuncState.320** %fs, align 8
  %2 = load %struct.FuncState.320** %fs, align 8
  call void @enterblock(%struct.FuncState.320* %2, %struct.BlockCnt* %bl, i8 zeroext 1)
  %3 = load %struct.LexState.321** %ls.addr, align 8
  call void bitcast (void (%struct.LexState.235*)* @luaX_next to void (%struct.LexState.321*)*)(%struct.LexState.321* %3)
  %4 = load %struct.LexState.321** %ls.addr, align 8
  %call = call %union.TString.143* @str_checkname(%struct.LexState.321* %4)
  store %union.TString.143* %call, %union.TString.143** %varname, align 8
  %5 = load %struct.LexState.321** %ls.addr, align 8
  %t = getelementptr inbounds %struct.LexState.321* %5, i32 0, i32 3
  %token = getelementptr inbounds %struct.Token* %t, i32 0, i32 0
  %6 = load i32* %token, align 4
  switch i32 %6, label %sw.default [
    i32 61, label %sw.bb
    i32 44, label %sw.bb2
    i32 268, label %sw.bb2
  ]

sw.bb:                                            ; preds = %entry
  %7 = load %struct.LexState.321** %ls.addr, align 8
  %8 = load %union.TString.143** %varname, align 8
  %9 = load i32* %line.addr, align 4
  call void @fornum(%struct.LexState.321* %7, %union.TString.143* %8, i32 %9)
  br label %sw.epilog

sw.bb2:                                           ; preds = %entry, %entry
  %10 = load %struct.LexState.321** %ls.addr, align 8
  %11 = load %union.TString.143** %varname, align 8
  call void @forlist(%struct.LexState.321* %10, %union.TString.143* %11)
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %12 = load %struct.LexState.321** %ls.addr, align 8
  call void bitcast (void (%struct.LexState.235*, i8*)* @luaX_syntaxerror to void (%struct.LexState.321*, i8*)*)(%struct.LexState.321* %12, i8* getelementptr inbounds ([21 x i8]* @.str20621, i32 0, i32 0)) #9
  unreachable

sw.epilog:                                        ; preds = %sw.bb2, %sw.bb
  %13 = load %struct.LexState.321** %ls.addr, align 8
  %14 = load i32* %line.addr, align 4
  call void @check_match(%struct.LexState.321* %13, i32 262, i32 264, i32 %14)
  %15 = load %struct.FuncState.320** %fs, align 8
  call void @leaveblock(%struct.FuncState.320* %15)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @repeatstat(%struct.LexState.321* %ls, i32 %line) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %line.addr = alloca i32, align 4
  %condexit = alloca i32, align 4
  %fs = alloca %struct.FuncState.320*, align 8
  %repeat_init = alloca i32, align 4
  %bl1 = alloca %struct.BlockCnt, align 8
  %bl2 = alloca %struct.BlockCnt, align 8
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store i32 %line, i32* %line.addr, align 4
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %fs1 = getelementptr inbounds %struct.LexState.321* %0, i32 0, i32 5
  %1 = load %struct.FuncState.320** %fs1, align 8
  store %struct.FuncState.320* %1, %struct.FuncState.320** %fs, align 8
  %2 = load %struct.FuncState.320** %fs, align 8
  %call = call i32 bitcast (i32 (%struct.FuncState*)* @luaK_getlabel to i32 (%struct.FuncState.320*)*)(%struct.FuncState.320* %2)
  store i32 %call, i32* %repeat_init, align 4
  %3 = load %struct.FuncState.320** %fs, align 8
  call void @enterblock(%struct.FuncState.320* %3, %struct.BlockCnt* %bl1, i8 zeroext 1)
  %4 = load %struct.FuncState.320** %fs, align 8
  call void @enterblock(%struct.FuncState.320* %4, %struct.BlockCnt* %bl2, i8 zeroext 0)
  %5 = load %struct.LexState.321** %ls.addr, align 8
  call void bitcast (void (%struct.LexState.235*)* @luaX_next to void (%struct.LexState.321*)*)(%struct.LexState.321* %5)
  %6 = load %struct.LexState.321** %ls.addr, align 8
  call void @statlist(%struct.LexState.321* %6)
  %7 = load %struct.LexState.321** %ls.addr, align 8
  %8 = load i32* %line.addr, align 4
  call void @check_match(%struct.LexState.321* %7, i32 277, i32 273, i32 %8)
  %9 = load %struct.LexState.321** %ls.addr, align 8
  %call2 = call i32 @cond(%struct.LexState.321* %9)
  store i32 %call2, i32* %condexit, align 4
  %upval = getelementptr inbounds %struct.BlockCnt* %bl2, i32 0, i32 4
  %10 = load i8* %upval, align 1
  %tobool = icmp ne i8 %10, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %11 = load %struct.FuncState.320** %fs, align 8
  %12 = load i32* %condexit, align 4
  %nactvar = getelementptr inbounds %struct.BlockCnt* %bl2, i32 0, i32 3
  %13 = load i8* %nactvar, align 1
  %conv = zext i8 %13 to i32
  call void bitcast (void (%struct.FuncState*, i32, i32)* @luaK_patchclose to void (%struct.FuncState.320*, i32, i32)*)(%struct.FuncState.320* %11, i32 %12, i32 %conv)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %14 = load %struct.FuncState.320** %fs, align 8
  call void @leaveblock(%struct.FuncState.320* %14)
  %15 = load %struct.FuncState.320** %fs, align 8
  %16 = load i32* %condexit, align 4
  %17 = load i32* %repeat_init, align 4
  call void bitcast (void (%struct.FuncState*, i32, i32)* @luaK_patchlist to void (%struct.FuncState.320*, i32, i32)*)(%struct.FuncState.320* %15, i32 %16, i32 %17)
  %18 = load %struct.FuncState.320** %fs, align 8
  call void @leaveblock(%struct.FuncState.320* %18)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @funcstat(%struct.LexState.321* %ls, i32 %line) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %line.addr = alloca i32, align 4
  %ismethod = alloca i32, align 4
  %v = alloca %struct.expdesc, align 8
  %b = alloca %struct.expdesc, align 8
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store i32 %line, i32* %line.addr, align 4
  %0 = load %struct.LexState.321** %ls.addr, align 8
  call void bitcast (void (%struct.LexState.235*)* @luaX_next to void (%struct.LexState.321*)*)(%struct.LexState.321* %0)
  %1 = load %struct.LexState.321** %ls.addr, align 8
  %call = call i32 @funcname(%struct.LexState.321* %1, %struct.expdesc* %v)
  store i32 %call, i32* %ismethod, align 4
  %2 = load %struct.LexState.321** %ls.addr, align 8
  %3 = load i32* %ismethod, align 4
  %4 = load i32* %line.addr, align 4
  call void @body(%struct.LexState.321* %2, %struct.expdesc* %b, i32 %3, i32 %4)
  %5 = load %struct.LexState.321** %ls.addr, align 8
  %fs = getelementptr inbounds %struct.LexState.321* %5, i32 0, i32 5
  %6 = load %struct.FuncState.320** %fs, align 8
  call void bitcast (void (%struct.FuncState*, %struct.expdesc*, %struct.expdesc*)* @luaK_storevar to void (%struct.FuncState.320*, %struct.expdesc*, %struct.expdesc*)*)(%struct.FuncState.320* %6, %struct.expdesc* %v, %struct.expdesc* %b)
  %7 = load %struct.LexState.321** %ls.addr, align 8
  %fs1 = getelementptr inbounds %struct.LexState.321* %7, i32 0, i32 5
  %8 = load %struct.FuncState.320** %fs1, align 8
  %9 = load i32* %line.addr, align 4
  call void bitcast (void (%struct.FuncState*, i32)* @luaK_fixline to void (%struct.FuncState.320*, i32)*)(%struct.FuncState.320* %8, i32 %9)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @testnext(%struct.LexState.321* %ls, i32 %c) #0 {
entry:
  %retval = alloca i32, align 4
  %ls.addr = alloca %struct.LexState.321*, align 8
  %c.addr = alloca i32, align 4
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store i32 %c, i32* %c.addr, align 4
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %t = getelementptr inbounds %struct.LexState.321* %0, i32 0, i32 3
  %token = getelementptr inbounds %struct.Token* %t, i32 0, i32 0
  %1 = load i32* %token, align 4
  %2 = load i32* %c.addr, align 4
  %cmp = icmp eq i32 %1, %2
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load %struct.LexState.321** %ls.addr, align 8
  call void bitcast (void (%struct.LexState.235*)* @luaX_next to void (%struct.LexState.321*)*)(%struct.LexState.321* %3)
  store i32 1, i32* %retval
  br label %return

if.else:                                          ; preds = %entry
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %4 = load i32* %retval
  ret i32 %4
}

; Function Attrs: nounwind uwtable
define internal void @localfunc(%struct.LexState.321* %ls) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %b = alloca %struct.expdesc, align 8
  %fs = alloca %struct.FuncState.320*, align 8
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %fs1 = getelementptr inbounds %struct.LexState.321* %0, i32 0, i32 5
  %1 = load %struct.FuncState.320** %fs1, align 8
  store %struct.FuncState.320* %1, %struct.FuncState.320** %fs, align 8
  %2 = load %struct.LexState.321** %ls.addr, align 8
  %3 = load %struct.LexState.321** %ls.addr, align 8
  %call = call %union.TString.143* @str_checkname(%struct.LexState.321* %3)
  call void @new_localvar(%struct.LexState.321* %2, %union.TString.143* %call)
  %4 = load %struct.LexState.321** %ls.addr, align 8
  call void @adjustlocalvars(%struct.LexState.321* %4, i32 1)
  %5 = load %struct.LexState.321** %ls.addr, align 8
  %6 = load %struct.LexState.321** %ls.addr, align 8
  %linenumber = getelementptr inbounds %struct.LexState.321* %6, i32 0, i32 1
  %7 = load i32* %linenumber, align 4
  call void @body(%struct.LexState.321* %5, %struct.expdesc* %b, i32 0, i32 %7)
  %8 = load %struct.FuncState.320** %fs, align 8
  %pc = getelementptr inbounds %struct.FuncState.320* %8, i32 0, i32 5
  %9 = load i32* %pc, align 4
  %10 = load %struct.FuncState.320** %fs, align 8
  %u = getelementptr inbounds %struct.expdesc* %b, i32 0, i32 1
  %info = bitcast %union.anon.7* %u to i32*
  %11 = load i32* %info, align 4
  %call2 = call %struct.LocVar.158* @getlocvar(%struct.FuncState.320* %10, i32 %11)
  %startpc = getelementptr inbounds %struct.LocVar.158* %call2, i32 0, i32 1
  store i32 %9, i32* %startpc, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @localstat(%struct.LexState.321* %ls) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %nvars = alloca i32, align 4
  %nexps = alloca i32, align 4
  %e = alloca %struct.expdesc, align 8
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store i32 0, i32* %nvars, align 4
  br label %do.body

do.body:                                          ; preds = %do.cond, %entry
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %1 = load %struct.LexState.321** %ls.addr, align 8
  %call = call %union.TString.143* @str_checkname(%struct.LexState.321* %1)
  call void @new_localvar(%struct.LexState.321* %0, %union.TString.143* %call)
  %2 = load i32* %nvars, align 4
  %inc = add nsw i32 %2, 1
  store i32 %inc, i32* %nvars, align 4
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %3 = load %struct.LexState.321** %ls.addr, align 8
  %call1 = call i32 @testnext(%struct.LexState.321* %3, i32 44)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  %4 = load %struct.LexState.321** %ls.addr, align 8
  %call2 = call i32 @testnext(%struct.LexState.321* %4, i32 61)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.then, label %if.else

if.then:                                          ; preds = %do.end
  %5 = load %struct.LexState.321** %ls.addr, align 8
  %call4 = call i32 @explist(%struct.LexState.321* %5, %struct.expdesc* %e)
  store i32 %call4, i32* %nexps, align 4
  br label %if.end

if.else:                                          ; preds = %do.end
  %k = getelementptr inbounds %struct.expdesc* %e, i32 0, i32 0
  store i32 0, i32* %k, align 4
  store i32 0, i32* %nexps, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %6 = load %struct.LexState.321** %ls.addr, align 8
  %7 = load i32* %nvars, align 4
  %8 = load i32* %nexps, align 4
  call void @adjust_assign(%struct.LexState.321* %6, i32 %7, i32 %8, %struct.expdesc* %e)
  %9 = load %struct.LexState.321** %ls.addr, align 8
  %10 = load i32* %nvars, align 4
  call void @adjustlocalvars(%struct.LexState.321* %9, i32 %10)
  ret void
}

; Function Attrs: nounwind uwtable
define internal %union.TString.143* @str_checkname(%struct.LexState.321* %ls) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %ts = alloca %union.TString.143*, align 8
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  %0 = load %struct.LexState.321** %ls.addr, align 8
  call void @check(%struct.LexState.321* %0, i32 288)
  %1 = load %struct.LexState.321** %ls.addr, align 8
  %t = getelementptr inbounds %struct.LexState.321* %1, i32 0, i32 3
  %seminfo = getelementptr inbounds %struct.Token* %t, i32 0, i32 1
  %ts1 = bitcast %union.SemInfo* %seminfo to %union.TString.143**
  %2 = load %union.TString.143** %ts1, align 8
  store %union.TString.143* %2, %union.TString.143** %ts, align 8
  %3 = load %struct.LexState.321** %ls.addr, align 8
  call void bitcast (void (%struct.LexState.235*)* @luaX_next to void (%struct.LexState.321*)*)(%struct.LexState.321* %3)
  %4 = load %union.TString.143** %ts, align 8
  ret %union.TString.143* %4
}

; Function Attrs: nounwind uwtable
define internal void @labelstat(%struct.LexState.321* %ls, %union.TString.143* %label, i32 %line) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %label.addr = alloca %union.TString.143*, align 8
  %line.addr = alloca i32, align 4
  %fs = alloca %struct.FuncState.320*, align 8
  %ll = alloca %struct.Labellist.312*, align 8
  %l = alloca i32, align 4
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store %union.TString.143* %label, %union.TString.143** %label.addr, align 8
  store i32 %line, i32* %line.addr, align 4
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %fs1 = getelementptr inbounds %struct.LexState.321* %0, i32 0, i32 5
  %1 = load %struct.FuncState.320** %fs1, align 8
  store %struct.FuncState.320* %1, %struct.FuncState.320** %fs, align 8
  %2 = load %struct.LexState.321** %ls.addr, align 8
  %dyd = getelementptr inbounds %struct.LexState.321* %2, i32 0, i32 9
  %3 = load %struct.Dyndata.313** %dyd, align 8
  %label2 = getelementptr inbounds %struct.Dyndata.313* %3, i32 0, i32 2
  store %struct.Labellist.312* %label2, %struct.Labellist.312** %ll, align 8
  %4 = load %struct.FuncState.320** %fs, align 8
  %5 = load %struct.Labellist.312** %ll, align 8
  %6 = load %union.TString.143** %label.addr, align 8
  call void @checkrepeated(%struct.FuncState.320* %4, %struct.Labellist.312* %5, %union.TString.143* %6)
  %7 = load %struct.LexState.321** %ls.addr, align 8
  call void @checknext(%struct.LexState.321* %7, i32 285)
  %8 = load %struct.LexState.321** %ls.addr, align 8
  %9 = load %struct.Labellist.312** %ll, align 8
  %10 = load %union.TString.143** %label.addr, align 8
  %11 = load i32* %line.addr, align 4
  %12 = load %struct.FuncState.320** %fs, align 8
  %pc = getelementptr inbounds %struct.FuncState.320* %12, i32 0, i32 5
  %13 = load i32* %pc, align 4
  %call = call i32 @newlabelentry(%struct.LexState.321* %8, %struct.Labellist.312* %9, %union.TString.143* %10, i32 %11, i32 %13)
  store i32 %call, i32* %l, align 4
  %14 = load %struct.LexState.321** %ls.addr, align 8
  call void @skipnoopstat(%struct.LexState.321* %14)
  %15 = load %struct.LexState.321** %ls.addr, align 8
  %call3 = call i32 @block_follow(%struct.LexState.321* %15, i32 0)
  %tobool = icmp ne i32 %call3, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %16 = load %struct.FuncState.320** %fs, align 8
  %bl = getelementptr inbounds %struct.FuncState.320* %16, i32 0, i32 4
  %17 = load %struct.BlockCnt** %bl, align 8
  %nactvar = getelementptr inbounds %struct.BlockCnt* %17, i32 0, i32 3
  %18 = load i8* %nactvar, align 1
  %19 = load i32* %l, align 4
  %idxprom = sext i32 %19 to i64
  %20 = load %struct.Labellist.312** %ll, align 8
  %arr = getelementptr inbounds %struct.Labellist.312* %20, i32 0, i32 0
  %21 = load %struct.Labeldesc.311** %arr, align 8
  %arrayidx = getelementptr inbounds %struct.Labeldesc.311* %21, i64 %idxprom
  %nactvar4 = getelementptr inbounds %struct.Labeldesc.311* %arrayidx, i32 0, i32 3
  store i8 %18, i8* %nactvar4, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %22 = load %struct.LexState.321** %ls.addr, align 8
  %23 = load i32* %l, align 4
  %idxprom5 = sext i32 %23 to i64
  %24 = load %struct.Labellist.312** %ll, align 8
  %arr6 = getelementptr inbounds %struct.Labellist.312* %24, i32 0, i32 0
  %25 = load %struct.Labeldesc.311** %arr6, align 8
  %arrayidx7 = getelementptr inbounds %struct.Labeldesc.311* %25, i64 %idxprom5
  call void @findgotos(%struct.LexState.321* %22, %struct.Labeldesc.311* %arrayidx7)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @retstat(%struct.LexState.321* %ls) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %fs = alloca %struct.FuncState.320*, align 8
  %e = alloca %struct.expdesc, align 8
  %first = alloca i32, align 4
  %nret = alloca i32, align 4
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %fs1 = getelementptr inbounds %struct.LexState.321* %0, i32 0, i32 5
  %1 = load %struct.FuncState.320** %fs1, align 8
  store %struct.FuncState.320* %1, %struct.FuncState.320** %fs, align 8
  %2 = load %struct.LexState.321** %ls.addr, align 8
  %call = call i32 @block_follow(%struct.LexState.321* %2, i32 1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %3 = load %struct.LexState.321** %ls.addr, align 8
  %t = getelementptr inbounds %struct.LexState.321* %3, i32 0, i32 3
  %token = getelementptr inbounds %struct.Token* %t, i32 0, i32 0
  %4 = load i32* %token, align 4
  %cmp = icmp eq i32 %4, 59
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 0, i32* %nret, align 4
  store i32 0, i32* %first, align 4
  br label %if.end28

if.else:                                          ; preds = %lor.lhs.false
  %5 = load %struct.LexState.321** %ls.addr, align 8
  %call2 = call i32 @explist(%struct.LexState.321* %5, %struct.expdesc* %e)
  store i32 %call2, i32* %nret, align 4
  %k = getelementptr inbounds %struct.expdesc* %e, i32 0, i32 0
  %6 = load i32* %k, align 4
  %cmp3 = icmp eq i32 %6, 12
  br i1 %cmp3, label %if.then7, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %if.else
  %k5 = getelementptr inbounds %struct.expdesc* %e, i32 0, i32 0
  %7 = load i32* %k5, align 4
  %cmp6 = icmp eq i32 %7, 13
  br i1 %cmp6, label %if.then7, label %if.else18

if.then7:                                         ; preds = %lor.lhs.false4, %if.else
  %8 = load %struct.FuncState.320** %fs, align 8
  call void bitcast (void (%struct.FuncState*, %struct.expdesc*, i32)* @luaK_setreturns to void (%struct.FuncState.320*, %struct.expdesc*, i32)*)(%struct.FuncState.320* %8, %struct.expdesc* %e, i32 -1)
  %k8 = getelementptr inbounds %struct.expdesc* %e, i32 0, i32 0
  %9 = load i32* %k8, align 4
  %cmp9 = icmp eq i32 %9, 12
  br i1 %cmp9, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then7
  %10 = load i32* %nret, align 4
  %cmp10 = icmp eq i32 %10, 1
  br i1 %cmp10, label %if.then11, label %if.end

if.then11:                                        ; preds = %land.lhs.true
  %u = getelementptr inbounds %struct.expdesc* %e, i32 0, i32 1
  %info = bitcast %union.anon.7* %u to i32*
  %11 = load i32* %info, align 4
  %idxprom = sext i32 %11 to i64
  %12 = load %struct.FuncState.320** %fs, align 8
  %f = getelementptr inbounds %struct.FuncState.320* %12, i32 0, i32 0
  %13 = load %struct.Proto.160** %f, align 8
  %code = getelementptr inbounds %struct.Proto.160* %13, i32 0, i32 4
  %14 = load i32** %code, align 8
  %arrayidx = getelementptr inbounds i32* %14, i64 %idxprom
  %15 = load i32* %arrayidx, align 4
  %and = and i32 %15, -64
  %or = or i32 %and, 30
  %u12 = getelementptr inbounds %struct.expdesc* %e, i32 0, i32 1
  %info13 = bitcast %union.anon.7* %u12 to i32*
  %16 = load i32* %info13, align 4
  %idxprom14 = sext i32 %16 to i64
  %17 = load %struct.FuncState.320** %fs, align 8
  %f15 = getelementptr inbounds %struct.FuncState.320* %17, i32 0, i32 0
  %18 = load %struct.Proto.160** %f15, align 8
  %code16 = getelementptr inbounds %struct.Proto.160* %18, i32 0, i32 4
  %19 = load i32** %code16, align 8
  %arrayidx17 = getelementptr inbounds i32* %19, i64 %idxprom14
  store i32 %or, i32* %arrayidx17, align 4
  br label %if.end

if.end:                                           ; preds = %if.then11, %land.lhs.true, %if.then7
  %20 = load %struct.FuncState.320** %fs, align 8
  %nactvar = getelementptr inbounds %struct.FuncState.320* %20, i32 0, i32 12
  %21 = load i8* %nactvar, align 1
  %conv = zext i8 %21 to i32
  store i32 %conv, i32* %first, align 4
  store i32 -1, i32* %nret, align 4
  br label %if.end27

if.else18:                                        ; preds = %lor.lhs.false4
  %22 = load i32* %nret, align 4
  %cmp19 = icmp eq i32 %22, 1
  br i1 %cmp19, label %if.then21, label %if.else23

if.then21:                                        ; preds = %if.else18
  %23 = load %struct.FuncState.320** %fs, align 8
  %call22 = call i32 bitcast (i32 (%struct.FuncState*, %struct.expdesc*)* @luaK_exp2anyreg to i32 (%struct.FuncState.320*, %struct.expdesc*)*)(%struct.FuncState.320* %23, %struct.expdesc* %e)
  store i32 %call22, i32* %first, align 4
  br label %if.end26

if.else23:                                        ; preds = %if.else18
  %24 = load %struct.FuncState.320** %fs, align 8
  call void bitcast (void (%struct.FuncState*, %struct.expdesc*)* @luaK_exp2nextreg to void (%struct.FuncState.320*, %struct.expdesc*)*)(%struct.FuncState.320* %24, %struct.expdesc* %e)
  %25 = load %struct.FuncState.320** %fs, align 8
  %nactvar24 = getelementptr inbounds %struct.FuncState.320* %25, i32 0, i32 12
  %26 = load i8* %nactvar24, align 1
  %conv25 = zext i8 %26 to i32
  store i32 %conv25, i32* %first, align 4
  br label %if.end26

if.end26:                                         ; preds = %if.else23, %if.then21
  br label %if.end27

if.end27:                                         ; preds = %if.end26, %if.end
  br label %if.end28

if.end28:                                         ; preds = %if.end27, %if.then
  %27 = load %struct.FuncState.320** %fs, align 8
  %28 = load i32* %first, align 4
  %29 = load i32* %nret, align 4
  call void bitcast (void (%struct.FuncState*, i32, i32)* @luaK_ret to void (%struct.FuncState.320*, i32, i32)*)(%struct.FuncState.320* %27, i32 %28, i32 %29)
  %30 = load %struct.LexState.321** %ls.addr, align 8
  %call29 = call i32 @testnext(%struct.LexState.321* %30, i32 59)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @gotostat(%struct.LexState.321* %ls, i32 %pc) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %pc.addr = alloca i32, align 4
  %line = alloca i32, align 4
  %label = alloca %union.TString.143*, align 8
  %g = alloca i32, align 4
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store i32 %pc, i32* %pc.addr, align 4
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %linenumber = getelementptr inbounds %struct.LexState.321* %0, i32 0, i32 1
  %1 = load i32* %linenumber, align 4
  store i32 %1, i32* %line, align 4
  %2 = load %struct.LexState.321** %ls.addr, align 8
  %call = call i32 @testnext(%struct.LexState.321* %2, i32 266)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load %struct.LexState.321** %ls.addr, align 8
  %call1 = call %union.TString.143* @str_checkname(%struct.LexState.321* %3)
  store %union.TString.143* %call1, %union.TString.143** %label, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %4 = load %struct.LexState.321** %ls.addr, align 8
  call void bitcast (void (%struct.LexState.235*)* @luaX_next to void (%struct.LexState.321*)*)(%struct.LexState.321* %4)
  %5 = load %struct.LexState.321** %ls.addr, align 8
  %L = getelementptr inbounds %struct.LexState.321* %5, i32 0, i32 6
  %6 = load %struct.lua_State.154** %L, align 8
  %call2 = call %union.TString.143* bitcast (%union.TString.367* (%struct.lua_State.364*, i8*)* @luaS_new to %union.TString.143* (%struct.lua_State.154*, i8*)*)(%struct.lua_State.154* %6, i8* getelementptr inbounds ([6 x i8]* @.str3604, i32 0, i32 0))
  store %union.TString.143* %call2, %union.TString.143** %label, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %7 = load %struct.LexState.321** %ls.addr, align 8
  %8 = load %struct.LexState.321** %ls.addr, align 8
  %dyd = getelementptr inbounds %struct.LexState.321* %8, i32 0, i32 9
  %9 = load %struct.Dyndata.313** %dyd, align 8
  %gt = getelementptr inbounds %struct.Dyndata.313* %9, i32 0, i32 1
  %10 = load %union.TString.143** %label, align 8
  %11 = load i32* %line, align 4
  %12 = load i32* %pc.addr, align 4
  %call3 = call i32 @newlabelentry(%struct.LexState.321* %7, %struct.Labellist.312* %gt, %union.TString.143* %10, i32 %11, i32 %12)
  store i32 %call3, i32* %g, align 4
  %13 = load %struct.LexState.321** %ls.addr, align 8
  %14 = load i32* %g, align 4
  %call4 = call i32 @findlabel(%struct.LexState.321* %13, i32 %14)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @exprstat(%struct.LexState.321* %ls) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %fs = alloca %struct.FuncState.320*, align 8
  %v = alloca %struct.LHS_assign, align 8
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %fs1 = getelementptr inbounds %struct.LexState.321* %0, i32 0, i32 5
  %1 = load %struct.FuncState.320** %fs1, align 8
  store %struct.FuncState.320* %1, %struct.FuncState.320** %fs, align 8
  %2 = load %struct.LexState.321** %ls.addr, align 8
  %v2 = getelementptr inbounds %struct.LHS_assign* %v, i32 0, i32 1
  call void @suffixedexp(%struct.LexState.321* %2, %struct.expdesc* %v2)
  %3 = load %struct.LexState.321** %ls.addr, align 8
  %t = getelementptr inbounds %struct.LexState.321* %3, i32 0, i32 3
  %token = getelementptr inbounds %struct.Token* %t, i32 0, i32 0
  %4 = load i32* %token, align 4
  %cmp = icmp eq i32 %4, 61
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %5 = load %struct.LexState.321** %ls.addr, align 8
  %t3 = getelementptr inbounds %struct.LexState.321* %5, i32 0, i32 3
  %token4 = getelementptr inbounds %struct.Token* %t3, i32 0, i32 0
  %6 = load i32* %token4, align 4
  %cmp5 = icmp eq i32 %6, 44
  br i1 %cmp5, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  %prev = getelementptr inbounds %struct.LHS_assign* %v, i32 0, i32 0
  store %struct.LHS_assign* null, %struct.LHS_assign** %prev, align 8
  %7 = load %struct.LexState.321** %ls.addr, align 8
  call void @assignment(%struct.LexState.321* %7, %struct.LHS_assign* %v, i32 1)
  br label %if.end17

if.else:                                          ; preds = %lor.lhs.false
  %v6 = getelementptr inbounds %struct.LHS_assign* %v, i32 0, i32 1
  %k = getelementptr inbounds %struct.expdesc* %v6, i32 0, i32 0
  %8 = load i32* %k, align 4
  %cmp7 = icmp eq i32 %8, 12
  br i1 %cmp7, label %if.end, label %if.then8

if.then8:                                         ; preds = %if.else
  %9 = load %struct.LexState.321** %ls.addr, align 8
  call void bitcast (void (%struct.LexState.235*, i8*)* @luaX_syntaxerror to void (%struct.LexState.321*, i8*)*)(%struct.LexState.321* %9, i8* getelementptr inbounds ([13 x i8]* @.str6607, i32 0, i32 0)) #9
  unreachable

if.end:                                           ; preds = %if.else
  %v9 = getelementptr inbounds %struct.LHS_assign* %v, i32 0, i32 1
  %u = getelementptr inbounds %struct.expdesc* %v9, i32 0, i32 1
  %info = bitcast %union.anon.7* %u to i32*
  %10 = load i32* %info, align 4
  %idxprom = sext i32 %10 to i64
  %11 = load %struct.FuncState.320** %fs, align 8
  %f = getelementptr inbounds %struct.FuncState.320* %11, i32 0, i32 0
  %12 = load %struct.Proto.160** %f, align 8
  %code = getelementptr inbounds %struct.Proto.160* %12, i32 0, i32 4
  %13 = load i32** %code, align 8
  %arrayidx = getelementptr inbounds i32* %13, i64 %idxprom
  %14 = load i32* %arrayidx, align 4
  %and = and i32 %14, -8372225
  %or = or i32 %and, 16384
  %v10 = getelementptr inbounds %struct.LHS_assign* %v, i32 0, i32 1
  %u11 = getelementptr inbounds %struct.expdesc* %v10, i32 0, i32 1
  %info12 = bitcast %union.anon.7* %u11 to i32*
  %15 = load i32* %info12, align 4
  %idxprom13 = sext i32 %15 to i64
  %16 = load %struct.FuncState.320** %fs, align 8
  %f14 = getelementptr inbounds %struct.FuncState.320* %16, i32 0, i32 0
  %17 = load %struct.Proto.160** %f14, align 8
  %code15 = getelementptr inbounds %struct.Proto.160* %17, i32 0, i32 4
  %18 = load i32** %code15, align 8
  %arrayidx16 = getelementptr inbounds i32* %18, i64 %idxprom13
  store i32 %or, i32* %arrayidx16, align 4
  br label %if.end17

if.end17:                                         ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @breaklabel(%struct.LexState.321* %ls) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %n = alloca %union.TString.143*, align 8
  %l = alloca i32, align 4
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %L = getelementptr inbounds %struct.LexState.321* %0, i32 0, i32 6
  %1 = load %struct.lua_State.154** %L, align 8
  %call = call %union.TString.143* bitcast (%union.TString.367* (%struct.lua_State.364*, i8*)* @luaS_new to %union.TString.143* (%struct.lua_State.154*, i8*)*)(%struct.lua_State.154* %1, i8* getelementptr inbounds ([6 x i8]* @.str3604, i32 0, i32 0))
  store %union.TString.143* %call, %union.TString.143** %n, align 8
  %2 = load %struct.LexState.321** %ls.addr, align 8
  %3 = load %struct.LexState.321** %ls.addr, align 8
  %dyd = getelementptr inbounds %struct.LexState.321* %3, i32 0, i32 9
  %4 = load %struct.Dyndata.313** %dyd, align 8
  %label = getelementptr inbounds %struct.Dyndata.313* %4, i32 0, i32 2
  %5 = load %union.TString.143** %n, align 8
  %6 = load %struct.LexState.321** %ls.addr, align 8
  %fs = getelementptr inbounds %struct.LexState.321* %6, i32 0, i32 5
  %7 = load %struct.FuncState.320** %fs, align 8
  %pc = getelementptr inbounds %struct.FuncState.320* %7, i32 0, i32 5
  %8 = load i32* %pc, align 4
  %call1 = call i32 @newlabelentry(%struct.LexState.321* %2, %struct.Labellist.312* %label, %union.TString.143* %5, i32 0, i32 %8)
  store i32 %call1, i32* %l, align 4
  %9 = load %struct.LexState.321** %ls.addr, align 8
  %10 = load i32* %l, align 4
  %idxprom = sext i32 %10 to i64
  %11 = load %struct.LexState.321** %ls.addr, align 8
  %dyd2 = getelementptr inbounds %struct.LexState.321* %11, i32 0, i32 9
  %12 = load %struct.Dyndata.313** %dyd2, align 8
  %label3 = getelementptr inbounds %struct.Dyndata.313* %12, i32 0, i32 2
  %arr = getelementptr inbounds %struct.Labellist.312* %label3, i32 0, i32 0
  %13 = load %struct.Labeldesc.311** %arr, align 8
  %arrayidx = getelementptr inbounds %struct.Labeldesc.311* %13, i64 %idxprom
  call void @findgotos(%struct.LexState.321* %9, %struct.Labeldesc.311* %arrayidx)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @removevars(%struct.FuncState.320* %fs, i32 %tolevel) #0 {
entry:
  %fs.addr = alloca %struct.FuncState.320*, align 8
  %tolevel.addr = alloca i32, align 4
  store %struct.FuncState.320* %fs, %struct.FuncState.320** %fs.addr, align 8
  store i32 %tolevel, i32* %tolevel.addr, align 4
  %0 = load %struct.FuncState.320** %fs.addr, align 8
  %nactvar = getelementptr inbounds %struct.FuncState.320* %0, i32 0, i32 12
  %1 = load i8* %nactvar, align 1
  %conv = zext i8 %1 to i32
  %2 = load i32* %tolevel.addr, align 4
  %sub = sub nsw i32 %conv, %2
  %3 = load %struct.FuncState.320** %fs.addr, align 8
  %ls = getelementptr inbounds %struct.FuncState.320* %3, i32 0, i32 3
  %4 = load %struct.LexState.321** %ls, align 8
  %dyd = getelementptr inbounds %struct.LexState.321* %4, i32 0, i32 9
  %5 = load %struct.Dyndata.313** %dyd, align 8
  %actvar = getelementptr inbounds %struct.Dyndata.313* %5, i32 0, i32 0
  %n = getelementptr inbounds %struct.anon.6* %actvar, i32 0, i32 1
  %6 = load i32* %n, align 4
  %sub1 = sub nsw i32 %6, %sub
  store i32 %sub1, i32* %n, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %7 = load %struct.FuncState.320** %fs.addr, align 8
  %nactvar2 = getelementptr inbounds %struct.FuncState.320* %7, i32 0, i32 12
  %8 = load i8* %nactvar2, align 1
  %conv3 = zext i8 %8 to i32
  %9 = load i32* %tolevel.addr, align 4
  %cmp = icmp sgt i32 %conv3, %9
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %10 = load %struct.FuncState.320** %fs.addr, align 8
  %pc = getelementptr inbounds %struct.FuncState.320* %10, i32 0, i32 5
  %11 = load i32* %pc, align 4
  %12 = load %struct.FuncState.320** %fs.addr, align 8
  %13 = load %struct.FuncState.320** %fs.addr, align 8
  %nactvar5 = getelementptr inbounds %struct.FuncState.320* %13, i32 0, i32 12
  %14 = load i8* %nactvar5, align 1
  %dec = add i8 %14, -1
  store i8 %dec, i8* %nactvar5, align 1
  %conv6 = zext i8 %dec to i32
  %call = call %struct.LocVar.158* @getlocvar(%struct.FuncState.320* %12, i32 %conv6)
  %endpc = getelementptr inbounds %struct.LocVar.158* %call, i32 0, i32 2
  store i32 %11, i32* %endpc, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @movegotosout(%struct.FuncState.320* %fs, %struct.BlockCnt* %bl) #0 {
entry:
  %fs.addr = alloca %struct.FuncState.320*, align 8
  %bl.addr = alloca %struct.BlockCnt*, align 8
  %i = alloca i32, align 4
  %gl = alloca %struct.Labellist.312*, align 8
  %gt2 = alloca %struct.Labeldesc.311*, align 8
  store %struct.FuncState.320* %fs, %struct.FuncState.320** %fs.addr, align 8
  store %struct.BlockCnt* %bl, %struct.BlockCnt** %bl.addr, align 8
  %0 = load %struct.BlockCnt** %bl.addr, align 8
  %firstgoto = getelementptr inbounds %struct.BlockCnt* %0, i32 0, i32 2
  %1 = load i16* %firstgoto, align 2
  %conv = sext i16 %1 to i32
  store i32 %conv, i32* %i, align 4
  %2 = load %struct.FuncState.320** %fs.addr, align 8
  %ls = getelementptr inbounds %struct.FuncState.320* %2, i32 0, i32 3
  %3 = load %struct.LexState.321** %ls, align 8
  %dyd = getelementptr inbounds %struct.LexState.321* %3, i32 0, i32 9
  %4 = load %struct.Dyndata.313** %dyd, align 8
  %gt = getelementptr inbounds %struct.Dyndata.313* %4, i32 0, i32 1
  store %struct.Labellist.312* %gt, %struct.Labellist.312** %gl, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end17, %entry
  %5 = load i32* %i, align 4
  %6 = load %struct.Labellist.312** %gl, align 8
  %n = getelementptr inbounds %struct.Labellist.312* %6, i32 0, i32 1
  %7 = load i32* %n, align 4
  %cmp = icmp slt i32 %5, %7
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %8 = load i32* %i, align 4
  %idxprom = sext i32 %8 to i64
  %9 = load %struct.Labellist.312** %gl, align 8
  %arr = getelementptr inbounds %struct.Labellist.312* %9, i32 0, i32 0
  %10 = load %struct.Labeldesc.311** %arr, align 8
  %arrayidx = getelementptr inbounds %struct.Labeldesc.311* %10, i64 %idxprom
  store %struct.Labeldesc.311* %arrayidx, %struct.Labeldesc.311** %gt2, align 8
  %11 = load %struct.Labeldesc.311** %gt2, align 8
  %nactvar = getelementptr inbounds %struct.Labeldesc.311* %11, i32 0, i32 3
  %12 = load i8* %nactvar, align 1
  %conv3 = zext i8 %12 to i32
  %13 = load %struct.BlockCnt** %bl.addr, align 8
  %nactvar4 = getelementptr inbounds %struct.BlockCnt* %13, i32 0, i32 3
  %14 = load i8* %nactvar4, align 1
  %conv5 = zext i8 %14 to i32
  %cmp6 = icmp sgt i32 %conv3, %conv5
  br i1 %cmp6, label %if.then, label %if.end13

if.then:                                          ; preds = %while.body
  %15 = load %struct.BlockCnt** %bl.addr, align 8
  %upval = getelementptr inbounds %struct.BlockCnt* %15, i32 0, i32 4
  %16 = load i8* %upval, align 1
  %tobool = icmp ne i8 %16, 0
  br i1 %tobool, label %if.then8, label %if.end

if.then8:                                         ; preds = %if.then
  %17 = load %struct.FuncState.320** %fs.addr, align 8
  %18 = load %struct.Labeldesc.311** %gt2, align 8
  %pc = getelementptr inbounds %struct.Labeldesc.311* %18, i32 0, i32 1
  %19 = load i32* %pc, align 4
  %20 = load %struct.BlockCnt** %bl.addr, align 8
  %nactvar9 = getelementptr inbounds %struct.BlockCnt* %20, i32 0, i32 3
  %21 = load i8* %nactvar9, align 1
  %conv10 = zext i8 %21 to i32
  call void bitcast (void (%struct.FuncState*, i32, i32)* @luaK_patchclose to void (%struct.FuncState.320*, i32, i32)*)(%struct.FuncState.320* %17, i32 %19, i32 %conv10)
  br label %if.end

if.end:                                           ; preds = %if.then8, %if.then
  %22 = load %struct.BlockCnt** %bl.addr, align 8
  %nactvar11 = getelementptr inbounds %struct.BlockCnt* %22, i32 0, i32 3
  %23 = load i8* %nactvar11, align 1
  %24 = load %struct.Labeldesc.311** %gt2, align 8
  %nactvar12 = getelementptr inbounds %struct.Labeldesc.311* %24, i32 0, i32 3
  store i8 %23, i8* %nactvar12, align 1
  br label %if.end13

if.end13:                                         ; preds = %if.end, %while.body
  %25 = load %struct.FuncState.320** %fs.addr, align 8
  %ls14 = getelementptr inbounds %struct.FuncState.320* %25, i32 0, i32 3
  %26 = load %struct.LexState.321** %ls14, align 8
  %27 = load i32* %i, align 4
  %call = call i32 @findlabel(%struct.LexState.321* %26, i32 %27)
  %tobool15 = icmp ne i32 %call, 0
  br i1 %tobool15, label %if.end17, label %if.then16

if.then16:                                        ; preds = %if.end13
  %28 = load i32* %i, align 4
  %inc = add nsw i32 %28, 1
  store i32 %inc, i32* %i, align 4
  br label %if.end17

if.end17:                                         ; preds = %if.then16, %if.end13
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: noreturn nounwind uwtable
define internal void @undefgoto(%struct.LexState.321* %ls, %struct.Labeldesc.311* %gt) #6 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %gt.addr = alloca %struct.Labeldesc.311*, align 8
  %msg = alloca i8*, align 8
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store %struct.Labeldesc.311* %gt, %struct.Labeldesc.311** %gt.addr, align 8
  %0 = load %struct.Labeldesc.311** %gt.addr, align 8
  %name = getelementptr inbounds %struct.Labeldesc.311* %0, i32 0, i32 0
  %1 = load %union.TString.143** %name, align 8
  %tsv = bitcast %union.TString.143* %1 to %struct.anon.0.142*
  %tt = getelementptr inbounds %struct.anon.0.142* %tsv, i32 0, i32 1
  %2 = load i8* %tt, align 1
  %conv = zext i8 %2 to i32
  %cmp = icmp eq i32 %conv, 4
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %3 = load %struct.Labeldesc.311** %gt.addr, align 8
  %name2 = getelementptr inbounds %struct.Labeldesc.311* %3, i32 0, i32 0
  %4 = load %union.TString.143** %name2, align 8
  %tsv3 = bitcast %union.TString.143* %4 to %struct.anon.0.142*
  %extra = getelementptr inbounds %struct.anon.0.142* %tsv3, i32 0, i32 3
  %5 = load i8* %extra, align 1
  %conv4 = zext i8 %5 to i32
  %cmp5 = icmp sgt i32 %conv4, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %6 = phi i1 [ false, %entry ], [ %cmp5, %land.rhs ]
  %cond = select i1 %6, i8* getelementptr inbounds ([34 x i8]* @.str601, i32 0, i32 0), i8* getelementptr inbounds ([44 x i8]* @.str1602, i32 0, i32 0)
  store i8* %cond, i8** %msg, align 8
  %7 = load %struct.LexState.321** %ls.addr, align 8
  %L = getelementptr inbounds %struct.LexState.321* %7, i32 0, i32 6
  %8 = load %struct.lua_State.154** %L, align 8
  %9 = load i8** %msg, align 8
  %10 = load %struct.Labeldesc.311** %gt.addr, align 8
  %name7 = getelementptr inbounds %struct.Labeldesc.311* %10, i32 0, i32 0
  %11 = load %union.TString.143** %name7, align 8
  %add.ptr = getelementptr inbounds %union.TString.143* %11, i64 1
  %12 = bitcast %union.TString.143* %add.ptr to i8*
  %13 = load %struct.Labeldesc.311** %gt.addr, align 8
  %line = getelementptr inbounds %struct.Labeldesc.311* %13, i32 0, i32 2
  %14 = load i32* %line, align 4
  %call = call i8* (%struct.lua_State.154*, i8*, ...)* bitcast (i8* (%struct.lua_State.279*, i8*, ...)* @luaO_pushfstring to i8* (%struct.lua_State.154*, i8*, ...)*)(%struct.lua_State.154* %8, i8* %9, i8* %12, i32 %14)
  store i8* %call, i8** %msg, align 8
  %15 = load %struct.LexState.321** %ls.addr, align 8
  %16 = load i8** %msg, align 8
  call void @semerror(%struct.LexState.321* %15, i8* %16) #9
  unreachable

return:                                           ; No predecessors!
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @test_then_block(%struct.LexState.321* %ls, i32* %escapelist) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %escapelist.addr = alloca i32*, align 8
  %bl = alloca %struct.BlockCnt, align 8
  %fs = alloca %struct.FuncState.320*, align 8
  %v = alloca %struct.expdesc, align 8
  %jf = alloca i32, align 4
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store i32* %escapelist, i32** %escapelist.addr, align 8
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %fs1 = getelementptr inbounds %struct.LexState.321* %0, i32 0, i32 5
  %1 = load %struct.FuncState.320** %fs1, align 8
  store %struct.FuncState.320* %1, %struct.FuncState.320** %fs, align 8
  %2 = load %struct.LexState.321** %ls.addr, align 8
  call void bitcast (void (%struct.LexState.235*)* @luaX_next to void (%struct.LexState.321*)*)(%struct.LexState.321* %2)
  %3 = load %struct.LexState.321** %ls.addr, align 8
  call void @expr(%struct.LexState.321* %3, %struct.expdesc* %v)
  %4 = load %struct.LexState.321** %ls.addr, align 8
  call void @checknext(%struct.LexState.321* %4, i32 275)
  %5 = load %struct.LexState.321** %ls.addr, align 8
  %t = getelementptr inbounds %struct.LexState.321* %5, i32 0, i32 3
  %token = getelementptr inbounds %struct.Token* %t, i32 0, i32 0
  %6 = load i32* %token, align 4
  %cmp = icmp eq i32 %6, 266
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %7 = load %struct.LexState.321** %ls.addr, align 8
  %t2 = getelementptr inbounds %struct.LexState.321* %7, i32 0, i32 3
  %token3 = getelementptr inbounds %struct.Token* %t2, i32 0, i32 0
  %8 = load i32* %token3, align 4
  %cmp4 = icmp eq i32 %8, 258
  br i1 %cmp4, label %if.then, label %if.else9

if.then:                                          ; preds = %lor.lhs.false, %entry
  %9 = load %struct.LexState.321** %ls.addr, align 8
  %fs5 = getelementptr inbounds %struct.LexState.321* %9, i32 0, i32 5
  %10 = load %struct.FuncState.320** %fs5, align 8
  call void bitcast (void (%struct.FuncState*, %struct.expdesc*)* @luaK_goiffalse to void (%struct.FuncState.320*, %struct.expdesc*)*)(%struct.FuncState.320* %10, %struct.expdesc* %v)
  %11 = load %struct.FuncState.320** %fs, align 8
  call void @enterblock(%struct.FuncState.320* %11, %struct.BlockCnt* %bl, i8 zeroext 0)
  %12 = load %struct.LexState.321** %ls.addr, align 8
  %t6 = getelementptr inbounds %struct.expdesc* %v, i32 0, i32 2
  %13 = load i32* %t6, align 4
  call void @gotostat(%struct.LexState.321* %12, i32 %13)
  %14 = load %struct.LexState.321** %ls.addr, align 8
  call void @skipnoopstat(%struct.LexState.321* %14)
  %15 = load %struct.LexState.321** %ls.addr, align 8
  %call = call i32 @block_follow(%struct.LexState.321* %15, i32 0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then7, label %if.else

if.then7:                                         ; preds = %if.then
  %16 = load %struct.FuncState.320** %fs, align 8
  call void @leaveblock(%struct.FuncState.320* %16)
  br label %return

if.else:                                          ; preds = %if.then
  %17 = load %struct.FuncState.320** %fs, align 8
  %call8 = call i32 bitcast (i32 (%struct.FuncState*)* @luaK_jump to i32 (%struct.FuncState.320*)*)(%struct.FuncState.320* %17)
  store i32 %call8, i32* %jf, align 4
  br label %if.end

if.end:                                           ; preds = %if.else
  br label %if.end11

if.else9:                                         ; preds = %lor.lhs.false
  %18 = load %struct.LexState.321** %ls.addr, align 8
  %fs10 = getelementptr inbounds %struct.LexState.321* %18, i32 0, i32 5
  %19 = load %struct.FuncState.320** %fs10, align 8
  call void bitcast (void (%struct.FuncState*, %struct.expdesc*)* @luaK_goiftrue to void (%struct.FuncState.320*, %struct.expdesc*)*)(%struct.FuncState.320* %19, %struct.expdesc* %v)
  %20 = load %struct.FuncState.320** %fs, align 8
  call void @enterblock(%struct.FuncState.320* %20, %struct.BlockCnt* %bl, i8 zeroext 0)
  %f = getelementptr inbounds %struct.expdesc* %v, i32 0, i32 3
  %21 = load i32* %f, align 4
  store i32 %21, i32* %jf, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.else9, %if.end
  %22 = load %struct.LexState.321** %ls.addr, align 8
  call void @statlist(%struct.LexState.321* %22)
  %23 = load %struct.FuncState.320** %fs, align 8
  call void @leaveblock(%struct.FuncState.320* %23)
  %24 = load %struct.LexState.321** %ls.addr, align 8
  %t12 = getelementptr inbounds %struct.LexState.321* %24, i32 0, i32 3
  %token13 = getelementptr inbounds %struct.Token* %t12, i32 0, i32 0
  %25 = load i32* %token13, align 4
  %cmp14 = icmp eq i32 %25, 260
  br i1 %cmp14, label %if.then19, label %lor.lhs.false15

lor.lhs.false15:                                  ; preds = %if.end11
  %26 = load %struct.LexState.321** %ls.addr, align 8
  %t16 = getelementptr inbounds %struct.LexState.321* %26, i32 0, i32 3
  %token17 = getelementptr inbounds %struct.Token* %t16, i32 0, i32 0
  %27 = load i32* %token17, align 4
  %cmp18 = icmp eq i32 %27, 261
  br i1 %cmp18, label %if.then19, label %if.end21

if.then19:                                        ; preds = %lor.lhs.false15, %if.end11
  %28 = load %struct.FuncState.320** %fs, align 8
  %29 = load i32** %escapelist.addr, align 8
  %30 = load %struct.FuncState.320** %fs, align 8
  %call20 = call i32 bitcast (i32 (%struct.FuncState*)* @luaK_jump to i32 (%struct.FuncState.320*)*)(%struct.FuncState.320* %30)
  call void bitcast (void (%struct.FuncState*, i32*, i32)* @luaK_concat to void (%struct.FuncState.320*, i32*, i32)*)(%struct.FuncState.320* %28, i32* %29, i32 %call20)
  br label %if.end21

if.end21:                                         ; preds = %if.then19, %lor.lhs.false15
  %31 = load %struct.FuncState.320** %fs, align 8
  %32 = load i32* %jf, align 4
  call void bitcast (void (%struct.FuncState*, i32)* @luaK_patchtohere to void (%struct.FuncState.320*, i32)*)(%struct.FuncState.320* %31, i32 %32)
  br label %return

return:                                           ; preds = %if.end21, %if.then7
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @cond(%struct.LexState.321* %ls) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %v = alloca %struct.expdesc, align 8
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  %0 = load %struct.LexState.321** %ls.addr, align 8
  call void @expr(%struct.LexState.321* %0, %struct.expdesc* %v)
  %k = getelementptr inbounds %struct.expdesc* %v, i32 0, i32 0
  %1 = load i32* %k, align 4
  %cmp = icmp eq i32 %1, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %k1 = getelementptr inbounds %struct.expdesc* %v, i32 0, i32 0
  store i32 3, i32* %k1, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load %struct.LexState.321** %ls.addr, align 8
  %fs = getelementptr inbounds %struct.LexState.321* %2, i32 0, i32 5
  %3 = load %struct.FuncState.320** %fs, align 8
  call void bitcast (void (%struct.FuncState*, %struct.expdesc*)* @luaK_goiftrue to void (%struct.FuncState.320*, %struct.expdesc*)*)(%struct.FuncState.320* %3, %struct.expdesc* %v)
  %f = getelementptr inbounds %struct.expdesc* %v, i32 0, i32 3
  %4 = load i32* %f, align 4
  ret i32 %4
}

; Function Attrs: nounwind uwtable
define internal void @checknext(%struct.LexState.321* %ls, i32 %c) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %c.addr = alloca i32, align 4
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store i32 %c, i32* %c.addr, align 4
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %1 = load i32* %c.addr, align 4
  call void @check(%struct.LexState.321* %0, i32 %1)
  %2 = load %struct.LexState.321** %ls.addr, align 8
  call void bitcast (void (%struct.LexState.235*)* @luaX_next to void (%struct.LexState.321*)*)(%struct.LexState.321* %2)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @fornum(%struct.LexState.321* %ls, %union.TString.143* %varname, i32 %line) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %varname.addr = alloca %union.TString.143*, align 8
  %line.addr = alloca i32, align 4
  %fs = alloca %struct.FuncState.320*, align 8
  %base = alloca i32, align 4
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store %union.TString.143* %varname, %union.TString.143** %varname.addr, align 8
  store i32 %line, i32* %line.addr, align 4
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %fs1 = getelementptr inbounds %struct.LexState.321* %0, i32 0, i32 5
  %1 = load %struct.FuncState.320** %fs1, align 8
  store %struct.FuncState.320* %1, %struct.FuncState.320** %fs, align 8
  %2 = load %struct.FuncState.320** %fs, align 8
  %freereg = getelementptr inbounds %struct.FuncState.320* %2, i32 0, i32 14
  %3 = load i8* %freereg, align 1
  %conv = zext i8 %3 to i32
  store i32 %conv, i32* %base, align 4
  %4 = load %struct.LexState.321** %ls.addr, align 8
  call void @new_localvarliteral_(%struct.LexState.321* %4, i8* getelementptr inbounds ([12 x i8]* @.str24625, i32 0, i32 0), i64 11)
  %5 = load %struct.LexState.321** %ls.addr, align 8
  call void @new_localvarliteral_(%struct.LexState.321* %5, i8* getelementptr inbounds ([12 x i8]* @.str25626, i32 0, i32 0), i64 11)
  %6 = load %struct.LexState.321** %ls.addr, align 8
  call void @new_localvarliteral_(%struct.LexState.321* %6, i8* getelementptr inbounds ([11 x i8]* @.str26627, i32 0, i32 0), i64 10)
  %7 = load %struct.LexState.321** %ls.addr, align 8
  %8 = load %union.TString.143** %varname.addr, align 8
  call void @new_localvar(%struct.LexState.321* %7, %union.TString.143* %8)
  %9 = load %struct.LexState.321** %ls.addr, align 8
  call void @checknext(%struct.LexState.321* %9, i32 61)
  %10 = load %struct.LexState.321** %ls.addr, align 8
  %call = call i32 @exp1(%struct.LexState.321* %10)
  %11 = load %struct.LexState.321** %ls.addr, align 8
  call void @checknext(%struct.LexState.321* %11, i32 44)
  %12 = load %struct.LexState.321** %ls.addr, align 8
  %call2 = call i32 @exp1(%struct.LexState.321* %12)
  %13 = load %struct.LexState.321** %ls.addr, align 8
  %call3 = call i32 @testnext(%struct.LexState.321* %13, i32 44)
  %tobool = icmp ne i32 %call3, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %14 = load %struct.LexState.321** %ls.addr, align 8
  %call4 = call i32 @exp1(%struct.LexState.321* %14)
  br label %if.end

if.else:                                          ; preds = %entry
  %15 = load %struct.FuncState.320** %fs, align 8
  %16 = load %struct.FuncState.320** %fs, align 8
  %freereg5 = getelementptr inbounds %struct.FuncState.320* %16, i32 0, i32 14
  %17 = load i8* %freereg5, align 1
  %conv6 = zext i8 %17 to i32
  %18 = load %struct.FuncState.320** %fs, align 8
  %call7 = call i32 bitcast (i32 (%struct.FuncState*, double)* @luaK_numberK to i32 (%struct.FuncState.320*, double)*)(%struct.FuncState.320* %18, double 1.000000e+00)
  %call8 = call i32 bitcast (i32 (%struct.FuncState*, i32, i32)* @luaK_codek to i32 (%struct.FuncState.320*, i32, i32)*)(%struct.FuncState.320* %15, i32 %conv6, i32 %call7)
  %19 = load %struct.FuncState.320** %fs, align 8
  call void bitcast (void (%struct.FuncState*, i32)* @luaK_reserveregs to void (%struct.FuncState.320*, i32)*)(%struct.FuncState.320* %19, i32 1)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %20 = load %struct.LexState.321** %ls.addr, align 8
  %21 = load i32* %base, align 4
  %22 = load i32* %line.addr, align 4
  call void @forbody(%struct.LexState.321* %20, i32 %21, i32 %22, i32 1, i32 1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @forlist(%struct.LexState.321* %ls, %union.TString.143* %indexname) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %indexname.addr = alloca %union.TString.143*, align 8
  %fs = alloca %struct.FuncState.320*, align 8
  %e = alloca %struct.expdesc, align 8
  %nvars = alloca i32, align 4
  %line = alloca i32, align 4
  %base = alloca i32, align 4
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store %union.TString.143* %indexname, %union.TString.143** %indexname.addr, align 8
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %fs1 = getelementptr inbounds %struct.LexState.321* %0, i32 0, i32 5
  %1 = load %struct.FuncState.320** %fs1, align 8
  store %struct.FuncState.320* %1, %struct.FuncState.320** %fs, align 8
  store i32 4, i32* %nvars, align 4
  %2 = load %struct.FuncState.320** %fs, align 8
  %freereg = getelementptr inbounds %struct.FuncState.320* %2, i32 0, i32 14
  %3 = load i8* %freereg, align 1
  %conv = zext i8 %3 to i32
  store i32 %conv, i32* %base, align 4
  %4 = load %struct.LexState.321** %ls.addr, align 8
  call void @new_localvarliteral_(%struct.LexState.321* %4, i8* getelementptr inbounds ([16 x i8]* @.str21622, i32 0, i32 0), i64 15)
  %5 = load %struct.LexState.321** %ls.addr, align 8
  call void @new_localvarliteral_(%struct.LexState.321* %5, i8* getelementptr inbounds ([12 x i8]* @.str22623, i32 0, i32 0), i64 11)
  %6 = load %struct.LexState.321** %ls.addr, align 8
  call void @new_localvarliteral_(%struct.LexState.321* %6, i8* getelementptr inbounds ([14 x i8]* @.str23624, i32 0, i32 0), i64 13)
  %7 = load %struct.LexState.321** %ls.addr, align 8
  %8 = load %union.TString.143** %indexname.addr, align 8
  call void @new_localvar(%struct.LexState.321* %7, %union.TString.143* %8)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %9 = load %struct.LexState.321** %ls.addr, align 8
  %call = call i32 @testnext(%struct.LexState.321* %9, i32 44)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %10 = load %struct.LexState.321** %ls.addr, align 8
  %11 = load %struct.LexState.321** %ls.addr, align 8
  %call2 = call %union.TString.143* @str_checkname(%struct.LexState.321* %11)
  call void @new_localvar(%struct.LexState.321* %10, %union.TString.143* %call2)
  %12 = load i32* %nvars, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %nvars, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %13 = load %struct.LexState.321** %ls.addr, align 8
  call void @checknext(%struct.LexState.321* %13, i32 268)
  %14 = load %struct.LexState.321** %ls.addr, align 8
  %linenumber = getelementptr inbounds %struct.LexState.321* %14, i32 0, i32 1
  %15 = load i32* %linenumber, align 4
  store i32 %15, i32* %line, align 4
  %16 = load %struct.LexState.321** %ls.addr, align 8
  %17 = load %struct.LexState.321** %ls.addr, align 8
  %call3 = call i32 @explist(%struct.LexState.321* %17, %struct.expdesc* %e)
  call void @adjust_assign(%struct.LexState.321* %16, i32 3, i32 %call3, %struct.expdesc* %e)
  %18 = load %struct.FuncState.320** %fs, align 8
  call void bitcast (void (%struct.FuncState*, i32)* @luaK_checkstack to void (%struct.FuncState.320*, i32)*)(%struct.FuncState.320* %18, i32 3)
  %19 = load %struct.LexState.321** %ls.addr, align 8
  %20 = load i32* %base, align 4
  %21 = load i32* %line, align 4
  %22 = load i32* %nvars, align 4
  %sub = sub nsw i32 %22, 3
  call void @forbody(%struct.LexState.321* %19, i32 %20, i32 %21, i32 %sub, i32 0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @funcname(%struct.LexState.321* %ls, %struct.expdesc* %v) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %v.addr = alloca %struct.expdesc*, align 8
  %ismethod = alloca i32, align 4
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store %struct.expdesc* %v, %struct.expdesc** %v.addr, align 8
  store i32 0, i32* %ismethod, align 4
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %1 = load %struct.expdesc** %v.addr, align 8
  call void @singlevar(%struct.LexState.321* %0, %struct.expdesc* %1)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %2 = load %struct.LexState.321** %ls.addr, align 8
  %t = getelementptr inbounds %struct.LexState.321* %2, i32 0, i32 3
  %token = getelementptr inbounds %struct.Token* %t, i32 0, i32 0
  %3 = load i32* %token, align 4
  %cmp = icmp eq i32 %3, 46
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %4 = load %struct.LexState.321** %ls.addr, align 8
  %5 = load %struct.expdesc** %v.addr, align 8
  call void @fieldsel(%struct.LexState.321* %4, %struct.expdesc* %5)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %6 = load %struct.LexState.321** %ls.addr, align 8
  %t1 = getelementptr inbounds %struct.LexState.321* %6, i32 0, i32 3
  %token2 = getelementptr inbounds %struct.Token* %t1, i32 0, i32 0
  %7 = load i32* %token2, align 4
  %cmp3 = icmp eq i32 %7, 58
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %while.end
  store i32 1, i32* %ismethod, align 4
  %8 = load %struct.LexState.321** %ls.addr, align 8
  %9 = load %struct.expdesc** %v.addr, align 8
  call void @fieldsel(%struct.LexState.321* %8, %struct.expdesc* %9)
  br label %if.end

if.end:                                           ; preds = %if.then, %while.end
  %10 = load i32* %ismethod, align 4
  ret i32 %10
}

; Function Attrs: nounwind uwtable
define internal void @body(%struct.LexState.321* %ls, %struct.expdesc* %e, i32 %ismethod, i32 %line) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %e.addr = alloca %struct.expdesc*, align 8
  %ismethod.addr = alloca i32, align 4
  %line.addr = alloca i32, align 4
  %new_fs = alloca %struct.FuncState.320, align 8
  %bl = alloca %struct.BlockCnt, align 8
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store %struct.expdesc* %e, %struct.expdesc** %e.addr, align 8
  store i32 %ismethod, i32* %ismethod.addr, align 4
  store i32 %line, i32* %line.addr, align 4
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %call = call %struct.Proto.160* @addprototype(%struct.LexState.321* %0)
  %f = getelementptr inbounds %struct.FuncState.320* %new_fs, i32 0, i32 0
  store %struct.Proto.160* %call, %struct.Proto.160** %f, align 8
  %1 = load i32* %line.addr, align 4
  %f1 = getelementptr inbounds %struct.FuncState.320* %new_fs, i32 0, i32 0
  %2 = load %struct.Proto.160** %f1, align 8
  %linedefined = getelementptr inbounds %struct.Proto.160* %2, i32 0, i32 17
  store i32 %1, i32* %linedefined, align 4
  %3 = load %struct.LexState.321** %ls.addr, align 8
  call void @open_func(%struct.LexState.321* %3, %struct.FuncState.320* %new_fs, %struct.BlockCnt* %bl)
  %4 = load %struct.LexState.321** %ls.addr, align 8
  call void @checknext(%struct.LexState.321* %4, i32 40)
  %5 = load i32* %ismethod.addr, align 4
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load %struct.LexState.321** %ls.addr, align 8
  call void @new_localvarliteral_(%struct.LexState.321* %6, i8* getelementptr inbounds ([5 x i8]* @.str9610, i32 0, i32 0), i64 4)
  %7 = load %struct.LexState.321** %ls.addr, align 8
  call void @adjustlocalvars(%struct.LexState.321* %7, i32 1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %8 = load %struct.LexState.321** %ls.addr, align 8
  call void @parlist(%struct.LexState.321* %8)
  %9 = load %struct.LexState.321** %ls.addr, align 8
  call void @checknext(%struct.LexState.321* %9, i32 41)
  %10 = load %struct.LexState.321** %ls.addr, align 8
  call void @statlist(%struct.LexState.321* %10)
  %11 = load %struct.LexState.321** %ls.addr, align 8
  %linenumber = getelementptr inbounds %struct.LexState.321* %11, i32 0, i32 1
  %12 = load i32* %linenumber, align 4
  %f2 = getelementptr inbounds %struct.FuncState.320* %new_fs, i32 0, i32 0
  %13 = load %struct.Proto.160** %f2, align 8
  %lastlinedefined = getelementptr inbounds %struct.Proto.160* %13, i32 0, i32 18
  store i32 %12, i32* %lastlinedefined, align 4
  %14 = load %struct.LexState.321** %ls.addr, align 8
  %15 = load i32* %line.addr, align 4
  call void @check_match(%struct.LexState.321* %14, i32 262, i32 265, i32 %15)
  %16 = load %struct.LexState.321** %ls.addr, align 8
  %17 = load %struct.expdesc** %e.addr, align 8
  call void @codeclosure(%struct.LexState.321* %16, %struct.expdesc* %17)
  %18 = load %struct.LexState.321** %ls.addr, align 8
  call void @close_func(%struct.LexState.321* %18)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @new_localvar(%struct.LexState.321* %ls, %union.TString.143* %name) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %name.addr = alloca %union.TString.143*, align 8
  %fs = alloca %struct.FuncState.320*, align 8
  %dyd = alloca %struct.Dyndata.313*, align 8
  %reg = alloca i32, align 4
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store %union.TString.143* %name, %union.TString.143** %name.addr, align 8
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %fs1 = getelementptr inbounds %struct.LexState.321* %0, i32 0, i32 5
  %1 = load %struct.FuncState.320** %fs1, align 8
  store %struct.FuncState.320* %1, %struct.FuncState.320** %fs, align 8
  %2 = load %struct.LexState.321** %ls.addr, align 8
  %dyd2 = getelementptr inbounds %struct.LexState.321* %2, i32 0, i32 9
  %3 = load %struct.Dyndata.313** %dyd2, align 8
  store %struct.Dyndata.313* %3, %struct.Dyndata.313** %dyd, align 8
  %4 = load %struct.LexState.321** %ls.addr, align 8
  %5 = load %union.TString.143** %name.addr, align 8
  %call = call i32 @registerlocalvar(%struct.LexState.321* %4, %union.TString.143* %5)
  store i32 %call, i32* %reg, align 4
  %6 = load %struct.FuncState.320** %fs, align 8
  %7 = load %struct.Dyndata.313** %dyd, align 8
  %actvar = getelementptr inbounds %struct.Dyndata.313* %7, i32 0, i32 0
  %n = getelementptr inbounds %struct.anon.6* %actvar, i32 0, i32 1
  %8 = load i32* %n, align 4
  %add = add nsw i32 %8, 1
  %9 = load %struct.FuncState.320** %fs, align 8
  %firstlocal = getelementptr inbounds %struct.FuncState.320* %9, i32 0, i32 10
  %10 = load i32* %firstlocal, align 4
  %sub = sub nsw i32 %add, %10
  call void @checklimit(%struct.FuncState.320* %6, i32 %sub, i32 200, i8* getelementptr inbounds ([16 x i8]* @.str11612, i32 0, i32 0))
  %11 = load %struct.Dyndata.313** %dyd, align 8
  %actvar3 = getelementptr inbounds %struct.Dyndata.313* %11, i32 0, i32 0
  %n4 = getelementptr inbounds %struct.anon.6* %actvar3, i32 0, i32 1
  %12 = load i32* %n4, align 4
  %add5 = add nsw i32 %12, 1
  %add6 = add nsw i32 %add5, 1
  %13 = load %struct.Dyndata.313** %dyd, align 8
  %actvar7 = getelementptr inbounds %struct.Dyndata.313* %13, i32 0, i32 0
  %size = getelementptr inbounds %struct.anon.6* %actvar7, i32 0, i32 2
  %14 = load i32* %size, align 4
  %cmp = icmp sgt i32 %add6, %14
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %15 = load %struct.LexState.321** %ls.addr, align 8
  %L = getelementptr inbounds %struct.LexState.321* %15, i32 0, i32 6
  %16 = load %struct.lua_State.154** %L, align 8
  %17 = load %struct.Dyndata.313** %dyd, align 8
  %actvar8 = getelementptr inbounds %struct.Dyndata.313* %17, i32 0, i32 0
  %arr = getelementptr inbounds %struct.anon.6* %actvar8, i32 0, i32 0
  %18 = load %struct.Vardesc** %arr, align 8
  %19 = bitcast %struct.Vardesc* %18 to i8*
  %20 = load %struct.Dyndata.313** %dyd, align 8
  %actvar9 = getelementptr inbounds %struct.Dyndata.313* %20, i32 0, i32 0
  %size10 = getelementptr inbounds %struct.anon.6* %actvar9, i32 0, i32 2
  %call11 = call i8* bitcast (i8* (%struct.lua_State*, i8*, i32*, i64, i32, i8*)* @luaM_growaux_ to i8* (%struct.lua_State.154*, i8*, i32*, i64, i32, i8*)*)(%struct.lua_State.154* %16, i8* %19, i32* %size10, i64 2, i32 2147483645, i8* getelementptr inbounds ([16 x i8]* @.str11612, i32 0, i32 0))
  %21 = bitcast i8* %call11 to %struct.Vardesc*
  %22 = load %struct.Dyndata.313** %dyd, align 8
  %actvar12 = getelementptr inbounds %struct.Dyndata.313* %22, i32 0, i32 0
  %arr13 = getelementptr inbounds %struct.anon.6* %actvar12, i32 0, i32 0
  store %struct.Vardesc* %21, %struct.Vardesc** %arr13, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %23 = load i32* %reg, align 4
  %conv = trunc i32 %23 to i16
  %24 = load %struct.Dyndata.313** %dyd, align 8
  %actvar14 = getelementptr inbounds %struct.Dyndata.313* %24, i32 0, i32 0
  %n15 = getelementptr inbounds %struct.anon.6* %actvar14, i32 0, i32 1
  %25 = load i32* %n15, align 4
  %inc = add nsw i32 %25, 1
  store i32 %inc, i32* %n15, align 4
  %idxprom = sext i32 %25 to i64
  %26 = load %struct.Dyndata.313** %dyd, align 8
  %actvar16 = getelementptr inbounds %struct.Dyndata.313* %26, i32 0, i32 0
  %arr17 = getelementptr inbounds %struct.anon.6* %actvar16, i32 0, i32 0
  %27 = load %struct.Vardesc** %arr17, align 8
  %arrayidx = getelementptr inbounds %struct.Vardesc* %27, i64 %idxprom
  %idx = getelementptr inbounds %struct.Vardesc* %arrayidx, i32 0, i32 0
  store i16 %conv, i16* %idx, align 2
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @adjustlocalvars(%struct.LexState.321* %ls, i32 %nvars) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %nvars.addr = alloca i32, align 4
  %fs = alloca %struct.FuncState.320*, align 8
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store i32 %nvars, i32* %nvars.addr, align 4
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %fs1 = getelementptr inbounds %struct.LexState.321* %0, i32 0, i32 5
  %1 = load %struct.FuncState.320** %fs1, align 8
  store %struct.FuncState.320* %1, %struct.FuncState.320** %fs, align 8
  %2 = load %struct.FuncState.320** %fs, align 8
  %nactvar = getelementptr inbounds %struct.FuncState.320* %2, i32 0, i32 12
  %3 = load i8* %nactvar, align 1
  %conv = zext i8 %3 to i32
  %4 = load i32* %nvars.addr, align 4
  %add = add nsw i32 %conv, %4
  %conv2 = trunc i32 %add to i8
  %5 = load %struct.FuncState.320** %fs, align 8
  %nactvar3 = getelementptr inbounds %struct.FuncState.320* %5, i32 0, i32 12
  store i8 %conv2, i8* %nactvar3, align 1
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %6 = load i32* %nvars.addr, align 4
  %tobool = icmp ne i32 %6, 0
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load %struct.FuncState.320** %fs, align 8
  %pc = getelementptr inbounds %struct.FuncState.320* %7, i32 0, i32 5
  %8 = load i32* %pc, align 4
  %9 = load %struct.FuncState.320** %fs, align 8
  %10 = load %struct.FuncState.320** %fs, align 8
  %nactvar4 = getelementptr inbounds %struct.FuncState.320* %10, i32 0, i32 12
  %11 = load i8* %nactvar4, align 1
  %conv5 = zext i8 %11 to i32
  %12 = load i32* %nvars.addr, align 4
  %sub = sub nsw i32 %conv5, %12
  %call = call %struct.LocVar.158* @getlocvar(%struct.FuncState.320* %9, i32 %sub)
  %startpc = getelementptr inbounds %struct.LocVar.158* %call, i32 0, i32 1
  store i32 %8, i32* %startpc, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %13 = load i32* %nvars.addr, align 4
  %dec = add nsw i32 %13, -1
  store i32 %dec, i32* %nvars.addr, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal %struct.LocVar.158* @getlocvar(%struct.FuncState.320* %fs, i32 %i) #0 {
entry:
  %fs.addr = alloca %struct.FuncState.320*, align 8
  %i.addr = alloca i32, align 4
  %idx = alloca i32, align 4
  store %struct.FuncState.320* %fs, %struct.FuncState.320** %fs.addr, align 8
  store i32 %i, i32* %i.addr, align 4
  %0 = load %struct.FuncState.320** %fs.addr, align 8
  %firstlocal = getelementptr inbounds %struct.FuncState.320* %0, i32 0, i32 10
  %1 = load i32* %firstlocal, align 4
  %2 = load i32* %i.addr, align 4
  %add = add nsw i32 %1, %2
  %idxprom = sext i32 %add to i64
  %3 = load %struct.FuncState.320** %fs.addr, align 8
  %ls = getelementptr inbounds %struct.FuncState.320* %3, i32 0, i32 3
  %4 = load %struct.LexState.321** %ls, align 8
  %dyd = getelementptr inbounds %struct.LexState.321* %4, i32 0, i32 9
  %5 = load %struct.Dyndata.313** %dyd, align 8
  %actvar = getelementptr inbounds %struct.Dyndata.313* %5, i32 0, i32 0
  %arr = getelementptr inbounds %struct.anon.6* %actvar, i32 0, i32 0
  %6 = load %struct.Vardesc** %arr, align 8
  %arrayidx = getelementptr inbounds %struct.Vardesc* %6, i64 %idxprom
  %idx1 = getelementptr inbounds %struct.Vardesc* %arrayidx, i32 0, i32 0
  %7 = load i16* %idx1, align 2
  %conv = sext i16 %7 to i32
  store i32 %conv, i32* %idx, align 4
  %8 = load i32* %idx, align 4
  %idxprom2 = sext i32 %8 to i64
  %9 = load %struct.FuncState.320** %fs.addr, align 8
  %f = getelementptr inbounds %struct.FuncState.320* %9, i32 0, i32 0
  %10 = load %struct.Proto.160** %f, align 8
  %locvars = getelementptr inbounds %struct.Proto.160* %10, i32 0, i32 7
  %11 = load %struct.LocVar.158** %locvars, align 8
  %arrayidx3 = getelementptr inbounds %struct.LocVar.158* %11, i64 %idxprom2
  ret %struct.LocVar.158* %arrayidx3
}

; Function Attrs: nounwind uwtable
define internal i32 @explist(%struct.LexState.321* %ls, %struct.expdesc* %v) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %v.addr = alloca %struct.expdesc*, align 8
  %n = alloca i32, align 4
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store %struct.expdesc* %v, %struct.expdesc** %v.addr, align 8
  store i32 1, i32* %n, align 4
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %1 = load %struct.expdesc** %v.addr, align 8
  call void @expr(%struct.LexState.321* %0, %struct.expdesc* %1)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %2 = load %struct.LexState.321** %ls.addr, align 8
  %call = call i32 @testnext(%struct.LexState.321* %2, i32 44)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load %struct.LexState.321** %ls.addr, align 8
  %fs = getelementptr inbounds %struct.LexState.321* %3, i32 0, i32 5
  %4 = load %struct.FuncState.320** %fs, align 8
  %5 = load %struct.expdesc** %v.addr, align 8
  call void bitcast (void (%struct.FuncState*, %struct.expdesc*)* @luaK_exp2nextreg to void (%struct.FuncState.320*, %struct.expdesc*)*)(%struct.FuncState.320* %4, %struct.expdesc* %5)
  %6 = load %struct.LexState.321** %ls.addr, align 8
  %7 = load %struct.expdesc** %v.addr, align 8
  call void @expr(%struct.LexState.321* %6, %struct.expdesc* %7)
  %8 = load i32* %n, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, i32* %n, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %9 = load i32* %n, align 4
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define internal void @adjust_assign(%struct.LexState.321* %ls, i32 %nvars, i32 %nexps, %struct.expdesc* %e) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %nvars.addr = alloca i32, align 4
  %nexps.addr = alloca i32, align 4
  %e.addr = alloca %struct.expdesc*, align 8
  %fs = alloca %struct.FuncState.320*, align 8
  %extra = alloca i32, align 4
  %reg = alloca i32, align 4
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store i32 %nvars, i32* %nvars.addr, align 4
  store i32 %nexps, i32* %nexps.addr, align 4
  store %struct.expdesc* %e, %struct.expdesc** %e.addr, align 8
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %fs1 = getelementptr inbounds %struct.LexState.321* %0, i32 0, i32 5
  %1 = load %struct.FuncState.320** %fs1, align 8
  store %struct.FuncState.320* %1, %struct.FuncState.320** %fs, align 8
  %2 = load i32* %nvars.addr, align 4
  %3 = load i32* %nexps.addr, align 4
  %sub = sub nsw i32 %2, %3
  store i32 %sub, i32* %extra, align 4
  %4 = load %struct.expdesc** %e.addr, align 8
  %k = getelementptr inbounds %struct.expdesc* %4, i32 0, i32 0
  %5 = load i32* %k, align 4
  %cmp = icmp eq i32 %5, 12
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %6 = load %struct.expdesc** %e.addr, align 8
  %k2 = getelementptr inbounds %struct.expdesc* %6, i32 0, i32 0
  %7 = load i32* %k2, align 4
  %cmp3 = icmp eq i32 %7, 13
  br i1 %cmp3, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  %8 = load i32* %extra, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, i32* %extra, align 4
  %9 = load i32* %extra, align 4
  %cmp4 = icmp slt i32 %9, 0
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.then
  store i32 0, i32* %extra, align 4
  br label %if.end

if.end:                                           ; preds = %if.then5, %if.then
  %10 = load %struct.FuncState.320** %fs, align 8
  %11 = load %struct.expdesc** %e.addr, align 8
  %12 = load i32* %extra, align 4
  call void bitcast (void (%struct.FuncState*, %struct.expdesc*, i32)* @luaK_setreturns to void (%struct.FuncState.320*, %struct.expdesc*, i32)*)(%struct.FuncState.320* %10, %struct.expdesc* %11, i32 %12)
  %13 = load i32* %extra, align 4
  %cmp6 = icmp sgt i32 %13, 1
  br i1 %cmp6, label %if.then7, label %if.end9

if.then7:                                         ; preds = %if.end
  %14 = load %struct.FuncState.320** %fs, align 8
  %15 = load i32* %extra, align 4
  %sub8 = sub nsw i32 %15, 1
  call void bitcast (void (%struct.FuncState*, i32)* @luaK_reserveregs to void (%struct.FuncState.320*, i32)*)(%struct.FuncState.320* %14, i32 %sub8)
  br label %if.end9

if.end9:                                          ; preds = %if.then7, %if.end
  br label %if.end17

if.else:                                          ; preds = %lor.lhs.false
  %16 = load %struct.expdesc** %e.addr, align 8
  %k10 = getelementptr inbounds %struct.expdesc* %16, i32 0, i32 0
  %17 = load i32* %k10, align 4
  %cmp11 = icmp ne i32 %17, 0
  br i1 %cmp11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.else
  %18 = load %struct.FuncState.320** %fs, align 8
  %19 = load %struct.expdesc** %e.addr, align 8
  call void bitcast (void (%struct.FuncState*, %struct.expdesc*)* @luaK_exp2nextreg to void (%struct.FuncState.320*, %struct.expdesc*)*)(%struct.FuncState.320* %18, %struct.expdesc* %19)
  br label %if.end13

if.end13:                                         ; preds = %if.then12, %if.else
  %20 = load i32* %extra, align 4
  %cmp14 = icmp sgt i32 %20, 0
  br i1 %cmp14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.end13
  %21 = load %struct.FuncState.320** %fs, align 8
  %freereg = getelementptr inbounds %struct.FuncState.320* %21, i32 0, i32 14
  %22 = load i8* %freereg, align 1
  %conv = zext i8 %22 to i32
  store i32 %conv, i32* %reg, align 4
  %23 = load %struct.FuncState.320** %fs, align 8
  %24 = load i32* %extra, align 4
  call void bitcast (void (%struct.FuncState*, i32)* @luaK_reserveregs to void (%struct.FuncState.320*, i32)*)(%struct.FuncState.320* %23, i32 %24)
  %25 = load %struct.FuncState.320** %fs, align 8
  %26 = load i32* %reg, align 4
  %27 = load i32* %extra, align 4
  call void bitcast (void (%struct.FuncState*, i32, i32)* @luaK_nil to void (%struct.FuncState.320*, i32, i32)*)(%struct.FuncState.320* %25, i32 %26, i32 %27)
  br label %if.end16

if.end16:                                         ; preds = %if.then15, %if.end13
  br label %if.end17

if.end17:                                         ; preds = %if.end16, %if.end9
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @checkrepeated(%struct.FuncState.320* %fs, %struct.Labellist.312* %ll, %union.TString.143* %label) #0 {
entry:
  %fs.addr = alloca %struct.FuncState.320*, align 8
  %ll.addr = alloca %struct.Labellist.312*, align 8
  %label.addr = alloca %union.TString.143*, align 8
  %i = alloca i32, align 4
  %msg = alloca i8*, align 8
  store %struct.FuncState.320* %fs, %struct.FuncState.320** %fs.addr, align 8
  store %struct.Labellist.312* %ll, %struct.Labellist.312** %ll.addr, align 8
  store %union.TString.143* %label, %union.TString.143** %label.addr, align 8
  %0 = load %struct.FuncState.320** %fs.addr, align 8
  %bl = getelementptr inbounds %struct.FuncState.320* %0, i32 0, i32 4
  %1 = load %struct.BlockCnt** %bl, align 8
  %firstlabel = getelementptr inbounds %struct.BlockCnt* %1, i32 0, i32 1
  %2 = load i16* %firstlabel, align 2
  %conv = sext i16 %2 to i32
  store i32 %conv, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %3 = load i32* %i, align 4
  %4 = load %struct.Labellist.312** %ll.addr, align 8
  %n = getelementptr inbounds %struct.Labellist.312* %4, i32 0, i32 1
  %5 = load i32* %n, align 4
  %cmp = icmp slt i32 %3, %5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load %union.TString.143** %label.addr, align 8
  %7 = load i32* %i, align 4
  %idxprom = sext i32 %7 to i64
  %8 = load %struct.Labellist.312** %ll.addr, align 8
  %arr = getelementptr inbounds %struct.Labellist.312* %8, i32 0, i32 0
  %9 = load %struct.Labeldesc.311** %arr, align 8
  %arrayidx = getelementptr inbounds %struct.Labeldesc.311* %9, i64 %idxprom
  %name = getelementptr inbounds %struct.Labeldesc.311* %arrayidx, i32 0, i32 0
  %10 = load %union.TString.143** %name, align 8
  %call = call i32 bitcast (i32 (%union.TString.367*, %union.TString.367*)* @luaS_eqstr to i32 (%union.TString.143*, %union.TString.143*)*)(%union.TString.143* %6, %union.TString.143* %10)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %11 = load %struct.FuncState.320** %fs.addr, align 8
  %ls = getelementptr inbounds %struct.FuncState.320* %11, i32 0, i32 3
  %12 = load %struct.LexState.321** %ls, align 8
  %L = getelementptr inbounds %struct.LexState.321* %12, i32 0, i32 6
  %13 = load %struct.lua_State.154** %L, align 8
  %14 = load %union.TString.143** %label.addr, align 8
  %add.ptr = getelementptr inbounds %union.TString.143* %14, i64 1
  %15 = bitcast %union.TString.143* %add.ptr to i8*
  %16 = load i32* %i, align 4
  %idxprom2 = sext i32 %16 to i64
  %17 = load %struct.Labellist.312** %ll.addr, align 8
  %arr3 = getelementptr inbounds %struct.Labellist.312* %17, i32 0, i32 0
  %18 = load %struct.Labeldesc.311** %arr3, align 8
  %arrayidx4 = getelementptr inbounds %struct.Labeldesc.311* %18, i64 %idxprom2
  %line = getelementptr inbounds %struct.Labeldesc.311* %arrayidx4, i32 0, i32 2
  %19 = load i32* %line, align 4
  %call5 = call i8* (%struct.lua_State.154*, i8*, ...)* bitcast (i8* (%struct.lua_State.279*, i8*, ...)* @luaO_pushfstring to i8* (%struct.lua_State.154*, i8*, ...)*)(%struct.lua_State.154* %13, i8* getelementptr inbounds ([38 x i8]* @.str19620, i32 0, i32 0), i8* %15, i32 %19)
  store i8* %call5, i8** %msg, align 8
  %20 = load %struct.FuncState.320** %fs.addr, align 8
  %ls6 = getelementptr inbounds %struct.FuncState.320* %20, i32 0, i32 3
  %21 = load %struct.LexState.321** %ls6, align 8
  %22 = load i8** %msg, align 8
  call void @semerror(%struct.LexState.321* %21, i8* %22) #9
  unreachable

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %23 = load i32* %i, align 4
  %inc = add nsw i32 %23, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @newlabelentry(%struct.LexState.321* %ls, %struct.Labellist.312* %l, %union.TString.143* %name, i32 %line, i32 %pc) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %l.addr = alloca %struct.Labellist.312*, align 8
  %name.addr = alloca %union.TString.143*, align 8
  %line.addr = alloca i32, align 4
  %pc.addr = alloca i32, align 4
  %n = alloca i32, align 4
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store %struct.Labellist.312* %l, %struct.Labellist.312** %l.addr, align 8
  store %union.TString.143* %name, %union.TString.143** %name.addr, align 8
  store i32 %line, i32* %line.addr, align 4
  store i32 %pc, i32* %pc.addr, align 4
  %0 = load %struct.Labellist.312** %l.addr, align 8
  %n1 = getelementptr inbounds %struct.Labellist.312* %0, i32 0, i32 1
  %1 = load i32* %n1, align 4
  store i32 %1, i32* %n, align 4
  %2 = load i32* %n, align 4
  %add = add nsw i32 %2, 1
  %3 = load %struct.Labellist.312** %l.addr, align 8
  %size = getelementptr inbounds %struct.Labellist.312* %3, i32 0, i32 2
  %4 = load i32* %size, align 4
  %cmp = icmp sgt i32 %add, %4
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load %struct.LexState.321** %ls.addr, align 8
  %L = getelementptr inbounds %struct.LexState.321* %5, i32 0, i32 6
  %6 = load %struct.lua_State.154** %L, align 8
  %7 = load %struct.Labellist.312** %l.addr, align 8
  %arr = getelementptr inbounds %struct.Labellist.312* %7, i32 0, i32 0
  %8 = load %struct.Labeldesc.311** %arr, align 8
  %9 = bitcast %struct.Labeldesc.311* %8 to i8*
  %10 = load %struct.Labellist.312** %l.addr, align 8
  %size2 = getelementptr inbounds %struct.Labellist.312* %10, i32 0, i32 2
  %call = call i8* bitcast (i8* (%struct.lua_State*, i8*, i32*, i64, i32, i8*)* @luaM_growaux_ to i8* (%struct.lua_State.154*, i8*, i32*, i64, i32, i8*)*)(%struct.lua_State.154* %6, i8* %9, i32* %size2, i64 24, i32 32767, i8* getelementptr inbounds ([13 x i8]* @.str4605, i32 0, i32 0))
  %11 = bitcast i8* %call to %struct.Labeldesc.311*
  %12 = load %struct.Labellist.312** %l.addr, align 8
  %arr3 = getelementptr inbounds %struct.Labellist.312* %12, i32 0, i32 0
  store %struct.Labeldesc.311* %11, %struct.Labeldesc.311** %arr3, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %13 = load %union.TString.143** %name.addr, align 8
  %14 = load i32* %n, align 4
  %idxprom = sext i32 %14 to i64
  %15 = load %struct.Labellist.312** %l.addr, align 8
  %arr4 = getelementptr inbounds %struct.Labellist.312* %15, i32 0, i32 0
  %16 = load %struct.Labeldesc.311** %arr4, align 8
  %arrayidx = getelementptr inbounds %struct.Labeldesc.311* %16, i64 %idxprom
  %name5 = getelementptr inbounds %struct.Labeldesc.311* %arrayidx, i32 0, i32 0
  store %union.TString.143* %13, %union.TString.143** %name5, align 8
  %17 = load i32* %line.addr, align 4
  %18 = load i32* %n, align 4
  %idxprom6 = sext i32 %18 to i64
  %19 = load %struct.Labellist.312** %l.addr, align 8
  %arr7 = getelementptr inbounds %struct.Labellist.312* %19, i32 0, i32 0
  %20 = load %struct.Labeldesc.311** %arr7, align 8
  %arrayidx8 = getelementptr inbounds %struct.Labeldesc.311* %20, i64 %idxprom6
  %line9 = getelementptr inbounds %struct.Labeldesc.311* %arrayidx8, i32 0, i32 2
  store i32 %17, i32* %line9, align 4
  %21 = load %struct.LexState.321** %ls.addr, align 8
  %fs = getelementptr inbounds %struct.LexState.321* %21, i32 0, i32 5
  %22 = load %struct.FuncState.320** %fs, align 8
  %nactvar = getelementptr inbounds %struct.FuncState.320* %22, i32 0, i32 12
  %23 = load i8* %nactvar, align 1
  %24 = load i32* %n, align 4
  %idxprom10 = sext i32 %24 to i64
  %25 = load %struct.Labellist.312** %l.addr, align 8
  %arr11 = getelementptr inbounds %struct.Labellist.312* %25, i32 0, i32 0
  %26 = load %struct.Labeldesc.311** %arr11, align 8
  %arrayidx12 = getelementptr inbounds %struct.Labeldesc.311* %26, i64 %idxprom10
  %nactvar13 = getelementptr inbounds %struct.Labeldesc.311* %arrayidx12, i32 0, i32 3
  store i8 %23, i8* %nactvar13, align 1
  %27 = load i32* %pc.addr, align 4
  %28 = load i32* %n, align 4
  %idxprom14 = sext i32 %28 to i64
  %29 = load %struct.Labellist.312** %l.addr, align 8
  %arr15 = getelementptr inbounds %struct.Labellist.312* %29, i32 0, i32 0
  %30 = load %struct.Labeldesc.311** %arr15, align 8
  %arrayidx16 = getelementptr inbounds %struct.Labeldesc.311* %30, i64 %idxprom14
  %pc17 = getelementptr inbounds %struct.Labeldesc.311* %arrayidx16, i32 0, i32 1
  store i32 %27, i32* %pc17, align 4
  %31 = load %struct.Labellist.312** %l.addr, align 8
  %n18 = getelementptr inbounds %struct.Labellist.312* %31, i32 0, i32 1
  %32 = load i32* %n18, align 4
  %inc = add nsw i32 %32, 1
  store i32 %inc, i32* %n18, align 4
  %33 = load i32* %n, align 4
  ret i32 %33
}

; Function Attrs: nounwind uwtable
define internal void @skipnoopstat(%struct.LexState.321* %ls) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %t = getelementptr inbounds %struct.LexState.321* %0, i32 0, i32 3
  %token = getelementptr inbounds %struct.Token* %t, i32 0, i32 0
  %1 = load i32* %token, align 4
  %cmp = icmp eq i32 %1, 59
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %while.cond
  %2 = load %struct.LexState.321** %ls.addr, align 8
  %t1 = getelementptr inbounds %struct.LexState.321* %2, i32 0, i32 3
  %token2 = getelementptr inbounds %struct.Token* %t1, i32 0, i32 0
  %3 = load i32* %token2, align 4
  %cmp3 = icmp eq i32 %3, 285
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %while.cond
  %4 = phi i1 [ true, %while.cond ], [ %cmp3, %lor.rhs ]
  br i1 %4, label %while.body, label %while.end

while.body:                                       ; preds = %lor.end
  %5 = load %struct.LexState.321** %ls.addr, align 8
  call void @statement(%struct.LexState.321* %5)
  br label %while.cond

while.end:                                        ; preds = %lor.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @findgotos(%struct.LexState.321* %ls, %struct.Labeldesc.311* %lb) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %lb.addr = alloca %struct.Labeldesc.311*, align 8
  %gl = alloca %struct.Labellist.312*, align 8
  %i = alloca i32, align 4
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store %struct.Labeldesc.311* %lb, %struct.Labeldesc.311** %lb.addr, align 8
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %dyd = getelementptr inbounds %struct.LexState.321* %0, i32 0, i32 9
  %1 = load %struct.Dyndata.313** %dyd, align 8
  %gt = getelementptr inbounds %struct.Dyndata.313* %1, i32 0, i32 1
  store %struct.Labellist.312* %gt, %struct.Labellist.312** %gl, align 8
  %2 = load %struct.LexState.321** %ls.addr, align 8
  %fs = getelementptr inbounds %struct.LexState.321* %2, i32 0, i32 5
  %3 = load %struct.FuncState.320** %fs, align 8
  %bl = getelementptr inbounds %struct.FuncState.320* %3, i32 0, i32 4
  %4 = load %struct.BlockCnt** %bl, align 8
  %firstgoto = getelementptr inbounds %struct.BlockCnt* %4, i32 0, i32 2
  %5 = load i16* %firstgoto, align 2
  %conv = sext i16 %5 to i32
  store i32 %conv, i32* %i, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %6 = load i32* %i, align 4
  %7 = load %struct.Labellist.312** %gl, align 8
  %n = getelementptr inbounds %struct.Labellist.312* %7, i32 0, i32 1
  %8 = load i32* %n, align 4
  %cmp = icmp slt i32 %6, %8
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %9 = load i32* %i, align 4
  %idxprom = sext i32 %9 to i64
  %10 = load %struct.Labellist.312** %gl, align 8
  %arr = getelementptr inbounds %struct.Labellist.312* %10, i32 0, i32 0
  %11 = load %struct.Labeldesc.311** %arr, align 8
  %arrayidx = getelementptr inbounds %struct.Labeldesc.311* %11, i64 %idxprom
  %name = getelementptr inbounds %struct.Labeldesc.311* %arrayidx, i32 0, i32 0
  %12 = load %union.TString.143** %name, align 8
  %13 = load %struct.Labeldesc.311** %lb.addr, align 8
  %name2 = getelementptr inbounds %struct.Labeldesc.311* %13, i32 0, i32 0
  %14 = load %union.TString.143** %name2, align 8
  %call = call i32 bitcast (i32 (%union.TString.367*, %union.TString.367*)* @luaS_eqstr to i32 (%union.TString.143*, %union.TString.143*)*)(%union.TString.143* %12, %union.TString.143* %14)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %while.body
  %15 = load %struct.LexState.321** %ls.addr, align 8
  %16 = load i32* %i, align 4
  %17 = load %struct.Labeldesc.311** %lb.addr, align 8
  call void @closegoto(%struct.LexState.321* %15, i32 %16, %struct.Labeldesc.311* %17)
  br label %if.end

if.else:                                          ; preds = %while.body
  %18 = load i32* %i, align 4
  %inc = add nsw i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @findlabel(%struct.LexState.321* %ls, i32 %g) #0 {
entry:
  %retval = alloca i32, align 4
  %ls.addr = alloca %struct.LexState.321*, align 8
  %g.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %bl = alloca %struct.BlockCnt*, align 8
  %dyd = alloca %struct.Dyndata.313*, align 8
  %gt = alloca %struct.Labeldesc.311*, align 8
  %lb = alloca %struct.Labeldesc.311*, align 8
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store i32 %g, i32* %g.addr, align 4
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %fs = getelementptr inbounds %struct.LexState.321* %0, i32 0, i32 5
  %1 = load %struct.FuncState.320** %fs, align 8
  %bl1 = getelementptr inbounds %struct.FuncState.320* %1, i32 0, i32 4
  %2 = load %struct.BlockCnt** %bl1, align 8
  store %struct.BlockCnt* %2, %struct.BlockCnt** %bl, align 8
  %3 = load %struct.LexState.321** %ls.addr, align 8
  %dyd2 = getelementptr inbounds %struct.LexState.321* %3, i32 0, i32 9
  %4 = load %struct.Dyndata.313** %dyd2, align 8
  store %struct.Dyndata.313* %4, %struct.Dyndata.313** %dyd, align 8
  %5 = load i32* %g.addr, align 4
  %idxprom = sext i32 %5 to i64
  %6 = load %struct.Dyndata.313** %dyd, align 8
  %gt3 = getelementptr inbounds %struct.Dyndata.313* %6, i32 0, i32 1
  %arr = getelementptr inbounds %struct.Labellist.312* %gt3, i32 0, i32 0
  %7 = load %struct.Labeldesc.311** %arr, align 8
  %arrayidx = getelementptr inbounds %struct.Labeldesc.311* %7, i64 %idxprom
  store %struct.Labeldesc.311* %arrayidx, %struct.Labeldesc.311** %gt, align 8
  %8 = load %struct.BlockCnt** %bl, align 8
  %firstlabel = getelementptr inbounds %struct.BlockCnt* %8, i32 0, i32 1
  %9 = load i16* %firstlabel, align 2
  %conv = sext i16 %9 to i32
  store i32 %conv, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32* %i, align 4
  %11 = load %struct.Dyndata.313** %dyd, align 8
  %label = getelementptr inbounds %struct.Dyndata.313* %11, i32 0, i32 2
  %n = getelementptr inbounds %struct.Labellist.312* %label, i32 0, i32 1
  %12 = load i32* %n, align 4
  %cmp = icmp slt i32 %10, %12
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %13 = load i32* %i, align 4
  %idxprom5 = sext i32 %13 to i64
  %14 = load %struct.Dyndata.313** %dyd, align 8
  %label6 = getelementptr inbounds %struct.Dyndata.313* %14, i32 0, i32 2
  %arr7 = getelementptr inbounds %struct.Labellist.312* %label6, i32 0, i32 0
  %15 = load %struct.Labeldesc.311** %arr7, align 8
  %arrayidx8 = getelementptr inbounds %struct.Labeldesc.311* %15, i64 %idxprom5
  store %struct.Labeldesc.311* %arrayidx8, %struct.Labeldesc.311** %lb, align 8
  %16 = load %struct.Labeldesc.311** %lb, align 8
  %name = getelementptr inbounds %struct.Labeldesc.311* %16, i32 0, i32 0
  %17 = load %union.TString.143** %name, align 8
  %18 = load %struct.Labeldesc.311** %gt, align 8
  %name9 = getelementptr inbounds %struct.Labeldesc.311* %18, i32 0, i32 0
  %19 = load %union.TString.143** %name9, align 8
  %call = call i32 bitcast (i32 (%union.TString.367*, %union.TString.367*)* @luaS_eqstr to i32 (%union.TString.143*, %union.TString.143*)*)(%union.TString.143* %17, %union.TString.143* %19)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end27

if.then:                                          ; preds = %for.body
  %20 = load %struct.Labeldesc.311** %gt, align 8
  %nactvar = getelementptr inbounds %struct.Labeldesc.311* %20, i32 0, i32 3
  %21 = load i8* %nactvar, align 1
  %conv10 = zext i8 %21 to i32
  %22 = load %struct.Labeldesc.311** %lb, align 8
  %nactvar11 = getelementptr inbounds %struct.Labeldesc.311* %22, i32 0, i32 3
  %23 = load i8* %nactvar11, align 1
  %conv12 = zext i8 %23 to i32
  %cmp13 = icmp sgt i32 %conv10, %conv12
  br i1 %cmp13, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then
  %24 = load %struct.BlockCnt** %bl, align 8
  %upval = getelementptr inbounds %struct.BlockCnt* %24, i32 0, i32 4
  %25 = load i8* %upval, align 1
  %conv15 = zext i8 %25 to i32
  %tobool16 = icmp ne i32 %conv15, 0
  br i1 %tobool16, label %if.then23, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %26 = load %struct.Dyndata.313** %dyd, align 8
  %label17 = getelementptr inbounds %struct.Dyndata.313* %26, i32 0, i32 2
  %n18 = getelementptr inbounds %struct.Labellist.312* %label17, i32 0, i32 1
  %27 = load i32* %n18, align 4
  %28 = load %struct.BlockCnt** %bl, align 8
  %firstlabel19 = getelementptr inbounds %struct.BlockCnt* %28, i32 0, i32 1
  %29 = load i16* %firstlabel19, align 2
  %conv20 = sext i16 %29 to i32
  %cmp21 = icmp sgt i32 %27, %conv20
  br i1 %cmp21, label %if.then23, label %if.end

if.then23:                                        ; preds = %lor.lhs.false, %land.lhs.true
  %30 = load %struct.LexState.321** %ls.addr, align 8
  %fs24 = getelementptr inbounds %struct.LexState.321* %30, i32 0, i32 5
  %31 = load %struct.FuncState.320** %fs24, align 8
  %32 = load %struct.Labeldesc.311** %gt, align 8
  %pc = getelementptr inbounds %struct.Labeldesc.311* %32, i32 0, i32 1
  %33 = load i32* %pc, align 4
  %34 = load %struct.Labeldesc.311** %lb, align 8
  %nactvar25 = getelementptr inbounds %struct.Labeldesc.311* %34, i32 0, i32 3
  %35 = load i8* %nactvar25, align 1
  %conv26 = zext i8 %35 to i32
  call void bitcast (void (%struct.FuncState*, i32, i32)* @luaK_patchclose to void (%struct.FuncState.320*, i32, i32)*)(%struct.FuncState.320* %31, i32 %33, i32 %conv26)
  br label %if.end

if.end:                                           ; preds = %if.then23, %lor.lhs.false, %if.then
  %36 = load %struct.LexState.321** %ls.addr, align 8
  %37 = load i32* %g.addr, align 4
  %38 = load %struct.Labeldesc.311** %lb, align 8
  call void @closegoto(%struct.LexState.321* %36, i32 %37, %struct.Labeldesc.311* %38)
  store i32 1, i32* %retval
  br label %return

if.end27:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end27
  %39 = load i32* %i, align 4
  %inc = add nsw i32 %39, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %for.end, %if.end
  %40 = load i32* %retval
  ret i32 %40
}

; Function Attrs: nounwind uwtable
define internal void @suffixedexp(%struct.LexState.321* %ls, %struct.expdesc* %v) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %v.addr = alloca %struct.expdesc*, align 8
  %fs = alloca %struct.FuncState.320*, align 8
  %line = alloca i32, align 4
  %key = alloca %struct.expdesc, align 8
  %key4 = alloca %struct.expdesc, align 8
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store %struct.expdesc* %v, %struct.expdesc** %v.addr, align 8
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %fs1 = getelementptr inbounds %struct.LexState.321* %0, i32 0, i32 5
  %1 = load %struct.FuncState.320** %fs1, align 8
  store %struct.FuncState.320* %1, %struct.FuncState.320** %fs, align 8
  %2 = load %struct.LexState.321** %ls.addr, align 8
  %linenumber = getelementptr inbounds %struct.LexState.321* %2, i32 0, i32 1
  %3 = load i32* %linenumber, align 4
  store i32 %3, i32* %line, align 4
  %4 = load %struct.LexState.321** %ls.addr, align 8
  %5 = load %struct.expdesc** %v.addr, align 8
  call void @primaryexp(%struct.LexState.321* %4, %struct.expdesc* %5)
  br label %for.cond

for.cond:                                         ; preds = %sw.epilog, %entry
  %6 = load %struct.LexState.321** %ls.addr, align 8
  %t = getelementptr inbounds %struct.LexState.321* %6, i32 0, i32 3
  %token = getelementptr inbounds %struct.Token* %t, i32 0, i32 0
  %7 = load i32* %token, align 4
  switch i32 %7, label %sw.default [
    i32 46, label %sw.bb
    i32 91, label %sw.bb2
    i32 58, label %sw.bb3
    i32 40, label %sw.bb5
    i32 289, label %sw.bb5
    i32 123, label %sw.bb5
  ]

sw.bb:                                            ; preds = %for.cond
  %8 = load %struct.LexState.321** %ls.addr, align 8
  %9 = load %struct.expdesc** %v.addr, align 8
  call void @fieldsel(%struct.LexState.321* %8, %struct.expdesc* %9)
  br label %sw.epilog

sw.bb2:                                           ; preds = %for.cond
  %10 = load %struct.FuncState.320** %fs, align 8
  %11 = load %struct.expdesc** %v.addr, align 8
  call void bitcast (void (%struct.FuncState*, %struct.expdesc*)* @luaK_exp2anyregup to void (%struct.FuncState.320*, %struct.expdesc*)*)(%struct.FuncState.320* %10, %struct.expdesc* %11)
  %12 = load %struct.LexState.321** %ls.addr, align 8
  call void @yindex(%struct.LexState.321* %12, %struct.expdesc* %key)
  %13 = load %struct.FuncState.320** %fs, align 8
  %14 = load %struct.expdesc** %v.addr, align 8
  call void bitcast (void (%struct.FuncState*, %struct.expdesc*, %struct.expdesc*)* @luaK_indexed to void (%struct.FuncState.320*, %struct.expdesc*, %struct.expdesc*)*)(%struct.FuncState.320* %13, %struct.expdesc* %14, %struct.expdesc* %key)
  br label %sw.epilog

sw.bb3:                                           ; preds = %for.cond
  %15 = load %struct.LexState.321** %ls.addr, align 8
  call void bitcast (void (%struct.LexState.235*)* @luaX_next to void (%struct.LexState.321*)*)(%struct.LexState.321* %15)
  %16 = load %struct.LexState.321** %ls.addr, align 8
  call void @checkname(%struct.LexState.321* %16, %struct.expdesc* %key4)
  %17 = load %struct.FuncState.320** %fs, align 8
  %18 = load %struct.expdesc** %v.addr, align 8
  call void bitcast (void (%struct.FuncState*, %struct.expdesc*, %struct.expdesc*)* @luaK_self to void (%struct.FuncState.320*, %struct.expdesc*, %struct.expdesc*)*)(%struct.FuncState.320* %17, %struct.expdesc* %18, %struct.expdesc* %key4)
  %19 = load %struct.LexState.321** %ls.addr, align 8
  %20 = load %struct.expdesc** %v.addr, align 8
  %21 = load i32* %line, align 4
  call void @funcargs(%struct.LexState.321* %19, %struct.expdesc* %20, i32 %21)
  br label %sw.epilog

sw.bb5:                                           ; preds = %for.cond, %for.cond, %for.cond
  %22 = load %struct.FuncState.320** %fs, align 8
  %23 = load %struct.expdesc** %v.addr, align 8
  call void bitcast (void (%struct.FuncState*, %struct.expdesc*)* @luaK_exp2nextreg to void (%struct.FuncState.320*, %struct.expdesc*)*)(%struct.FuncState.320* %22, %struct.expdesc* %23)
  %24 = load %struct.LexState.321** %ls.addr, align 8
  %25 = load %struct.expdesc** %v.addr, align 8
  %26 = load i32* %line, align 4
  call void @funcargs(%struct.LexState.321* %24, %struct.expdesc* %25, i32 %26)
  br label %sw.epilog

sw.default:                                       ; preds = %for.cond
  ret void

sw.epilog:                                        ; preds = %sw.bb5, %sw.bb3, %sw.bb2, %sw.bb
  br label %for.cond
}

; Function Attrs: nounwind uwtable
define internal void @assignment(%struct.LexState.321* %ls, %struct.LHS_assign* %lh, i32 %nvars) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %lh.addr = alloca %struct.LHS_assign*, align 8
  %nvars.addr = alloca i32, align 4
  %e = alloca %struct.expdesc, align 8
  %nv = alloca %struct.LHS_assign, align 8
  %nexps = alloca i32, align 4
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store %struct.LHS_assign* %lh, %struct.LHS_assign** %lh.addr, align 8
  store i32 %nvars, i32* %nvars.addr, align 4
  %0 = load %struct.LHS_assign** %lh.addr, align 8
  %v = getelementptr inbounds %struct.LHS_assign* %0, i32 0, i32 1
  %k = getelementptr inbounds %struct.expdesc* %v, i32 0, i32 0
  %1 = load i32* %k, align 4
  %cmp = icmp ule i32 7, %1
  br i1 %cmp, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %entry
  %2 = load %struct.LHS_assign** %lh.addr, align 8
  %v1 = getelementptr inbounds %struct.LHS_assign* %2, i32 0, i32 1
  %k2 = getelementptr inbounds %struct.expdesc* %v1, i32 0, i32 0
  %3 = load i32* %k2, align 4
  %cmp3 = icmp ule i32 %3, 9
  br i1 %cmp3, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true, %entry
  %4 = load %struct.LexState.321** %ls.addr, align 8
  call void bitcast (void (%struct.LexState.235*, i8*)* @luaX_syntaxerror to void (%struct.LexState.321*, i8*)*)(%struct.LexState.321* %4, i8* getelementptr inbounds ([13 x i8]* @.str6607, i32 0, i32 0)) #9
  unreachable

if.end:                                           ; preds = %land.lhs.true
  %5 = load %struct.LexState.321** %ls.addr, align 8
  %call = call i32 @testnext(%struct.LexState.321* %5, i32 44)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.end
  %6 = load %struct.LHS_assign** %lh.addr, align 8
  %prev = getelementptr inbounds %struct.LHS_assign* %nv, i32 0, i32 0
  store %struct.LHS_assign* %6, %struct.LHS_assign** %prev, align 8
  %7 = load %struct.LexState.321** %ls.addr, align 8
  %v5 = getelementptr inbounds %struct.LHS_assign* %nv, i32 0, i32 1
  call void @suffixedexp(%struct.LexState.321* %7, %struct.expdesc* %v5)
  %v6 = getelementptr inbounds %struct.LHS_assign* %nv, i32 0, i32 1
  %k7 = getelementptr inbounds %struct.expdesc* %v6, i32 0, i32 0
  %8 = load i32* %k7, align 4
  %cmp8 = icmp ne i32 %8, 9
  br i1 %cmp8, label %if.then9, label %if.end11

if.then9:                                         ; preds = %if.then4
  %9 = load %struct.LexState.321** %ls.addr, align 8
  %10 = load %struct.LHS_assign** %lh.addr, align 8
  %v10 = getelementptr inbounds %struct.LHS_assign* %nv, i32 0, i32 1
  call void @check_conflict(%struct.LexState.321* %9, %struct.LHS_assign* %10, %struct.expdesc* %v10)
  br label %if.end11

if.end11:                                         ; preds = %if.then9, %if.then4
  %11 = load %struct.LexState.321** %ls.addr, align 8
  %fs = getelementptr inbounds %struct.LexState.321* %11, i32 0, i32 5
  %12 = load %struct.FuncState.320** %fs, align 8
  %13 = load i32* %nvars.addr, align 4
  %14 = load %struct.LexState.321** %ls.addr, align 8
  %L = getelementptr inbounds %struct.LexState.321* %14, i32 0, i32 6
  %15 = load %struct.lua_State.154** %L, align 8
  %nCcalls = getelementptr inbounds %struct.lua_State.154* %15, i32 0, i32 12
  %16 = load i16* %nCcalls, align 2
  %conv = zext i16 %16 to i32
  %add = add nsw i32 %13, %conv
  call void @checklimit(%struct.FuncState.320* %12, i32 %add, i32 200, i8* getelementptr inbounds ([9 x i8]* @.str7608, i32 0, i32 0))
  %17 = load %struct.LexState.321** %ls.addr, align 8
  %18 = load i32* %nvars.addr, align 4
  %add12 = add nsw i32 %18, 1
  call void @assignment(%struct.LexState.321* %17, %struct.LHS_assign* %nv, i32 %add12)
  br label %if.end30

if.else:                                          ; preds = %if.end
  %19 = load %struct.LexState.321** %ls.addr, align 8
  call void @checknext(%struct.LexState.321* %19, i32 61)
  %20 = load %struct.LexState.321** %ls.addr, align 8
  %call13 = call i32 @explist(%struct.LexState.321* %20, %struct.expdesc* %e)
  store i32 %call13, i32* %nexps, align 4
  %21 = load i32* %nexps, align 4
  %22 = load i32* %nvars.addr, align 4
  %cmp14 = icmp ne i32 %21, %22
  br i1 %cmp14, label %if.then16, label %if.else25

if.then16:                                        ; preds = %if.else
  %23 = load %struct.LexState.321** %ls.addr, align 8
  %24 = load i32* %nvars.addr, align 4
  %25 = load i32* %nexps, align 4
  call void @adjust_assign(%struct.LexState.321* %23, i32 %24, i32 %25, %struct.expdesc* %e)
  %26 = load i32* %nexps, align 4
  %27 = load i32* %nvars.addr, align 4
  %cmp17 = icmp sgt i32 %26, %27
  br i1 %cmp17, label %if.then19, label %if.end24

if.then19:                                        ; preds = %if.then16
  %28 = load i32* %nexps, align 4
  %29 = load i32* %nvars.addr, align 4
  %sub = sub nsw i32 %28, %29
  %30 = load %struct.LexState.321** %ls.addr, align 8
  %fs20 = getelementptr inbounds %struct.LexState.321* %30, i32 0, i32 5
  %31 = load %struct.FuncState.320** %fs20, align 8
  %freereg = getelementptr inbounds %struct.FuncState.320* %31, i32 0, i32 14
  %32 = load i8* %freereg, align 1
  %conv21 = zext i8 %32 to i32
  %sub22 = sub nsw i32 %conv21, %sub
  %conv23 = trunc i32 %sub22 to i8
  store i8 %conv23, i8* %freereg, align 1
  br label %if.end24

if.end24:                                         ; preds = %if.then19, %if.then16
  br label %if.end29

if.else25:                                        ; preds = %if.else
  %33 = load %struct.LexState.321** %ls.addr, align 8
  %fs26 = getelementptr inbounds %struct.LexState.321* %33, i32 0, i32 5
  %34 = load %struct.FuncState.320** %fs26, align 8
  call void bitcast (void (%struct.FuncState*, %struct.expdesc*)* @luaK_setoneret to void (%struct.FuncState.320*, %struct.expdesc*)*)(%struct.FuncState.320* %34, %struct.expdesc* %e)
  %35 = load %struct.LexState.321** %ls.addr, align 8
  %fs27 = getelementptr inbounds %struct.LexState.321* %35, i32 0, i32 5
  %36 = load %struct.FuncState.320** %fs27, align 8
  %37 = load %struct.LHS_assign** %lh.addr, align 8
  %v28 = getelementptr inbounds %struct.LHS_assign* %37, i32 0, i32 1
  call void bitcast (void (%struct.FuncState*, %struct.expdesc*, %struct.expdesc*)* @luaK_storevar to void (%struct.FuncState.320*, %struct.expdesc*, %struct.expdesc*)*)(%struct.FuncState.320* %36, %struct.expdesc* %v28, %struct.expdesc* %e)
  br label %return

if.end29:                                         ; preds = %if.end24
  br label %if.end30

if.end30:                                         ; preds = %if.end29, %if.end11
  %38 = load %struct.LexState.321** %ls.addr, align 8
  %fs31 = getelementptr inbounds %struct.LexState.321* %38, i32 0, i32 5
  %39 = load %struct.FuncState.320** %fs31, align 8
  %freereg32 = getelementptr inbounds %struct.FuncState.320* %39, i32 0, i32 14
  %40 = load i8* %freereg32, align 1
  %conv33 = zext i8 %40 to i32
  %sub34 = sub nsw i32 %conv33, 1
  call void @init_exp(%struct.expdesc* %e, i32 6, i32 %sub34)
  %41 = load %struct.LexState.321** %ls.addr, align 8
  %fs35 = getelementptr inbounds %struct.LexState.321* %41, i32 0, i32 5
  %42 = load %struct.FuncState.320** %fs35, align 8
  %43 = load %struct.LHS_assign** %lh.addr, align 8
  %v36 = getelementptr inbounds %struct.LHS_assign* %43, i32 0, i32 1
  call void bitcast (void (%struct.FuncState*, %struct.expdesc*, %struct.expdesc*)* @luaK_storevar to void (%struct.FuncState.320*, %struct.expdesc*, %struct.expdesc*)*)(%struct.FuncState.320* %42, %struct.expdesc* %v36, %struct.expdesc* %e)
  br label %return

return:                                           ; preds = %if.end30, %if.else25
  ret void
}

; Function Attrs: noreturn nounwind uwtable
define internal void @semerror(%struct.LexState.321* %ls, i8* %msg) #6 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %msg.addr = alloca i8*, align 8
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store i8* %msg, i8** %msg.addr, align 8
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %t = getelementptr inbounds %struct.LexState.321* %0, i32 0, i32 3
  %token = getelementptr inbounds %struct.Token* %t, i32 0, i32 0
  store i32 0, i32* %token, align 4
  %1 = load %struct.LexState.321** %ls.addr, align 8
  %2 = load i8** %msg.addr, align 8
  call void bitcast (void (%struct.LexState.235*, i8*)* @luaX_syntaxerror to void (%struct.LexState.321*, i8*)*)(%struct.LexState.321* %1, i8* %2) #9
  unreachable

return:                                           ; No predecessors!
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @expr(%struct.LexState.321* %ls, %struct.expdesc* %v) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %v.addr = alloca %struct.expdesc*, align 8
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store %struct.expdesc* %v, %struct.expdesc** %v.addr, align 8
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %1 = load %struct.expdesc** %v.addr, align 8
  %call = call i32 @subexpr(%struct.LexState.321* %0, %struct.expdesc* %1, i32 0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @new_localvarliteral_(%struct.LexState.321* %ls, i8* %name, i64 %sz) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %name.addr = alloca i8*, align 8
  %sz.addr = alloca i64, align 8
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store i8* %name, i8** %name.addr, align 8
  store i64 %sz, i64* %sz.addr, align 8
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %1 = load %struct.LexState.321** %ls.addr, align 8
  %2 = load i8** %name.addr, align 8
  %3 = load i64* %sz.addr, align 8
  %call = call %union.TString.143* bitcast (%union.TString* (%struct.LexState.235*, i8*, i64)* @luaX_newstring to %union.TString.143* (%struct.LexState.321*, i8*, i64)*)(%struct.LexState.321* %1, i8* %2, i64 %3)
  call void @new_localvar(%struct.LexState.321* %0, %union.TString.143* %call)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @exp1(%struct.LexState.321* %ls) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %e = alloca %struct.expdesc, align 8
  %reg = alloca i32, align 4
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  %0 = load %struct.LexState.321** %ls.addr, align 8
  call void @expr(%struct.LexState.321* %0, %struct.expdesc* %e)
  %1 = load %struct.LexState.321** %ls.addr, align 8
  %fs = getelementptr inbounds %struct.LexState.321* %1, i32 0, i32 5
  %2 = load %struct.FuncState.320** %fs, align 8
  call void bitcast (void (%struct.FuncState*, %struct.expdesc*)* @luaK_exp2nextreg to void (%struct.FuncState.320*, %struct.expdesc*)*)(%struct.FuncState.320* %2, %struct.expdesc* %e)
  %u = getelementptr inbounds %struct.expdesc* %e, i32 0, i32 1
  %info = bitcast %union.anon.7* %u to i32*
  %3 = load i32* %info, align 4
  store i32 %3, i32* %reg, align 4
  %4 = load i32* %reg, align 4
  ret i32 %4
}

; Function Attrs: nounwind uwtable
define internal void @forbody(%struct.LexState.321* %ls, i32 %base, i32 %line, i32 %nvars, i32 %isnum) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %base.addr = alloca i32, align 4
  %line.addr = alloca i32, align 4
  %nvars.addr = alloca i32, align 4
  %isnum.addr = alloca i32, align 4
  %bl = alloca %struct.BlockCnt, align 8
  %fs = alloca %struct.FuncState.320*, align 8
  %prep = alloca i32, align 4
  %endfor = alloca i32, align 4
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store i32 %base, i32* %base.addr, align 4
  store i32 %line, i32* %line.addr, align 4
  store i32 %nvars, i32* %nvars.addr, align 4
  store i32 %isnum, i32* %isnum.addr, align 4
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %fs1 = getelementptr inbounds %struct.LexState.321* %0, i32 0, i32 5
  %1 = load %struct.FuncState.320** %fs1, align 8
  store %struct.FuncState.320* %1, %struct.FuncState.320** %fs, align 8
  %2 = load %struct.LexState.321** %ls.addr, align 8
  call void @adjustlocalvars(%struct.LexState.321* %2, i32 3)
  %3 = load %struct.LexState.321** %ls.addr, align 8
  call void @checknext(%struct.LexState.321* %3, i32 259)
  %4 = load i32* %isnum.addr, align 4
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %5 = load %struct.FuncState.320** %fs, align 8
  %6 = load i32* %base.addr, align 4
  %call = call i32 bitcast (i32 (%struct.FuncState*, i32, i32, i32)* @luaK_codeABx to i32 (%struct.FuncState.320*, i32, i32, i32)*)(%struct.FuncState.320* %5, i32 33, i32 %6, i32 131070)
  br label %cond.end

cond.false:                                       ; preds = %entry
  %7 = load %struct.FuncState.320** %fs, align 8
  %call2 = call i32 bitcast (i32 (%struct.FuncState*)* @luaK_jump to i32 (%struct.FuncState.320*)*)(%struct.FuncState.320* %7)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %call, %cond.true ], [ %call2, %cond.false ]
  store i32 %cond, i32* %prep, align 4
  %8 = load %struct.FuncState.320** %fs, align 8
  call void @enterblock(%struct.FuncState.320* %8, %struct.BlockCnt* %bl, i8 zeroext 0)
  %9 = load %struct.LexState.321** %ls.addr, align 8
  %10 = load i32* %nvars.addr, align 4
  call void @adjustlocalvars(%struct.LexState.321* %9, i32 %10)
  %11 = load %struct.FuncState.320** %fs, align 8
  %12 = load i32* %nvars.addr, align 4
  call void bitcast (void (%struct.FuncState*, i32)* @luaK_reserveregs to void (%struct.FuncState.320*, i32)*)(%struct.FuncState.320* %11, i32 %12)
  %13 = load %struct.LexState.321** %ls.addr, align 8
  call void @block(%struct.LexState.321* %13)
  %14 = load %struct.FuncState.320** %fs, align 8
  call void @leaveblock(%struct.FuncState.320* %14)
  %15 = load %struct.FuncState.320** %fs, align 8
  %16 = load i32* %prep, align 4
  call void bitcast (void (%struct.FuncState*, i32)* @luaK_patchtohere to void (%struct.FuncState.320*, i32)*)(%struct.FuncState.320* %15, i32 %16)
  %17 = load i32* %isnum.addr, align 4
  %tobool3 = icmp ne i32 %17, 0
  br i1 %tobool3, label %if.then, label %if.else

if.then:                                          ; preds = %cond.end
  %18 = load %struct.FuncState.320** %fs, align 8
  %19 = load i32* %base.addr, align 4
  %call4 = call i32 bitcast (i32 (%struct.FuncState*, i32, i32, i32)* @luaK_codeABx to i32 (%struct.FuncState.320*, i32, i32, i32)*)(%struct.FuncState.320* %18, i32 32, i32 %19, i32 131070)
  store i32 %call4, i32* %endfor, align 4
  br label %if.end

if.else:                                          ; preds = %cond.end
  %20 = load %struct.FuncState.320** %fs, align 8
  %21 = load i32* %base.addr, align 4
  %22 = load i32* %nvars.addr, align 4
  %call5 = call i32 bitcast (i32 (%struct.FuncState*, i32, i32, i32, i32)* @luaK_codeABC to i32 (%struct.FuncState.320*, i32, i32, i32, i32)*)(%struct.FuncState.320* %20, i32 34, i32 %21, i32 0, i32 %22)
  %23 = load %struct.FuncState.320** %fs, align 8
  %24 = load i32* %line.addr, align 4
  call void bitcast (void (%struct.FuncState*, i32)* @luaK_fixline to void (%struct.FuncState.320*, i32)*)(%struct.FuncState.320* %23, i32 %24)
  %25 = load %struct.FuncState.320** %fs, align 8
  %26 = load i32* %base.addr, align 4
  %add = add nsw i32 %26, 2
  %call6 = call i32 bitcast (i32 (%struct.FuncState*, i32, i32, i32)* @luaK_codeABx to i32 (%struct.FuncState.320*, i32, i32, i32)*)(%struct.FuncState.320* %25, i32 35, i32 %add, i32 131070)
  store i32 %call6, i32* %endfor, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %27 = load %struct.FuncState.320** %fs, align 8
  %28 = load i32* %endfor, align 4
  %29 = load i32* %prep, align 4
  %add7 = add nsw i32 %29, 1
  call void bitcast (void (%struct.FuncState*, i32, i32)* @luaK_patchlist to void (%struct.FuncState.320*, i32, i32)*)(%struct.FuncState.320* %27, i32 %28, i32 %add7)
  %30 = load %struct.FuncState.320** %fs, align 8
  %31 = load i32* %line.addr, align 4
  call void bitcast (void (%struct.FuncState*, i32)* @luaK_fixline to void (%struct.FuncState.320*, i32)*)(%struct.FuncState.320* %30, i32 %31)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @singlevar(%struct.LexState.321* %ls, %struct.expdesc* %var) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %var.addr = alloca %struct.expdesc*, align 8
  %varname = alloca %union.TString.143*, align 8
  %fs = alloca %struct.FuncState.320*, align 8
  %key = alloca %struct.expdesc, align 8
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store %struct.expdesc* %var, %struct.expdesc** %var.addr, align 8
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %call = call %union.TString.143* @str_checkname(%struct.LexState.321* %0)
  store %union.TString.143* %call, %union.TString.143** %varname, align 8
  %1 = load %struct.LexState.321** %ls.addr, align 8
  %fs1 = getelementptr inbounds %struct.LexState.321* %1, i32 0, i32 5
  %2 = load %struct.FuncState.320** %fs1, align 8
  store %struct.FuncState.320* %2, %struct.FuncState.320** %fs, align 8
  %3 = load %struct.FuncState.320** %fs, align 8
  %4 = load %union.TString.143** %varname, align 8
  %5 = load %struct.expdesc** %var.addr, align 8
  %call2 = call i32 @singlevaraux(%struct.FuncState.320* %3, %union.TString.143* %4, %struct.expdesc* %5, i32 1)
  %cmp = icmp eq i32 %call2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load %struct.FuncState.320** %fs, align 8
  %7 = load %struct.LexState.321** %ls.addr, align 8
  %envn = getelementptr inbounds %struct.LexState.321* %7, i32 0, i32 11
  %8 = load %union.TString.143** %envn, align 8
  %9 = load %struct.expdesc** %var.addr, align 8
  %call3 = call i32 @singlevaraux(%struct.FuncState.320* %6, %union.TString.143* %8, %struct.expdesc* %9, i32 1)
  %10 = load %struct.LexState.321** %ls.addr, align 8
  %11 = load %union.TString.143** %varname, align 8
  call void @codestring(%struct.LexState.321* %10, %struct.expdesc* %key, %union.TString.143* %11)
  %12 = load %struct.FuncState.320** %fs, align 8
  %13 = load %struct.expdesc** %var.addr, align 8
  call void bitcast (void (%struct.FuncState*, %struct.expdesc*, %struct.expdesc*)* @luaK_indexed to void (%struct.FuncState.320*, %struct.expdesc*, %struct.expdesc*)*)(%struct.FuncState.320* %12, %struct.expdesc* %13, %struct.expdesc* %key)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @fieldsel(%struct.LexState.321* %ls, %struct.expdesc* %v) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %v.addr = alloca %struct.expdesc*, align 8
  %fs = alloca %struct.FuncState.320*, align 8
  %key = alloca %struct.expdesc, align 8
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store %struct.expdesc* %v, %struct.expdesc** %v.addr, align 8
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %fs1 = getelementptr inbounds %struct.LexState.321* %0, i32 0, i32 5
  %1 = load %struct.FuncState.320** %fs1, align 8
  store %struct.FuncState.320* %1, %struct.FuncState.320** %fs, align 8
  %2 = load %struct.FuncState.320** %fs, align 8
  %3 = load %struct.expdesc** %v.addr, align 8
  call void bitcast (void (%struct.FuncState*, %struct.expdesc*)* @luaK_exp2anyregup to void (%struct.FuncState.320*, %struct.expdesc*)*)(%struct.FuncState.320* %2, %struct.expdesc* %3)
  %4 = load %struct.LexState.321** %ls.addr, align 8
  call void bitcast (void (%struct.LexState.235*)* @luaX_next to void (%struct.LexState.321*)*)(%struct.LexState.321* %4)
  %5 = load %struct.LexState.321** %ls.addr, align 8
  call void @checkname(%struct.LexState.321* %5, %struct.expdesc* %key)
  %6 = load %struct.FuncState.320** %fs, align 8
  %7 = load %struct.expdesc** %v.addr, align 8
  call void bitcast (void (%struct.FuncState*, %struct.expdesc*, %struct.expdesc*)* @luaK_indexed to void (%struct.FuncState.320*, %struct.expdesc*, %struct.expdesc*)*)(%struct.FuncState.320* %6, %struct.expdesc* %7, %struct.expdesc* %key)
  ret void
}

; Function Attrs: nounwind uwtable
define internal %struct.Proto.160* @addprototype(%struct.LexState.321* %ls) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %clp = alloca %struct.Proto.160*, align 8
  %L = alloca %struct.lua_State.154*, align 8
  %fs = alloca %struct.FuncState.320*, align 8
  %f = alloca %struct.Proto.160*, align 8
  %oldsize = alloca i32, align 4
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %L1 = getelementptr inbounds %struct.LexState.321* %0, i32 0, i32 6
  %1 = load %struct.lua_State.154** %L1, align 8
  store %struct.lua_State.154* %1, %struct.lua_State.154** %L, align 8
  %2 = load %struct.LexState.321** %ls.addr, align 8
  %fs2 = getelementptr inbounds %struct.LexState.321* %2, i32 0, i32 5
  %3 = load %struct.FuncState.320** %fs2, align 8
  store %struct.FuncState.320* %3, %struct.FuncState.320** %fs, align 8
  %4 = load %struct.FuncState.320** %fs, align 8
  %f3 = getelementptr inbounds %struct.FuncState.320* %4, i32 0, i32 0
  %5 = load %struct.Proto.160** %f3, align 8
  store %struct.Proto.160* %5, %struct.Proto.160** %f, align 8
  %6 = load %struct.FuncState.320** %fs, align 8
  %np = getelementptr inbounds %struct.FuncState.320* %6, i32 0, i32 9
  %7 = load i32* %np, align 4
  %8 = load %struct.Proto.160** %f, align 8
  %sizep = getelementptr inbounds %struct.Proto.160* %8, i32 0, i32 15
  %9 = load i32* %sizep, align 4
  %cmp = icmp sge i32 %7, %9
  br i1 %cmp, label %if.then, label %if.end14

if.then:                                          ; preds = %entry
  %10 = load %struct.Proto.160** %f, align 8
  %sizep4 = getelementptr inbounds %struct.Proto.160* %10, i32 0, i32 15
  %11 = load i32* %sizep4, align 4
  store i32 %11, i32* %oldsize, align 4
  %12 = load %struct.FuncState.320** %fs, align 8
  %np5 = getelementptr inbounds %struct.FuncState.320* %12, i32 0, i32 9
  %13 = load i32* %np5, align 4
  %add = add nsw i32 %13, 1
  %14 = load %struct.Proto.160** %f, align 8
  %sizep6 = getelementptr inbounds %struct.Proto.160* %14, i32 0, i32 15
  %15 = load i32* %sizep6, align 4
  %cmp7 = icmp sgt i32 %add, %15
  br i1 %cmp7, label %if.then8, label %if.end

if.then8:                                         ; preds = %if.then
  %16 = load %struct.lua_State.154** %L, align 8
  %17 = load %struct.Proto.160** %f, align 8
  %p = getelementptr inbounds %struct.Proto.160* %17, i32 0, i32 5
  %18 = load %struct.Proto.160*** %p, align 8
  %19 = bitcast %struct.Proto.160** %18 to i8*
  %20 = load %struct.Proto.160** %f, align 8
  %sizep9 = getelementptr inbounds %struct.Proto.160* %20, i32 0, i32 15
  %call = call i8* bitcast (i8* (%struct.lua_State*, i8*, i32*, i64, i32, i8*)* @luaM_growaux_ to i8* (%struct.lua_State.154*, i8*, i32*, i64, i32, i8*)*)(%struct.lua_State.154* %16, i8* %19, i32* %sizep9, i64 8, i32 262143, i8* getelementptr inbounds ([10 x i8]* @.str12613, i32 0, i32 0))
  %21 = bitcast i8* %call to %struct.Proto.160**
  %22 = load %struct.Proto.160** %f, align 8
  %p10 = getelementptr inbounds %struct.Proto.160* %22, i32 0, i32 5
  store %struct.Proto.160** %21, %struct.Proto.160*** %p10, align 8
  br label %if.end

if.end:                                           ; preds = %if.then8, %if.then
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %23 = load i32* %oldsize, align 4
  %24 = load %struct.Proto.160** %f, align 8
  %sizep11 = getelementptr inbounds %struct.Proto.160* %24, i32 0, i32 15
  %25 = load i32* %sizep11, align 4
  %cmp12 = icmp slt i32 %23, %25
  br i1 %cmp12, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %26 = load i32* %oldsize, align 4
  %inc = add nsw i32 %26, 1
  store i32 %inc, i32* %oldsize, align 4
  %idxprom = sext i32 %26 to i64
  %27 = load %struct.Proto.160** %f, align 8
  %p13 = getelementptr inbounds %struct.Proto.160* %27, i32 0, i32 5
  %28 = load %struct.Proto.160*** %p13, align 8
  %arrayidx = getelementptr inbounds %struct.Proto.160** %28, i64 %idxprom
  store %struct.Proto.160* null, %struct.Proto.160** %arrayidx, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  br label %if.end14

if.end14:                                         ; preds = %while.end, %entry
  %29 = load %struct.lua_State.154** %L, align 8
  %call15 = call %struct.Proto.160* @luaF_newproto(%struct.lua_State.154* %29)
  store %struct.Proto.160* %call15, %struct.Proto.160** %clp, align 8
  %30 = load %struct.FuncState.320** %fs, align 8
  %np16 = getelementptr inbounds %struct.FuncState.320* %30, i32 0, i32 9
  %31 = load i32* %np16, align 4
  %inc17 = add nsw i32 %31, 1
  store i32 %inc17, i32* %np16, align 4
  %idxprom18 = sext i32 %31 to i64
  %32 = load %struct.Proto.160** %f, align 8
  %p19 = getelementptr inbounds %struct.Proto.160* %32, i32 0, i32 5
  %33 = load %struct.Proto.160*** %p19, align 8
  %arrayidx20 = getelementptr inbounds %struct.Proto.160** %33, i64 %idxprom18
  store %struct.Proto.160* %call15, %struct.Proto.160** %arrayidx20, align 8
  %34 = load %struct.Proto.160** %clp, align 8
  %35 = bitcast %struct.Proto.160* %34 to %union.GCObject.155*
  %gch = bitcast %union.GCObject.155* %35 to %struct.GCheader.325*
  %marked = getelementptr inbounds %struct.GCheader.325* %gch, i32 0, i32 2
  %36 = load i8* %marked, align 1
  %conv = zext i8 %36 to i32
  %and = and i32 %conv, 3
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end27

land.lhs.true:                                    ; preds = %if.end14
  %37 = load %struct.Proto.160** %f, align 8
  %38 = bitcast %struct.Proto.160* %37 to %union.GCObject.155*
  %gch21 = bitcast %union.GCObject.155* %38 to %struct.GCheader.325*
  %marked22 = getelementptr inbounds %struct.GCheader.325* %gch21, i32 0, i32 2
  %39 = load i8* %marked22, align 1
  %conv23 = zext i8 %39 to i32
  %and24 = and i32 %conv23, 4
  %tobool25 = icmp ne i32 %and24, 0
  br i1 %tobool25, label %if.then26, label %if.end27

if.then26:                                        ; preds = %land.lhs.true
  %40 = load %struct.lua_State.154** %L, align 8
  %41 = load %struct.Proto.160** %f, align 8
  %42 = bitcast %struct.Proto.160* %41 to %union.GCObject.155*
  %43 = load %struct.Proto.160** %clp, align 8
  %44 = bitcast %struct.Proto.160* %43 to %union.GCObject.155*
  call void bitcast (void (%struct.lua_State*, %union.GCObject*, %union.GCObject*)* @luaC_barrier_ to void (%struct.lua_State.154*, %union.GCObject.155*, %union.GCObject.155*)*)(%struct.lua_State.154* %40, %union.GCObject.155* %42, %union.GCObject.155* %44)
  br label %if.end27

if.end27:                                         ; preds = %if.then26, %land.lhs.true, %if.end14
  %45 = load %struct.Proto.160** %clp, align 8
  ret %struct.Proto.160* %45
}

; Function Attrs: nounwind uwtable
define internal void @parlist(%struct.LexState.321* %ls) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %fs = alloca %struct.FuncState.320*, align 8
  %f = alloca %struct.Proto.160*, align 8
  %nparams = alloca i32, align 4
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %fs1 = getelementptr inbounds %struct.LexState.321* %0, i32 0, i32 5
  %1 = load %struct.FuncState.320** %fs1, align 8
  store %struct.FuncState.320* %1, %struct.FuncState.320** %fs, align 8
  %2 = load %struct.FuncState.320** %fs, align 8
  %f2 = getelementptr inbounds %struct.FuncState.320* %2, i32 0, i32 0
  %3 = load %struct.Proto.160** %f2, align 8
  store %struct.Proto.160* %3, %struct.Proto.160** %f, align 8
  store i32 0, i32* %nparams, align 4
  %4 = load %struct.Proto.160** %f, align 8
  %is_vararg = getelementptr inbounds %struct.Proto.160* %4, i32 0, i32 21
  store i8 0, i8* %is_vararg, align 1
  %5 = load %struct.LexState.321** %ls.addr, align 8
  %t = getelementptr inbounds %struct.LexState.321* %5, i32 0, i32 3
  %token = getelementptr inbounds %struct.Token* %t, i32 0, i32 0
  %6 = load i32* %token, align 4
  %cmp = icmp ne i32 %6, 41
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %land.end, %if.then
  %7 = load %struct.LexState.321** %ls.addr, align 8
  %t3 = getelementptr inbounds %struct.LexState.321* %7, i32 0, i32 3
  %token4 = getelementptr inbounds %struct.Token* %t3, i32 0, i32 0
  %8 = load i32* %token4, align 4
  switch i32 %8, label %sw.default [
    i32 288, label %sw.bb
    i32 280, label %sw.bb5
  ]

sw.bb:                                            ; preds = %do.body
  %9 = load %struct.LexState.321** %ls.addr, align 8
  %10 = load %struct.LexState.321** %ls.addr, align 8
  %call = call %union.TString.143* @str_checkname(%struct.LexState.321* %10)
  call void @new_localvar(%struct.LexState.321* %9, %union.TString.143* %call)
  %11 = load i32* %nparams, align 4
  %inc = add nsw i32 %11, 1
  store i32 %inc, i32* %nparams, align 4
  br label %sw.epilog

sw.bb5:                                           ; preds = %do.body
  %12 = load %struct.LexState.321** %ls.addr, align 8
  call void bitcast (void (%struct.LexState.235*)* @luaX_next to void (%struct.LexState.321*)*)(%struct.LexState.321* %12)
  %13 = load %struct.Proto.160** %f, align 8
  %is_vararg6 = getelementptr inbounds %struct.Proto.160* %13, i32 0, i32 21
  store i8 1, i8* %is_vararg6, align 1
  br label %sw.epilog

sw.default:                                       ; preds = %do.body
  %14 = load %struct.LexState.321** %ls.addr, align 8
  call void bitcast (void (%struct.LexState.235*, i8*)* @luaX_syntaxerror to void (%struct.LexState.321*, i8*)*)(%struct.LexState.321* %14, i8* getelementptr inbounds ([25 x i8]* @.str10611, i32 0, i32 0)) #9
  unreachable

sw.epilog:                                        ; preds = %sw.bb5, %sw.bb
  br label %do.cond

do.cond:                                          ; preds = %sw.epilog
  %15 = load %struct.Proto.160** %f, align 8
  %is_vararg7 = getelementptr inbounds %struct.Proto.160* %15, i32 0, i32 21
  %16 = load i8* %is_vararg7, align 1
  %tobool = icmp ne i8 %16, 0
  br i1 %tobool, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %do.cond
  %17 = load %struct.LexState.321** %ls.addr, align 8
  %call8 = call i32 @testnext(%struct.LexState.321* %17, i32 44)
  %tobool9 = icmp ne i32 %call8, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %do.cond
  %18 = phi i1 [ false, %do.cond ], [ %tobool9, %land.rhs ]
  br i1 %18, label %do.body, label %do.end

do.end:                                           ; preds = %land.end
  br label %if.end

if.end:                                           ; preds = %do.end, %entry
  %19 = load %struct.LexState.321** %ls.addr, align 8
  %20 = load i32* %nparams, align 4
  call void @adjustlocalvars(%struct.LexState.321* %19, i32 %20)
  %21 = load %struct.FuncState.320** %fs, align 8
  %nactvar = getelementptr inbounds %struct.FuncState.320* %21, i32 0, i32 12
  %22 = load i8* %nactvar, align 1
  %23 = load %struct.Proto.160** %f, align 8
  %numparams = getelementptr inbounds %struct.Proto.160* %23, i32 0, i32 20
  store i8 %22, i8* %numparams, align 1
  %24 = load %struct.FuncState.320** %fs, align 8
  %25 = load %struct.FuncState.320** %fs, align 8
  %nactvar10 = getelementptr inbounds %struct.FuncState.320* %25, i32 0, i32 12
  %26 = load i8* %nactvar10, align 1
  %conv = zext i8 %26 to i32
  call void bitcast (void (%struct.FuncState*, i32)* @luaK_reserveregs to void (%struct.FuncState.320*, i32)*)(%struct.FuncState.320* %24, i32 %conv)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @codeclosure(%struct.LexState.321* %ls, %struct.expdesc* %v) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %v.addr = alloca %struct.expdesc*, align 8
  %fs = alloca %struct.FuncState.320*, align 8
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store %struct.expdesc* %v, %struct.expdesc** %v.addr, align 8
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %fs1 = getelementptr inbounds %struct.LexState.321* %0, i32 0, i32 5
  %1 = load %struct.FuncState.320** %fs1, align 8
  %prev = getelementptr inbounds %struct.FuncState.320* %1, i32 0, i32 2
  %2 = load %struct.FuncState.320** %prev, align 8
  store %struct.FuncState.320* %2, %struct.FuncState.320** %fs, align 8
  %3 = load %struct.expdesc** %v.addr, align 8
  %4 = load %struct.FuncState.320** %fs, align 8
  %5 = load %struct.FuncState.320** %fs, align 8
  %np = getelementptr inbounds %struct.FuncState.320* %5, i32 0, i32 9
  %6 = load i32* %np, align 4
  %sub = sub nsw i32 %6, 1
  %call = call i32 bitcast (i32 (%struct.FuncState*, i32, i32, i32)* @luaK_codeABx to i32 (%struct.FuncState.320*, i32, i32, i32)*)(%struct.FuncState.320* %4, i32 37, i32 0, i32 %sub)
  call void @init_exp(%struct.expdesc* %3, i32 11, i32 %call)
  %7 = load %struct.FuncState.320** %fs, align 8
  %8 = load %struct.expdesc** %v.addr, align 8
  call void bitcast (void (%struct.FuncState*, %struct.expdesc*)* @luaK_exp2nextreg to void (%struct.FuncState.320*, %struct.expdesc*)*)(%struct.FuncState.320* %7, %struct.expdesc* %8)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @registerlocalvar(%struct.LexState.321* %ls, %union.TString.143* %varname) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %varname.addr = alloca %union.TString.143*, align 8
  %fs = alloca %struct.FuncState.320*, align 8
  %f = alloca %struct.Proto.160*, align 8
  %oldsize = alloca i32, align 4
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store %union.TString.143* %varname, %union.TString.143** %varname.addr, align 8
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %fs1 = getelementptr inbounds %struct.LexState.321* %0, i32 0, i32 5
  %1 = load %struct.FuncState.320** %fs1, align 8
  store %struct.FuncState.320* %1, %struct.FuncState.320** %fs, align 8
  %2 = load %struct.FuncState.320** %fs, align 8
  %f2 = getelementptr inbounds %struct.FuncState.320* %2, i32 0, i32 0
  %3 = load %struct.Proto.160** %f2, align 8
  store %struct.Proto.160* %3, %struct.Proto.160** %f, align 8
  %4 = load %struct.Proto.160** %f, align 8
  %sizelocvars = getelementptr inbounds %struct.Proto.160* %4, i32 0, i32 16
  %5 = load i32* %sizelocvars, align 4
  store i32 %5, i32* %oldsize, align 4
  %6 = load %struct.FuncState.320** %fs, align 8
  %nlocvars = getelementptr inbounds %struct.FuncState.320* %6, i32 0, i32 11
  %7 = load i16* %nlocvars, align 2
  %conv = sext i16 %7 to i32
  %add = add nsw i32 %conv, 1
  %8 = load %struct.Proto.160** %f, align 8
  %sizelocvars3 = getelementptr inbounds %struct.Proto.160* %8, i32 0, i32 16
  %9 = load i32* %sizelocvars3, align 4
  %cmp = icmp sgt i32 %add, %9
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %10 = load %struct.LexState.321** %ls.addr, align 8
  %L = getelementptr inbounds %struct.LexState.321* %10, i32 0, i32 6
  %11 = load %struct.lua_State.154** %L, align 8
  %12 = load %struct.Proto.160** %f, align 8
  %locvars = getelementptr inbounds %struct.Proto.160* %12, i32 0, i32 7
  %13 = load %struct.LocVar.158** %locvars, align 8
  %14 = bitcast %struct.LocVar.158* %13 to i8*
  %15 = load %struct.Proto.160** %f, align 8
  %sizelocvars5 = getelementptr inbounds %struct.Proto.160* %15, i32 0, i32 16
  %call = call i8* bitcast (i8* (%struct.lua_State*, i8*, i32*, i64, i32, i8*)* @luaM_growaux_ to i8* (%struct.lua_State.154*, i8*, i32*, i64, i32, i8*)*)(%struct.lua_State.154* %11, i8* %14, i32* %sizelocvars5, i64 16, i32 32767, i8* getelementptr inbounds ([16 x i8]* @.str11612, i32 0, i32 0))
  %16 = bitcast i8* %call to %struct.LocVar.158*
  %17 = load %struct.Proto.160** %f, align 8
  %locvars6 = getelementptr inbounds %struct.Proto.160* %17, i32 0, i32 7
  store %struct.LocVar.158* %16, %struct.LocVar.158** %locvars6, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %18 = load i32* %oldsize, align 4
  %19 = load %struct.Proto.160** %f, align 8
  %sizelocvars7 = getelementptr inbounds %struct.Proto.160* %19, i32 0, i32 16
  %20 = load i32* %sizelocvars7, align 4
  %cmp8 = icmp slt i32 %18, %20
  br i1 %cmp8, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %21 = load i32* %oldsize, align 4
  %inc = add nsw i32 %21, 1
  store i32 %inc, i32* %oldsize, align 4
  %idxprom = sext i32 %21 to i64
  %22 = load %struct.Proto.160** %f, align 8
  %locvars10 = getelementptr inbounds %struct.Proto.160* %22, i32 0, i32 7
  %23 = load %struct.LocVar.158** %locvars10, align 8
  %arrayidx = getelementptr inbounds %struct.LocVar.158* %23, i64 %idxprom
  %varname11 = getelementptr inbounds %struct.LocVar.158* %arrayidx, i32 0, i32 0
  store %union.TString.143* null, %union.TString.143** %varname11, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %24 = load %union.TString.143** %varname.addr, align 8
  %25 = load %struct.FuncState.320** %fs, align 8
  %nlocvars12 = getelementptr inbounds %struct.FuncState.320* %25, i32 0, i32 11
  %26 = load i16* %nlocvars12, align 2
  %idxprom13 = sext i16 %26 to i64
  %27 = load %struct.Proto.160** %f, align 8
  %locvars14 = getelementptr inbounds %struct.Proto.160* %27, i32 0, i32 7
  %28 = load %struct.LocVar.158** %locvars14, align 8
  %arrayidx15 = getelementptr inbounds %struct.LocVar.158* %28, i64 %idxprom13
  %varname16 = getelementptr inbounds %struct.LocVar.158* %arrayidx15, i32 0, i32 0
  store %union.TString.143* %24, %union.TString.143** %varname16, align 8
  %29 = load %union.TString.143** %varname.addr, align 8
  %30 = bitcast %union.TString.143* %29 to %union.GCObject.155*
  %gch = bitcast %union.GCObject.155* %30 to %struct.GCheader.325*
  %marked = getelementptr inbounds %struct.GCheader.325* %gch, i32 0, i32 2
  %31 = load i8* %marked, align 1
  %conv17 = zext i8 %31 to i32
  %and = and i32 %conv17, 3
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end25

land.lhs.true:                                    ; preds = %while.end
  %32 = load %struct.Proto.160** %f, align 8
  %33 = bitcast %struct.Proto.160* %32 to %union.GCObject.155*
  %gch18 = bitcast %union.GCObject.155* %33 to %struct.GCheader.325*
  %marked19 = getelementptr inbounds %struct.GCheader.325* %gch18, i32 0, i32 2
  %34 = load i8* %marked19, align 1
  %conv20 = zext i8 %34 to i32
  %and21 = and i32 %conv20, 4
  %tobool22 = icmp ne i32 %and21, 0
  br i1 %tobool22, label %if.then23, label %if.end25

if.then23:                                        ; preds = %land.lhs.true
  %35 = load %struct.LexState.321** %ls.addr, align 8
  %L24 = getelementptr inbounds %struct.LexState.321* %35, i32 0, i32 6
  %36 = load %struct.lua_State.154** %L24, align 8
  %37 = load %struct.Proto.160** %f, align 8
  %38 = bitcast %struct.Proto.160* %37 to %union.GCObject.155*
  %39 = load %union.TString.143** %varname.addr, align 8
  %40 = bitcast %union.TString.143* %39 to %union.GCObject.155*
  call void bitcast (void (%struct.lua_State*, %union.GCObject*, %union.GCObject*)* @luaC_barrier_ to void (%struct.lua_State.154*, %union.GCObject.155*, %union.GCObject.155*)*)(%struct.lua_State.154* %36, %union.GCObject.155* %38, %union.GCObject.155* %40)
  br label %if.end25

if.end25:                                         ; preds = %if.then23, %land.lhs.true, %while.end
  %41 = load %struct.FuncState.320** %fs, align 8
  %nlocvars26 = getelementptr inbounds %struct.FuncState.320* %41, i32 0, i32 11
  %42 = load i16* %nlocvars26, align 2
  %inc27 = add i16 %42, 1
  store i16 %inc27, i16* %nlocvars26, align 2
  %conv28 = sext i16 %42 to i32
  ret i32 %conv28
}

; Function Attrs: nounwind uwtable
define internal void @closegoto(%struct.LexState.321* %ls, i32 %g, %struct.Labeldesc.311* %label) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %g.addr = alloca i32, align 4
  %label.addr = alloca %struct.Labeldesc.311*, align 8
  %i = alloca i32, align 4
  %fs = alloca %struct.FuncState.320*, align 8
  %gl = alloca %struct.Labellist.312*, align 8
  %gt2 = alloca %struct.Labeldesc.311*, align 8
  %vname = alloca %union.TString.143*, align 8
  %msg = alloca i8*, align 8
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store i32 %g, i32* %g.addr, align 4
  store %struct.Labeldesc.311* %label, %struct.Labeldesc.311** %label.addr, align 8
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %fs1 = getelementptr inbounds %struct.LexState.321* %0, i32 0, i32 5
  %1 = load %struct.FuncState.320** %fs1, align 8
  store %struct.FuncState.320* %1, %struct.FuncState.320** %fs, align 8
  %2 = load %struct.LexState.321** %ls.addr, align 8
  %dyd = getelementptr inbounds %struct.LexState.321* %2, i32 0, i32 9
  %3 = load %struct.Dyndata.313** %dyd, align 8
  %gt = getelementptr inbounds %struct.Dyndata.313* %3, i32 0, i32 1
  store %struct.Labellist.312* %gt, %struct.Labellist.312** %gl, align 8
  %4 = load i32* %g.addr, align 4
  %idxprom = sext i32 %4 to i64
  %5 = load %struct.Labellist.312** %gl, align 8
  %arr = getelementptr inbounds %struct.Labellist.312* %5, i32 0, i32 0
  %6 = load %struct.Labeldesc.311** %arr, align 8
  %arrayidx = getelementptr inbounds %struct.Labeldesc.311* %6, i64 %idxprom
  store %struct.Labeldesc.311* %arrayidx, %struct.Labeldesc.311** %gt2, align 8
  %7 = load %struct.Labeldesc.311** %gt2, align 8
  %nactvar = getelementptr inbounds %struct.Labeldesc.311* %7, i32 0, i32 3
  %8 = load i8* %nactvar, align 1
  %conv = zext i8 %8 to i32
  %9 = load %struct.Labeldesc.311** %label.addr, align 8
  %nactvar3 = getelementptr inbounds %struct.Labeldesc.311* %9, i32 0, i32 3
  %10 = load i8* %nactvar3, align 1
  %conv4 = zext i8 %10 to i32
  %cmp = icmp slt i32 %conv, %conv4
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %11 = load %struct.FuncState.320** %fs, align 8
  %12 = load %struct.Labeldesc.311** %gt2, align 8
  %nactvar6 = getelementptr inbounds %struct.Labeldesc.311* %12, i32 0, i32 3
  %13 = load i8* %nactvar6, align 1
  %conv7 = zext i8 %13 to i32
  %call = call %struct.LocVar.158* @getlocvar(%struct.FuncState.320* %11, i32 %conv7)
  %varname = getelementptr inbounds %struct.LocVar.158* %call, i32 0, i32 0
  %14 = load %union.TString.143** %varname, align 8
  store %union.TString.143* %14, %union.TString.143** %vname, align 8
  %15 = load %struct.LexState.321** %ls.addr, align 8
  %L = getelementptr inbounds %struct.LexState.321* %15, i32 0, i32 6
  %16 = load %struct.lua_State.154** %L, align 8
  %17 = load %struct.Labeldesc.311** %gt2, align 8
  %name = getelementptr inbounds %struct.Labeldesc.311* %17, i32 0, i32 0
  %18 = load %union.TString.143** %name, align 8
  %add.ptr = getelementptr inbounds %union.TString.143* %18, i64 1
  %19 = bitcast %union.TString.143* %add.ptr to i8*
  %20 = load %struct.Labeldesc.311** %gt2, align 8
  %line = getelementptr inbounds %struct.Labeldesc.311* %20, i32 0, i32 2
  %21 = load i32* %line, align 4
  %22 = load %union.TString.143** %vname, align 8
  %add.ptr8 = getelementptr inbounds %union.TString.143* %22, i64 1
  %23 = bitcast %union.TString.143* %add.ptr8 to i8*
  %call9 = call i8* (%struct.lua_State.154*, i8*, ...)* bitcast (i8* (%struct.lua_State.279*, i8*, ...)* @luaO_pushfstring to i8* (%struct.lua_State.154*, i8*, ...)*)(%struct.lua_State.154* %16, i8* getelementptr inbounds ([56 x i8]* @.str2603, i32 0, i32 0), i8* %19, i32 %21, i8* %23)
  store i8* %call9, i8** %msg, align 8
  %24 = load %struct.LexState.321** %ls.addr, align 8
  %25 = load i8** %msg, align 8
  call void @semerror(%struct.LexState.321* %24, i8* %25) #9
  unreachable

if.end:                                           ; preds = %entry
  %26 = load %struct.FuncState.320** %fs, align 8
  %27 = load %struct.Labeldesc.311** %gt2, align 8
  %pc = getelementptr inbounds %struct.Labeldesc.311* %27, i32 0, i32 1
  %28 = load i32* %pc, align 4
  %29 = load %struct.Labeldesc.311** %label.addr, align 8
  %pc10 = getelementptr inbounds %struct.Labeldesc.311* %29, i32 0, i32 1
  %30 = load i32* %pc10, align 4
  call void bitcast (void (%struct.FuncState*, i32, i32)* @luaK_patchlist to void (%struct.FuncState.320*, i32, i32)*)(%struct.FuncState.320* %26, i32 %28, i32 %30)
  %31 = load i32* %g.addr, align 4
  store i32 %31, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %32 = load i32* %i, align 4
  %33 = load %struct.Labellist.312** %gl, align 8
  %n = getelementptr inbounds %struct.Labellist.312* %33, i32 0, i32 1
  %34 = load i32* %n, align 4
  %sub = sub nsw i32 %34, 1
  %cmp11 = icmp slt i32 %32, %sub
  br i1 %cmp11, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %35 = load i32* %i, align 4
  %idxprom13 = sext i32 %35 to i64
  %36 = load %struct.Labellist.312** %gl, align 8
  %arr14 = getelementptr inbounds %struct.Labellist.312* %36, i32 0, i32 0
  %37 = load %struct.Labeldesc.311** %arr14, align 8
  %arrayidx15 = getelementptr inbounds %struct.Labeldesc.311* %37, i64 %idxprom13
  %38 = load i32* %i, align 4
  %add = add nsw i32 %38, 1
  %idxprom16 = sext i32 %add to i64
  %39 = load %struct.Labellist.312** %gl, align 8
  %arr17 = getelementptr inbounds %struct.Labellist.312* %39, i32 0, i32 0
  %40 = load %struct.Labeldesc.311** %arr17, align 8
  %arrayidx18 = getelementptr inbounds %struct.Labeldesc.311* %40, i64 %idxprom16
  %41 = bitcast %struct.Labeldesc.311* %arrayidx15 to i8*
  %42 = bitcast %struct.Labeldesc.311* %arrayidx18 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %41, i8* %42, i64 24, i32 8, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %43 = load i32* %i, align 4
  %inc = add nsw i32 %43, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %44 = load %struct.Labellist.312** %gl, align 8
  %n19 = getelementptr inbounds %struct.Labellist.312* %44, i32 0, i32 1
  %45 = load i32* %n19, align 4
  %dec = add nsw i32 %45, -1
  store i32 %dec, i32* %n19, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @primaryexp(%struct.LexState.321* %ls, %struct.expdesc* %v) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %v.addr = alloca %struct.expdesc*, align 8
  %line = alloca i32, align 4
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store %struct.expdesc* %v, %struct.expdesc** %v.addr, align 8
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %t = getelementptr inbounds %struct.LexState.321* %0, i32 0, i32 3
  %token = getelementptr inbounds %struct.Token* %t, i32 0, i32 0
  %1 = load i32* %token, align 4
  switch i32 %1, label %sw.default [
    i32 40, label %sw.bb
    i32 288, label %sw.bb1
  ]

sw.bb:                                            ; preds = %entry
  %2 = load %struct.LexState.321** %ls.addr, align 8
  %linenumber = getelementptr inbounds %struct.LexState.321* %2, i32 0, i32 1
  %3 = load i32* %linenumber, align 4
  store i32 %3, i32* %line, align 4
  %4 = load %struct.LexState.321** %ls.addr, align 8
  call void bitcast (void (%struct.LexState.235*)* @luaX_next to void (%struct.LexState.321*)*)(%struct.LexState.321* %4)
  %5 = load %struct.LexState.321** %ls.addr, align 8
  %6 = load %struct.expdesc** %v.addr, align 8
  call void @expr(%struct.LexState.321* %5, %struct.expdesc* %6)
  %7 = load %struct.LexState.321** %ls.addr, align 8
  %8 = load i32* %line, align 4
  call void @check_match(%struct.LexState.321* %7, i32 41, i32 40, i32 %8)
  %9 = load %struct.LexState.321** %ls.addr, align 8
  %fs = getelementptr inbounds %struct.LexState.321* %9, i32 0, i32 5
  %10 = load %struct.FuncState.320** %fs, align 8
  %11 = load %struct.expdesc** %v.addr, align 8
  call void bitcast (void (%struct.FuncState*, %struct.expdesc*)* @luaK_dischargevars to void (%struct.FuncState.320*, %struct.expdesc*)*)(%struct.FuncState.320* %10, %struct.expdesc* %11)
  br label %return

sw.bb1:                                           ; preds = %entry
  %12 = load %struct.LexState.321** %ls.addr, align 8
  %13 = load %struct.expdesc** %v.addr, align 8
  call void @singlevar(%struct.LexState.321* %12, %struct.expdesc* %13)
  br label %return

sw.default:                                       ; preds = %entry
  %14 = load %struct.LexState.321** %ls.addr, align 8
  call void bitcast (void (%struct.LexState.235*, i8*)* @luaX_syntaxerror to void (%struct.LexState.321*, i8*)*)(%struct.LexState.321* %14, i8* getelementptr inbounds ([18 x i8]* @.str18619, i32 0, i32 0)) #9
  unreachable

return:                                           ; preds = %sw.bb1, %sw.bb
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @yindex(%struct.LexState.321* %ls, %struct.expdesc* %v) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %v.addr = alloca %struct.expdesc*, align 8
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store %struct.expdesc* %v, %struct.expdesc** %v.addr, align 8
  %0 = load %struct.LexState.321** %ls.addr, align 8
  call void bitcast (void (%struct.LexState.235*)* @luaX_next to void (%struct.LexState.321*)*)(%struct.LexState.321* %0)
  %1 = load %struct.LexState.321** %ls.addr, align 8
  %2 = load %struct.expdesc** %v.addr, align 8
  call void @expr(%struct.LexState.321* %1, %struct.expdesc* %2)
  %3 = load %struct.LexState.321** %ls.addr, align 8
  %fs = getelementptr inbounds %struct.LexState.321* %3, i32 0, i32 5
  %4 = load %struct.FuncState.320** %fs, align 8
  %5 = load %struct.expdesc** %v.addr, align 8
  call void bitcast (void (%struct.FuncState*, %struct.expdesc*)* @luaK_exp2val to void (%struct.FuncState.320*, %struct.expdesc*)*)(%struct.FuncState.320* %4, %struct.expdesc* %5)
  %6 = load %struct.LexState.321** %ls.addr, align 8
  call void @checknext(%struct.LexState.321* %6, i32 93)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @checkname(%struct.LexState.321* %ls, %struct.expdesc* %e) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %e.addr = alloca %struct.expdesc*, align 8
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store %struct.expdesc* %e, %struct.expdesc** %e.addr, align 8
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %1 = load %struct.expdesc** %e.addr, align 8
  %2 = load %struct.LexState.321** %ls.addr, align 8
  %call = call %union.TString.143* @str_checkname(%struct.LexState.321* %2)
  call void @codestring(%struct.LexState.321* %0, %struct.expdesc* %1, %union.TString.143* %call)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @funcargs(%struct.LexState.321* %ls, %struct.expdesc* %f, i32 %line) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %f.addr = alloca %struct.expdesc*, align 8
  %line.addr = alloca i32, align 4
  %fs = alloca %struct.FuncState.320*, align 8
  %args = alloca %struct.expdesc, align 8
  %base = alloca i32, align 4
  %nparams = alloca i32, align 4
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store %struct.expdesc* %f, %struct.expdesc** %f.addr, align 8
  store i32 %line, i32* %line.addr, align 4
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %fs1 = getelementptr inbounds %struct.LexState.321* %0, i32 0, i32 5
  %1 = load %struct.FuncState.320** %fs1, align 8
  store %struct.FuncState.320* %1, %struct.FuncState.320** %fs, align 8
  %2 = load %struct.LexState.321** %ls.addr, align 8
  %t = getelementptr inbounds %struct.LexState.321* %2, i32 0, i32 3
  %token = getelementptr inbounds %struct.Token* %t, i32 0, i32 0
  %3 = load i32* %token, align 4
  switch i32 %3, label %sw.default [
    i32 40, label %sw.bb
    i32 123, label %sw.bb4
    i32 289, label %sw.bb5
  ]

sw.bb:                                            ; preds = %entry
  %4 = load %struct.LexState.321** %ls.addr, align 8
  call void bitcast (void (%struct.LexState.235*)* @luaX_next to void (%struct.LexState.321*)*)(%struct.LexState.321* %4)
  %5 = load %struct.LexState.321** %ls.addr, align 8
  %t2 = getelementptr inbounds %struct.LexState.321* %5, i32 0, i32 3
  %token3 = getelementptr inbounds %struct.Token* %t2, i32 0, i32 0
  %6 = load i32* %token3, align 4
  %cmp = icmp eq i32 %6, 41
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb
  %k = getelementptr inbounds %struct.expdesc* %args, i32 0, i32 0
  store i32 0, i32* %k, align 4
  br label %if.end

if.else:                                          ; preds = %sw.bb
  %7 = load %struct.LexState.321** %ls.addr, align 8
  %call = call i32 @explist(%struct.LexState.321* %7, %struct.expdesc* %args)
  %8 = load %struct.FuncState.320** %fs, align 8
  call void bitcast (void (%struct.FuncState*, %struct.expdesc*, i32)* @luaK_setreturns to void (%struct.FuncState.320*, %struct.expdesc*, i32)*)(%struct.FuncState.320* %8, %struct.expdesc* %args, i32 -1)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %9 = load %struct.LexState.321** %ls.addr, align 8
  %10 = load i32* %line.addr, align 4
  call void @check_match(%struct.LexState.321* %9, i32 41, i32 40, i32 %10)
  br label %sw.epilog

sw.bb4:                                           ; preds = %entry
  %11 = load %struct.LexState.321** %ls.addr, align 8
  call void @constructor(%struct.LexState.321* %11, %struct.expdesc* %args)
  br label %sw.epilog

sw.bb5:                                           ; preds = %entry
  %12 = load %struct.LexState.321** %ls.addr, align 8
  %13 = load %struct.LexState.321** %ls.addr, align 8
  %t6 = getelementptr inbounds %struct.LexState.321* %13, i32 0, i32 3
  %seminfo = getelementptr inbounds %struct.Token* %t6, i32 0, i32 1
  %ts = bitcast %union.SemInfo* %seminfo to %union.TString.143**
  %14 = load %union.TString.143** %ts, align 8
  call void @codestring(%struct.LexState.321* %12, %struct.expdesc* %args, %union.TString.143* %14)
  %15 = load %struct.LexState.321** %ls.addr, align 8
  call void bitcast (void (%struct.LexState.235*)* @luaX_next to void (%struct.LexState.321*)*)(%struct.LexState.321* %15)
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %16 = load %struct.LexState.321** %ls.addr, align 8
  call void bitcast (void (%struct.LexState.235*, i8*)* @luaX_syntaxerror to void (%struct.LexState.321*, i8*)*)(%struct.LexState.321* %16, i8* getelementptr inbounds ([28 x i8]* @.str17618, i32 0, i32 0)) #9
  unreachable

sw.epilog:                                        ; preds = %sw.bb5, %sw.bb4, %if.end
  %17 = load %struct.expdesc** %f.addr, align 8
  %u = getelementptr inbounds %struct.expdesc* %17, i32 0, i32 1
  %info = bitcast %union.anon.7* %u to i32*
  %18 = load i32* %info, align 4
  store i32 %18, i32* %base, align 4
  %k7 = getelementptr inbounds %struct.expdesc* %args, i32 0, i32 0
  %19 = load i32* %k7, align 4
  %cmp8 = icmp eq i32 %19, 12
  br i1 %cmp8, label %if.then11, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %sw.epilog
  %k9 = getelementptr inbounds %struct.expdesc* %args, i32 0, i32 0
  %20 = load i32* %k9, align 4
  %cmp10 = icmp eq i32 %20, 13
  br i1 %cmp10, label %if.then11, label %if.else12

if.then11:                                        ; preds = %lor.lhs.false, %sw.epilog
  store i32 -1, i32* %nparams, align 4
  br label %if.end17

if.else12:                                        ; preds = %lor.lhs.false
  %k13 = getelementptr inbounds %struct.expdesc* %args, i32 0, i32 0
  %21 = load i32* %k13, align 4
  %cmp14 = icmp ne i32 %21, 0
  br i1 %cmp14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.else12
  %22 = load %struct.FuncState.320** %fs, align 8
  call void bitcast (void (%struct.FuncState*, %struct.expdesc*)* @luaK_exp2nextreg to void (%struct.FuncState.320*, %struct.expdesc*)*)(%struct.FuncState.320* %22, %struct.expdesc* %args)
  br label %if.end16

if.end16:                                         ; preds = %if.then15, %if.else12
  %23 = load %struct.FuncState.320** %fs, align 8
  %freereg = getelementptr inbounds %struct.FuncState.320* %23, i32 0, i32 14
  %24 = load i8* %freereg, align 1
  %conv = zext i8 %24 to i32
  %25 = load i32* %base, align 4
  %add = add nsw i32 %25, 1
  %sub = sub nsw i32 %conv, %add
  store i32 %sub, i32* %nparams, align 4
  br label %if.end17

if.end17:                                         ; preds = %if.end16, %if.then11
  %26 = load %struct.expdesc** %f.addr, align 8
  %27 = load %struct.FuncState.320** %fs, align 8
  %28 = load i32* %base, align 4
  %29 = load i32* %nparams, align 4
  %add18 = add nsw i32 %29, 1
  %call19 = call i32 bitcast (i32 (%struct.FuncState*, i32, i32, i32, i32)* @luaK_codeABC to i32 (%struct.FuncState.320*, i32, i32, i32, i32)*)(%struct.FuncState.320* %27, i32 29, i32 %28, i32 %add18, i32 2)
  call void @init_exp(%struct.expdesc* %26, i32 12, i32 %call19)
  %30 = load %struct.FuncState.320** %fs, align 8
  %31 = load i32* %line.addr, align 4
  call void bitcast (void (%struct.FuncState*, i32)* @luaK_fixline to void (%struct.FuncState.320*, i32)*)(%struct.FuncState.320* %30, i32 %31)
  %32 = load i32* %base, align 4
  %add20 = add nsw i32 %32, 1
  %conv21 = trunc i32 %add20 to i8
  %33 = load %struct.FuncState.320** %fs, align 8
  %freereg22 = getelementptr inbounds %struct.FuncState.320* %33, i32 0, i32 14
  store i8 %conv21, i8* %freereg22, align 1
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @check_conflict(%struct.LexState.321* %ls, %struct.LHS_assign* %lh, %struct.expdesc* %v) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %lh.addr = alloca %struct.LHS_assign*, align 8
  %v.addr = alloca %struct.expdesc*, align 8
  %fs = alloca %struct.FuncState.320*, align 8
  %extra = alloca i32, align 4
  %conflict = alloca i32, align 4
  %op = alloca i32, align 4
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store %struct.LHS_assign* %lh, %struct.LHS_assign** %lh.addr, align 8
  store %struct.expdesc* %v, %struct.expdesc** %v.addr, align 8
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %fs1 = getelementptr inbounds %struct.LexState.321* %0, i32 0, i32 5
  %1 = load %struct.FuncState.320** %fs1, align 8
  store %struct.FuncState.320* %1, %struct.FuncState.320** %fs, align 8
  %2 = load %struct.FuncState.320** %fs, align 8
  %freereg = getelementptr inbounds %struct.FuncState.320* %2, i32 0, i32 14
  %3 = load i8* %freereg, align 1
  %conv = zext i8 %3 to i32
  store i32 %conv, i32* %extra, align 4
  store i32 0, i32* %conflict, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %4 = load %struct.LHS_assign** %lh.addr, align 8
  %tobool = icmp ne %struct.LHS_assign* %4, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load %struct.LHS_assign** %lh.addr, align 8
  %v2 = getelementptr inbounds %struct.LHS_assign* %5, i32 0, i32 1
  %k = getelementptr inbounds %struct.expdesc* %v2, i32 0, i32 0
  %6 = load i32* %k, align 4
  %cmp = icmp eq i32 %6, 9
  br i1 %cmp, label %if.then, label %if.end45

if.then:                                          ; preds = %for.body
  %7 = load %struct.LHS_assign** %lh.addr, align 8
  %v4 = getelementptr inbounds %struct.LHS_assign* %7, i32 0, i32 1
  %u = getelementptr inbounds %struct.expdesc* %v4, i32 0, i32 1
  %ind = bitcast %union.anon.7* %u to %struct.anon.8*
  %vt = getelementptr inbounds %struct.anon.8* %ind, i32 0, i32 2
  %8 = load i8* %vt, align 1
  %conv5 = zext i8 %8 to i32
  %9 = load %struct.expdesc** %v.addr, align 8
  %k6 = getelementptr inbounds %struct.expdesc* %9, i32 0, i32 0
  %10 = load i32* %k6, align 4
  %cmp7 = icmp eq i32 %conv5, %10
  br i1 %cmp7, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then
  %11 = load %struct.LHS_assign** %lh.addr, align 8
  %v9 = getelementptr inbounds %struct.LHS_assign* %11, i32 0, i32 1
  %u10 = getelementptr inbounds %struct.expdesc* %v9, i32 0, i32 1
  %ind11 = bitcast %union.anon.7* %u10 to %struct.anon.8*
  %t = getelementptr inbounds %struct.anon.8* %ind11, i32 0, i32 1
  %12 = load i8* %t, align 1
  %conv12 = zext i8 %12 to i32
  %13 = load %struct.expdesc** %v.addr, align 8
  %u13 = getelementptr inbounds %struct.expdesc* %13, i32 0, i32 1
  %info = bitcast %union.anon.7* %u13 to i32*
  %14 = load i32* %info, align 4
  %cmp14 = icmp eq i32 %conv12, %14
  br i1 %cmp14, label %if.then16, label %if.end

if.then16:                                        ; preds = %land.lhs.true
  store i32 1, i32* %conflict, align 4
  %15 = load %struct.LHS_assign** %lh.addr, align 8
  %v17 = getelementptr inbounds %struct.LHS_assign* %15, i32 0, i32 1
  %u18 = getelementptr inbounds %struct.expdesc* %v17, i32 0, i32 1
  %ind19 = bitcast %union.anon.7* %u18 to %struct.anon.8*
  %vt20 = getelementptr inbounds %struct.anon.8* %ind19, i32 0, i32 2
  store i8 7, i8* %vt20, align 1
  %16 = load i32* %extra, align 4
  %conv21 = trunc i32 %16 to i8
  %17 = load %struct.LHS_assign** %lh.addr, align 8
  %v22 = getelementptr inbounds %struct.LHS_assign* %17, i32 0, i32 1
  %u23 = getelementptr inbounds %struct.expdesc* %v22, i32 0, i32 1
  %ind24 = bitcast %union.anon.7* %u23 to %struct.anon.8*
  %t25 = getelementptr inbounds %struct.anon.8* %ind24, i32 0, i32 1
  store i8 %conv21, i8* %t25, align 1
  br label %if.end

if.end:                                           ; preds = %if.then16, %land.lhs.true, %if.then
  %18 = load %struct.expdesc** %v.addr, align 8
  %k26 = getelementptr inbounds %struct.expdesc* %18, i32 0, i32 0
  %19 = load i32* %k26, align 4
  %cmp27 = icmp eq i32 %19, 7
  br i1 %cmp27, label %land.lhs.true29, label %if.end44

land.lhs.true29:                                  ; preds = %if.end
  %20 = load %struct.LHS_assign** %lh.addr, align 8
  %v30 = getelementptr inbounds %struct.LHS_assign* %20, i32 0, i32 1
  %u31 = getelementptr inbounds %struct.expdesc* %v30, i32 0, i32 1
  %ind32 = bitcast %union.anon.7* %u31 to %struct.anon.8*
  %idx = getelementptr inbounds %struct.anon.8* %ind32, i32 0, i32 0
  %21 = load i16* %idx, align 2
  %conv33 = sext i16 %21 to i32
  %22 = load %struct.expdesc** %v.addr, align 8
  %u34 = getelementptr inbounds %struct.expdesc* %22, i32 0, i32 1
  %info35 = bitcast %union.anon.7* %u34 to i32*
  %23 = load i32* %info35, align 4
  %cmp36 = icmp eq i32 %conv33, %23
  br i1 %cmp36, label %if.then38, label %if.end44

if.then38:                                        ; preds = %land.lhs.true29
  store i32 1, i32* %conflict, align 4
  %24 = load i32* %extra, align 4
  %conv39 = trunc i32 %24 to i16
  %25 = load %struct.LHS_assign** %lh.addr, align 8
  %v40 = getelementptr inbounds %struct.LHS_assign* %25, i32 0, i32 1
  %u41 = getelementptr inbounds %struct.expdesc* %v40, i32 0, i32 1
  %ind42 = bitcast %union.anon.7* %u41 to %struct.anon.8*
  %idx43 = getelementptr inbounds %struct.anon.8* %ind42, i32 0, i32 0
  store i16 %conv39, i16* %idx43, align 2
  br label %if.end44

if.end44:                                         ; preds = %if.then38, %land.lhs.true29, %if.end
  br label %if.end45

if.end45:                                         ; preds = %if.end44, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end45
  %26 = load %struct.LHS_assign** %lh.addr, align 8
  %prev = getelementptr inbounds %struct.LHS_assign* %26, i32 0, i32 0
  %27 = load %struct.LHS_assign** %prev, align 8
  store %struct.LHS_assign* %27, %struct.LHS_assign** %lh.addr, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %28 = load i32* %conflict, align 4
  %tobool46 = icmp ne i32 %28, 0
  br i1 %tobool46, label %if.then47, label %if.end53

if.then47:                                        ; preds = %for.end
  %29 = load %struct.expdesc** %v.addr, align 8
  %k48 = getelementptr inbounds %struct.expdesc* %29, i32 0, i32 0
  %30 = load i32* %k48, align 4
  %cmp49 = icmp eq i32 %30, 7
  %cond = select i1 %cmp49, i32 0, i32 5
  store i32 %cond, i32* %op, align 4
  %31 = load %struct.FuncState.320** %fs, align 8
  %32 = load i32* %op, align 4
  %33 = load i32* %extra, align 4
  %34 = load %struct.expdesc** %v.addr, align 8
  %u51 = getelementptr inbounds %struct.expdesc* %34, i32 0, i32 1
  %info52 = bitcast %union.anon.7* %u51 to i32*
  %35 = load i32* %info52, align 4
  %call = call i32 bitcast (i32 (%struct.FuncState*, i32, i32, i32, i32)* @luaK_codeABC to i32 (%struct.FuncState.320*, i32, i32, i32, i32)*)(%struct.FuncState.320* %31, i32 %32, i32 %33, i32 %35, i32 0)
  %36 = load %struct.FuncState.320** %fs, align 8
  call void bitcast (void (%struct.FuncState*, i32)* @luaK_reserveregs to void (%struct.FuncState.320*, i32)*)(%struct.FuncState.320* %36, i32 1)
  br label %if.end53

if.end53:                                         ; preds = %if.then47, %for.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @subexpr(%struct.LexState.321* %ls, %struct.expdesc* %v, i32 %limit) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %v.addr = alloca %struct.expdesc*, align 8
  %limit.addr = alloca i32, align 4
  %op = alloca i32, align 4
  %uop = alloca i32, align 4
  %line = alloca i32, align 4
  %v2 = alloca %struct.expdesc, align 8
  %nextop = alloca i32, align 4
  %line8 = alloca i32, align 4
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store %struct.expdesc* %v, %struct.expdesc** %v.addr, align 8
  store i32 %limit, i32* %limit.addr, align 4
  %0 = load %struct.LexState.321** %ls.addr, align 8
  call void @enterlevel(%struct.LexState.321* %0)
  %1 = load %struct.LexState.321** %ls.addr, align 8
  %t = getelementptr inbounds %struct.LexState.321* %1, i32 0, i32 3
  %token = getelementptr inbounds %struct.Token* %t, i32 0, i32 0
  %2 = load i32* %token, align 4
  %call = call i32 @getunopr(i32 %2)
  store i32 %call, i32* %uop, align 4
  %3 = load i32* %uop, align 4
  %cmp = icmp ne i32 %3, 3
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %4 = load %struct.LexState.321** %ls.addr, align 8
  %linenumber = getelementptr inbounds %struct.LexState.321* %4, i32 0, i32 1
  %5 = load i32* %linenumber, align 4
  store i32 %5, i32* %line, align 4
  %6 = load %struct.LexState.321** %ls.addr, align 8
  call void bitcast (void (%struct.LexState.235*)* @luaX_next to void (%struct.LexState.321*)*)(%struct.LexState.321* %6)
  %7 = load %struct.LexState.321** %ls.addr, align 8
  %8 = load %struct.expdesc** %v.addr, align 8
  %call1 = call i32 @subexpr(%struct.LexState.321* %7, %struct.expdesc* %8, i32 8)
  %9 = load %struct.LexState.321** %ls.addr, align 8
  %fs = getelementptr inbounds %struct.LexState.321* %9, i32 0, i32 5
  %10 = load %struct.FuncState.320** %fs, align 8
  %11 = load i32* %uop, align 4
  %12 = load %struct.expdesc** %v.addr, align 8
  %13 = load i32* %line, align 4
  call void bitcast (void (%struct.FuncState*, i32, %struct.expdesc*, i32)* @luaK_prefix to void (%struct.FuncState.320*, i32, %struct.expdesc*, i32)*)(%struct.FuncState.320* %10, i32 %11, %struct.expdesc* %12, i32 %13)
  br label %if.end

if.else:                                          ; preds = %entry
  %14 = load %struct.LexState.321** %ls.addr, align 8
  %15 = load %struct.expdesc** %v.addr, align 8
  call void @simpleexp(%struct.LexState.321* %14, %struct.expdesc* %15)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %16 = load %struct.LexState.321** %ls.addr, align 8
  %t2 = getelementptr inbounds %struct.LexState.321* %16, i32 0, i32 3
  %token3 = getelementptr inbounds %struct.Token* %t2, i32 0, i32 0
  %17 = load i32* %token3, align 4
  %call4 = call i32 @getbinopr(i32 %17)
  store i32 %call4, i32* %op, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %18 = load i32* %op, align 4
  %cmp5 = icmp ne i32 %18, 15
  br i1 %cmp5, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %19 = load i32* %op, align 4
  %idxprom = zext i32 %19 to i64
  %arrayidx = getelementptr inbounds [15 x %struct.anon.9]* @priority, i32 0, i64 %idxprom
  %left = getelementptr inbounds %struct.anon.9* %arrayidx, i32 0, i32 0
  %20 = load i8* %left, align 1
  %conv = zext i8 %20 to i32
  %21 = load i32* %limit.addr, align 4
  %cmp6 = icmp sgt i32 %conv, %21
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %22 = phi i1 [ false, %while.cond ], [ %cmp6, %land.rhs ]
  br i1 %22, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %23 = load %struct.LexState.321** %ls.addr, align 8
  %linenumber9 = getelementptr inbounds %struct.LexState.321* %23, i32 0, i32 1
  %24 = load i32* %linenumber9, align 4
  store i32 %24, i32* %line8, align 4
  %25 = load %struct.LexState.321** %ls.addr, align 8
  call void bitcast (void (%struct.LexState.235*)* @luaX_next to void (%struct.LexState.321*)*)(%struct.LexState.321* %25)
  %26 = load %struct.LexState.321** %ls.addr, align 8
  %fs10 = getelementptr inbounds %struct.LexState.321* %26, i32 0, i32 5
  %27 = load %struct.FuncState.320** %fs10, align 8
  %28 = load i32* %op, align 4
  %29 = load %struct.expdesc** %v.addr, align 8
  call void bitcast (void (%struct.FuncState*, i32, %struct.expdesc*)* @luaK_infix to void (%struct.FuncState.320*, i32, %struct.expdesc*)*)(%struct.FuncState.320* %27, i32 %28, %struct.expdesc* %29)
  %30 = load %struct.LexState.321** %ls.addr, align 8
  %31 = load i32* %op, align 4
  %idxprom11 = zext i32 %31 to i64
  %arrayidx12 = getelementptr inbounds [15 x %struct.anon.9]* @priority, i32 0, i64 %idxprom11
  %right = getelementptr inbounds %struct.anon.9* %arrayidx12, i32 0, i32 1
  %32 = load i8* %right, align 1
  %conv13 = zext i8 %32 to i32
  %call14 = call i32 @subexpr(%struct.LexState.321* %30, %struct.expdesc* %v2, i32 %conv13)
  store i32 %call14, i32* %nextop, align 4
  %33 = load %struct.LexState.321** %ls.addr, align 8
  %fs15 = getelementptr inbounds %struct.LexState.321* %33, i32 0, i32 5
  %34 = load %struct.FuncState.320** %fs15, align 8
  %35 = load i32* %op, align 4
  %36 = load %struct.expdesc** %v.addr, align 8
  %37 = load i32* %line8, align 4
  call void bitcast (void (%struct.FuncState*, i32, %struct.expdesc*, %struct.expdesc*, i32)* @luaK_posfix to void (%struct.FuncState.320*, i32, %struct.expdesc*, %struct.expdesc*, i32)*)(%struct.FuncState.320* %34, i32 %35, %struct.expdesc* %36, %struct.expdesc* %v2, i32 %37)
  %38 = load i32* %nextop, align 4
  store i32 %38, i32* %op, align 4
  br label %while.cond

while.end:                                        ; preds = %land.end
  %39 = load %struct.LexState.321** %ls.addr, align 8
  %L = getelementptr inbounds %struct.LexState.321* %39, i32 0, i32 6
  %40 = load %struct.lua_State.154** %L, align 8
  %nCcalls = getelementptr inbounds %struct.lua_State.154* %40, i32 0, i32 12
  %41 = load i16* %nCcalls, align 2
  %dec = add i16 %41, -1
  store i16 %dec, i16* %nCcalls, align 2
  %42 = load i32* %op, align 4
  ret i32 %42
}

; Function Attrs: nounwind uwtable
define internal i32 @singlevaraux(%struct.FuncState.320* %fs, %union.TString.143* %n, %struct.expdesc* %var, i32 %base) #0 {
entry:
  %retval = alloca i32, align 4
  %fs.addr = alloca %struct.FuncState.320*, align 8
  %n.addr = alloca %union.TString.143*, align 8
  %var.addr = alloca %struct.expdesc*, align 8
  %base.addr = alloca i32, align 4
  %v = alloca i32, align 4
  %idx = alloca i32, align 4
  store %struct.FuncState.320* %fs, %struct.FuncState.320** %fs.addr, align 8
  store %union.TString.143* %n, %union.TString.143** %n.addr, align 8
  store %struct.expdesc* %var, %struct.expdesc** %var.addr, align 8
  store i32 %base, i32* %base.addr, align 4
  %0 = load %struct.FuncState.320** %fs.addr, align 8
  %cmp = icmp eq %struct.FuncState.320* %0, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval
  br label %return

if.else:                                          ; preds = %entry
  %1 = load %struct.FuncState.320** %fs.addr, align 8
  %2 = load %union.TString.143** %n.addr, align 8
  %call = call i32 @searchvar(%struct.FuncState.320* %1, %union.TString.143* %2)
  store i32 %call, i32* %v, align 4
  %3 = load i32* %v, align 4
  %cmp1 = icmp sge i32 %3, 0
  br i1 %cmp1, label %if.then2, label %if.else4

if.then2:                                         ; preds = %if.else
  %4 = load %struct.expdesc** %var.addr, align 8
  %5 = load i32* %v, align 4
  call void @init_exp(%struct.expdesc* %4, i32 7, i32 %5)
  %6 = load i32* %base.addr, align 4
  %tobool = icmp ne i32 %6, 0
  br i1 %tobool, label %if.end, label %if.then3

if.then3:                                         ; preds = %if.then2
  %7 = load %struct.FuncState.320** %fs.addr, align 8
  %8 = load i32* %v, align 4
  call void @markupval(%struct.FuncState.320* %7, i32 %8)
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.then2
  store i32 7, i32* %retval
  br label %return

if.else4:                                         ; preds = %if.else
  %9 = load %struct.FuncState.320** %fs.addr, align 8
  %10 = load %union.TString.143** %n.addr, align 8
  %call5 = call i32 @searchupvalue(%struct.FuncState.320* %9, %union.TString.143* %10)
  store i32 %call5, i32* %idx, align 4
  %11 = load i32* %idx, align 4
  %cmp6 = icmp slt i32 %11, 0
  br i1 %cmp6, label %if.then7, label %if.end13

if.then7:                                         ; preds = %if.else4
  %12 = load %struct.FuncState.320** %fs.addr, align 8
  %prev = getelementptr inbounds %struct.FuncState.320* %12, i32 0, i32 2
  %13 = load %struct.FuncState.320** %prev, align 8
  %14 = load %union.TString.143** %n.addr, align 8
  %15 = load %struct.expdesc** %var.addr, align 8
  %call8 = call i32 @singlevaraux(%struct.FuncState.320* %13, %union.TString.143* %14, %struct.expdesc* %15, i32 0)
  %cmp9 = icmp eq i32 %call8, 0
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.then7
  store i32 0, i32* %retval
  br label %return

if.end11:                                         ; preds = %if.then7
  %16 = load %struct.FuncState.320** %fs.addr, align 8
  %17 = load %union.TString.143** %n.addr, align 8
  %18 = load %struct.expdesc** %var.addr, align 8
  %call12 = call i32 @newupvalue(%struct.FuncState.320* %16, %union.TString.143* %17, %struct.expdesc* %18)
  store i32 %call12, i32* %idx, align 4
  br label %if.end13

if.end13:                                         ; preds = %if.end11, %if.else4
  %19 = load %struct.expdesc** %var.addr, align 8
  %20 = load i32* %idx, align 4
  call void @init_exp(%struct.expdesc* %19, i32 8, i32 %20)
  store i32 8, i32* %retval
  br label %return

return:                                           ; preds = %if.end13, %if.then10, %if.end, %if.then
  %21 = load i32* %retval
  ret i32 %21
}

; Function Attrs: nounwind uwtable
define internal void @codestring(%struct.LexState.321* %ls, %struct.expdesc* %e, %union.TString.143* %s) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %e.addr = alloca %struct.expdesc*, align 8
  %s.addr = alloca %union.TString.143*, align 8
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store %struct.expdesc* %e, %struct.expdesc** %e.addr, align 8
  store %union.TString.143* %s, %union.TString.143** %s.addr, align 8
  %0 = load %struct.expdesc** %e.addr, align 8
  %1 = load %struct.LexState.321** %ls.addr, align 8
  %fs = getelementptr inbounds %struct.LexState.321* %1, i32 0, i32 5
  %2 = load %struct.FuncState.320** %fs, align 8
  %3 = load %union.TString.143** %s.addr, align 8
  %call = call i32 bitcast (i32 (%struct.FuncState*, %union.TString.19*)* @luaK_stringK to i32 (%struct.FuncState.320*, %union.TString.143*)*)(%struct.FuncState.320* %2, %union.TString.143* %3)
  call void @init_exp(%struct.expdesc* %0, i32 4, i32 %call)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @constructor(%struct.LexState.321* %ls, %struct.expdesc* %t) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %t.addr = alloca %struct.expdesc*, align 8
  %fs = alloca %struct.FuncState.320*, align 8
  %line = alloca i32, align 4
  %pc = alloca i32, align 4
  %cc = alloca %struct.ConsControl, align 8
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store %struct.expdesc* %t, %struct.expdesc** %t.addr, align 8
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %fs1 = getelementptr inbounds %struct.LexState.321* %0, i32 0, i32 5
  %1 = load %struct.FuncState.320** %fs1, align 8
  store %struct.FuncState.320* %1, %struct.FuncState.320** %fs, align 8
  %2 = load %struct.LexState.321** %ls.addr, align 8
  %linenumber = getelementptr inbounds %struct.LexState.321* %2, i32 0, i32 1
  %3 = load i32* %linenumber, align 4
  store i32 %3, i32* %line, align 4
  %4 = load %struct.FuncState.320** %fs, align 8
  %call = call i32 bitcast (i32 (%struct.FuncState*, i32, i32, i32, i32)* @luaK_codeABC to i32 (%struct.FuncState.320*, i32, i32, i32, i32)*)(%struct.FuncState.320* %4, i32 11, i32 0, i32 0, i32 0)
  store i32 %call, i32* %pc, align 4
  %tostore = getelementptr inbounds %struct.ConsControl* %cc, i32 0, i32 4
  store i32 0, i32* %tostore, align 4
  %nh = getelementptr inbounds %struct.ConsControl* %cc, i32 0, i32 2
  store i32 0, i32* %nh, align 4
  %na = getelementptr inbounds %struct.ConsControl* %cc, i32 0, i32 3
  store i32 0, i32* %na, align 4
  %5 = load %struct.expdesc** %t.addr, align 8
  %t2 = getelementptr inbounds %struct.ConsControl* %cc, i32 0, i32 1
  store %struct.expdesc* %5, %struct.expdesc** %t2, align 8
  %6 = load %struct.expdesc** %t.addr, align 8
  %7 = load i32* %pc, align 4
  call void @init_exp(%struct.expdesc* %6, i32 11, i32 %7)
  %v = getelementptr inbounds %struct.ConsControl* %cc, i32 0, i32 0
  call void @init_exp(%struct.expdesc* %v, i32 0, i32 0)
  %8 = load %struct.LexState.321** %ls.addr, align 8
  %fs3 = getelementptr inbounds %struct.LexState.321* %8, i32 0, i32 5
  %9 = load %struct.FuncState.320** %fs3, align 8
  %10 = load %struct.expdesc** %t.addr, align 8
  call void bitcast (void (%struct.FuncState*, %struct.expdesc*)* @luaK_exp2nextreg to void (%struct.FuncState.320*, %struct.expdesc*)*)(%struct.FuncState.320* %9, %struct.expdesc* %10)
  %11 = load %struct.LexState.321** %ls.addr, align 8
  call void @checknext(%struct.LexState.321* %11, i32 123)
  br label %do.body

do.body:                                          ; preds = %lor.end, %entry
  %12 = load %struct.LexState.321** %ls.addr, align 8
  %t4 = getelementptr inbounds %struct.LexState.321* %12, i32 0, i32 3
  %token = getelementptr inbounds %struct.Token* %t4, i32 0, i32 0
  %13 = load i32* %token, align 4
  %cmp = icmp eq i32 %13, 125
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  br label %do.end

if.end:                                           ; preds = %do.body
  %14 = load %struct.FuncState.320** %fs, align 8
  call void @closelistfield(%struct.FuncState.320* %14, %struct.ConsControl* %cc)
  %15 = load %struct.LexState.321** %ls.addr, align 8
  call void @field(%struct.LexState.321* %15, %struct.ConsControl* %cc)
  br label %do.cond

do.cond:                                          ; preds = %if.end
  %16 = load %struct.LexState.321** %ls.addr, align 8
  %call5 = call i32 @testnext(%struct.LexState.321* %16, i32 44)
  %tobool = icmp ne i32 %call5, 0
  br i1 %tobool, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %do.cond
  %17 = load %struct.LexState.321** %ls.addr, align 8
  %call6 = call i32 @testnext(%struct.LexState.321* %17, i32 59)
  %tobool7 = icmp ne i32 %call6, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %do.cond
  %18 = phi i1 [ true, %do.cond ], [ %tobool7, %lor.rhs ]
  br i1 %18, label %do.body, label %do.end

do.end:                                           ; preds = %lor.end, %if.then
  %19 = load %struct.LexState.321** %ls.addr, align 8
  %20 = load i32* %line, align 4
  call void @check_match(%struct.LexState.321* %19, i32 125, i32 123, i32 %20)
  %21 = load %struct.FuncState.320** %fs, align 8
  call void @lastlistfield(%struct.FuncState.320* %21, %struct.ConsControl* %cc)
  %22 = load i32* %pc, align 4
  %idxprom = sext i32 %22 to i64
  %23 = load %struct.FuncState.320** %fs, align 8
  %f = getelementptr inbounds %struct.FuncState.320* %23, i32 0, i32 0
  %24 = load %struct.Proto.160** %f, align 8
  %code = getelementptr inbounds %struct.Proto.160* %24, i32 0, i32 4
  %25 = load i32** %code, align 8
  %arrayidx = getelementptr inbounds i32* %25, i64 %idxprom
  %26 = load i32* %arrayidx, align 4
  %and = and i32 %26, 8388607
  %na8 = getelementptr inbounds %struct.ConsControl* %cc, i32 0, i32 3
  %27 = load i32* %na8, align 4
  %call9 = call i32 @luaO_int2fb(i32 %27)
  %shl = shl i32 %call9, 23
  %and10 = and i32 %shl, -8388608
  %or = or i32 %and, %and10
  %28 = load i32* %pc, align 4
  %idxprom11 = sext i32 %28 to i64
  %29 = load %struct.FuncState.320** %fs, align 8
  %f12 = getelementptr inbounds %struct.FuncState.320* %29, i32 0, i32 0
  %30 = load %struct.Proto.160** %f12, align 8
  %code13 = getelementptr inbounds %struct.Proto.160* %30, i32 0, i32 4
  %31 = load i32** %code13, align 8
  %arrayidx14 = getelementptr inbounds i32* %31, i64 %idxprom11
  store i32 %or, i32* %arrayidx14, align 4
  %32 = load i32* %pc, align 4
  %idxprom15 = sext i32 %32 to i64
  %33 = load %struct.FuncState.320** %fs, align 8
  %f16 = getelementptr inbounds %struct.FuncState.320* %33, i32 0, i32 0
  %34 = load %struct.Proto.160** %f16, align 8
  %code17 = getelementptr inbounds %struct.Proto.160* %34, i32 0, i32 4
  %35 = load i32** %code17, align 8
  %arrayidx18 = getelementptr inbounds i32* %35, i64 %idxprom15
  %36 = load i32* %arrayidx18, align 4
  %and19 = and i32 %36, -8372225
  %nh20 = getelementptr inbounds %struct.ConsControl* %cc, i32 0, i32 2
  %37 = load i32* %nh20, align 4
  %call21 = call i32 @luaO_int2fb(i32 %37)
  %shl22 = shl i32 %call21, 14
  %and23 = and i32 %shl22, 8372224
  %or24 = or i32 %and19, %and23
  %38 = load i32* %pc, align 4
  %idxprom25 = sext i32 %38 to i64
  %39 = load %struct.FuncState.320** %fs, align 8
  %f26 = getelementptr inbounds %struct.FuncState.320* %39, i32 0, i32 0
  %40 = load %struct.Proto.160** %f26, align 8
  %code27 = getelementptr inbounds %struct.Proto.160* %40, i32 0, i32 4
  %41 = load i32** %code27, align 8
  %arrayidx28 = getelementptr inbounds i32* %41, i64 %idxprom25
  store i32 %or24, i32* %arrayidx28, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @getunopr(i32 %op) #0 {
entry:
  %retval = alloca i32, align 4
  %op.addr = alloca i32, align 4
  store i32 %op, i32* %op.addr, align 4
  %0 = load i32* %op.addr, align 4
  switch i32 %0, label %sw.default [
    i32 271, label %sw.bb
    i32 45, label %sw.bb1
    i32 35, label %sw.bb2
  ]

sw.bb:                                            ; preds = %entry
  store i32 1, i32* %retval
  br label %return

sw.bb1:                                           ; preds = %entry
  store i32 0, i32* %retval
  br label %return

sw.bb2:                                           ; preds = %entry
  store i32 2, i32* %retval
  br label %return

sw.default:                                       ; preds = %entry
  store i32 3, i32* %retval
  br label %return

return:                                           ; preds = %sw.default, %sw.bb2, %sw.bb1, %sw.bb
  %1 = load i32* %retval
  ret i32 %1
}

; Function Attrs: nounwind uwtable
define internal void @simpleexp(%struct.LexState.321* %ls, %struct.expdesc* %v) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %v.addr = alloca %struct.expdesc*, align 8
  %fs = alloca %struct.FuncState.320*, align 8
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store %struct.expdesc* %v, %struct.expdesc** %v.addr, align 8
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %t = getelementptr inbounds %struct.LexState.321* %0, i32 0, i32 3
  %token = getelementptr inbounds %struct.Token* %t, i32 0, i32 0
  %1 = load i32* %token, align 4
  switch i32 %1, label %sw.default [
    i32 287, label %sw.bb
    i32 289, label %sw.bb2
    i32 270, label %sw.bb5
    i32 276, label %sw.bb6
    i32 263, label %sw.bb7
    i32 280, label %sw.bb8
    i32 123, label %sw.bb10
    i32 265, label %sw.bb11
  ]

sw.bb:                                            ; preds = %entry
  %2 = load %struct.expdesc** %v.addr, align 8
  call void @init_exp(%struct.expdesc* %2, i32 5, i32 0)
  %3 = load %struct.LexState.321** %ls.addr, align 8
  %t1 = getelementptr inbounds %struct.LexState.321* %3, i32 0, i32 3
  %seminfo = getelementptr inbounds %struct.Token* %t1, i32 0, i32 1
  %r = bitcast %union.SemInfo* %seminfo to double*
  %4 = load double* %r, align 8
  %5 = load %struct.expdesc** %v.addr, align 8
  %u = getelementptr inbounds %struct.expdesc* %5, i32 0, i32 1
  %nval = bitcast %union.anon.7* %u to double*
  store double %4, double* %nval, align 8
  br label %sw.epilog

sw.bb2:                                           ; preds = %entry
  %6 = load %struct.LexState.321** %ls.addr, align 8
  %7 = load %struct.expdesc** %v.addr, align 8
  %8 = load %struct.LexState.321** %ls.addr, align 8
  %t3 = getelementptr inbounds %struct.LexState.321* %8, i32 0, i32 3
  %seminfo4 = getelementptr inbounds %struct.Token* %t3, i32 0, i32 1
  %ts = bitcast %union.SemInfo* %seminfo4 to %union.TString.143**
  %9 = load %union.TString.143** %ts, align 8
  call void @codestring(%struct.LexState.321* %6, %struct.expdesc* %7, %union.TString.143* %9)
  br label %sw.epilog

sw.bb5:                                           ; preds = %entry
  %10 = load %struct.expdesc** %v.addr, align 8
  call void @init_exp(%struct.expdesc* %10, i32 1, i32 0)
  br label %sw.epilog

sw.bb6:                                           ; preds = %entry
  %11 = load %struct.expdesc** %v.addr, align 8
  call void @init_exp(%struct.expdesc* %11, i32 2, i32 0)
  br label %sw.epilog

sw.bb7:                                           ; preds = %entry
  %12 = load %struct.expdesc** %v.addr, align 8
  call void @init_exp(%struct.expdesc* %12, i32 3, i32 0)
  br label %sw.epilog

sw.bb8:                                           ; preds = %entry
  %13 = load %struct.LexState.321** %ls.addr, align 8
  %fs9 = getelementptr inbounds %struct.LexState.321* %13, i32 0, i32 5
  %14 = load %struct.FuncState.320** %fs9, align 8
  store %struct.FuncState.320* %14, %struct.FuncState.320** %fs, align 8
  %15 = load %struct.FuncState.320** %fs, align 8
  %f = getelementptr inbounds %struct.FuncState.320* %15, i32 0, i32 0
  %16 = load %struct.Proto.160** %f, align 8
  %is_vararg = getelementptr inbounds %struct.Proto.160* %16, i32 0, i32 21
  %17 = load i8* %is_vararg, align 1
  %tobool = icmp ne i8 %17, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %sw.bb8
  %18 = load %struct.LexState.321** %ls.addr, align 8
  call void bitcast (void (%struct.LexState.235*, i8*)* @luaX_syntaxerror to void (%struct.LexState.321*, i8*)*)(%struct.LexState.321* %18, i8* getelementptr inbounds ([43 x i8]* @.str8609, i32 0, i32 0)) #9
  unreachable

if.end:                                           ; preds = %sw.bb8
  %19 = load %struct.expdesc** %v.addr, align 8
  %20 = load %struct.FuncState.320** %fs, align 8
  %call = call i32 bitcast (i32 (%struct.FuncState*, i32, i32, i32, i32)* @luaK_codeABC to i32 (%struct.FuncState.320*, i32, i32, i32, i32)*)(%struct.FuncState.320* %20, i32 38, i32 0, i32 1, i32 0)
  call void @init_exp(%struct.expdesc* %19, i32 13, i32 %call)
  br label %sw.epilog

sw.bb10:                                          ; preds = %entry
  %21 = load %struct.LexState.321** %ls.addr, align 8
  %22 = load %struct.expdesc** %v.addr, align 8
  call void @constructor(%struct.LexState.321* %21, %struct.expdesc* %22)
  br label %return

sw.bb11:                                          ; preds = %entry
  %23 = load %struct.LexState.321** %ls.addr, align 8
  call void bitcast (void (%struct.LexState.235*)* @luaX_next to void (%struct.LexState.321*)*)(%struct.LexState.321* %23)
  %24 = load %struct.LexState.321** %ls.addr, align 8
  %25 = load %struct.expdesc** %v.addr, align 8
  %26 = load %struct.LexState.321** %ls.addr, align 8
  %linenumber = getelementptr inbounds %struct.LexState.321* %26, i32 0, i32 1
  %27 = load i32* %linenumber, align 4
  call void @body(%struct.LexState.321* %24, %struct.expdesc* %25, i32 0, i32 %27)
  br label %return

sw.default:                                       ; preds = %entry
  %28 = load %struct.LexState.321** %ls.addr, align 8
  %29 = load %struct.expdesc** %v.addr, align 8
  call void @suffixedexp(%struct.LexState.321* %28, %struct.expdesc* %29)
  br label %return

sw.epilog:                                        ; preds = %if.end, %sw.bb7, %sw.bb6, %sw.bb5, %sw.bb2, %sw.bb
  %30 = load %struct.LexState.321** %ls.addr, align 8
  call void bitcast (void (%struct.LexState.235*)* @luaX_next to void (%struct.LexState.321*)*)(%struct.LexState.321* %30)
  br label %return

return:                                           ; preds = %sw.epilog, %sw.default, %sw.bb11, %sw.bb10
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @getbinopr(i32 %op) #0 {
entry:
  %retval = alloca i32, align 4
  %op.addr = alloca i32, align 4
  store i32 %op, i32* %op.addr, align 4
  %0 = load i32* %op.addr, align 4
  switch i32 %0, label %sw.default [
    i32 43, label %sw.bb
    i32 45, label %sw.bb1
    i32 42, label %sw.bb2
    i32 47, label %sw.bb3
    i32 37, label %sw.bb4
    i32 94, label %sw.bb5
    i32 279, label %sw.bb6
    i32 284, label %sw.bb7
    i32 281, label %sw.bb8
    i32 60, label %sw.bb9
    i32 283, label %sw.bb10
    i32 62, label %sw.bb11
    i32 282, label %sw.bb12
    i32 257, label %sw.bb13
    i32 272, label %sw.bb14
  ]

sw.bb:                                            ; preds = %entry
  store i32 0, i32* %retval
  br label %return

sw.bb1:                                           ; preds = %entry
  store i32 1, i32* %retval
  br label %return

sw.bb2:                                           ; preds = %entry
  store i32 2, i32* %retval
  br label %return

sw.bb3:                                           ; preds = %entry
  store i32 3, i32* %retval
  br label %return

sw.bb4:                                           ; preds = %entry
  store i32 4, i32* %retval
  br label %return

sw.bb5:                                           ; preds = %entry
  store i32 5, i32* %retval
  br label %return

sw.bb6:                                           ; preds = %entry
  store i32 6, i32* %retval
  br label %return

sw.bb7:                                           ; preds = %entry
  store i32 10, i32* %retval
  br label %return

sw.bb8:                                           ; preds = %entry
  store i32 7, i32* %retval
  br label %return

sw.bb9:                                           ; preds = %entry
  store i32 8, i32* %retval
  br label %return

sw.bb10:                                          ; preds = %entry
  store i32 9, i32* %retval
  br label %return

sw.bb11:                                          ; preds = %entry
  store i32 11, i32* %retval
  br label %return

sw.bb12:                                          ; preds = %entry
  store i32 12, i32* %retval
  br label %return

sw.bb13:                                          ; preds = %entry
  store i32 13, i32* %retval
  br label %return

sw.bb14:                                          ; preds = %entry
  store i32 14, i32* %retval
  br label %return

sw.default:                                       ; preds = %entry
  store i32 15, i32* %retval
  br label %return

return:                                           ; preds = %sw.default, %sw.bb14, %sw.bb13, %sw.bb12, %sw.bb11, %sw.bb10, %sw.bb9, %sw.bb8, %sw.bb7, %sw.bb6, %sw.bb5, %sw.bb4, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb
  %1 = load i32* %retval
  ret i32 %1
}

; Function Attrs: nounwind uwtable
define internal i32 @searchvar(%struct.FuncState.320* %fs, %union.TString.143* %n) #0 {
entry:
  %retval = alloca i32, align 4
  %fs.addr = alloca %struct.FuncState.320*, align 8
  %n.addr = alloca %union.TString.143*, align 8
  %i = alloca i32, align 4
  store %struct.FuncState.320* %fs, %struct.FuncState.320** %fs.addr, align 8
  store %union.TString.143* %n, %union.TString.143** %n.addr, align 8
  %0 = load %struct.FuncState.320** %fs.addr, align 8
  %nactvar = getelementptr inbounds %struct.FuncState.320* %0, i32 0, i32 12
  %1 = load i8* %nactvar, align 1
  %conv = zext i8 %1 to i32
  %sub = sub nsw i32 %conv, 1
  store i32 %sub, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32* %i, align 4
  %cmp = icmp sge i32 %2, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %union.TString.143** %n.addr, align 8
  %4 = load %struct.FuncState.320** %fs.addr, align 8
  %5 = load i32* %i, align 4
  %call = call %struct.LocVar.158* @getlocvar(%struct.FuncState.320* %4, i32 %5)
  %varname = getelementptr inbounds %struct.LocVar.158* %call, i32 0, i32 0
  %6 = load %union.TString.143** %varname, align 8
  %call2 = call i32 bitcast (i32 (%union.TString.367*, %union.TString.367*)* @luaS_eqstr to i32 (%union.TString.143*, %union.TString.143*)*)(%union.TString.143* %3, %union.TString.143* %6)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %7 = load i32* %i, align 4
  store i32 %7, i32* %retval
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %8 = load i32* %i, align 4
  %dec = add nsw i32 %8, -1
  store i32 %dec, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 -1, i32* %retval
  br label %return

return:                                           ; preds = %for.end, %if.then
  %9 = load i32* %retval
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define internal void @markupval(%struct.FuncState.320* %fs, i32 %level) #0 {
entry:
  %fs.addr = alloca %struct.FuncState.320*, align 8
  %level.addr = alloca i32, align 4
  %bl = alloca %struct.BlockCnt*, align 8
  store %struct.FuncState.320* %fs, %struct.FuncState.320** %fs.addr, align 8
  store i32 %level, i32* %level.addr, align 4
  %0 = load %struct.FuncState.320** %fs.addr, align 8
  %bl1 = getelementptr inbounds %struct.FuncState.320* %0, i32 0, i32 4
  %1 = load %struct.BlockCnt** %bl1, align 8
  store %struct.BlockCnt* %1, %struct.BlockCnt** %bl, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %2 = load %struct.BlockCnt** %bl, align 8
  %nactvar = getelementptr inbounds %struct.BlockCnt* %2, i32 0, i32 3
  %3 = load i8* %nactvar, align 1
  %conv = zext i8 %3 to i32
  %4 = load i32* %level.addr, align 4
  %cmp = icmp sgt i32 %conv, %4
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %5 = load %struct.BlockCnt** %bl, align 8
  %previous = getelementptr inbounds %struct.BlockCnt* %5, i32 0, i32 0
  %6 = load %struct.BlockCnt** %previous, align 8
  store %struct.BlockCnt* %6, %struct.BlockCnt** %bl, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %7 = load %struct.BlockCnt** %bl, align 8
  %upval = getelementptr inbounds %struct.BlockCnt* %7, i32 0, i32 4
  store i8 1, i8* %upval, align 1
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @searchupvalue(%struct.FuncState.320* %fs, %union.TString.143* %name) #0 {
entry:
  %retval = alloca i32, align 4
  %fs.addr = alloca %struct.FuncState.320*, align 8
  %name.addr = alloca %union.TString.143*, align 8
  %i = alloca i32, align 4
  %up = alloca %struct.Upvaldesc.159*, align 8
  store %struct.FuncState.320* %fs, %struct.FuncState.320** %fs.addr, align 8
  store %union.TString.143* %name, %union.TString.143** %name.addr, align 8
  %0 = load %struct.FuncState.320** %fs.addr, align 8
  %f = getelementptr inbounds %struct.FuncState.320* %0, i32 0, i32 0
  %1 = load %struct.Proto.160** %f, align 8
  %upvalues = getelementptr inbounds %struct.Proto.160* %1, i32 0, i32 8
  %2 = load %struct.Upvaldesc.159** %upvalues, align 8
  store %struct.Upvaldesc.159* %2, %struct.Upvaldesc.159** %up, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %3 = load i32* %i, align 4
  %4 = load %struct.FuncState.320** %fs.addr, align 8
  %nups = getelementptr inbounds %struct.FuncState.320* %4, i32 0, i32 13
  %5 = load i8* %nups, align 1
  %conv = zext i8 %5 to i32
  %cmp = icmp slt i32 %3, %conv
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load i32* %i, align 4
  %idxprom = sext i32 %6 to i64
  %7 = load %struct.Upvaldesc.159** %up, align 8
  %arrayidx = getelementptr inbounds %struct.Upvaldesc.159* %7, i64 %idxprom
  %name2 = getelementptr inbounds %struct.Upvaldesc.159* %arrayidx, i32 0, i32 0
  %8 = load %union.TString.143** %name2, align 8
  %9 = load %union.TString.143** %name.addr, align 8
  %call = call i32 bitcast (i32 (%union.TString.367*, %union.TString.367*)* @luaS_eqstr to i32 (%union.TString.143*, %union.TString.143*)*)(%union.TString.143* %8, %union.TString.143* %9)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %10 = load i32* %i, align 4
  store i32 %10, i32* %retval
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %11 = load i32* %i, align 4
  %inc = add nsw i32 %11, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 -1, i32* %retval
  br label %return

return:                                           ; preds = %for.end, %if.then
  %12 = load i32* %retval
  ret i32 %12
}

; Function Attrs: nounwind uwtable
define internal void @closelistfield(%struct.FuncState.320* %fs, %struct.ConsControl* %cc) #0 {
entry:
  %fs.addr = alloca %struct.FuncState.320*, align 8
  %cc.addr = alloca %struct.ConsControl*, align 8
  store %struct.FuncState.320* %fs, %struct.FuncState.320** %fs.addr, align 8
  store %struct.ConsControl* %cc, %struct.ConsControl** %cc.addr, align 8
  %0 = load %struct.ConsControl** %cc.addr, align 8
  %v = getelementptr inbounds %struct.ConsControl* %0, i32 0, i32 0
  %k = getelementptr inbounds %struct.expdesc* %v, i32 0, i32 0
  %1 = load i32* %k, align 4
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end8

if.end:                                           ; preds = %entry
  %2 = load %struct.FuncState.320** %fs.addr, align 8
  %3 = load %struct.ConsControl** %cc.addr, align 8
  %v1 = getelementptr inbounds %struct.ConsControl* %3, i32 0, i32 0
  call void bitcast (void (%struct.FuncState*, %struct.expdesc*)* @luaK_exp2nextreg to void (%struct.FuncState.320*, %struct.expdesc*)*)(%struct.FuncState.320* %2, %struct.expdesc* %v1)
  %4 = load %struct.ConsControl** %cc.addr, align 8
  %v2 = getelementptr inbounds %struct.ConsControl* %4, i32 0, i32 0
  %k3 = getelementptr inbounds %struct.expdesc* %v2, i32 0, i32 0
  store i32 0, i32* %k3, align 4
  %5 = load %struct.ConsControl** %cc.addr, align 8
  %tostore = getelementptr inbounds %struct.ConsControl* %5, i32 0, i32 4
  %6 = load i32* %tostore, align 4
  %cmp4 = icmp eq i32 %6, 50
  br i1 %cmp4, label %if.then5, label %if.end8

if.then5:                                         ; preds = %if.end
  %7 = load %struct.FuncState.320** %fs.addr, align 8
  %8 = load %struct.ConsControl** %cc.addr, align 8
  %t = getelementptr inbounds %struct.ConsControl* %8, i32 0, i32 1
  %9 = load %struct.expdesc** %t, align 8
  %u = getelementptr inbounds %struct.expdesc* %9, i32 0, i32 1
  %info = bitcast %union.anon.7* %u to i32*
  %10 = load i32* %info, align 4
  %11 = load %struct.ConsControl** %cc.addr, align 8
  %na = getelementptr inbounds %struct.ConsControl* %11, i32 0, i32 3
  %12 = load i32* %na, align 4
  %13 = load %struct.ConsControl** %cc.addr, align 8
  %tostore6 = getelementptr inbounds %struct.ConsControl* %13, i32 0, i32 4
  %14 = load i32* %tostore6, align 4
  call void bitcast (void (%struct.FuncState*, i32, i32, i32)* @luaK_setlist to void (%struct.FuncState.320*, i32, i32, i32)*)(%struct.FuncState.320* %7, i32 %10, i32 %12, i32 %14)
  %15 = load %struct.ConsControl** %cc.addr, align 8
  %tostore7 = getelementptr inbounds %struct.ConsControl* %15, i32 0, i32 4
  store i32 0, i32* %tostore7, align 4
  br label %if.end8

if.end8:                                          ; preds = %if.then5, %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @field(%struct.LexState.321* %ls, %struct.ConsControl* %cc) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %cc.addr = alloca %struct.ConsControl*, align 8
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store %struct.ConsControl* %cc, %struct.ConsControl** %cc.addr, align 8
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %t = getelementptr inbounds %struct.LexState.321* %0, i32 0, i32 3
  %token = getelementptr inbounds %struct.Token* %t, i32 0, i32 0
  %1 = load i32* %token, align 4
  switch i32 %1, label %sw.default [
    i32 288, label %sw.bb
    i32 91, label %sw.bb1
  ]

sw.bb:                                            ; preds = %entry
  %2 = load %struct.LexState.321** %ls.addr, align 8
  %call = call i32 bitcast (i32 (%struct.LexState.235*)* @luaX_lookahead to i32 (%struct.LexState.321*)*)(%struct.LexState.321* %2)
  %cmp = icmp ne i32 %call, 61
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb
  %3 = load %struct.LexState.321** %ls.addr, align 8
  %4 = load %struct.ConsControl** %cc.addr, align 8
  call void @listfield(%struct.LexState.321* %3, %struct.ConsControl* %4)
  br label %if.end

if.else:                                          ; preds = %sw.bb
  %5 = load %struct.LexState.321** %ls.addr, align 8
  %6 = load %struct.ConsControl** %cc.addr, align 8
  call void @recfield(%struct.LexState.321* %5, %struct.ConsControl* %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  %7 = load %struct.LexState.321** %ls.addr, align 8
  %8 = load %struct.ConsControl** %cc.addr, align 8
  call void @recfield(%struct.LexState.321* %7, %struct.ConsControl* %8)
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %9 = load %struct.LexState.321** %ls.addr, align 8
  %10 = load %struct.ConsControl** %cc.addr, align 8
  call void @listfield(%struct.LexState.321* %9, %struct.ConsControl* %10)
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb1, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @lastlistfield(%struct.FuncState.320* %fs, %struct.ConsControl* %cc) #0 {
entry:
  %fs.addr = alloca %struct.FuncState.320*, align 8
  %cc.addr = alloca %struct.ConsControl*, align 8
  store %struct.FuncState.320* %fs, %struct.FuncState.320** %fs.addr, align 8
  store %struct.ConsControl* %cc, %struct.ConsControl** %cc.addr, align 8
  %0 = load %struct.ConsControl** %cc.addr, align 8
  %tostore = getelementptr inbounds %struct.ConsControl* %0, i32 0, i32 4
  %1 = load i32* %tostore, align 4
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end19

if.end:                                           ; preds = %entry
  %2 = load %struct.ConsControl** %cc.addr, align 8
  %v = getelementptr inbounds %struct.ConsControl* %2, i32 0, i32 0
  %k = getelementptr inbounds %struct.expdesc* %v, i32 0, i32 0
  %3 = load i32* %k, align 4
  %cmp1 = icmp eq i32 %3, 12
  br i1 %cmp1, label %if.then5, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %4 = load %struct.ConsControl** %cc.addr, align 8
  %v2 = getelementptr inbounds %struct.ConsControl* %4, i32 0, i32 0
  %k3 = getelementptr inbounds %struct.expdesc* %v2, i32 0, i32 0
  %5 = load i32* %k3, align 4
  %cmp4 = icmp eq i32 %5, 13
  br i1 %cmp4, label %if.then5, label %if.else

if.then5:                                         ; preds = %lor.lhs.false, %if.end
  %6 = load %struct.FuncState.320** %fs.addr, align 8
  %7 = load %struct.ConsControl** %cc.addr, align 8
  %v6 = getelementptr inbounds %struct.ConsControl* %7, i32 0, i32 0
  call void bitcast (void (%struct.FuncState*, %struct.expdesc*, i32)* @luaK_setreturns to void (%struct.FuncState.320*, %struct.expdesc*, i32)*)(%struct.FuncState.320* %6, %struct.expdesc* %v6, i32 -1)
  %8 = load %struct.FuncState.320** %fs.addr, align 8
  %9 = load %struct.ConsControl** %cc.addr, align 8
  %t = getelementptr inbounds %struct.ConsControl* %9, i32 0, i32 1
  %10 = load %struct.expdesc** %t, align 8
  %u = getelementptr inbounds %struct.expdesc* %10, i32 0, i32 1
  %info = bitcast %union.anon.7* %u to i32*
  %11 = load i32* %info, align 4
  %12 = load %struct.ConsControl** %cc.addr, align 8
  %na = getelementptr inbounds %struct.ConsControl* %12, i32 0, i32 3
  %13 = load i32* %na, align 4
  call void bitcast (void (%struct.FuncState*, i32, i32, i32)* @luaK_setlist to void (%struct.FuncState.320*, i32, i32, i32)*)(%struct.FuncState.320* %8, i32 %11, i32 %13, i32 -1)
  %14 = load %struct.ConsControl** %cc.addr, align 8
  %na7 = getelementptr inbounds %struct.ConsControl* %14, i32 0, i32 3
  %15 = load i32* %na7, align 4
  %dec = add nsw i32 %15, -1
  store i32 %dec, i32* %na7, align 4
  br label %if.end19

if.else:                                          ; preds = %lor.lhs.false
  %16 = load %struct.ConsControl** %cc.addr, align 8
  %v8 = getelementptr inbounds %struct.ConsControl* %16, i32 0, i32 0
  %k9 = getelementptr inbounds %struct.expdesc* %v8, i32 0, i32 0
  %17 = load i32* %k9, align 4
  %cmp10 = icmp ne i32 %17, 0
  br i1 %cmp10, label %if.then11, label %if.end13

if.then11:                                        ; preds = %if.else
  %18 = load %struct.FuncState.320** %fs.addr, align 8
  %19 = load %struct.ConsControl** %cc.addr, align 8
  %v12 = getelementptr inbounds %struct.ConsControl* %19, i32 0, i32 0
  call void bitcast (void (%struct.FuncState*, %struct.expdesc*)* @luaK_exp2nextreg to void (%struct.FuncState.320*, %struct.expdesc*)*)(%struct.FuncState.320* %18, %struct.expdesc* %v12)
  br label %if.end13

if.end13:                                         ; preds = %if.then11, %if.else
  %20 = load %struct.FuncState.320** %fs.addr, align 8
  %21 = load %struct.ConsControl** %cc.addr, align 8
  %t14 = getelementptr inbounds %struct.ConsControl* %21, i32 0, i32 1
  %22 = load %struct.expdesc** %t14, align 8
  %u15 = getelementptr inbounds %struct.expdesc* %22, i32 0, i32 1
  %info16 = bitcast %union.anon.7* %u15 to i32*
  %23 = load i32* %info16, align 4
  %24 = load %struct.ConsControl** %cc.addr, align 8
  %na17 = getelementptr inbounds %struct.ConsControl* %24, i32 0, i32 3
  %25 = load i32* %na17, align 4
  %26 = load %struct.ConsControl** %cc.addr, align 8
  %tostore18 = getelementptr inbounds %struct.ConsControl* %26, i32 0, i32 4
  %27 = load i32* %tostore18, align 4
  call void bitcast (void (%struct.FuncState*, i32, i32, i32)* @luaK_setlist to void (%struct.FuncState.320*, i32, i32, i32)*)(%struct.FuncState.320* %20, i32 %23, i32 %25, i32 %27)
  br label %if.end19

if.end19:                                         ; preds = %if.end13, %if.then5, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @listfield(%struct.LexState.321* %ls, %struct.ConsControl* %cc) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %cc.addr = alloca %struct.ConsControl*, align 8
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store %struct.ConsControl* %cc, %struct.ConsControl** %cc.addr, align 8
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %1 = load %struct.ConsControl** %cc.addr, align 8
  %v = getelementptr inbounds %struct.ConsControl* %1, i32 0, i32 0
  call void @expr(%struct.LexState.321* %0, %struct.expdesc* %v)
  %2 = load %struct.LexState.321** %ls.addr, align 8
  %fs = getelementptr inbounds %struct.LexState.321* %2, i32 0, i32 5
  %3 = load %struct.FuncState.320** %fs, align 8
  %4 = load %struct.ConsControl** %cc.addr, align 8
  %na = getelementptr inbounds %struct.ConsControl* %4, i32 0, i32 3
  %5 = load i32* %na, align 4
  call void @checklimit(%struct.FuncState.320* %3, i32 %5, i32 2147483645, i8* getelementptr inbounds ([23 x i8]* @.str13614, i32 0, i32 0))
  %6 = load %struct.ConsControl** %cc.addr, align 8
  %na1 = getelementptr inbounds %struct.ConsControl* %6, i32 0, i32 3
  %7 = load i32* %na1, align 4
  %inc = add nsw i32 %7, 1
  store i32 %inc, i32* %na1, align 4
  %8 = load %struct.ConsControl** %cc.addr, align 8
  %tostore = getelementptr inbounds %struct.ConsControl* %8, i32 0, i32 4
  %9 = load i32* %tostore, align 4
  %inc2 = add nsw i32 %9, 1
  store i32 %inc2, i32* %tostore, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @recfield(%struct.LexState.321* %ls, %struct.ConsControl* %cc) #0 {
entry:
  %ls.addr = alloca %struct.LexState.321*, align 8
  %cc.addr = alloca %struct.ConsControl*, align 8
  %fs = alloca %struct.FuncState.320*, align 8
  %reg = alloca i32, align 4
  %key = alloca %struct.expdesc, align 8
  %val = alloca %struct.expdesc, align 8
  %rkkey = alloca i32, align 4
  store %struct.LexState.321* %ls, %struct.LexState.321** %ls.addr, align 8
  store %struct.ConsControl* %cc, %struct.ConsControl** %cc.addr, align 8
  %0 = load %struct.LexState.321** %ls.addr, align 8
  %fs1 = getelementptr inbounds %struct.LexState.321* %0, i32 0, i32 5
  %1 = load %struct.FuncState.320** %fs1, align 8
  store %struct.FuncState.320* %1, %struct.FuncState.320** %fs, align 8
  %2 = load %struct.LexState.321** %ls.addr, align 8
  %fs2 = getelementptr inbounds %struct.LexState.321* %2, i32 0, i32 5
  %3 = load %struct.FuncState.320** %fs2, align 8
  %freereg = getelementptr inbounds %struct.FuncState.320* %3, i32 0, i32 14
  %4 = load i8* %freereg, align 1
  %conv = zext i8 %4 to i32
  store i32 %conv, i32* %reg, align 4
  %5 = load %struct.LexState.321** %ls.addr, align 8
  %t = getelementptr inbounds %struct.LexState.321* %5, i32 0, i32 3
  %token = getelementptr inbounds %struct.Token* %t, i32 0, i32 0
  %6 = load i32* %token, align 4
  %cmp = icmp eq i32 %6, 288
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %7 = load %struct.FuncState.320** %fs, align 8
  %8 = load %struct.ConsControl** %cc.addr, align 8
  %nh = getelementptr inbounds %struct.ConsControl* %8, i32 0, i32 2
  %9 = load i32* %nh, align 4
  call void @checklimit(%struct.FuncState.320* %7, i32 %9, i32 2147483645, i8* getelementptr inbounds ([23 x i8]* @.str13614, i32 0, i32 0))
  %10 = load %struct.LexState.321** %ls.addr, align 8
  call void @checkname(%struct.LexState.321* %10, %struct.expdesc* %key)
  br label %if.end

if.else:                                          ; preds = %entry
  %11 = load %struct.LexState.321** %ls.addr, align 8
  call void @yindex(%struct.LexState.321* %11, %struct.expdesc* %key)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %12 = load %struct.ConsControl** %cc.addr, align 8
  %nh4 = getelementptr inbounds %struct.ConsControl* %12, i32 0, i32 2
  %13 = load i32* %nh4, align 4
  %inc = add nsw i32 %13, 1
  store i32 %inc, i32* %nh4, align 4
  %14 = load %struct.LexState.321** %ls.addr, align 8
  call void @checknext(%struct.LexState.321* %14, i32 61)
  %15 = load %struct.FuncState.320** %fs, align 8
  %call = call i32 bitcast (i32 (%struct.FuncState*, %struct.expdesc*)* @luaK_exp2RK to i32 (%struct.FuncState.320*, %struct.expdesc*)*)(%struct.FuncState.320* %15, %struct.expdesc* %key)
  store i32 %call, i32* %rkkey, align 4
  %16 = load %struct.LexState.321** %ls.addr, align 8
  call void @expr(%struct.LexState.321* %16, %struct.expdesc* %val)
  %17 = load %struct.FuncState.320** %fs, align 8
  %18 = load %struct.ConsControl** %cc.addr, align 8
  %t5 = getelementptr inbounds %struct.ConsControl* %18, i32 0, i32 1
  %19 = load %struct.expdesc** %t5, align 8
  %u = getelementptr inbounds %struct.expdesc* %19, i32 0, i32 1
  %info = bitcast %union.anon.7* %u to i32*
  %20 = load i32* %info, align 4
  %21 = load i32* %rkkey, align 4
  %22 = load %struct.FuncState.320** %fs, align 8
  %call6 = call i32 bitcast (i32 (%struct.FuncState*, %struct.expdesc*)* @luaK_exp2RK to i32 (%struct.FuncState.320*, %struct.expdesc*)*)(%struct.FuncState.320* %22, %struct.expdesc* %val)
  %call7 = call i32 bitcast (i32 (%struct.FuncState*, i32, i32, i32, i32)* @luaK_codeABC to i32 (%struct.FuncState.320*, i32, i32, i32, i32)*)(%struct.FuncState.320* %17, i32 10, i32 %20, i32 %21, i32 %call6)
  %23 = load i32* %reg, align 4
  %conv8 = trunc i32 %23 to i8
  %24 = load %struct.FuncState.320** %fs, align 8
  %freereg9 = getelementptr inbounds %struct.FuncState.320* %24, i32 0, i32 14
  store i8 %conv8, i8* %freereg9, align 1
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @luaE_setdebt(%struct.global_State.337* %g, i64 %debt) #0 {
entry:
  %g.addr = alloca %struct.global_State.337*, align 8
  %debt.addr = alloca i64, align 8
  store %struct.global_State.337* %g, %struct.global_State.337** %g.addr, align 8
  store i64 %debt, i64* %debt.addr, align 8
  %0 = load i64* %debt.addr, align 8
  %1 = load %struct.global_State.337** %g.addr, align 8
  %GCdebt = getelementptr inbounds %struct.global_State.337* %1, i32 0, i32 3
  %2 = load i64* %GCdebt, align 8
  %sub = sub nsw i64 %0, %2
  %3 = load %struct.global_State.337** %g.addr, align 8
  %totalbytes = getelementptr inbounds %struct.global_State.337* %3, i32 0, i32 2
  %4 = load i64* %totalbytes, align 8
  %sub1 = sub i64 %4, %sub
  store i64 %sub1, i64* %totalbytes, align 8
  %5 = load i64* %debt.addr, align 8
  %6 = load %struct.global_State.337** %g.addr, align 8
  %GCdebt2 = getelementptr inbounds %struct.global_State.337* %6, i32 0, i32 3
  store i64 %5, i64* %GCdebt2, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define hidden %struct.CallInfo.340* @luaE_extendCI(%struct.lua_State.343* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State.343*, align 8
  %ci = alloca %struct.CallInfo.340*, align 8
  store %struct.lua_State.343* %L, %struct.lua_State.343** %L.addr, align 8
  %0 = load %struct.lua_State.343** %L.addr, align 8
  %call = call i8* bitcast (i8* (%struct.lua_State*, i8*, i64, i64)* @luaM_realloc_ to i8* (%struct.lua_State.343*, i8*, i64, i64)*)(%struct.lua_State.343* %0, i8* null, i64 0, i64 80)
  %1 = bitcast i8* %call to %struct.CallInfo.340*
  store %struct.CallInfo.340* %1, %struct.CallInfo.340** %ci, align 8
  %2 = load %struct.CallInfo.340** %ci, align 8
  %3 = load %struct.lua_State.343** %L.addr, align 8
  %ci1 = getelementptr inbounds %struct.lua_State.343* %3, i32 0, i32 6
  %4 = load %struct.CallInfo.340** %ci1, align 8
  %next = getelementptr inbounds %struct.CallInfo.340* %4, i32 0, i32 3
  store %struct.CallInfo.340* %2, %struct.CallInfo.340** %next, align 8
  %5 = load %struct.lua_State.343** %L.addr, align 8
  %ci2 = getelementptr inbounds %struct.lua_State.343* %5, i32 0, i32 6
  %6 = load %struct.CallInfo.340** %ci2, align 8
  %7 = load %struct.CallInfo.340** %ci, align 8
  %previous = getelementptr inbounds %struct.CallInfo.340* %7, i32 0, i32 2
  store %struct.CallInfo.340* %6, %struct.CallInfo.340** %previous, align 8
  %8 = load %struct.CallInfo.340** %ci, align 8
  %next3 = getelementptr inbounds %struct.CallInfo.340* %8, i32 0, i32 3
  store %struct.CallInfo.340* null, %struct.CallInfo.340** %next3, align 8
  %9 = load %struct.CallInfo.340** %ci, align 8
  ret %struct.CallInfo.340* %9
}

; Function Attrs: nounwind uwtable
define hidden void @luaE_freeCI(%struct.lua_State.343* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State.343*, align 8
  %ci = alloca %struct.CallInfo.340*, align 8
  %next = alloca %struct.CallInfo.340*, align 8
  store %struct.lua_State.343* %L, %struct.lua_State.343** %L.addr, align 8
  %0 = load %struct.lua_State.343** %L.addr, align 8
  %ci1 = getelementptr inbounds %struct.lua_State.343* %0, i32 0, i32 6
  %1 = load %struct.CallInfo.340** %ci1, align 8
  store %struct.CallInfo.340* %1, %struct.CallInfo.340** %ci, align 8
  %2 = load %struct.CallInfo.340** %ci, align 8
  %next2 = getelementptr inbounds %struct.CallInfo.340* %2, i32 0, i32 3
  %3 = load %struct.CallInfo.340** %next2, align 8
  store %struct.CallInfo.340* %3, %struct.CallInfo.340** %next, align 8
  %4 = load %struct.CallInfo.340** %ci, align 8
  %next3 = getelementptr inbounds %struct.CallInfo.340* %4, i32 0, i32 3
  store %struct.CallInfo.340* null, %struct.CallInfo.340** %next3, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %5 = load %struct.CallInfo.340** %next, align 8
  store %struct.CallInfo.340* %5, %struct.CallInfo.340** %ci, align 8
  %cmp = icmp ne %struct.CallInfo.340* %5, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %6 = load %struct.CallInfo.340** %ci, align 8
  %next4 = getelementptr inbounds %struct.CallInfo.340* %6, i32 0, i32 3
  %7 = load %struct.CallInfo.340** %next4, align 8
  store %struct.CallInfo.340* %7, %struct.CallInfo.340** %next, align 8
  %8 = load %struct.lua_State.343** %L.addr, align 8
  %9 = load %struct.CallInfo.340** %ci, align 8
  %10 = bitcast %struct.CallInfo.340* %9 to i8*
  %call = call i8* bitcast (i8* (%struct.lua_State*, i8*, i64, i64)* @luaM_realloc_ to i8* (%struct.lua_State.343*, i8*, i64, i64)*)(%struct.lua_State.343* %8, i8* %10, i64 80, i64 0)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.lua_State.343* @lua_newthread(%struct.lua_State.343* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State.343*, align 8
  %L1 = alloca %struct.lua_State.343*, align 8
  %io = alloca %struct.lua_TValue.346*, align 8
  store %struct.lua_State.343* %L, %struct.lua_State.343** %L.addr, align 8
  %0 = load %struct.lua_State.343** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State.343* %0, i32 0, i32 5
  %1 = load %struct.global_State.337** %l_G, align 8
  %GCdebt = getelementptr inbounds %struct.global_State.337* %1, i32 0, i32 3
  %2 = load i64* %GCdebt, align 8
  %cmp = icmp sgt i64 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load %struct.lua_State.343** %L.addr, align 8
  call void bitcast (void (%struct.lua_State*)* @luaC_step to void (%struct.lua_State.343*)*)(%struct.lua_State.343* %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load %struct.lua_State.343** %L.addr, align 8
  %call = call %union.GCObject.344* bitcast (%union.GCObject* (%struct.lua_State*, i32, i64, %union.GCObject**, i32)* @luaC_newobj to %union.GCObject.344* (%struct.lua_State.343*, i32, i64, %union.GCObject.344**, i32)*)(%struct.lua_State.343* %4, i32 8, i64 208, %union.GCObject.344** null, i32 0)
  %th = bitcast %union.GCObject.344* %call to %struct.lua_State.343*
  store %struct.lua_State.343* %th, %struct.lua_State.343** %L1, align 8
  %5 = load %struct.lua_State.343** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State.343* %5, i32 0, i32 4
  %6 = load %struct.lua_TValue.346** %top, align 8
  store %struct.lua_TValue.346* %6, %struct.lua_TValue.346** %io, align 8
  %7 = load %struct.lua_State.343** %L1, align 8
  %8 = bitcast %struct.lua_State.343* %7 to %union.GCObject.344*
  %9 = load %struct.lua_TValue.346** %io, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue.346* %9, i32 0, i32 0
  %gc = bitcast %union.Value.345* %value_ to %union.GCObject.344**
  store %union.GCObject.344* %8, %union.GCObject.344** %gc, align 8
  %10 = load %struct.lua_TValue.346** %io, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue.346* %10, i32 0, i32 1
  store i32 72, i32* %tt_, align 4
  %11 = load %struct.lua_State.343** %L.addr, align 8
  %top1 = getelementptr inbounds %struct.lua_State.343* %11, i32 0, i32 4
  %12 = load %struct.lua_TValue.346** %top1, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue.346* %12, i32 1
  store %struct.lua_TValue.346* %incdec.ptr, %struct.lua_TValue.346** %top1, align 8
  %13 = load %struct.lua_State.343** %L1, align 8
  %14 = load %struct.lua_State.343** %L.addr, align 8
  %l_G2 = getelementptr inbounds %struct.lua_State.343* %14, i32 0, i32 5
  %15 = load %struct.global_State.337** %l_G2, align 8
  call void @preinit_state(%struct.lua_State.343* %13, %struct.global_State.337* %15)
  %16 = load %struct.lua_State.343** %L.addr, align 8
  %hookmask = getelementptr inbounds %struct.lua_State.343* %16, i32 0, i32 13
  %17 = load i8* %hookmask, align 1
  %18 = load %struct.lua_State.343** %L1, align 8
  %hookmask3 = getelementptr inbounds %struct.lua_State.343* %18, i32 0, i32 13
  store i8 %17, i8* %hookmask3, align 1
  %19 = load %struct.lua_State.343** %L.addr, align 8
  %basehookcount = getelementptr inbounds %struct.lua_State.343* %19, i32 0, i32 15
  %20 = load i32* %basehookcount, align 4
  %21 = load %struct.lua_State.343** %L1, align 8
  %basehookcount4 = getelementptr inbounds %struct.lua_State.343* %21, i32 0, i32 15
  store i32 %20, i32* %basehookcount4, align 4
  %22 = load %struct.lua_State.343** %L.addr, align 8
  %hook = getelementptr inbounds %struct.lua_State.343* %22, i32 0, i32 17
  %23 = load void (%struct.lua_State.343*, %struct.lua_Debug.341*)** %hook, align 8
  %24 = load %struct.lua_State.343** %L1, align 8
  %hook5 = getelementptr inbounds %struct.lua_State.343* %24, i32 0, i32 17
  store void (%struct.lua_State.343*, %struct.lua_Debug.341*)* %23, void (%struct.lua_State.343*, %struct.lua_Debug.341*)** %hook5, align 8
  %25 = load %struct.lua_State.343** %L1, align 8
  %basehookcount6 = getelementptr inbounds %struct.lua_State.343* %25, i32 0, i32 15
  %26 = load i32* %basehookcount6, align 4
  %27 = load %struct.lua_State.343** %L1, align 8
  %hookcount = getelementptr inbounds %struct.lua_State.343* %27, i32 0, i32 16
  store i32 %26, i32* %hookcount, align 4
  %28 = load %struct.lua_State.343** %L.addr, align 8
  %29 = load %struct.lua_State.343** %L1, align 8
  %30 = load %struct.lua_State.343** %L.addr, align 8
  call void @stack_init(%struct.lua_State.343* %29, %struct.lua_State.343* %30)
  %31 = load %struct.lua_State.343** %L1, align 8
  ret %struct.lua_State.343* %31
}

; Function Attrs: nounwind uwtable
define hidden void @luaE_freethread(%struct.lua_State.343* %L, %struct.lua_State.343* %L1) #0 {
entry:
  %L.addr = alloca %struct.lua_State.343*, align 8
  %L1.addr = alloca %struct.lua_State.343*, align 8
  %l = alloca %struct.LX*, align 8
  store %struct.lua_State.343* %L, %struct.lua_State.343** %L.addr, align 8
  store %struct.lua_State.343* %L1, %struct.lua_State.343** %L1.addr, align 8
  %0 = load %struct.lua_State.343** %L1.addr, align 8
  %1 = bitcast %struct.lua_State.343* %0 to i8*
  %add.ptr = getelementptr inbounds i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.LX*
  store %struct.LX* %2, %struct.LX** %l, align 8
  %3 = load %struct.lua_State.343** %L1.addr, align 8
  %4 = load %struct.lua_State.343** %L1.addr, align 8
  %stack = getelementptr inbounds %struct.lua_State.343* %4, i32 0, i32 9
  %5 = load %struct.lua_TValue.346** %stack, align 8
  call void bitcast (void (%struct.lua_State.154*, %struct.lua_TValue.137*)* @luaF_close to void (%struct.lua_State.343*, %struct.lua_TValue.346*)*)(%struct.lua_State.343* %3, %struct.lua_TValue.346* %5)
  %6 = load %struct.lua_State.343** %L.addr, align 8
  %7 = load %struct.lua_State.343** %L1.addr, align 8
  call void @freestack(%struct.lua_State.343* %7)
  %8 = load %struct.lua_State.343** %L.addr, align 8
  %9 = load %struct.LX** %l, align 8
  %10 = bitcast %struct.LX* %9 to i8*
  %call = call i8* bitcast (i8* (%struct.lua_State*, i8*, i64, i64)* @luaM_realloc_ to i8* (%struct.lua_State.343*, i8*, i64, i64)*)(%struct.lua_State.343* %8, i8* %10, i64 208, i64 0)
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.lua_State.343* @lua_newstate(i8* (i8*, i8*, i64, i64)* %f, i8* %ud) #0 {
entry:
  %retval = alloca %struct.lua_State.343*, align 8
  %f.addr = alloca i8* (i8*, i8*, i64, i64)*, align 8
  %ud.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %L = alloca %struct.lua_State.343*, align 8
  %g = alloca %struct.global_State.337*, align 8
  %l = alloca %struct.LG*, align 8
  store i8* (i8*, i8*, i64, i64)* %f, i8* (i8*, i8*, i64, i64)** %f.addr, align 8
  store i8* %ud, i8** %ud.addr, align 8
  %0 = load i8* (i8*, i8*, i64, i64)** %f.addr, align 8
  %1 = load i8** %ud.addr, align 8
  %call = call i8* %0(i8* %1, i8* null, i64 8, i64 704)
  %2 = bitcast i8* %call to %struct.LG*
  store %struct.LG* %2, %struct.LG** %l, align 8
  %3 = load %struct.LG** %l, align 8
  %cmp = icmp eq %struct.LG* %3, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store %struct.lua_State.343* null, %struct.lua_State.343** %retval
  br label %return

if.end:                                           ; preds = %entry
  %4 = load %struct.LG** %l, align 8
  %l1 = getelementptr inbounds %struct.LG* %4, i32 0, i32 0
  %l2 = getelementptr inbounds %struct.LX* %l1, i32 0, i32 0
  store %struct.lua_State.343* %l2, %struct.lua_State.343** %L, align 8
  %5 = load %struct.LG** %l, align 8
  %g3 = getelementptr inbounds %struct.LG* %5, i32 0, i32 1
  store %struct.global_State.337* %g3, %struct.global_State.337** %g, align 8
  %6 = load %struct.lua_State.343** %L, align 8
  %next = getelementptr inbounds %struct.lua_State.343* %6, i32 0, i32 0
  store %union.GCObject.344* null, %union.GCObject.344** %next, align 8
  %7 = load %struct.lua_State.343** %L, align 8
  %tt = getelementptr inbounds %struct.lua_State.343* %7, i32 0, i32 1
  store i8 8, i8* %tt, align 1
  %8 = load %struct.global_State.337** %g, align 8
  %currentwhite = getelementptr inbounds %struct.global_State.337* %8, i32 0, i32 9
  store i8 33, i8* %currentwhite, align 1
  %9 = load %struct.global_State.337** %g, align 8
  %currentwhite4 = getelementptr inbounds %struct.global_State.337* %9, i32 0, i32 9
  %10 = load i8* %currentwhite4, align 1
  %conv = zext i8 %10 to i32
  %and = and i32 %conv, 3
  %conv5 = trunc i32 %and to i8
  %11 = load %struct.lua_State.343** %L, align 8
  %marked = getelementptr inbounds %struct.lua_State.343* %11, i32 0, i32 2
  store i8 %conv5, i8* %marked, align 1
  %12 = load %struct.global_State.337** %g, align 8
  %gckind = getelementptr inbounds %struct.global_State.337* %12, i32 0, i32 11
  store i8 0, i8* %gckind, align 1
  %13 = load %struct.lua_State.343** %L, align 8
  %14 = load %struct.global_State.337** %g, align 8
  call void @preinit_state(%struct.lua_State.343* %13, %struct.global_State.337* %14)
  %15 = load i8* (i8*, i8*, i64, i64)** %f.addr, align 8
  %16 = load %struct.global_State.337** %g, align 8
  %frealloc = getelementptr inbounds %struct.global_State.337* %16, i32 0, i32 0
  store i8* (i8*, i8*, i64, i64)* %15, i8* (i8*, i8*, i64, i64)** %frealloc, align 8
  %17 = load i8** %ud.addr, align 8
  %18 = load %struct.global_State.337** %g, align 8
  %ud6 = getelementptr inbounds %struct.global_State.337* %18, i32 0, i32 1
  store i8* %17, i8** %ud6, align 8
  %19 = load %struct.lua_State.343** %L, align 8
  %20 = load %struct.global_State.337** %g, align 8
  %mainthread = getelementptr inbounds %struct.global_State.337* %20, i32 0, i32 30
  store %struct.lua_State.343* %19, %struct.lua_State.343** %mainthread, align 8
  %21 = load %struct.lua_State.343** %L, align 8
  %call7 = call i32 @makeseed(%struct.lua_State.343* %21)
  %22 = load %struct.global_State.337** %g, align 8
  %seed = getelementptr inbounds %struct.global_State.337* %22, i32 0, i32 8
  store i32 %call7, i32* %seed, align 4
  %23 = load %struct.global_State.337** %g, align 8
  %uvhead = getelementptr inbounds %struct.global_State.337* %23, i32 0, i32 24
  %24 = load %struct.global_State.337** %g, align 8
  %uvhead8 = getelementptr inbounds %struct.global_State.337* %24, i32 0, i32 24
  %u = getelementptr inbounds %struct.UpVal.329* %uvhead8, i32 0, i32 4
  %l9 = bitcast %union.anon.4.328* %u to %struct.anon.5.347*
  %prev = getelementptr inbounds %struct.anon.5.347* %l9, i32 0, i32 0
  store %struct.UpVal.329* %uvhead, %struct.UpVal.329** %prev, align 8
  %25 = load %struct.global_State.337** %g, align 8
  %uvhead10 = getelementptr inbounds %struct.global_State.337* %25, i32 0, i32 24
  %26 = load %struct.global_State.337** %g, align 8
  %uvhead11 = getelementptr inbounds %struct.global_State.337* %26, i32 0, i32 24
  %u12 = getelementptr inbounds %struct.UpVal.329* %uvhead11, i32 0, i32 4
  %l13 = bitcast %union.anon.4.328* %u12 to %struct.anon.5.347*
  %next14 = getelementptr inbounds %struct.anon.5.347* %l13, i32 0, i32 1
  store %struct.UpVal.329* %uvhead10, %struct.UpVal.329** %next14, align 8
  %27 = load %struct.global_State.337** %g, align 8
  %gcrunning = getelementptr inbounds %struct.global_State.337* %27, i32 0, i32 12
  store i8 0, i8* %gcrunning, align 1
  %28 = load %struct.global_State.337** %g, align 8
  %GCestimate = getelementptr inbounds %struct.global_State.337* %28, i32 0, i32 5
  store i64 0, i64* %GCestimate, align 8
  %29 = load %struct.global_State.337** %g, align 8
  %strt = getelementptr inbounds %struct.global_State.337* %29, i32 0, i32 6
  %size = getelementptr inbounds %struct.stringtable.327* %strt, i32 0, i32 2
  store i32 0, i32* %size, align 4
  %30 = load %struct.global_State.337** %g, align 8
  %strt15 = getelementptr inbounds %struct.global_State.337* %30, i32 0, i32 6
  %nuse = getelementptr inbounds %struct.stringtable.327* %strt15, i32 0, i32 1
  store i32 0, i32* %nuse, align 4
  %31 = load %struct.global_State.337** %g, align 8
  %strt16 = getelementptr inbounds %struct.global_State.337* %31, i32 0, i32 6
  %hash = getelementptr inbounds %struct.stringtable.327* %strt16, i32 0, i32 0
  store %union.GCObject.344** null, %union.GCObject.344*** %hash, align 8
  %32 = load %struct.global_State.337** %g, align 8
  %l_registry = getelementptr inbounds %struct.global_State.337* %32, i32 0, i32 7
  %tt_ = getelementptr inbounds %struct.lua_TValue.346* %l_registry, i32 0, i32 1
  store i32 0, i32* %tt_, align 4
  %33 = load %struct.global_State.337** %g, align 8
  %buff = getelementptr inbounds %struct.global_State.337* %33, i32 0, i32 25
  %buffer = getelementptr inbounds %struct.Mbuffer* %buff, i32 0, i32 0
  store i8* null, i8** %buffer, align 8
  %34 = load %struct.global_State.337** %g, align 8
  %buff17 = getelementptr inbounds %struct.global_State.337* %34, i32 0, i32 25
  %buffsize = getelementptr inbounds %struct.Mbuffer* %buff17, i32 0, i32 2
  store i64 0, i64* %buffsize, align 8
  %35 = load %struct.global_State.337** %g, align 8
  %panic = getelementptr inbounds %struct.global_State.337* %35, i32 0, i32 29
  store i32 (%struct.lua_State.343*)* null, i32 (%struct.lua_State.343*)** %panic, align 8
  %call18 = call double* bitcast (double* (%struct.lua_State*)* @lua_version to double* (%struct.lua_State.343*)*)(%struct.lua_State.343* null)
  %36 = load %struct.global_State.337** %g, align 8
  %version = getelementptr inbounds %struct.global_State.337* %36, i32 0, i32 31
  store double* %call18, double** %version, align 8
  %37 = load %struct.global_State.337** %g, align 8
  %gcstate = getelementptr inbounds %struct.global_State.337* %37, i32 0, i32 10
  store i8 5, i8* %gcstate, align 1
  %38 = load %struct.global_State.337** %g, align 8
  %allgc = getelementptr inbounds %struct.global_State.337* %38, i32 0, i32 14
  store %union.GCObject.344* null, %union.GCObject.344** %allgc, align 8
  %39 = load %struct.global_State.337** %g, align 8
  %finobj = getelementptr inbounds %struct.global_State.337* %39, i32 0, i32 15
  store %union.GCObject.344* null, %union.GCObject.344** %finobj, align 8
  %40 = load %struct.global_State.337** %g, align 8
  %tobefnz = getelementptr inbounds %struct.global_State.337* %40, i32 0, i32 23
  store %union.GCObject.344* null, %union.GCObject.344** %tobefnz, align 8
  %41 = load %struct.global_State.337** %g, align 8
  %sweepfin = getelementptr inbounds %struct.global_State.337* %41, i32 0, i32 17
  store %union.GCObject.344** null, %union.GCObject.344*** %sweepfin, align 8
  %42 = load %struct.global_State.337** %g, align 8
  %sweepgc = getelementptr inbounds %struct.global_State.337* %42, i32 0, i32 16
  store %union.GCObject.344** null, %union.GCObject.344*** %sweepgc, align 8
  %43 = load %struct.global_State.337** %g, align 8
  %grayagain = getelementptr inbounds %struct.global_State.337* %43, i32 0, i32 19
  store %union.GCObject.344* null, %union.GCObject.344** %grayagain, align 8
  %44 = load %struct.global_State.337** %g, align 8
  %gray = getelementptr inbounds %struct.global_State.337* %44, i32 0, i32 18
  store %union.GCObject.344* null, %union.GCObject.344** %gray, align 8
  %45 = load %struct.global_State.337** %g, align 8
  %allweak = getelementptr inbounds %struct.global_State.337* %45, i32 0, i32 22
  store %union.GCObject.344* null, %union.GCObject.344** %allweak, align 8
  %46 = load %struct.global_State.337** %g, align 8
  %ephemeron = getelementptr inbounds %struct.global_State.337* %46, i32 0, i32 21
  store %union.GCObject.344* null, %union.GCObject.344** %ephemeron, align 8
  %47 = load %struct.global_State.337** %g, align 8
  %weak = getelementptr inbounds %struct.global_State.337* %47, i32 0, i32 20
  store %union.GCObject.344* null, %union.GCObject.344** %weak, align 8
  %48 = load %struct.global_State.337** %g, align 8
  %totalbytes = getelementptr inbounds %struct.global_State.337* %48, i32 0, i32 2
  store i64 704, i64* %totalbytes, align 8
  %49 = load %struct.global_State.337** %g, align 8
  %GCdebt = getelementptr inbounds %struct.global_State.337* %49, i32 0, i32 3
  store i64 0, i64* %GCdebt, align 8
  %50 = load %struct.global_State.337** %g, align 8
  %gcpause = getelementptr inbounds %struct.global_State.337* %50, i32 0, i32 26
  store i32 200, i32* %gcpause, align 4
  %51 = load %struct.global_State.337** %g, align 8
  %gcmajorinc = getelementptr inbounds %struct.global_State.337* %51, i32 0, i32 27
  store i32 200, i32* %gcmajorinc, align 4
  %52 = load %struct.global_State.337** %g, align 8
  %gcstepmul = getelementptr inbounds %struct.global_State.337* %52, i32 0, i32 28
  store i32 200, i32* %gcstepmul, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %53 = load i32* %i, align 4
  %cmp19 = icmp slt i32 %53, 9
  br i1 %cmp19, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %54 = load i32* %i, align 4
  %idxprom = sext i32 %54 to i64
  %55 = load %struct.global_State.337** %g, align 8
  %mt = getelementptr inbounds %struct.global_State.337* %55, i32 0, i32 34
  %arrayidx = getelementptr inbounds [9 x %struct.Table.336*]* %mt, i32 0, i64 %idxprom
  store %struct.Table.336* null, %struct.Table.336** %arrayidx, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %56 = load i32* %i, align 4
  %inc = add nsw i32 %56, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %57 = load %struct.lua_State.343** %L, align 8
  %call21 = call i32 bitcast (i32 (%struct.lua_State*, void (%struct.lua_State*, i8*)*, i8*)* @luaD_rawrunprotected to i32 (%struct.lua_State.343*, void (%struct.lua_State.343*, i8*)*, i8*)*)(%struct.lua_State.343* %57, void (%struct.lua_State.343*, i8*)* @f_luaopen, i8* null)
  %cmp22 = icmp ne i32 %call21, 0
  br i1 %cmp22, label %if.then24, label %if.else

if.then24:                                        ; preds = %for.end
  %58 = load %struct.lua_State.343** %L, align 8
  call void @close_state(%struct.lua_State.343* %58)
  store %struct.lua_State.343* null, %struct.lua_State.343** %L, align 8
  br label %if.end25

if.else:                                          ; preds = %for.end
  %59 = load %struct.lua_State.343** %L, align 8
  br label %if.end25

if.end25:                                         ; preds = %if.else, %if.then24
  %60 = load %struct.lua_State.343** %L, align 8
  store %struct.lua_State.343* %60, %struct.lua_State.343** %retval
  br label %return

return:                                           ; preds = %if.end25, %if.then
  %61 = load %struct.lua_State.343** %retval
  ret %struct.lua_State.343* %61
}

; Function Attrs: nounwind uwtable
define void @lua_close(%struct.lua_State.343* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State.343*, align 8
  store %struct.lua_State.343* %L, %struct.lua_State.343** %L.addr, align 8
  %0 = load %struct.lua_State.343** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State.343* %0, i32 0, i32 5
  %1 = load %struct.global_State.337** %l_G, align 8
  %mainthread = getelementptr inbounds %struct.global_State.337* %1, i32 0, i32 30
  %2 = load %struct.lua_State.343** %mainthread, align 8
  store %struct.lua_State.343* %2, %struct.lua_State.343** %L.addr, align 8
  %3 = load %struct.lua_State.343** %L.addr, align 8
  %4 = load %struct.lua_State.343** %L.addr, align 8
  call void @close_state(%struct.lua_State.343* %4)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @preinit_state(%struct.lua_State.343* %L, %struct.global_State.337* %g) #0 {
entry:
  %L.addr = alloca %struct.lua_State.343*, align 8
  %g.addr = alloca %struct.global_State.337*, align 8
  store %struct.lua_State.343* %L, %struct.lua_State.343** %L.addr, align 8
  store %struct.global_State.337* %g, %struct.global_State.337** %g.addr, align 8
  %0 = load %struct.global_State.337** %g.addr, align 8
  %1 = load %struct.lua_State.343** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State.343* %1, i32 0, i32 5
  store %struct.global_State.337* %0, %struct.global_State.337** %l_G, align 8
  %2 = load %struct.lua_State.343** %L.addr, align 8
  %stack = getelementptr inbounds %struct.lua_State.343* %2, i32 0, i32 9
  store %struct.lua_TValue.346* null, %struct.lua_TValue.346** %stack, align 8
  %3 = load %struct.lua_State.343** %L.addr, align 8
  %ci = getelementptr inbounds %struct.lua_State.343* %3, i32 0, i32 6
  store %struct.CallInfo.340* null, %struct.CallInfo.340** %ci, align 8
  %4 = load %struct.lua_State.343** %L.addr, align 8
  %stacksize = getelementptr inbounds %struct.lua_State.343* %4, i32 0, i32 10
  store i32 0, i32* %stacksize, align 4
  %5 = load %struct.lua_State.343** %L.addr, align 8
  %errorJmp = getelementptr inbounds %struct.lua_State.343* %5, i32 0, i32 20
  store %struct.lua_longjmp* null, %struct.lua_longjmp** %errorJmp, align 8
  %6 = load %struct.lua_State.343** %L.addr, align 8
  %nCcalls = getelementptr inbounds %struct.lua_State.343* %6, i32 0, i32 12
  store i16 0, i16* %nCcalls, align 2
  %7 = load %struct.lua_State.343** %L.addr, align 8
  %hook = getelementptr inbounds %struct.lua_State.343* %7, i32 0, i32 17
  store void (%struct.lua_State.343*, %struct.lua_Debug.341*)* null, void (%struct.lua_State.343*, %struct.lua_Debug.341*)** %hook, align 8
  %8 = load %struct.lua_State.343** %L.addr, align 8
  %hookmask = getelementptr inbounds %struct.lua_State.343* %8, i32 0, i32 13
  store i8 0, i8* %hookmask, align 1
  %9 = load %struct.lua_State.343** %L.addr, align 8
  %basehookcount = getelementptr inbounds %struct.lua_State.343* %9, i32 0, i32 15
  store i32 0, i32* %basehookcount, align 4
  %10 = load %struct.lua_State.343** %L.addr, align 8
  %allowhook = getelementptr inbounds %struct.lua_State.343* %10, i32 0, i32 14
  store i8 1, i8* %allowhook, align 1
  %11 = load %struct.lua_State.343** %L.addr, align 8
  %basehookcount1 = getelementptr inbounds %struct.lua_State.343* %11, i32 0, i32 15
  %12 = load i32* %basehookcount1, align 4
  %13 = load %struct.lua_State.343** %L.addr, align 8
  %hookcount = getelementptr inbounds %struct.lua_State.343* %13, i32 0, i32 16
  store i32 %12, i32* %hookcount, align 4
  %14 = load %struct.lua_State.343** %L.addr, align 8
  %openupval = getelementptr inbounds %struct.lua_State.343* %14, i32 0, i32 18
  store %union.GCObject.344* null, %union.GCObject.344** %openupval, align 8
  %15 = load %struct.lua_State.343** %L.addr, align 8
  %nny = getelementptr inbounds %struct.lua_State.343* %15, i32 0, i32 11
  store i16 1, i16* %nny, align 2
  %16 = load %struct.lua_State.343** %L.addr, align 8
  %status = getelementptr inbounds %struct.lua_State.343* %16, i32 0, i32 3
  store i8 0, i8* %status, align 1
  %17 = load %struct.lua_State.343** %L.addr, align 8
  %errfunc = getelementptr inbounds %struct.lua_State.343* %17, i32 0, i32 21
  store i64 0, i64* %errfunc, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @stack_init(%struct.lua_State.343* %L1, %struct.lua_State.343* %L) #0 {
entry:
  %L1.addr = alloca %struct.lua_State.343*, align 8
  %L.addr = alloca %struct.lua_State.343*, align 8
  %i = alloca i32, align 4
  %ci = alloca %struct.CallInfo.340*, align 8
  store %struct.lua_State.343* %L1, %struct.lua_State.343** %L1.addr, align 8
  store %struct.lua_State.343* %L, %struct.lua_State.343** %L.addr, align 8
  %0 = load %struct.lua_State.343** %L.addr, align 8
  %call = call i8* bitcast (i8* (%struct.lua_State*, i8*, i64, i64)* @luaM_realloc_ to i8* (%struct.lua_State.343*, i8*, i64, i64)*)(%struct.lua_State.343* %0, i8* null, i64 0, i64 640)
  %1 = bitcast i8* %call to %struct.lua_TValue.346*
  %2 = load %struct.lua_State.343** %L1.addr, align 8
  %stack = getelementptr inbounds %struct.lua_State.343* %2, i32 0, i32 9
  store %struct.lua_TValue.346* %1, %struct.lua_TValue.346** %stack, align 8
  %3 = load %struct.lua_State.343** %L1.addr, align 8
  %stacksize = getelementptr inbounds %struct.lua_State.343* %3, i32 0, i32 10
  store i32 40, i32* %stacksize, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %4 = load i32* %i, align 4
  %cmp = icmp slt i32 %4, 40
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load %struct.lua_State.343** %L1.addr, align 8
  %stack1 = getelementptr inbounds %struct.lua_State.343* %5, i32 0, i32 9
  %6 = load %struct.lua_TValue.346** %stack1, align 8
  %7 = load i32* %i, align 4
  %idx.ext = sext i32 %7 to i64
  %add.ptr = getelementptr inbounds %struct.lua_TValue.346* %6, i64 %idx.ext
  %tt_ = getelementptr inbounds %struct.lua_TValue.346* %add.ptr, i32 0, i32 1
  store i32 0, i32* %tt_, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %8 = load i32* %i, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %9 = load %struct.lua_State.343** %L1.addr, align 8
  %stack2 = getelementptr inbounds %struct.lua_State.343* %9, i32 0, i32 9
  %10 = load %struct.lua_TValue.346** %stack2, align 8
  %11 = load %struct.lua_State.343** %L1.addr, align 8
  %top = getelementptr inbounds %struct.lua_State.343* %11, i32 0, i32 4
  store %struct.lua_TValue.346* %10, %struct.lua_TValue.346** %top, align 8
  %12 = load %struct.lua_State.343** %L1.addr, align 8
  %stack3 = getelementptr inbounds %struct.lua_State.343* %12, i32 0, i32 9
  %13 = load %struct.lua_TValue.346** %stack3, align 8
  %14 = load %struct.lua_State.343** %L1.addr, align 8
  %stacksize4 = getelementptr inbounds %struct.lua_State.343* %14, i32 0, i32 10
  %15 = load i32* %stacksize4, align 4
  %idx.ext5 = sext i32 %15 to i64
  %add.ptr6 = getelementptr inbounds %struct.lua_TValue.346* %13, i64 %idx.ext5
  %add.ptr7 = getelementptr inbounds %struct.lua_TValue.346* %add.ptr6, i64 -5
  %16 = load %struct.lua_State.343** %L1.addr, align 8
  %stack_last = getelementptr inbounds %struct.lua_State.343* %16, i32 0, i32 8
  store %struct.lua_TValue.346* %add.ptr7, %struct.lua_TValue.346** %stack_last, align 8
  %17 = load %struct.lua_State.343** %L1.addr, align 8
  %base_ci = getelementptr inbounds %struct.lua_State.343* %17, i32 0, i32 22
  store %struct.CallInfo.340* %base_ci, %struct.CallInfo.340** %ci, align 8
  %18 = load %struct.CallInfo.340** %ci, align 8
  %previous = getelementptr inbounds %struct.CallInfo.340* %18, i32 0, i32 2
  store %struct.CallInfo.340* null, %struct.CallInfo.340** %previous, align 8
  %19 = load %struct.CallInfo.340** %ci, align 8
  %next = getelementptr inbounds %struct.CallInfo.340* %19, i32 0, i32 3
  store %struct.CallInfo.340* null, %struct.CallInfo.340** %next, align 8
  %20 = load %struct.CallInfo.340** %ci, align 8
  %callstatus = getelementptr inbounds %struct.CallInfo.340* %20, i32 0, i32 5
  store i8 0, i8* %callstatus, align 1
  %21 = load %struct.lua_State.343** %L1.addr, align 8
  %top8 = getelementptr inbounds %struct.lua_State.343* %21, i32 0, i32 4
  %22 = load %struct.lua_TValue.346** %top8, align 8
  %23 = load %struct.CallInfo.340** %ci, align 8
  %func = getelementptr inbounds %struct.CallInfo.340* %23, i32 0, i32 0
  store %struct.lua_TValue.346* %22, %struct.lua_TValue.346** %func, align 8
  %24 = load %struct.lua_State.343** %L1.addr, align 8
  %top9 = getelementptr inbounds %struct.lua_State.343* %24, i32 0, i32 4
  %25 = load %struct.lua_TValue.346** %top9, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue.346* %25, i32 1
  store %struct.lua_TValue.346* %incdec.ptr, %struct.lua_TValue.346** %top9, align 8
  %tt_10 = getelementptr inbounds %struct.lua_TValue.346* %25, i32 0, i32 1
  store i32 0, i32* %tt_10, align 4
  %26 = load %struct.lua_State.343** %L1.addr, align 8
  %top11 = getelementptr inbounds %struct.lua_State.343* %26, i32 0, i32 4
  %27 = load %struct.lua_TValue.346** %top11, align 8
  %add.ptr12 = getelementptr inbounds %struct.lua_TValue.346* %27, i64 20
  %28 = load %struct.CallInfo.340** %ci, align 8
  %top13 = getelementptr inbounds %struct.CallInfo.340* %28, i32 0, i32 1
  store %struct.lua_TValue.346* %add.ptr12, %struct.lua_TValue.346** %top13, align 8
  %29 = load %struct.CallInfo.340** %ci, align 8
  %30 = load %struct.lua_State.343** %L1.addr, align 8
  %ci14 = getelementptr inbounds %struct.lua_State.343* %30, i32 0, i32 6
  store %struct.CallInfo.340* %29, %struct.CallInfo.340** %ci14, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @freestack(%struct.lua_State.343* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State.343*, align 8
  store %struct.lua_State.343* %L, %struct.lua_State.343** %L.addr, align 8
  %0 = load %struct.lua_State.343** %L.addr, align 8
  %stack = getelementptr inbounds %struct.lua_State.343* %0, i32 0, i32 9
  %1 = load %struct.lua_TValue.346** %stack, align 8
  %cmp = icmp eq %struct.lua_TValue.346* %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.lua_State.343** %L.addr, align 8
  %base_ci = getelementptr inbounds %struct.lua_State.343* %2, i32 0, i32 22
  %3 = load %struct.lua_State.343** %L.addr, align 8
  %ci = getelementptr inbounds %struct.lua_State.343* %3, i32 0, i32 6
  store %struct.CallInfo.340* %base_ci, %struct.CallInfo.340** %ci, align 8
  %4 = load %struct.lua_State.343** %L.addr, align 8
  call void @luaE_freeCI(%struct.lua_State.343* %4)
  %5 = load %struct.lua_State.343** %L.addr, align 8
  %6 = load %struct.lua_State.343** %L.addr, align 8
  %stack1 = getelementptr inbounds %struct.lua_State.343* %6, i32 0, i32 9
  %7 = load %struct.lua_TValue.346** %stack1, align 8
  %8 = bitcast %struct.lua_TValue.346* %7 to i8*
  %9 = load %struct.lua_State.343** %L.addr, align 8
  %stacksize = getelementptr inbounds %struct.lua_State.343* %9, i32 0, i32 10
  %10 = load i32* %stacksize, align 4
  %conv = sext i32 %10 to i64
  %mul = mul i64 %conv, 16
  %call = call i8* bitcast (i8* (%struct.lua_State*, i8*, i64, i64)* @luaM_realloc_ to i8* (%struct.lua_State.343*, i8*, i64, i64)*)(%struct.lua_State.343* %5, i8* %8, i64 %mul, i64 0)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @makeseed(%struct.lua_State.343* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State.343*, align 8
  %buff = alloca [32 x i8], align 16
  %h = alloca i32, align 4
  %p = alloca i32, align 4
  %t = alloca i64, align 8
  %t3 = alloca i64, align 8
  %t10 = alloca i64, align 8
  %t17 = alloca i64, align 8
  store %struct.lua_State.343* %L, %struct.lua_State.343** %L.addr, align 8
  %call = call i64 @time(i64* null) #1
  %conv = trunc i64 %call to i32
  store i32 %conv, i32* %h, align 4
  store i32 0, i32* %p, align 4
  %0 = load %struct.lua_State.343** %L.addr, align 8
  %1 = ptrtoint %struct.lua_State.343* %0 to i64
  store i64 %1, i64* %t, align 8
  %arraydecay = getelementptr inbounds [32 x i8]* %buff, i32 0, i32 0
  %2 = load i32* %p, align 4
  %idx.ext = sext i32 %2 to i64
  %add.ptr = getelementptr inbounds i8* %arraydecay, i64 %idx.ext
  %3 = bitcast i64* %t to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %add.ptr, i8* %3, i64 8, i32 1, i1 false)
  %4 = load i32* %p, align 4
  %conv1 = sext i32 %4 to i64
  %add = add i64 %conv1, 8
  %conv2 = trunc i64 %add to i32
  store i32 %conv2, i32* %p, align 4
  %5 = ptrtoint i32* %h to i64
  store i64 %5, i64* %t3, align 8
  %arraydecay4 = getelementptr inbounds [32 x i8]* %buff, i32 0, i32 0
  %6 = load i32* %p, align 4
  %idx.ext5 = sext i32 %6 to i64
  %add.ptr6 = getelementptr inbounds i8* %arraydecay4, i64 %idx.ext5
  %7 = bitcast i64* %t3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %add.ptr6, i8* %7, i64 8, i32 1, i1 false)
  %8 = load i32* %p, align 4
  %conv7 = sext i32 %8 to i64
  %add8 = add i64 %conv7, 8
  %conv9 = trunc i64 %add8 to i32
  store i32 %conv9, i32* %p, align 4
  store i64 ptrtoint ({ %union.Value.281, i32, [4 x i8] }* @luaO_nilobject_ to i64), i64* %t10, align 8
  %arraydecay11 = getelementptr inbounds [32 x i8]* %buff, i32 0, i32 0
  %9 = load i32* %p, align 4
  %idx.ext12 = sext i32 %9 to i64
  %add.ptr13 = getelementptr inbounds i8* %arraydecay11, i64 %idx.ext12
  %10 = bitcast i64* %t10 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %add.ptr13, i8* %10, i64 8, i32 1, i1 false)
  %11 = load i32* %p, align 4
  %conv14 = sext i32 %11 to i64
  %add15 = add i64 %conv14, 8
  %conv16 = trunc i64 %add15 to i32
  store i32 %conv16, i32* %p, align 4
  store i64 ptrtoint (%struct.lua_State.343* (i8* (i8*, i8*, i64, i64)*, i8*)* @lua_newstate to i64), i64* %t17, align 8
  %arraydecay18 = getelementptr inbounds [32 x i8]* %buff, i32 0, i32 0
  %12 = load i32* %p, align 4
  %idx.ext19 = sext i32 %12 to i64
  %add.ptr20 = getelementptr inbounds i8* %arraydecay18, i64 %idx.ext19
  %13 = bitcast i64* %t17 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %add.ptr20, i8* %13, i64 8, i32 1, i1 false)
  %14 = load i32* %p, align 4
  %conv21 = sext i32 %14 to i64
  %add22 = add i64 %conv21, 8
  %conv23 = trunc i64 %add22 to i32
  store i32 %conv23, i32* %p, align 4
  %arraydecay24 = getelementptr inbounds [32 x i8]* %buff, i32 0, i32 0
  %15 = load i32* %p, align 4
  %conv25 = sext i32 %15 to i64
  %16 = load i32* %h, align 4
  %call26 = call i32 @luaS_hash(i8* %arraydecay24, i64 %conv25, i32 %16)
  ret i32 %call26
}

; Function Attrs: nounwind uwtable
define internal void @f_luaopen(%struct.lua_State.343* %L, i8* %ud) #0 {
entry:
  %L.addr = alloca %struct.lua_State.343*, align 8
  %ud.addr = alloca i8*, align 8
  %g = alloca %struct.global_State.337*, align 8
  store %struct.lua_State.343* %L, %struct.lua_State.343** %L.addr, align 8
  store i8* %ud, i8** %ud.addr, align 8
  %0 = load %struct.lua_State.343** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State.343* %0, i32 0, i32 5
  %1 = load %struct.global_State.337** %l_G, align 8
  store %struct.global_State.337* %1, %struct.global_State.337** %g, align 8
  %2 = load i8** %ud.addr, align 8
  %3 = load %struct.lua_State.343** %L.addr, align 8
  %4 = load %struct.lua_State.343** %L.addr, align 8
  call void @stack_init(%struct.lua_State.343* %3, %struct.lua_State.343* %4)
  %5 = load %struct.lua_State.343** %L.addr, align 8
  %6 = load %struct.global_State.337** %g, align 8
  call void @init_registry(%struct.lua_State.343* %5, %struct.global_State.337* %6)
  %7 = load %struct.lua_State.343** %L.addr, align 8
  call void bitcast (void (%struct.lua_State.364*, i32)* @luaS_resize to void (%struct.lua_State.343*, i32)*)(%struct.lua_State.343* %7, i32 32)
  %8 = load %struct.lua_State.343** %L.addr, align 8
  call void bitcast (void (%struct.lua_State*)* @luaT_init to void (%struct.lua_State.343*)*)(%struct.lua_State.343* %8)
  %9 = load %struct.lua_State.343** %L.addr, align 8
  call void bitcast (void (%struct.lua_State*)* @luaX_init to void (%struct.lua_State.343*)*)(%struct.lua_State.343* %9)
  %10 = load %struct.lua_State.343** %L.addr, align 8
  %call = call %union.TString.332* bitcast (%union.TString.367* (%struct.lua_State.364*, i8*, i64)* @luaS_newlstr to %union.TString.332* (%struct.lua_State.343*, i8*, i64)*)(%struct.lua_State.343* %10, i8* getelementptr inbounds ([18 x i8]* @.str632, i32 0, i32 0), i64 17)
  %11 = load %struct.global_State.337** %g, align 8
  %memerrmsg = getelementptr inbounds %struct.global_State.337* %11, i32 0, i32 32
  store %union.TString.332* %call, %union.TString.332** %memerrmsg, align 8
  %12 = load %struct.global_State.337** %g, align 8
  %memerrmsg1 = getelementptr inbounds %struct.global_State.337* %12, i32 0, i32 32
  %13 = load %union.TString.332** %memerrmsg1, align 8
  %tsv = bitcast %union.TString.332* %13 to %struct.anon.331*
  %marked = getelementptr inbounds %struct.anon.331* %tsv, i32 0, i32 2
  %14 = load i8* %marked, align 1
  %conv = zext i8 %14 to i32
  %or = or i32 %conv, 32
  %conv2 = trunc i32 %or to i8
  store i8 %conv2, i8* %marked, align 1
  %15 = load %struct.global_State.337** %g, align 8
  %gcrunning = getelementptr inbounds %struct.global_State.337* %15, i32 0, i32 12
  store i8 1, i8* %gcrunning, align 1
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @close_state(%struct.lua_State.343* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State.343*, align 8
  %g = alloca %struct.global_State.337*, align 8
  store %struct.lua_State.343* %L, %struct.lua_State.343** %L.addr, align 8
  %0 = load %struct.lua_State.343** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State.343* %0, i32 0, i32 5
  %1 = load %struct.global_State.337** %l_G, align 8
  store %struct.global_State.337* %1, %struct.global_State.337** %g, align 8
  %2 = load %struct.lua_State.343** %L.addr, align 8
  %3 = load %struct.lua_State.343** %L.addr, align 8
  %stack = getelementptr inbounds %struct.lua_State.343* %3, i32 0, i32 9
  %4 = load %struct.lua_TValue.346** %stack, align 8
  call void bitcast (void (%struct.lua_State.154*, %struct.lua_TValue.137*)* @luaF_close to void (%struct.lua_State.343*, %struct.lua_TValue.346*)*)(%struct.lua_State.343* %2, %struct.lua_TValue.346* %4)
  %5 = load %struct.lua_State.343** %L.addr, align 8
  call void bitcast (void (%struct.lua_State*)* @luaC_freeallobjects to void (%struct.lua_State.343*)*)(%struct.lua_State.343* %5)
  %6 = load %struct.lua_State.343** %L.addr, align 8
  %7 = load %struct.lua_State.343** %L.addr, align 8
  %l_G1 = getelementptr inbounds %struct.lua_State.343* %7, i32 0, i32 5
  %8 = load %struct.global_State.337** %l_G1, align 8
  %strt = getelementptr inbounds %struct.global_State.337* %8, i32 0, i32 6
  %hash = getelementptr inbounds %struct.stringtable.327* %strt, i32 0, i32 0
  %9 = load %union.GCObject.344*** %hash, align 8
  %10 = bitcast %union.GCObject.344** %9 to i8*
  %11 = load %struct.lua_State.343** %L.addr, align 8
  %l_G2 = getelementptr inbounds %struct.lua_State.343* %11, i32 0, i32 5
  %12 = load %struct.global_State.337** %l_G2, align 8
  %strt3 = getelementptr inbounds %struct.global_State.337* %12, i32 0, i32 6
  %size = getelementptr inbounds %struct.stringtable.327* %strt3, i32 0, i32 2
  %13 = load i32* %size, align 4
  %conv = sext i32 %13 to i64
  %mul = mul i64 %conv, 8
  %call = call i8* bitcast (i8* (%struct.lua_State*, i8*, i64, i64)* @luaM_realloc_ to i8* (%struct.lua_State.343*, i8*, i64, i64)*)(%struct.lua_State.343* %6, i8* %10, i64 %mul, i64 0)
  %14 = load %struct.lua_State.343** %L.addr, align 8
  %15 = load %struct.global_State.337** %g, align 8
  %buff = getelementptr inbounds %struct.global_State.337* %15, i32 0, i32 25
  %buffer = getelementptr inbounds %struct.Mbuffer* %buff, i32 0, i32 0
  %16 = load i8** %buffer, align 8
  %17 = load %struct.global_State.337** %g, align 8
  %buff4 = getelementptr inbounds %struct.global_State.337* %17, i32 0, i32 25
  %buffsize = getelementptr inbounds %struct.Mbuffer* %buff4, i32 0, i32 2
  %18 = load i64* %buffsize, align 8
  %mul5 = mul i64 %18, 1
  %call6 = call i8* bitcast (i8* (%struct.lua_State*, i8*, i64, i64)* @luaM_realloc_ to i8* (%struct.lua_State.343*, i8*, i64, i64)*)(%struct.lua_State.343* %14, i8* %16, i64 %mul5, i64 0)
  %19 = load %struct.global_State.337** %g, align 8
  %buff7 = getelementptr inbounds %struct.global_State.337* %19, i32 0, i32 25
  %buffer8 = getelementptr inbounds %struct.Mbuffer* %buff7, i32 0, i32 0
  store i8* %call6, i8** %buffer8, align 8
  %20 = load %struct.global_State.337** %g, align 8
  %buff9 = getelementptr inbounds %struct.global_State.337* %20, i32 0, i32 25
  %buffsize10 = getelementptr inbounds %struct.Mbuffer* %buff9, i32 0, i32 2
  store i64 0, i64* %buffsize10, align 8
  %21 = load %struct.lua_State.343** %L.addr, align 8
  call void @freestack(%struct.lua_State.343* %21)
  %22 = load %struct.global_State.337** %g, align 8
  %frealloc = getelementptr inbounds %struct.global_State.337* %22, i32 0, i32 0
  %23 = load i8* (i8*, i8*, i64, i64)** %frealloc, align 8
  %24 = load %struct.global_State.337** %g, align 8
  %ud = getelementptr inbounds %struct.global_State.337* %24, i32 0, i32 1
  %25 = load i8** %ud, align 8
  %26 = load %struct.lua_State.343** %L.addr, align 8
  %27 = bitcast %struct.lua_State.343* %26 to i8*
  %add.ptr = getelementptr inbounds i8* %27, i64 0
  %28 = bitcast i8* %add.ptr to %struct.LX*
  %29 = bitcast %struct.LX* %28 to i8*
  %call11 = call i8* %23(i8* %25, i8* %29, i64 704, i64 0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @init_registry(%struct.lua_State.343* %L, %struct.global_State.337* %g) #0 {
entry:
  %L.addr = alloca %struct.lua_State.343*, align 8
  %g.addr = alloca %struct.global_State.337*, align 8
  %mt = alloca %struct.lua_TValue.346, align 8
  %registry = alloca %struct.Table.336*, align 8
  %io = alloca %struct.lua_TValue.346*, align 8
  %io1 = alloca %struct.lua_TValue.346*, align 8
  %io5 = alloca %struct.lua_TValue.346*, align 8
  store %struct.lua_State.343* %L, %struct.lua_State.343** %L.addr, align 8
  store %struct.global_State.337* %g, %struct.global_State.337** %g.addr, align 8
  %0 = load %struct.lua_State.343** %L.addr, align 8
  %call = call %struct.Table.336* bitcast (%struct.Table* (%struct.lua_State*)* @luaH_new to %struct.Table.336* (%struct.lua_State.343*)*)(%struct.lua_State.343* %0)
  store %struct.Table.336* %call, %struct.Table.336** %registry, align 8
  %1 = load %struct.global_State.337** %g.addr, align 8
  %l_registry = getelementptr inbounds %struct.global_State.337* %1, i32 0, i32 7
  store %struct.lua_TValue.346* %l_registry, %struct.lua_TValue.346** %io, align 8
  %2 = load %struct.Table.336** %registry, align 8
  %3 = bitcast %struct.Table.336* %2 to %union.GCObject.344*
  %4 = load %struct.lua_TValue.346** %io, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue.346* %4, i32 0, i32 0
  %gc = bitcast %union.Value.345* %value_ to %union.GCObject.344**
  store %union.GCObject.344* %3, %union.GCObject.344** %gc, align 8
  %5 = load %struct.lua_TValue.346** %io, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue.346* %5, i32 0, i32 1
  store i32 69, i32* %tt_, align 4
  %6 = load %struct.lua_State.343** %L.addr, align 8
  %7 = load %struct.Table.336** %registry, align 8
  call void bitcast (void (%struct.lua_State*, %struct.Table*, i32, i32)* @luaH_resize to void (%struct.lua_State.343*, %struct.Table.336*, i32, i32)*)(%struct.lua_State.343* %6, %struct.Table.336* %7, i32 2, i32 0)
  store %struct.lua_TValue.346* %mt, %struct.lua_TValue.346** %io1, align 8
  %8 = load %struct.lua_State.343** %L.addr, align 8
  %9 = bitcast %struct.lua_State.343* %8 to %union.GCObject.344*
  %10 = load %struct.lua_TValue.346** %io1, align 8
  %value_2 = getelementptr inbounds %struct.lua_TValue.346* %10, i32 0, i32 0
  %gc3 = bitcast %union.Value.345* %value_2 to %union.GCObject.344**
  store %union.GCObject.344* %9, %union.GCObject.344** %gc3, align 8
  %11 = load %struct.lua_TValue.346** %io1, align 8
  %tt_4 = getelementptr inbounds %struct.lua_TValue.346* %11, i32 0, i32 1
  store i32 72, i32* %tt_4, align 4
  %12 = load %struct.lua_State.343** %L.addr, align 8
  %13 = load %struct.Table.336** %registry, align 8
  call void bitcast (void (%struct.lua_State*, %struct.Table*, i32, %struct.lua_TValue*)* @luaH_setint to void (%struct.lua_State.343*, %struct.Table.336*, i32, %struct.lua_TValue.346*)*)(%struct.lua_State.343* %12, %struct.Table.336* %13, i32 1, %struct.lua_TValue.346* %mt)
  store %struct.lua_TValue.346* %mt, %struct.lua_TValue.346** %io5, align 8
  %14 = load %struct.lua_State.343** %L.addr, align 8
  %call6 = call %struct.Table.336* bitcast (%struct.Table* (%struct.lua_State*)* @luaH_new to %struct.Table.336* (%struct.lua_State.343*)*)(%struct.lua_State.343* %14)
  %15 = bitcast %struct.Table.336* %call6 to %union.GCObject.344*
  %16 = load %struct.lua_TValue.346** %io5, align 8
  %value_7 = getelementptr inbounds %struct.lua_TValue.346* %16, i32 0, i32 0
  %gc8 = bitcast %union.Value.345* %value_7 to %union.GCObject.344**
  store %union.GCObject.344* %15, %union.GCObject.344** %gc8, align 8
  %17 = load %struct.lua_TValue.346** %io5, align 8
  %tt_9 = getelementptr inbounds %struct.lua_TValue.346* %17, i32 0, i32 1
  store i32 69, i32* %tt_9, align 4
  %18 = load %struct.lua_State.343** %L.addr, align 8
  %19 = load %struct.Table.336** %registry, align 8
  call void bitcast (void (%struct.lua_State*, %struct.Table*, i32, %struct.lua_TValue*)* @luaH_setint to void (%struct.lua_State.343*, %struct.Table.336*, i32, %struct.lua_TValue.346*)*)(%struct.lua_State.343* %18, %struct.Table.336* %19, i32 2, %struct.lua_TValue.346* %mt)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden i32 @luaS_eqlngstr(%union.TString.367* %a, %union.TString.367* %b) #0 {
entry:
  %a.addr = alloca %union.TString.367*, align 8
  %b.addr = alloca %union.TString.367*, align 8
  %len = alloca i64, align 8
  store %union.TString.367* %a, %union.TString.367** %a.addr, align 8
  store %union.TString.367* %b, %union.TString.367** %b.addr, align 8
  %0 = load %union.TString.367** %a.addr, align 8
  %tsv = bitcast %union.TString.367* %0 to %struct.anon.366*
  %len1 = getelementptr inbounds %struct.anon.366* %tsv, i32 0, i32 5
  %1 = load i64* %len1, align 8
  store i64 %1, i64* %len, align 8
  %2 = load %union.TString.367** %a.addr, align 8
  %3 = load %union.TString.367** %b.addr, align 8
  %cmp = icmp eq %union.TString.367* %2, %3
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %4 = load i64* %len, align 8
  %5 = load %union.TString.367** %b.addr, align 8
  %tsv2 = bitcast %union.TString.367* %5 to %struct.anon.366*
  %len3 = getelementptr inbounds %struct.anon.366* %tsv2, i32 0, i32 5
  %6 = load i64* %len3, align 8
  %cmp4 = icmp eq i64 %4, %6
  br i1 %cmp4, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %lor.rhs
  %7 = load %union.TString.367** %a.addr, align 8
  %add.ptr = getelementptr inbounds %union.TString.367* %7, i64 1
  %8 = bitcast %union.TString.367* %add.ptr to i8*
  %9 = load %union.TString.367** %b.addr, align 8
  %add.ptr5 = getelementptr inbounds %union.TString.367* %9, i64 1
  %10 = bitcast %union.TString.367* %add.ptr5 to i8*
  %11 = load i64* %len, align 8
  %call = call i32 @memcmp(i8* %8, i8* %10, i64 %11) #10
  %cmp6 = icmp eq i32 %call, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %lor.rhs
  %12 = phi i1 [ false, %lor.rhs ], [ %cmp6, %land.rhs ]
  br label %lor.end

lor.end:                                          ; preds = %land.end, %entry
  %13 = phi i1 [ true, %entry ], [ %12, %land.end ]
  %lor.ext = zext i1 %13 to i32
  ret i32 %lor.ext
}

; Function Attrs: nounwind readonly
declare i32 @memcmp(i8*, i8*, i64) #2

; Function Attrs: nounwind uwtable
define hidden i32 @luaS_eqstr(%union.TString.367* %a, %union.TString.367* %b) #0 {
entry:
  %a.addr = alloca %union.TString.367*, align 8
  %b.addr = alloca %union.TString.367*, align 8
  store %union.TString.367* %a, %union.TString.367** %a.addr, align 8
  store %union.TString.367* %b, %union.TString.367** %b.addr, align 8
  %0 = load %union.TString.367** %a.addr, align 8
  %tsv = bitcast %union.TString.367* %0 to %struct.anon.366*
  %tt = getelementptr inbounds %struct.anon.366* %tsv, i32 0, i32 1
  %1 = load i8* %tt, align 1
  %conv = zext i8 %1 to i32
  %2 = load %union.TString.367** %b.addr, align 8
  %tsv1 = bitcast %union.TString.367* %2 to %struct.anon.366*
  %tt2 = getelementptr inbounds %struct.anon.366* %tsv1, i32 0, i32 1
  %3 = load i8* %tt2, align 1
  %conv3 = zext i8 %3 to i32
  %cmp = icmp eq i32 %conv, %conv3
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %4 = load %union.TString.367** %a.addr, align 8
  %tsv5 = bitcast %union.TString.367* %4 to %struct.anon.366*
  %tt6 = getelementptr inbounds %struct.anon.366* %tsv5, i32 0, i32 1
  %5 = load i8* %tt6, align 1
  %conv7 = zext i8 %5 to i32
  %cmp8 = icmp eq i32 %conv7, 4
  br i1 %cmp8, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.rhs
  %6 = load %union.TString.367** %a.addr, align 8
  %7 = load %union.TString.367** %b.addr, align 8
  %cmp10 = icmp eq %union.TString.367* %6, %7
  %conv11 = zext i1 %cmp10 to i32
  br label %cond.end

cond.false:                                       ; preds = %land.rhs
  %8 = load %union.TString.367** %a.addr, align 8
  %9 = load %union.TString.367** %b.addr, align 8
  %call = call i32 @luaS_eqlngstr(%union.TString.367* %8, %union.TString.367* %9)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv11, %cond.true ], [ %call, %cond.false ]
  %tobool = icmp ne i32 %cond, 0
  br label %land.end

land.end:                                         ; preds = %cond.end, %entry
  %10 = phi i1 [ false, %entry ], [ %tobool, %cond.end ]
  %land.ext = zext i1 %10 to i32
  ret i32 %land.ext
}

; Function Attrs: nounwind uwtable
define hidden i32 @luaS_hash(i8* %str, i64 %l, i32 %seed) #0 {
entry:
  %str.addr = alloca i8*, align 8
  %l.addr = alloca i64, align 8
  %seed.addr = alloca i32, align 4
  %h = alloca i32, align 4
  %l1 = alloca i64, align 8
  %step = alloca i64, align 8
  store i8* %str, i8** %str.addr, align 8
  store i64 %l, i64* %l.addr, align 8
  store i32 %seed, i32* %seed.addr, align 4
  %0 = load i32* %seed.addr, align 4
  %1 = load i64* %l.addr, align 8
  %conv = trunc i64 %1 to i32
  %xor = xor i32 %0, %conv
  store i32 %xor, i32* %h, align 4
  %2 = load i64* %l.addr, align 8
  %shr = lshr i64 %2, 5
  %add = add i64 %shr, 1
  store i64 %add, i64* %step, align 8
  %3 = load i64* %l.addr, align 8
  store i64 %3, i64* %l1, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %4 = load i64* %l1, align 8
  %5 = load i64* %step, align 8
  %cmp = icmp uge i64 %4, %5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load i32* %h, align 4
  %7 = load i32* %h, align 4
  %shl = shl i32 %7, 5
  %8 = load i32* %h, align 4
  %shr2 = lshr i32 %8, 2
  %add3 = add i32 %shl, %shr2
  %9 = load i64* %l1, align 8
  %sub = sub i64 %9, 1
  %10 = load i8** %str.addr, align 8
  %arrayidx = getelementptr inbounds i8* %10, i64 %sub
  %11 = load i8* %arrayidx, align 1
  %conv4 = zext i8 %11 to i32
  %add5 = add i32 %add3, %conv4
  %xor6 = xor i32 %6, %add5
  store i32 %xor6, i32* %h, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %12 = load i64* %step, align 8
  %13 = load i64* %l1, align 8
  %sub7 = sub i64 %13, %12
  store i64 %sub7, i64* %l1, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %14 = load i32* %h, align 4
  ret i32 %14
}

; Function Attrs: nounwind uwtable
define hidden void @luaS_resize(%struct.lua_State.364* %L, i32 %newsize) #0 {
entry:
  %L.addr = alloca %struct.lua_State.364*, align 8
  %newsize.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %tb = alloca %struct.stringtable.350*, align 8
  %p = alloca %union.GCObject.365*, align 8
  %next = alloca %union.GCObject.365*, align 8
  %h = alloca i32, align 4
  store %struct.lua_State.364* %L, %struct.lua_State.364** %L.addr, align 8
  store i32 %newsize, i32* %newsize.addr, align 4
  %0 = load %struct.lua_State.364** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State.364* %0, i32 0, i32 5
  %1 = load %struct.global_State.358** %l_G, align 8
  %strt = getelementptr inbounds %struct.global_State.358* %1, i32 0, i32 6
  store %struct.stringtable.350* %strt, %struct.stringtable.350** %tb, align 8
  %2 = load %struct.lua_State.364** %L.addr, align 8
  call void bitcast (void (%struct.lua_State*, i32)* @luaC_runtilstate to void (%struct.lua_State.364*, i32)*)(%struct.lua_State.364* %2, i32 -5)
  %3 = load i32* %newsize.addr, align 4
  %4 = load %struct.stringtable.350** %tb, align 8
  %size = getelementptr inbounds %struct.stringtable.350* %4, i32 0, i32 2
  %5 = load i32* %size, align 4
  %cmp = icmp sgt i32 %3, %5
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load i32* %newsize.addr, align 4
  %add = add nsw i32 %6, 1
  %conv = sext i32 %add to i64
  %cmp1 = icmp ugt i64 %conv, 2305843009213693951
  br i1 %cmp1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  %7 = load %struct.lua_State.364** %L.addr, align 8
  call void bitcast (void (%struct.lua_State*)* @luaM_toobig to void (%struct.lua_State.364*)*)(%struct.lua_State.364* %7) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.false:                                       ; preds = %if.then
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %8
  %cond = phi i32 [ 0, %8 ], [ 0, %cond.false ]
  %9 = load %struct.lua_State.364** %L.addr, align 8
  %10 = load %struct.stringtable.350** %tb, align 8
  %hash = getelementptr inbounds %struct.stringtable.350* %10, i32 0, i32 0
  %11 = load %union.GCObject.365*** %hash, align 8
  %12 = bitcast %union.GCObject.365** %11 to i8*
  %13 = load %struct.stringtable.350** %tb, align 8
  %size3 = getelementptr inbounds %struct.stringtable.350* %13, i32 0, i32 2
  %14 = load i32* %size3, align 4
  %conv4 = sext i32 %14 to i64
  %mul = mul i64 %conv4, 8
  %15 = load i32* %newsize.addr, align 4
  %conv5 = sext i32 %15 to i64
  %mul6 = mul i64 %conv5, 8
  %call = call i8* bitcast (i8* (%struct.lua_State*, i8*, i64, i64)* @luaM_realloc_ to i8* (%struct.lua_State.364*, i8*, i64, i64)*)(%struct.lua_State.364* %9, i8* %12, i64 %mul, i64 %mul6)
  %16 = bitcast i8* %call to %union.GCObject.365**
  %17 = load %struct.stringtable.350** %tb, align 8
  %hash7 = getelementptr inbounds %struct.stringtable.350* %17, i32 0, i32 0
  store %union.GCObject.365** %16, %union.GCObject.365*** %hash7, align 8
  %18 = load %struct.stringtable.350** %tb, align 8
  %size8 = getelementptr inbounds %struct.stringtable.350* %18, i32 0, i32 2
  %19 = load i32* %size8, align 4
  store i32 %19, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %20 = load i32* %i, align 4
  %21 = load i32* %newsize.addr, align 4
  %cmp9 = icmp slt i32 %20, %21
  br i1 %cmp9, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %22 = load i32* %i, align 4
  %idxprom = sext i32 %22 to i64
  %23 = load %struct.stringtable.350** %tb, align 8
  %hash11 = getelementptr inbounds %struct.stringtable.350* %23, i32 0, i32 0
  %24 = load %union.GCObject.365*** %hash11, align 8
  %arrayidx = getelementptr inbounds %union.GCObject.365** %24, i64 %idxprom
  store %union.GCObject.365* null, %union.GCObject.365** %arrayidx, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %25 = load i32* %i, align 4
  %inc = add nsw i32 %25, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end

if.end:                                           ; preds = %for.end, %entry
  store i32 0, i32* %i, align 4
  br label %for.cond12

for.cond12:                                       ; preds = %for.inc37, %if.end
  %26 = load i32* %i, align 4
  %27 = load %struct.stringtable.350** %tb, align 8
  %size13 = getelementptr inbounds %struct.stringtable.350* %27, i32 0, i32 2
  %28 = load i32* %size13, align 4
  %cmp14 = icmp slt i32 %26, %28
  br i1 %cmp14, label %for.body16, label %for.end39

for.body16:                                       ; preds = %for.cond12
  %29 = load i32* %i, align 4
  %idxprom17 = sext i32 %29 to i64
  %30 = load %struct.stringtable.350** %tb, align 8
  %hash18 = getelementptr inbounds %struct.stringtable.350* %30, i32 0, i32 0
  %31 = load %union.GCObject.365*** %hash18, align 8
  %arrayidx19 = getelementptr inbounds %union.GCObject.365** %31, i64 %idxprom17
  %32 = load %union.GCObject.365** %arrayidx19, align 8
  store %union.GCObject.365* %32, %union.GCObject.365** %p, align 8
  %33 = load i32* %i, align 4
  %idxprom20 = sext i32 %33 to i64
  %34 = load %struct.stringtable.350** %tb, align 8
  %hash21 = getelementptr inbounds %struct.stringtable.350* %34, i32 0, i32 0
  %35 = load %union.GCObject.365*** %hash21, align 8
  %arrayidx22 = getelementptr inbounds %union.GCObject.365** %35, i64 %idxprom20
  store %union.GCObject.365* null, %union.GCObject.365** %arrayidx22, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %for.body16
  %36 = load %union.GCObject.365** %p, align 8
  %tobool = icmp ne %union.GCObject.365* %36, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %37 = load %union.GCObject.365** %p, align 8
  %gch = bitcast %union.GCObject.365* %37 to %struct.GCheader.370*
  %next23 = getelementptr inbounds %struct.GCheader.370* %gch, i32 0, i32 0
  %38 = load %union.GCObject.365** %next23, align 8
  store %union.GCObject.365* %38, %union.GCObject.365** %next, align 8
  %39 = load %union.GCObject.365** %p, align 8
  %ts = bitcast %union.GCObject.365* %39 to %union.TString.367*
  %tsv = bitcast %union.TString.367* %ts to %struct.anon.366*
  %hash24 = getelementptr inbounds %struct.anon.366* %tsv, i32 0, i32 4
  %40 = load i32* %hash24, align 4
  %41 = load i32* %newsize.addr, align 4
  %sub = sub nsw i32 %41, 1
  %and = and i32 %40, %sub
  store i32 %and, i32* %h, align 4
  %42 = load i32* %h, align 4
  %idxprom25 = zext i32 %42 to i64
  %43 = load %struct.stringtable.350** %tb, align 8
  %hash26 = getelementptr inbounds %struct.stringtable.350* %43, i32 0, i32 0
  %44 = load %union.GCObject.365*** %hash26, align 8
  %arrayidx27 = getelementptr inbounds %union.GCObject.365** %44, i64 %idxprom25
  %45 = load %union.GCObject.365** %arrayidx27, align 8
  %46 = load %union.GCObject.365** %p, align 8
  %gch28 = bitcast %union.GCObject.365* %46 to %struct.GCheader.370*
  %next29 = getelementptr inbounds %struct.GCheader.370* %gch28, i32 0, i32 0
  store %union.GCObject.365* %45, %union.GCObject.365** %next29, align 8
  %47 = load %union.GCObject.365** %p, align 8
  %48 = load i32* %h, align 4
  %idxprom30 = zext i32 %48 to i64
  %49 = load %struct.stringtable.350** %tb, align 8
  %hash31 = getelementptr inbounds %struct.stringtable.350* %49, i32 0, i32 0
  %50 = load %union.GCObject.365*** %hash31, align 8
  %arrayidx32 = getelementptr inbounds %union.GCObject.365** %50, i64 %idxprom30
  store %union.GCObject.365* %47, %union.GCObject.365** %arrayidx32, align 8
  %51 = load %union.GCObject.365** %p, align 8
  %gch33 = bitcast %union.GCObject.365* %51 to %struct.GCheader.370*
  %marked = getelementptr inbounds %struct.GCheader.370* %gch33, i32 0, i32 2
  %52 = load i8* %marked, align 1
  %conv34 = zext i8 %52 to i32
  %and35 = and i32 %conv34, 191
  %conv36 = trunc i32 %and35 to i8
  store i8 %conv36, i8* %marked, align 1
  %53 = load %union.GCObject.365** %next, align 8
  store %union.GCObject.365* %53, %union.GCObject.365** %p, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  br label %for.inc37

for.inc37:                                        ; preds = %while.end
  %54 = load i32* %i, align 4
  %inc38 = add nsw i32 %54, 1
  store i32 %inc38, i32* %i, align 4
  br label %for.cond12

for.end39:                                        ; preds = %for.cond12
  %55 = load i32* %newsize.addr, align 4
  %56 = load %struct.stringtable.350** %tb, align 8
  %size40 = getelementptr inbounds %struct.stringtable.350* %56, i32 0, i32 2
  %57 = load i32* %size40, align 4
  %cmp41 = icmp slt i32 %55, %57
  br i1 %cmp41, label %if.then43, label %if.end60

if.then43:                                        ; preds = %for.end39
  %58 = load i32* %newsize.addr, align 4
  %add44 = add nsw i32 %58, 1
  %conv45 = sext i32 %add44 to i64
  %cmp46 = icmp ugt i64 %conv45, 2305843009213693951
  br i1 %cmp46, label %cond.true48, label %cond.false49

cond.true48:                                      ; preds = %if.then43
  %59 = load %struct.lua_State.364** %L.addr, align 8
  call void bitcast (void (%struct.lua_State*)* @luaM_toobig to void (%struct.lua_State.364*)*)(%struct.lua_State.364* %59) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end50

cond.false49:                                     ; preds = %if.then43
  br label %cond.end50

cond.end50:                                       ; preds = %cond.false49, %60
  %cond51 = phi i32 [ 0, %60 ], [ 0, %cond.false49 ]
  %61 = load %struct.lua_State.364** %L.addr, align 8
  %62 = load %struct.stringtable.350** %tb, align 8
  %hash52 = getelementptr inbounds %struct.stringtable.350* %62, i32 0, i32 0
  %63 = load %union.GCObject.365*** %hash52, align 8
  %64 = bitcast %union.GCObject.365** %63 to i8*
  %65 = load %struct.stringtable.350** %tb, align 8
  %size53 = getelementptr inbounds %struct.stringtable.350* %65, i32 0, i32 2
  %66 = load i32* %size53, align 4
  %conv54 = sext i32 %66 to i64
  %mul55 = mul i64 %conv54, 8
  %67 = load i32* %newsize.addr, align 4
  %conv56 = sext i32 %67 to i64
  %mul57 = mul i64 %conv56, 8
  %call58 = call i8* bitcast (i8* (%struct.lua_State*, i8*, i64, i64)* @luaM_realloc_ to i8* (%struct.lua_State.364*, i8*, i64, i64)*)(%struct.lua_State.364* %61, i8* %64, i64 %mul55, i64 %mul57)
  %68 = bitcast i8* %call58 to %union.GCObject.365**
  %69 = load %struct.stringtable.350** %tb, align 8
  %hash59 = getelementptr inbounds %struct.stringtable.350* %69, i32 0, i32 0
  store %union.GCObject.365** %68, %union.GCObject.365*** %hash59, align 8
  br label %if.end60

if.end60:                                         ; preds = %cond.end50, %for.end39
  %70 = load i32* %newsize.addr, align 4
  %71 = load %struct.stringtable.350** %tb, align 8
  %size61 = getelementptr inbounds %struct.stringtable.350* %71, i32 0, i32 2
  store i32 %70, i32* %size61, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define hidden %union.TString.367* @luaS_newlstr(%struct.lua_State.364* %L, i8* %str, i64 %l) #0 {
entry:
  %retval = alloca %union.TString.367*, align 8
  %L.addr = alloca %struct.lua_State.364*, align 8
  %str.addr = alloca i8*, align 8
  %l.addr = alloca i64, align 8
  store %struct.lua_State.364* %L, %struct.lua_State.364** %L.addr, align 8
  store i8* %str, i8** %str.addr, align 8
  store i64 %l, i64* %l.addr, align 8
  %0 = load i64* %l.addr, align 8
  %cmp = icmp ule i64 %0, 40
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load %struct.lua_State.364** %L.addr, align 8
  %2 = load i8** %str.addr, align 8
  %3 = load i64* %l.addr, align 8
  %call = call %union.TString.367* @internshrstr(%struct.lua_State.364* %1, i8* %2, i64 %3)
  store %union.TString.367* %call, %union.TString.367** %retval
  br label %return

if.else:                                          ; preds = %entry
  %4 = load i64* %l.addr, align 8
  %add = add i64 %4, 1
  %cmp1 = icmp ugt i64 %add, -27
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.else
  %5 = load %struct.lua_State.364** %L.addr, align 8
  call void bitcast (void (%struct.lua_State*)* @luaM_toobig to void (%struct.lua_State.364*)*)(%struct.lua_State.364* %5) #9
  unreachable

if.end:                                           ; preds = %if.else
  %6 = load %struct.lua_State.364** %L.addr, align 8
  %7 = load i8** %str.addr, align 8
  %8 = load i64* %l.addr, align 8
  %9 = load %struct.lua_State.364** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State.364* %9, i32 0, i32 5
  %10 = load %struct.global_State.358** %l_G, align 8
  %seed = getelementptr inbounds %struct.global_State.358* %10, i32 0, i32 8
  %11 = load i32* %seed, align 4
  %call3 = call %union.TString.367* @createstrobj(%struct.lua_State.364* %6, i8* %7, i64 %8, i32 20, i32 %11, %union.GCObject.365** null)
  store %union.TString.367* %call3, %union.TString.367** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %12 = load %union.TString.367** %retval
  ret %union.TString.367* %12
}

; Function Attrs: nounwind uwtable
define hidden %union.TString.367* @luaS_new(%struct.lua_State.364* %L, i8* %str) #0 {
entry:
  %L.addr = alloca %struct.lua_State.364*, align 8
  %str.addr = alloca i8*, align 8
  store %struct.lua_State.364* %L, %struct.lua_State.364** %L.addr, align 8
  store i8* %str, i8** %str.addr, align 8
  %0 = load %struct.lua_State.364** %L.addr, align 8
  %1 = load i8** %str.addr, align 8
  %2 = load i8** %str.addr, align 8
  %call = call i64 @strlen(i8* %2) #10
  %call1 = call %union.TString.367* @luaS_newlstr(%struct.lua_State.364* %0, i8* %1, i64 %call)
  ret %union.TString.367* %call1
}

; Function Attrs: nounwind uwtable
define hidden %union.Udata.369* @luaS_newudata(%struct.lua_State.364* %L, i64 %s, %struct.Table.357* %e) #0 {
entry:
  %L.addr = alloca %struct.lua_State.364*, align 8
  %s.addr = alloca i64, align 8
  %e.addr = alloca %struct.Table.357*, align 8
  %u = alloca %union.Udata.369*, align 8
  store %struct.lua_State.364* %L, %struct.lua_State.364** %L.addr, align 8
  store i64 %s, i64* %s.addr, align 8
  store %struct.Table.357* %e, %struct.Table.357** %e.addr, align 8
  %0 = load i64* %s.addr, align 8
  %cmp = icmp ugt i64 %0, -43
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.lua_State.364** %L.addr, align 8
  call void bitcast (void (%struct.lua_State*)* @luaM_toobig to void (%struct.lua_State.364*)*)(%struct.lua_State.364* %1) #9
  unreachable

if.end:                                           ; preds = %entry
  %2 = load %struct.lua_State.364** %L.addr, align 8
  %3 = load i64* %s.addr, align 8
  %add = add i64 40, %3
  %call = call %union.GCObject.365* bitcast (%union.GCObject* (%struct.lua_State*, i32, i64, %union.GCObject**, i32)* @luaC_newobj to %union.GCObject.365* (%struct.lua_State.364*, i32, i64, %union.GCObject.365**, i32)*)(%struct.lua_State.364* %2, i32 7, i64 %add, %union.GCObject.365** null, i32 0)
  %u1 = bitcast %union.GCObject.365* %call to %union.Udata.369*
  store %union.Udata.369* %u1, %union.Udata.369** %u, align 8
  %4 = load i64* %s.addr, align 8
  %5 = load %union.Udata.369** %u, align 8
  %uv = bitcast %union.Udata.369* %5 to %struct.anon.0.368*
  %len = getelementptr inbounds %struct.anon.0.368* %uv, i32 0, i32 5
  store i64 %4, i64* %len, align 8
  %6 = load %union.Udata.369** %u, align 8
  %uv2 = bitcast %union.Udata.369* %6 to %struct.anon.0.368*
  %metatable = getelementptr inbounds %struct.anon.0.368* %uv2, i32 0, i32 3
  store %struct.Table.357* null, %struct.Table.357** %metatable, align 8
  %7 = load %struct.Table.357** %e.addr, align 8
  %8 = load %union.Udata.369** %u, align 8
  %uv3 = bitcast %union.Udata.369* %8 to %struct.anon.0.368*
  %env = getelementptr inbounds %struct.anon.0.368* %uv3, i32 0, i32 4
  store %struct.Table.357* %7, %struct.Table.357** %env, align 8
  %9 = load %union.Udata.369** %u, align 8
  ret %union.Udata.369* %9
}

; Function Attrs: nounwind uwtable
define internal %union.TString.367* @internshrstr(%struct.lua_State.364* %L, i8* %str, i64 %l) #0 {
entry:
  %retval = alloca %union.TString.367*, align 8
  %L.addr = alloca %struct.lua_State.364*, align 8
  %str.addr = alloca i8*, align 8
  %l.addr = alloca i64, align 8
  %o = alloca %union.GCObject.365*, align 8
  %g = alloca %struct.global_State.358*, align 8
  %h = alloca i32, align 4
  %ts = alloca %union.TString.367*, align 8
  store %struct.lua_State.364* %L, %struct.lua_State.364** %L.addr, align 8
  store i8* %str, i8** %str.addr, align 8
  store i64 %l, i64* %l.addr, align 8
  %0 = load %struct.lua_State.364** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State.364* %0, i32 0, i32 5
  %1 = load %struct.global_State.358** %l_G, align 8
  store %struct.global_State.358* %1, %struct.global_State.358** %g, align 8
  %2 = load i8** %str.addr, align 8
  %3 = load i64* %l.addr, align 8
  %4 = load %struct.global_State.358** %g, align 8
  %seed = getelementptr inbounds %struct.global_State.358* %4, i32 0, i32 8
  %5 = load i32* %seed, align 4
  %call = call i32 @luaS_hash(i8* %2, i64 %3, i32 %5)
  store i32 %call, i32* %h, align 4
  %6 = load i32* %h, align 4
  %7 = load %struct.global_State.358** %g, align 8
  %strt = getelementptr inbounds %struct.global_State.358* %7, i32 0, i32 6
  %size = getelementptr inbounds %struct.stringtable.350* %strt, i32 0, i32 2
  %8 = load i32* %size, align 4
  %sub = sub nsw i32 %8, 1
  %and = and i32 %6, %sub
  %idxprom = sext i32 %and to i64
  %9 = load %struct.global_State.358** %g, align 8
  %strt1 = getelementptr inbounds %struct.global_State.358* %9, i32 0, i32 6
  %hash = getelementptr inbounds %struct.stringtable.350* %strt1, i32 0, i32 0
  %10 = load %union.GCObject.365*** %hash, align 8
  %arrayidx = getelementptr inbounds %union.GCObject.365** %10, i64 %idxprom
  %11 = load %union.GCObject.365** %arrayidx, align 8
  store %union.GCObject.365* %11, %union.GCObject.365** %o, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %12 = load %union.GCObject.365** %o, align 8
  %cmp = icmp ne %union.GCObject.365* %12, null
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %13 = load %union.GCObject.365** %o, align 8
  %ts2 = bitcast %union.GCObject.365* %13 to %union.TString.367*
  store %union.TString.367* %ts2, %union.TString.367** %ts, align 8
  %14 = load i32* %h, align 4
  %15 = load %union.TString.367** %ts, align 8
  %tsv = bitcast %union.TString.367* %15 to %struct.anon.366*
  %hash3 = getelementptr inbounds %struct.anon.366* %tsv, i32 0, i32 4
  %16 = load i32* %hash3, align 4
  %cmp4 = icmp eq i32 %14, %16
  br i1 %cmp4, label %land.lhs.true, label %if.end20

land.lhs.true:                                    ; preds = %for.body
  %17 = load i64* %l.addr, align 8
  %18 = load %union.TString.367** %ts, align 8
  %tsv5 = bitcast %union.TString.367* %18 to %struct.anon.366*
  %len = getelementptr inbounds %struct.anon.366* %tsv5, i32 0, i32 5
  %19 = load i64* %len, align 8
  %cmp6 = icmp eq i64 %17, %19
  br i1 %cmp6, label %land.lhs.true7, label %if.end20

land.lhs.true7:                                   ; preds = %land.lhs.true
  %20 = load i8** %str.addr, align 8
  %21 = load %union.TString.367** %ts, align 8
  %add.ptr = getelementptr inbounds %union.TString.367* %21, i64 1
  %22 = bitcast %union.TString.367* %add.ptr to i8*
  %23 = load i64* %l.addr, align 8
  %mul = mul i64 %23, 1
  %call8 = call i32 @memcmp(i8* %20, i8* %22, i64 %mul) #10
  %cmp9 = icmp eq i32 %call8, 0
  br i1 %cmp9, label %if.then, label %if.end20

if.then:                                          ; preds = %land.lhs.true7
  %24 = load %union.GCObject.365** %o, align 8
  %gch = bitcast %union.GCObject.365* %24 to %struct.GCheader.370*
  %marked = getelementptr inbounds %struct.GCheader.370* %gch, i32 0, i32 2
  %25 = load i8* %marked, align 1
  %conv = zext i8 %25 to i32
  %xor = xor i32 %conv, 3
  %26 = load %struct.lua_State.364** %L.addr, align 8
  %l_G10 = getelementptr inbounds %struct.lua_State.364* %26, i32 0, i32 5
  %27 = load %struct.global_State.358** %l_G10, align 8
  %currentwhite = getelementptr inbounds %struct.global_State.358* %27, i32 0, i32 9
  %28 = load i8* %currentwhite, align 1
  %conv11 = zext i8 %28 to i32
  %xor12 = xor i32 %conv11, 3
  %and13 = and i32 %xor, %xor12
  %tobool = icmp ne i32 %and13, 0
  br i1 %tobool, label %if.end, label %if.then14

if.then14:                                        ; preds = %if.then
  %29 = load %union.GCObject.365** %o, align 8
  %gch15 = bitcast %union.GCObject.365* %29 to %struct.GCheader.370*
  %marked16 = getelementptr inbounds %struct.GCheader.370* %gch15, i32 0, i32 2
  %30 = load i8* %marked16, align 1
  %conv17 = zext i8 %30 to i32
  %xor18 = xor i32 %conv17, 3
  %conv19 = trunc i32 %xor18 to i8
  store i8 %conv19, i8* %marked16, align 1
  br label %if.end

if.end:                                           ; preds = %if.then14, %if.then
  %31 = load %union.TString.367** %ts, align 8
  store %union.TString.367* %31, %union.TString.367** %retval
  br label %return

if.end20:                                         ; preds = %land.lhs.true7, %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end20
  %32 = load %union.GCObject.365** %o, align 8
  %gch21 = bitcast %union.GCObject.365* %32 to %struct.GCheader.370*
  %next = getelementptr inbounds %struct.GCheader.370* %gch21, i32 0, i32 0
  %33 = load %union.GCObject.365** %next, align 8
  store %union.GCObject.365* %33, %union.GCObject.365** %o, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %34 = load %struct.lua_State.364** %L.addr, align 8
  %35 = load i8** %str.addr, align 8
  %36 = load i64* %l.addr, align 8
  %37 = load i32* %h, align 4
  %call22 = call %union.TString.367* @newshrstr(%struct.lua_State.364* %34, i8* %35, i64 %36, i32 %37)
  store %union.TString.367* %call22, %union.TString.367** %retval
  br label %return

return:                                           ; preds = %for.end, %if.end
  %38 = load %union.TString.367** %retval
  ret %union.TString.367* %38
}

; Function Attrs: nounwind uwtable
define internal %union.TString.367* @createstrobj(%struct.lua_State.364* %L, i8* %str, i64 %l, i32 %tag, i32 %h, %union.GCObject.365** %list) #0 {
entry:
  %L.addr = alloca %struct.lua_State.364*, align 8
  %str.addr = alloca i8*, align 8
  %l.addr = alloca i64, align 8
  %tag.addr = alloca i32, align 4
  %h.addr = alloca i32, align 4
  %list.addr = alloca %union.GCObject.365**, align 8
  %ts = alloca %union.TString.367*, align 8
  %totalsize = alloca i64, align 8
  store %struct.lua_State.364* %L, %struct.lua_State.364** %L.addr, align 8
  store i8* %str, i8** %str.addr, align 8
  store i64 %l, i64* %l.addr, align 8
  store i32 %tag, i32* %tag.addr, align 4
  store i32 %h, i32* %h.addr, align 4
  store %union.GCObject.365** %list, %union.GCObject.365*** %list.addr, align 8
  %0 = load i64* %l.addr, align 8
  %add = add i64 %0, 1
  %mul = mul i64 %add, 1
  %add1 = add i64 24, %mul
  store i64 %add1, i64* %totalsize, align 8
  %1 = load %struct.lua_State.364** %L.addr, align 8
  %2 = load i32* %tag.addr, align 4
  %3 = load i64* %totalsize, align 8
  %4 = load %union.GCObject.365*** %list.addr, align 8
  %call = call %union.GCObject.365* bitcast (%union.GCObject* (%struct.lua_State*, i32, i64, %union.GCObject**, i32)* @luaC_newobj to %union.GCObject.365* (%struct.lua_State.364*, i32, i64, %union.GCObject.365**, i32)*)(%struct.lua_State.364* %1, i32 %2, i64 %3, %union.GCObject.365** %4, i32 0)
  %ts2 = bitcast %union.GCObject.365* %call to %union.TString.367*
  store %union.TString.367* %ts2, %union.TString.367** %ts, align 8
  %5 = load i64* %l.addr, align 8
  %6 = load %union.TString.367** %ts, align 8
  %tsv = bitcast %union.TString.367* %6 to %struct.anon.366*
  %len = getelementptr inbounds %struct.anon.366* %tsv, i32 0, i32 5
  store i64 %5, i64* %len, align 8
  %7 = load i32* %h.addr, align 4
  %8 = load %union.TString.367** %ts, align 8
  %tsv3 = bitcast %union.TString.367* %8 to %struct.anon.366*
  %hash = getelementptr inbounds %struct.anon.366* %tsv3, i32 0, i32 4
  store i32 %7, i32* %hash, align 4
  %9 = load %union.TString.367** %ts, align 8
  %tsv4 = bitcast %union.TString.367* %9 to %struct.anon.366*
  %extra = getelementptr inbounds %struct.anon.366* %tsv4, i32 0, i32 3
  store i8 0, i8* %extra, align 1
  %10 = load %union.TString.367** %ts, align 8
  %add.ptr = getelementptr inbounds %union.TString.367* %10, i64 1
  %11 = bitcast %union.TString.367* %add.ptr to i8*
  %12 = load i8** %str.addr, align 8
  %13 = load i64* %l.addr, align 8
  %mul5 = mul i64 %13, 1
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %11, i8* %12, i64 %mul5, i32 1, i1 false)
  %14 = load i64* %l.addr, align 8
  %15 = load %union.TString.367** %ts, align 8
  %add.ptr6 = getelementptr inbounds %union.TString.367* %15, i64 1
  %16 = bitcast %union.TString.367* %add.ptr6 to i8*
  %arrayidx = getelementptr inbounds i8* %16, i64 %14
  store i8 0, i8* %arrayidx, align 1
  %17 = load %union.TString.367** %ts, align 8
  ret %union.TString.367* %17
}

; Function Attrs: nounwind uwtable
define internal %union.TString.367* @newshrstr(%struct.lua_State.364* %L, i8* %str, i64 %l, i32 %h) #0 {
entry:
  %L.addr = alloca %struct.lua_State.364*, align 8
  %str.addr = alloca i8*, align 8
  %l.addr = alloca i64, align 8
  %h.addr = alloca i32, align 4
  %list = alloca %union.GCObject.365**, align 8
  %tb = alloca %struct.stringtable.350*, align 8
  %s = alloca %union.TString.367*, align 8
  store %struct.lua_State.364* %L, %struct.lua_State.364** %L.addr, align 8
  store i8* %str, i8** %str.addr, align 8
  store i64 %l, i64* %l.addr, align 8
  store i32 %h, i32* %h.addr, align 4
  %0 = load %struct.lua_State.364** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State.364* %0, i32 0, i32 5
  %1 = load %struct.global_State.358** %l_G, align 8
  %strt = getelementptr inbounds %struct.global_State.358* %1, i32 0, i32 6
  store %struct.stringtable.350* %strt, %struct.stringtable.350** %tb, align 8
  %2 = load %struct.stringtable.350** %tb, align 8
  %nuse = getelementptr inbounds %struct.stringtable.350* %2, i32 0, i32 1
  %3 = load i32* %nuse, align 4
  %4 = load %struct.stringtable.350** %tb, align 8
  %size = getelementptr inbounds %struct.stringtable.350* %4, i32 0, i32 2
  %5 = load i32* %size, align 4
  %cmp = icmp uge i32 %3, %5
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %6 = load %struct.stringtable.350** %tb, align 8
  %size1 = getelementptr inbounds %struct.stringtable.350* %6, i32 0, i32 2
  %7 = load i32* %size1, align 4
  %cmp2 = icmp sle i32 %7, 1073741822
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %8 = load %struct.lua_State.364** %L.addr, align 8
  %9 = load %struct.stringtable.350** %tb, align 8
  %size3 = getelementptr inbounds %struct.stringtable.350* %9, i32 0, i32 2
  %10 = load i32* %size3, align 4
  %mul = mul nsw i32 %10, 2
  call void @luaS_resize(%struct.lua_State.364* %8, i32 %mul)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %11 = load i32* %h.addr, align 4
  %12 = load %struct.stringtable.350** %tb, align 8
  %size4 = getelementptr inbounds %struct.stringtable.350* %12, i32 0, i32 2
  %13 = load i32* %size4, align 4
  %sub = sub nsw i32 %13, 1
  %and = and i32 %11, %sub
  %idxprom = sext i32 %and to i64
  %14 = load %struct.stringtable.350** %tb, align 8
  %hash = getelementptr inbounds %struct.stringtable.350* %14, i32 0, i32 0
  %15 = load %union.GCObject.365*** %hash, align 8
  %arrayidx = getelementptr inbounds %union.GCObject.365** %15, i64 %idxprom
  store %union.GCObject.365** %arrayidx, %union.GCObject.365*** %list, align 8
  %16 = load %struct.lua_State.364** %L.addr, align 8
  %17 = load i8** %str.addr, align 8
  %18 = load i64* %l.addr, align 8
  %19 = load i32* %h.addr, align 4
  %20 = load %union.GCObject.365*** %list, align 8
  %call = call %union.TString.367* @createstrobj(%struct.lua_State.364* %16, i8* %17, i64 %18, i32 4, i32 %19, %union.GCObject.365** %20)
  store %union.TString.367* %call, %union.TString.367** %s, align 8
  %21 = load %struct.stringtable.350** %tb, align 8
  %nuse5 = getelementptr inbounds %struct.stringtable.350* %21, i32 0, i32 1
  %22 = load i32* %nuse5, align 4
  %inc = add i32 %22, 1
  store i32 %inc, i32* %nuse5, align 4
  %23 = load %union.TString.367** %s, align 8
  ret %union.TString.367* %23
}

; Function Attrs: nounwind uwtable
define i32 @luaopen_string(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 14)
  %1 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_setfuncs(%struct.lua_State* %1, %struct.luaL_Reg* getelementptr inbounds ([15 x %struct.luaL_Reg]* @strlib, i32 0, i32 0), i32 0)
  %2 = load %struct.lua_State** %L.addr, align 8
  call void @createmetatable(%struct.lua_State* %2)
  ret i32 1
}

; Function Attrs: nounwind
declare i32 @tolower(i32) #4

; Function Attrs: nounwind readonly
declare i8* @memchr(i8*, i32, i64) #2

; Function Attrs: nounwind uwtable
define internal i32 @str_byte(%struct.lua_State* %L) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %l = alloca i64, align 8
  %s = alloca i8*, align 8
  %posi = alloca i64, align 8
  %pose = alloca i64, align 8
  %n = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* %l)
  store i8* %call, i8** %s, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i64 @luaL_optinteger(%struct.lua_State* %1, i32 2, i64 1)
  %2 = load i64* %l, align 8
  %call2 = call i64 @posrelat(i64 %call1, i64 %2)
  store i64 %call2, i64* %posi, align 8
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load i64* %posi, align 8
  %call3 = call i64 @luaL_optinteger(%struct.lua_State* %3, i32 3, i64 %4)
  %5 = load i64* %l, align 8
  %call4 = call i64 @posrelat(i64 %call3, i64 %5)
  store i64 %call4, i64* %pose, align 8
  %6 = load i64* %posi, align 8
  %cmp = icmp ult i64 %6, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 1, i64* %posi, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %7 = load i64* %pose, align 8
  %8 = load i64* %l, align 8
  %cmp5 = icmp ugt i64 %7, %8
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  %9 = load i64* %l, align 8
  store i64 %9, i64* %pose, align 8
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %if.end
  %10 = load i64* %posi, align 8
  %11 = load i64* %pose, align 8
  %cmp8 = icmp ugt i64 %10, %11
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end7
  store i32 0, i32* %retval
  br label %return

if.end10:                                         ; preds = %if.end7
  %12 = load i64* %pose, align 8
  %13 = load i64* %posi, align 8
  %sub = sub i64 %12, %13
  %add = add i64 %sub, 1
  %conv = trunc i64 %add to i32
  store i32 %conv, i32* %n, align 4
  %14 = load i64* %posi, align 8
  %15 = load i32* %n, align 4
  %conv11 = sext i32 %15 to i64
  %add12 = add i64 %14, %conv11
  %16 = load i64* %pose, align 8
  %cmp13 = icmp ule i64 %add12, %16
  br i1 %cmp13, label %if.then15, label %if.end17

if.then15:                                        ; preds = %if.end10
  %17 = load %struct.lua_State** %L.addr, align 8
  %call16 = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %17, i8* getelementptr inbounds ([22 x i8]* @.str43703, i32 0, i32 0))
  store i32 %call16, i32* %retval
  br label %return

if.end17:                                         ; preds = %if.end10
  %18 = load %struct.lua_State** %L.addr, align 8
  %19 = load i32* %n, align 4
  call void @luaL_checkstack(%struct.lua_State* %18, i32 %19, i8* getelementptr inbounds ([22 x i8]* @.str43703, i32 0, i32 0))
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end17
  %20 = load i32* %i, align 4
  %21 = load i32* %n, align 4
  %cmp18 = icmp slt i32 %20, %21
  br i1 %cmp18, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %22 = load %struct.lua_State** %L.addr, align 8
  %23 = load i64* %posi, align 8
  %24 = load i32* %i, align 4
  %conv20 = sext i32 %24 to i64
  %add21 = add i64 %23, %conv20
  %sub22 = sub i64 %add21, 1
  %25 = load i8** %s, align 8
  %arrayidx = getelementptr inbounds i8* %25, i64 %sub22
  %26 = load i8* %arrayidx, align 1
  %conv23 = zext i8 %26 to i64
  call void @lua_pushinteger(%struct.lua_State* %22, i64 %conv23)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %27 = load i32* %i, align 4
  %inc = add nsw i32 %27, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %28 = load i32* %n, align 4
  store i32 %28, i32* %retval
  br label %return

return:                                           ; preds = %for.end, %if.then15, %if.then9
  %29 = load i32* %retval
  ret i32 %29
}

; Function Attrs: nounwind uwtable
define internal i32 @str_char(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %n = alloca i32, align 4
  %i = alloca i32, align 4
  %b = alloca %struct.luaL_Buffer, align 8
  %p = alloca i8*, align 8
  %c = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_gettop(%struct.lua_State* %0)
  store i32 %call, i32* %n, align 4
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load i32* %n, align 4
  %conv = sext i32 %2 to i64
  %call1 = call i8* @luaL_buffinitsize(%struct.lua_State* %1, %struct.luaL_Buffer* %b, i64 %conv)
  store i8* %call1, i8** %p, align 8
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %3 = load i32* %i, align 4
  %4 = load i32* %n, align 4
  %cmp = icmp sle i32 %3, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load %struct.lua_State** %L.addr, align 8
  %6 = load i32* %i, align 4
  %call3 = call i64 @luaL_checkinteger(%struct.lua_State* %5, i32 %6)
  %conv4 = trunc i64 %call3 to i32
  store i32 %conv4, i32* %c, align 4
  %7 = load i32* %c, align 4
  %conv5 = trunc i32 %7 to i8
  %conv6 = zext i8 %conv5 to i32
  %8 = load i32* %c, align 4
  %cmp7 = icmp eq i32 %conv6, %8
  br i1 %cmp7, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %for.body
  %9 = load %struct.lua_State** %L.addr, align 8
  %10 = load i32* %i, align 4
  %call9 = call i32 @luaL_argerror(%struct.lua_State* %9, i32 %10, i8* getelementptr inbounds ([19 x i8]* @.str42702, i32 0, i32 0))
  %tobool = icmp ne i32 %call9, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %for.body
  %11 = phi i1 [ true, %for.body ], [ %tobool, %lor.rhs ]
  %lor.ext = zext i1 %11 to i32
  %12 = load i32* %c, align 4
  %conv10 = trunc i32 %12 to i8
  %13 = load i32* %i, align 4
  %sub = sub nsw i32 %13, 1
  %idxprom = sext i32 %sub to i64
  %14 = load i8** %p, align 8
  %arrayidx = getelementptr inbounds i8* %14, i64 %idxprom
  store i8 %conv10, i8* %arrayidx, align 1
  br label %for.inc

for.inc:                                          ; preds = %lor.end
  %15 = load i32* %i, align 4
  %inc = add nsw i32 %15, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %16 = load i32* %n, align 4
  %conv11 = sext i32 %16 to i64
  call void @luaL_pushresultsize(%struct.luaL_Buffer* %b, i64 %conv11)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @str_dump(%struct.lua_State* %L) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %b = alloca %struct.luaL_Buffer, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_checktype(%struct.lua_State* %0, i32 1, i32 6)
  %1 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %1, i32 1)
  %2 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_buffinit(%struct.lua_State* %2, %struct.luaL_Buffer* %b)
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = bitcast %struct.luaL_Buffer* %b to i8*
  %call = call i32 @lua_dump(%struct.lua_State* %3, i32 (%struct.lua_State*, i8*, i64, i8*)* @writer, i8* %4)
  %cmp = icmp ne i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %5, i8* getelementptr inbounds ([30 x i8]* @.str41701, i32 0, i32 0))
  store i32 %call1, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  call void @luaL_pushresult(%struct.luaL_Buffer* %b)
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i32* %retval
  ret i32 %6
}

; Function Attrs: nounwind uwtable
define internal i32 @str_find(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @str_find_aux(%struct.lua_State* %0, i32 1)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @str_format(%struct.lua_State* %L) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %top = alloca i32, align 4
  %arg = alloca i32, align 4
  %sfl = alloca i64, align 8
  %strfrmt = alloca i8*, align 8
  %strfrmt_end = alloca i8*, align 8
  %b = alloca %struct.luaL_Buffer, align 8
  %form = alloca [19 x i8], align 16
  %buff = alloca i8*, align 8
  %nb = alloca i32, align 4
  %n43 = alloca double, align 8
  %ni = alloca i64, align 8
  %diff = alloca double, align 8
  %n60 = alloca double, align 8
  %ni62 = alloca i64, align 8
  %diff64 = alloca double, align 8
  %l = alloca i64, align 8
  %s = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_gettop(%struct.lua_State* %0)
  store i32 %call, i32* %top, align 4
  store i32 1, i32* %arg, align 4
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load i32* %arg, align 4
  %call1 = call i8* @luaL_checklstring(%struct.lua_State* %1, i32 %2, i64* %sfl)
  store i8* %call1, i8** %strfrmt, align 8
  %3 = load i8** %strfrmt, align 8
  %4 = load i64* %sfl, align 8
  %add.ptr = getelementptr inbounds i8* %3, i64 %4
  store i8* %add.ptr, i8** %strfrmt_end, align 8
  %5 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_buffinit(%struct.lua_State* %5, %struct.luaL_Buffer* %b)
  br label %while.cond

while.cond:                                       ; preds = %if.end104, %entry
  %6 = load i8** %strfrmt, align 8
  %7 = load i8** %strfrmt_end, align 8
  %cmp = icmp ult i8* %6, %7
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %8 = load i8** %strfrmt, align 8
  %9 = load i8* %8, align 1
  %conv = sext i8 %9 to i32
  %cmp2 = icmp ne i32 %conv, 37
  br i1 %cmp2, label %if.then, label %if.else

if.then:                                          ; preds = %while.body
  %n = getelementptr inbounds %struct.luaL_Buffer* %b, i32 0, i32 2
  %10 = load i64* %n, align 8
  %size = getelementptr inbounds %struct.luaL_Buffer* %b, i32 0, i32 1
  %11 = load i64* %size, align 8
  %cmp4 = icmp ult i64 %10, %11
  br i1 %cmp4, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.then
  %call6 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* %b, i64 1)
  %tobool = icmp ne i8* %call6, null
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.then
  %12 = phi i1 [ true, %if.then ], [ %tobool, %lor.rhs ]
  %lor.ext = zext i1 %12 to i32
  %13 = load i8** %strfrmt, align 8
  %incdec.ptr = getelementptr inbounds i8* %13, i32 1
  store i8* %incdec.ptr, i8** %strfrmt, align 8
  %14 = load i8* %13, align 1
  %n7 = getelementptr inbounds %struct.luaL_Buffer* %b, i32 0, i32 2
  %15 = load i64* %n7, align 8
  %inc = add i64 %15, 1
  store i64 %inc, i64* %n7, align 8
  %b8 = getelementptr inbounds %struct.luaL_Buffer* %b, i32 0, i32 0
  %16 = load i8** %b8, align 8
  %arrayidx = getelementptr inbounds i8* %16, i64 %15
  store i8 %14, i8* %arrayidx, align 1
  br label %if.end104

if.else:                                          ; preds = %while.body
  %17 = load i8** %strfrmt, align 8
  %incdec.ptr9 = getelementptr inbounds i8* %17, i32 1
  store i8* %incdec.ptr9, i8** %strfrmt, align 8
  %18 = load i8* %incdec.ptr9, align 1
  %conv10 = sext i8 %18 to i32
  %cmp11 = icmp eq i32 %conv10, 37
  br i1 %cmp11, label %if.then13, label %if.else28

if.then13:                                        ; preds = %if.else
  %n14 = getelementptr inbounds %struct.luaL_Buffer* %b, i32 0, i32 2
  %19 = load i64* %n14, align 8
  %size15 = getelementptr inbounds %struct.luaL_Buffer* %b, i32 0, i32 1
  %20 = load i64* %size15, align 8
  %cmp16 = icmp ult i64 %19, %20
  br i1 %cmp16, label %lor.end21, label %lor.rhs18

lor.rhs18:                                        ; preds = %if.then13
  %call19 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* %b, i64 1)
  %tobool20 = icmp ne i8* %call19, null
  br label %lor.end21

lor.end21:                                        ; preds = %lor.rhs18, %if.then13
  %21 = phi i1 [ true, %if.then13 ], [ %tobool20, %lor.rhs18 ]
  %lor.ext22 = zext i1 %21 to i32
  %22 = load i8** %strfrmt, align 8
  %incdec.ptr23 = getelementptr inbounds i8* %22, i32 1
  store i8* %incdec.ptr23, i8** %strfrmt, align 8
  %23 = load i8* %22, align 1
  %n24 = getelementptr inbounds %struct.luaL_Buffer* %b, i32 0, i32 2
  %24 = load i64* %n24, align 8
  %inc25 = add i64 %24, 1
  store i64 %inc25, i64* %n24, align 8
  %b26 = getelementptr inbounds %struct.luaL_Buffer* %b, i32 0, i32 0
  %25 = load i8** %b26, align 8
  %arrayidx27 = getelementptr inbounds i8* %25, i64 %24
  store i8 %23, i8* %arrayidx27, align 1
  br label %if.end103

if.else28:                                        ; preds = %if.else
  %call29 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* %b, i64 512)
  store i8* %call29, i8** %buff, align 8
  store i32 0, i32* %nb, align 4
  %26 = load i32* %arg, align 4
  %inc30 = add nsw i32 %26, 1
  store i32 %inc30, i32* %arg, align 4
  %27 = load i32* %top, align 4
  %cmp31 = icmp sgt i32 %inc30, %27
  br i1 %cmp31, label %if.then33, label %if.end

if.then33:                                        ; preds = %if.else28
  %28 = load %struct.lua_State** %L.addr, align 8
  %29 = load i32* %arg, align 4
  %call34 = call i32 @luaL_argerror(%struct.lua_State* %28, i32 %29, i8* getelementptr inbounds ([9 x i8]* @.str31691, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then33, %if.else28
  %30 = load %struct.lua_State** %L.addr, align 8
  %31 = load i8** %strfrmt, align 8
  %arraydecay = getelementptr inbounds [19 x i8]* %form, i32 0, i32 0
  %call35 = call i8* @scanformat(%struct.lua_State* %30, i8* %31, i8* %arraydecay)
  store i8* %call35, i8** %strfrmt, align 8
  %32 = load i8** %strfrmt, align 8
  %incdec.ptr36 = getelementptr inbounds i8* %32, i32 1
  store i8* %incdec.ptr36, i8** %strfrmt, align 8
  %33 = load i8* %32, align 1
  %conv37 = sext i8 %33 to i32
  switch i32 %conv37, label %sw.default [
    i32 99, label %sw.bb
    i32 100, label %sw.bb42
    i32 105, label %sw.bb42
    i32 111, label %sw.bb59
    i32 117, label %sw.bb59
    i32 120, label %sw.bb59
    i32 88, label %sw.bb59
    i32 101, label %sw.bb80
    i32 69, label %sw.bb80
    i32 102, label %sw.bb80
    i32 97, label %sw.bb80
    i32 65, label %sw.bb80
    i32 103, label %sw.bb80
    i32 71, label %sw.bb80
    i32 113, label %sw.bb85
    i32 115, label %sw.bb86
  ]

sw.bb:                                            ; preds = %if.end
  %34 = load i8** %buff, align 8
  %arraydecay38 = getelementptr inbounds [19 x i8]* %form, i32 0, i32 0
  %35 = load %struct.lua_State** %L.addr, align 8
  %36 = load i32* %arg, align 4
  %call39 = call i64 @luaL_checkinteger(%struct.lua_State* %35, i32 %36)
  %conv40 = trunc i64 %call39 to i32
  %call41 = call i32 (i8*, i8*, ...)* @sprintf(i8* %34, i8* %arraydecay38, i32 %conv40) #1
  store i32 %call41, i32* %nb, align 4
  br label %sw.epilog

sw.bb42:                                          ; preds = %if.end, %if.end
  %37 = load %struct.lua_State** %L.addr, align 8
  %38 = load i32* %arg, align 4
  %call44 = call double @luaL_checknumber(%struct.lua_State* %37, i32 %38)
  store double %call44, double* %n43, align 8
  %39 = load double* %n43, align 8
  %conv45 = fptosi double %39 to i64
  store i64 %conv45, i64* %ni, align 8
  %40 = load double* %n43, align 8
  %41 = load i64* %ni, align 8
  %conv46 = sitofp i64 %41 to double
  %sub = fsub double %40, %conv46
  store double %sub, double* %diff, align 8
  %42 = load double* %diff, align 8
  %cmp47 = fcmp olt double -1.000000e+00, %42
  br i1 %cmp47, label %land.lhs.true, label %lor.rhs51

land.lhs.true:                                    ; preds = %sw.bb42
  %43 = load double* %diff, align 8
  %cmp49 = fcmp olt double %43, 1.000000e+00
  br i1 %cmp49, label %lor.end54, label %lor.rhs51

lor.rhs51:                                        ; preds = %land.lhs.true, %sw.bb42
  %44 = load %struct.lua_State** %L.addr, align 8
  %45 = load i32* %arg, align 4
  %call52 = call i32 @luaL_argerror(%struct.lua_State* %44, i32 %45, i8* getelementptr inbounds ([29 x i8]* @.str32692, i32 0, i32 0))
  %tobool53 = icmp ne i32 %call52, 0
  br label %lor.end54

lor.end54:                                        ; preds = %lor.rhs51, %land.lhs.true
  %46 = phi i1 [ true, %land.lhs.true ], [ %tobool53, %lor.rhs51 ]
  %lor.ext55 = zext i1 %46 to i32
  %arraydecay56 = getelementptr inbounds [19 x i8]* %form, i32 0, i32 0
  call void @addlenmod(i8* %arraydecay56, i8* getelementptr inbounds ([3 x i8]* @.str33693, i32 0, i32 0))
  %47 = load i8** %buff, align 8
  %arraydecay57 = getelementptr inbounds [19 x i8]* %form, i32 0, i32 0
  %48 = load i64* %ni, align 8
  %call58 = call i32 (i8*, i8*, ...)* @sprintf(i8* %47, i8* %arraydecay57, i64 %48) #1
  store i32 %call58, i32* %nb, align 4
  br label %sw.epilog

sw.bb59:                                          ; preds = %if.end, %if.end, %if.end, %if.end
  %49 = load %struct.lua_State** %L.addr, align 8
  %50 = load i32* %arg, align 4
  %call61 = call double @luaL_checknumber(%struct.lua_State* %49, i32 %50)
  store double %call61, double* %n60, align 8
  %51 = load double* %n60, align 8
  %conv63 = fptoui double %51 to i64
  store i64 %conv63, i64* %ni62, align 8
  %52 = load double* %n60, align 8
  %53 = load i64* %ni62, align 8
  %conv65 = uitofp i64 %53 to double
  %sub66 = fsub double %52, %conv65
  store double %sub66, double* %diff64, align 8
  %54 = load double* %diff64, align 8
  %cmp67 = fcmp olt double -1.000000e+00, %54
  br i1 %cmp67, label %land.lhs.true69, label %lor.rhs72

land.lhs.true69:                                  ; preds = %sw.bb59
  %55 = load double* %diff64, align 8
  %cmp70 = fcmp olt double %55, 1.000000e+00
  br i1 %cmp70, label %lor.end75, label %lor.rhs72

lor.rhs72:                                        ; preds = %land.lhs.true69, %sw.bb59
  %56 = load %struct.lua_State** %L.addr, align 8
  %57 = load i32* %arg, align 4
  %call73 = call i32 @luaL_argerror(%struct.lua_State* %56, i32 %57, i8* getelementptr inbounds ([42 x i8]* @.str34694, i32 0, i32 0))
  %tobool74 = icmp ne i32 %call73, 0
  br label %lor.end75

lor.end75:                                        ; preds = %lor.rhs72, %land.lhs.true69
  %58 = phi i1 [ true, %land.lhs.true69 ], [ %tobool74, %lor.rhs72 ]
  %lor.ext76 = zext i1 %58 to i32
  %arraydecay77 = getelementptr inbounds [19 x i8]* %form, i32 0, i32 0
  call void @addlenmod(i8* %arraydecay77, i8* getelementptr inbounds ([3 x i8]* @.str33693, i32 0, i32 0))
  %59 = load i8** %buff, align 8
  %arraydecay78 = getelementptr inbounds [19 x i8]* %form, i32 0, i32 0
  %60 = load i64* %ni62, align 8
  %call79 = call i32 (i8*, i8*, ...)* @sprintf(i8* %59, i8* %arraydecay78, i64 %60) #1
  store i32 %call79, i32* %nb, align 4
  br label %sw.epilog

sw.bb80:                                          ; preds = %if.end, %if.end, %if.end, %if.end, %if.end, %if.end, %if.end
  %arraydecay81 = getelementptr inbounds [19 x i8]* %form, i32 0, i32 0
  call void @addlenmod(i8* %arraydecay81, i8* getelementptr inbounds ([1 x i8]* @.str660, i32 0, i32 0))
  %61 = load i8** %buff, align 8
  %arraydecay82 = getelementptr inbounds [19 x i8]* %form, i32 0, i32 0
  %62 = load %struct.lua_State** %L.addr, align 8
  %63 = load i32* %arg, align 4
  %call83 = call double @luaL_checknumber(%struct.lua_State* %62, i32 %63)
  %call84 = call i32 (i8*, i8*, ...)* @sprintf(i8* %61, i8* %arraydecay82, double %call83) #1
  store i32 %call84, i32* %nb, align 4
  br label %sw.epilog

sw.bb85:                                          ; preds = %if.end
  %64 = load %struct.lua_State** %L.addr, align 8
  %65 = load i32* %arg, align 4
  call void @addquoted(%struct.lua_State* %64, %struct.luaL_Buffer* %b, i32 %65)
  br label %sw.epilog

sw.bb86:                                          ; preds = %if.end
  %66 = load %struct.lua_State** %L.addr, align 8
  %67 = load i32* %arg, align 4
  %call87 = call i8* @luaL_tolstring(%struct.lua_State* %66, i32 %67, i64* %l)
  store i8* %call87, i8** %s, align 8
  %arraydecay88 = getelementptr inbounds [19 x i8]* %form, i32 0, i32 0
  %call89 = call i8* @strchr(i8* %arraydecay88, i32 46) #10
  %tobool90 = icmp ne i8* %call89, null
  br i1 %tobool90, label %if.else95, label %land.lhs.true91

land.lhs.true91:                                  ; preds = %sw.bb86
  %68 = load i64* %l, align 8
  %cmp92 = icmp uge i64 %68, 100
  br i1 %cmp92, label %if.then94, label %if.else95

if.then94:                                        ; preds = %land.lhs.true91
  call void @luaL_addvalue(%struct.luaL_Buffer* %b)
  br label %sw.epilog

if.else95:                                        ; preds = %land.lhs.true91, %sw.bb86
  %69 = load i8** %buff, align 8
  %arraydecay96 = getelementptr inbounds [19 x i8]* %form, i32 0, i32 0
  %70 = load i8** %s, align 8
  %call97 = call i32 (i8*, i8*, ...)* @sprintf(i8* %69, i8* %arraydecay96, i8* %70) #1
  store i32 %call97, i32* %nb, align 4
  %71 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %71, i32 -2)
  br label %sw.epilog

sw.default:                                       ; preds = %if.end
  %72 = load %struct.lua_State** %L.addr, align 8
  %73 = load i8** %strfrmt, align 8
  %add.ptr98 = getelementptr inbounds i8* %73, i64 -1
  %74 = load i8* %add.ptr98, align 1
  %conv99 = sext i8 %74 to i32
  %call100 = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %72, i8* getelementptr inbounds ([34 x i8]* @.str35695, i32 0, i32 0), i32 %conv99)
  store i32 %call100, i32* %retval
  br label %return

sw.epilog:                                        ; preds = %if.else95, %if.then94, %sw.bb85, %sw.bb80, %lor.end75, %lor.end54, %sw.bb
  %75 = load i32* %nb, align 4
  %conv101 = sext i32 %75 to i64
  %n102 = getelementptr inbounds %struct.luaL_Buffer* %b, i32 0, i32 2
  %76 = load i64* %n102, align 8
  %add = add i64 %76, %conv101
  store i64 %add, i64* %n102, align 8
  br label %if.end103

if.end103:                                        ; preds = %sw.epilog, %lor.end21
  br label %if.end104

if.end104:                                        ; preds = %if.end103, %lor.end
  br label %while.cond

while.end:                                        ; preds = %while.cond
  call void @luaL_pushresult(%struct.luaL_Buffer* %b)
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %while.end, %sw.default
  %77 = load i32* %retval
  ret i32 %77
}

; Function Attrs: nounwind uwtable
define internal i32 @gmatch(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null)
  %1 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i8* @luaL_checklstring(%struct.lua_State* %1, i32 2, i64* null)
  %2 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %2, i32 2)
  %3 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushinteger(%struct.lua_State* %3, i64 0)
  %4 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushcclosure(%struct.lua_State* %4, i32 (%struct.lua_State*)* @gmatch_aux, i32 3)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @str_gsub(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %srcl = alloca i64, align 8
  %lp = alloca i64, align 8
  %src = alloca i8*, align 8
  %p = alloca i8*, align 8
  %tr = alloca i32, align 4
  %max_s = alloca i64, align 8
  %anchor = alloca i32, align 4
  %n = alloca i64, align 8
  %ms = alloca %struct.MatchState, align 8
  %b = alloca %struct.luaL_Buffer, align 8
  %e = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* %srcl)
  store i8* %call, i8** %src, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i8* @luaL_checklstring(%struct.lua_State* %1, i32 2, i64* %lp)
  store i8* %call1, i8** %p, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %call2 = call i32 @lua_type(%struct.lua_State* %2, i32 3)
  store i32 %call2, i32* %tr, align 4
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load i64* %srcl, align 8
  %add = add i64 %4, 1
  %call3 = call i64 @luaL_optinteger(%struct.lua_State* %3, i32 4, i64 %add)
  store i64 %call3, i64* %max_s, align 8
  %5 = load i8** %p, align 8
  %6 = load i8* %5, align 1
  %conv = sext i8 %6 to i32
  %cmp = icmp eq i32 %conv, 94
  %conv4 = zext i1 %cmp to i32
  store i32 %conv4, i32* %anchor, align 4
  store i64 0, i64* %n, align 8
  %7 = load i32* %tr, align 4
  %cmp5 = icmp eq i32 %7, 3
  br i1 %cmp5, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %8 = load i32* %tr, align 4
  %cmp7 = icmp eq i32 %8, 4
  br i1 %cmp7, label %lor.end, label %lor.lhs.false9

lor.lhs.false9:                                   ; preds = %lor.lhs.false
  %9 = load i32* %tr, align 4
  %cmp10 = icmp eq i32 %9, 6
  br i1 %cmp10, label %lor.end, label %lor.lhs.false12

lor.lhs.false12:                                  ; preds = %lor.lhs.false9
  %10 = load i32* %tr, align 4
  %cmp13 = icmp eq i32 %10, 5
  br i1 %cmp13, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false12
  %11 = load %struct.lua_State** %L.addr, align 8
  %call15 = call i32 @luaL_argerror(%struct.lua_State* %11, i32 3, i8* getelementptr inbounds ([31 x i8]* @.str28688, i32 0, i32 0))
  %tobool = icmp ne i32 %call15, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false12, %lor.lhs.false9, %lor.lhs.false, %entry
  %12 = phi i1 [ true, %lor.lhs.false12 ], [ true, %lor.lhs.false9 ], [ true, %lor.lhs.false ], [ true, %entry ], [ %tobool, %lor.rhs ]
  %lor.ext = zext i1 %12 to i32
  %13 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_buffinit(%struct.lua_State* %13, %struct.luaL_Buffer* %b)
  %14 = load i32* %anchor, align 4
  %tobool16 = icmp ne i32 %14, 0
  br i1 %tobool16, label %if.then, label %if.end

if.then:                                          ; preds = %lor.end
  %15 = load i8** %p, align 8
  %incdec.ptr = getelementptr inbounds i8* %15, i32 1
  store i8* %incdec.ptr, i8** %p, align 8
  %16 = load i64* %lp, align 8
  %dec = add i64 %16, -1
  store i64 %dec, i64* %lp, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.end
  %17 = load %struct.lua_State** %L.addr, align 8
  %L17 = getelementptr inbounds %struct.MatchState* %ms, i32 0, i32 4
  store %struct.lua_State* %17, %struct.lua_State** %L17, align 8
  %matchdepth = getelementptr inbounds %struct.MatchState* %ms, i32 0, i32 0
  store i32 200, i32* %matchdepth, align 4
  %18 = load i8** %src, align 8
  %src_init = getelementptr inbounds %struct.MatchState* %ms, i32 0, i32 1
  store i8* %18, i8** %src_init, align 8
  %19 = load i8** %src, align 8
  %20 = load i64* %srcl, align 8
  %add.ptr = getelementptr inbounds i8* %19, i64 %20
  %src_end = getelementptr inbounds %struct.MatchState* %ms, i32 0, i32 2
  store i8* %add.ptr, i8** %src_end, align 8
  %21 = load i8** %p, align 8
  %22 = load i64* %lp, align 8
  %add.ptr18 = getelementptr inbounds i8* %21, i64 %22
  %p_end = getelementptr inbounds %struct.MatchState* %ms, i32 0, i32 3
  store i8* %add.ptr18, i8** %p_end, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end50, %if.end
  %23 = load i64* %n, align 8
  %24 = load i64* %max_s, align 8
  %cmp19 = icmp ult i64 %23, %24
  br i1 %cmp19, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %level = getelementptr inbounds %struct.MatchState* %ms, i32 0, i32 5
  store i32 0, i32* %level, align 4
  %25 = load i8** %src, align 8
  %26 = load i8** %p, align 8
  %call21 = call i8* @match(%struct.MatchState* %ms, i8* %25, i8* %26)
  store i8* %call21, i8** %e, align 8
  %27 = load i8** %e, align 8
  %tobool22 = icmp ne i8* %27, null
  br i1 %tobool22, label %if.then23, label %if.end24

if.then23:                                        ; preds = %while.body
  %28 = load i64* %n, align 8
  %inc = add i64 %28, 1
  store i64 %inc, i64* %n, align 8
  %29 = load i8** %src, align 8
  %30 = load i8** %e, align 8
  %31 = load i32* %tr, align 4
  call void @add_value(%struct.MatchState* %ms, %struct.luaL_Buffer* %b, i8* %29, i8* %30, i32 %31)
  br label %if.end24

if.end24:                                         ; preds = %if.then23, %while.body
  %32 = load i8** %e, align 8
  %tobool25 = icmp ne i8* %32, null
  br i1 %tobool25, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.end24
  %33 = load i8** %e, align 8
  %34 = load i8** %src, align 8
  %cmp26 = icmp ugt i8* %33, %34
  br i1 %cmp26, label %if.then28, label %if.else

if.then28:                                        ; preds = %land.lhs.true
  %35 = load i8** %e, align 8
  store i8* %35, i8** %src, align 8
  br label %if.end47

if.else:                                          ; preds = %land.lhs.true, %if.end24
  %36 = load i8** %src, align 8
  %src_end29 = getelementptr inbounds %struct.MatchState* %ms, i32 0, i32 2
  %37 = load i8** %src_end29, align 8
  %cmp30 = icmp ult i8* %36, %37
  br i1 %cmp30, label %if.then32, label %if.else45

if.then32:                                        ; preds = %if.else
  %n33 = getelementptr inbounds %struct.luaL_Buffer* %b, i32 0, i32 2
  %38 = load i64* %n33, align 8
  %size = getelementptr inbounds %struct.luaL_Buffer* %b, i32 0, i32 1
  %39 = load i64* %size, align 8
  %cmp34 = icmp ult i64 %38, %39
  br i1 %cmp34, label %lor.end39, label %lor.rhs36

lor.rhs36:                                        ; preds = %if.then32
  %call37 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* %b, i64 1)
  %tobool38 = icmp ne i8* %call37, null
  br label %lor.end39

lor.end39:                                        ; preds = %lor.rhs36, %if.then32
  %40 = phi i1 [ true, %if.then32 ], [ %tobool38, %lor.rhs36 ]
  %lor.ext40 = zext i1 %40 to i32
  %41 = load i8** %src, align 8
  %incdec.ptr41 = getelementptr inbounds i8* %41, i32 1
  store i8* %incdec.ptr41, i8** %src, align 8
  %42 = load i8* %41, align 1
  %n42 = getelementptr inbounds %struct.luaL_Buffer* %b, i32 0, i32 2
  %43 = load i64* %n42, align 8
  %inc43 = add i64 %43, 1
  store i64 %inc43, i64* %n42, align 8
  %b44 = getelementptr inbounds %struct.luaL_Buffer* %b, i32 0, i32 0
  %44 = load i8** %b44, align 8
  %arrayidx = getelementptr inbounds i8* %44, i64 %43
  store i8 %42, i8* %arrayidx, align 1
  br label %if.end46

if.else45:                                        ; preds = %if.else
  br label %while.end

if.end46:                                         ; preds = %lor.end39
  br label %if.end47

if.end47:                                         ; preds = %if.end46, %if.then28
  %45 = load i32* %anchor, align 4
  %tobool48 = icmp ne i32 %45, 0
  br i1 %tobool48, label %if.then49, label %if.end50

if.then49:                                        ; preds = %if.end47
  br label %while.end

if.end50:                                         ; preds = %if.end47
  br label %while.cond

while.end:                                        ; preds = %if.then49, %if.else45, %while.cond
  %46 = load i8** %src, align 8
  %src_end51 = getelementptr inbounds %struct.MatchState* %ms, i32 0, i32 2
  %47 = load i8** %src_end51, align 8
  %48 = load i8** %src, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %47 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %48 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  call void @luaL_addlstring(%struct.luaL_Buffer* %b, i8* %46, i64 %sub.ptr.sub)
  call void @luaL_pushresult(%struct.luaL_Buffer* %b)
  %49 = load %struct.lua_State** %L.addr, align 8
  %50 = load i64* %n, align 8
  call void @lua_pushinteger(%struct.lua_State* %49, i64 %50)
  ret i32 2
}

; Function Attrs: nounwind uwtable
define internal i32 @str_len(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %l = alloca i64, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* %l)
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load i64* %l, align 8
  call void @lua_pushinteger(%struct.lua_State* %1, i64 %2)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @str_lower(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %l = alloca i64, align 8
  %i = alloca i64, align 8
  %b = alloca %struct.luaL_Buffer, align 8
  %s = alloca i8*, align 8
  %p = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* %l)
  store i8* %call, i8** %s, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load i64* %l, align 8
  %call1 = call i8* @luaL_buffinitsize(%struct.lua_State* %1, %struct.luaL_Buffer* %b, i64 %2)
  store i8* %call1, i8** %p, align 8
  store i64 0, i64* %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %3 = load i64* %i, align 8
  %4 = load i64* %l, align 8
  %cmp = icmp ult i64 %3, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load i64* %i, align 8
  %6 = load i8** %s, align 8
  %arrayidx = getelementptr inbounds i8* %6, i64 %5
  %7 = load i8* %arrayidx, align 1
  %conv = zext i8 %7 to i32
  %call2 = call i32 @tolower(i32 %conv) #1
  %conv3 = trunc i32 %call2 to i8
  %8 = load i64* %i, align 8
  %9 = load i8** %p, align 8
  %arrayidx4 = getelementptr inbounds i8* %9, i64 %8
  store i8 %conv3, i8* %arrayidx4, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i64* %i, align 8
  %inc = add i64 %10, 1
  store i64 %inc, i64* %i, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %11 = load i64* %l, align 8
  call void @luaL_pushresultsize(%struct.luaL_Buffer* %b, i64 %11)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @str_match(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @str_find_aux(%struct.lua_State* %0, i32 0)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @str_rep(%struct.lua_State* %L) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %l = alloca i64, align 8
  %lsep = alloca i64, align 8
  %s = alloca i8*, align 8
  %n = alloca i32, align 4
  %sep = alloca i8*, align 8
  %totallen = alloca i64, align 8
  %b = alloca %struct.luaL_Buffer, align 8
  %p = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* %l)
  store i8* %call, i8** %s, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i64 @luaL_checkinteger(%struct.lua_State* %1, i32 2)
  %conv = trunc i64 %call1 to i32
  store i32 %conv, i32* %n, align 4
  %2 = load %struct.lua_State** %L.addr, align 8
  %call2 = call i8* @luaL_optlstring(%struct.lua_State* %2, i32 3, i8* getelementptr inbounds ([1 x i8]* @.str660, i32 0, i32 0), i64* %lsep)
  store i8* %call2, i8** %sep, align 8
  %3 = load i32* %n, align 4
  %cmp = icmp sle i32 %3, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %4 = load %struct.lua_State** %L.addr, align 8
  %call4 = call i8* @lua_pushlstring(%struct.lua_State* %4, i8* getelementptr inbounds ([1 x i8]* @.str660, i32 0, i32 0), i64 0)
  br label %if.end29

if.else:                                          ; preds = %entry
  %5 = load i64* %l, align 8
  %6 = load i64* %lsep, align 8
  %add = add i64 %5, %6
  %7 = load i64* %l, align 8
  %cmp5 = icmp ult i64 %add, %7
  br i1 %cmp5, label %if.then11, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else
  %8 = load i64* %l, align 8
  %9 = load i64* %lsep, align 8
  %add7 = add i64 %8, %9
  %10 = load i32* %n, align 4
  %conv8 = sext i32 %10 to i64
  %div = udiv i64 9223372036854775807, %conv8
  %cmp9 = icmp uge i64 %add7, %div
  br i1 %cmp9, label %if.then11, label %if.else13

if.then11:                                        ; preds = %lor.lhs.false, %if.else
  %11 = load %struct.lua_State** %L.addr, align 8
  %call12 = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %11, i8* getelementptr inbounds ([27 x i8]* @.str16676, i32 0, i32 0))
  store i32 %call12, i32* %retval
  br label %return

if.else13:                                        ; preds = %lor.lhs.false
  %12 = load i32* %n, align 4
  %conv14 = sext i32 %12 to i64
  %13 = load i64* %l, align 8
  %mul = mul i64 %conv14, %13
  %14 = load i32* %n, align 4
  %sub = sub nsw i32 %14, 1
  %conv15 = sext i32 %sub to i64
  %15 = load i64* %lsep, align 8
  %mul16 = mul i64 %conv15, %15
  %add17 = add i64 %mul, %mul16
  store i64 %add17, i64* %totallen, align 8
  %16 = load %struct.lua_State** %L.addr, align 8
  %17 = load i64* %totallen, align 8
  %call18 = call i8* @luaL_buffinitsize(%struct.lua_State* %16, %struct.luaL_Buffer* %b, i64 %17)
  store i8* %call18, i8** %p, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end, %if.else13
  %18 = load i32* %n, align 4
  %dec = add nsw i32 %18, -1
  store i32 %dec, i32* %n, align 4
  %cmp19 = icmp sgt i32 %18, 1
  br i1 %cmp19, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %19 = load i8** %p, align 8
  %20 = load i8** %s, align 8
  %21 = load i64* %l, align 8
  %mul21 = mul i64 %21, 1
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %19, i8* %20, i64 %mul21, i32 1, i1 false)
  %22 = load i64* %l, align 8
  %23 = load i8** %p, align 8
  %add.ptr = getelementptr inbounds i8* %23, i64 %22
  store i8* %add.ptr, i8** %p, align 8
  %24 = load i64* %lsep, align 8
  %cmp22 = icmp ugt i64 %24, 0
  br i1 %cmp22, label %if.then24, label %if.end

if.then24:                                        ; preds = %while.body
  %25 = load i8** %p, align 8
  %26 = load i8** %sep, align 8
  %27 = load i64* %lsep, align 8
  %mul25 = mul i64 %27, 1
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %25, i8* %26, i64 %mul25, i32 1, i1 false)
  %28 = load i64* %lsep, align 8
  %29 = load i8** %p, align 8
  %add.ptr26 = getelementptr inbounds i8* %29, i64 %28
  store i8* %add.ptr26, i8** %p, align 8
  br label %if.end

if.end:                                           ; preds = %if.then24, %while.body
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %30 = load i8** %p, align 8
  %31 = load i8** %s, align 8
  %32 = load i64* %l, align 8
  %mul27 = mul i64 %32, 1
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %30, i8* %31, i64 %mul27, i32 1, i1 false)
  %33 = load i64* %totallen, align 8
  call void @luaL_pushresultsize(%struct.luaL_Buffer* %b, i64 %33)
  br label %if.end28

if.end28:                                         ; preds = %while.end
  br label %if.end29

if.end29:                                         ; preds = %if.end28, %if.then
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %if.end29, %if.then11
  %34 = load i32* %retval
  ret i32 %34
}

; Function Attrs: nounwind uwtable
define internal i32 @str_reverse(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %l = alloca i64, align 8
  %i = alloca i64, align 8
  %b = alloca %struct.luaL_Buffer, align 8
  %s = alloca i8*, align 8
  %p = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* %l)
  store i8* %call, i8** %s, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load i64* %l, align 8
  %call1 = call i8* @luaL_buffinitsize(%struct.lua_State* %1, %struct.luaL_Buffer* %b, i64 %2)
  store i8* %call1, i8** %p, align 8
  store i64 0, i64* %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %3 = load i64* %i, align 8
  %4 = load i64* %l, align 8
  %cmp = icmp ult i64 %3, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load i64* %l, align 8
  %6 = load i64* %i, align 8
  %sub = sub i64 %5, %6
  %sub2 = sub i64 %sub, 1
  %7 = load i8** %s, align 8
  %arrayidx = getelementptr inbounds i8* %7, i64 %sub2
  %8 = load i8* %arrayidx, align 1
  %9 = load i64* %i, align 8
  %10 = load i8** %p, align 8
  %arrayidx3 = getelementptr inbounds i8* %10, i64 %9
  store i8 %8, i8* %arrayidx3, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %11 = load i64* %i, align 8
  %inc = add i64 %11, 1
  store i64 %inc, i64* %i, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %12 = load i64* %l, align 8
  call void @luaL_pushresultsize(%struct.luaL_Buffer* %b, i64 %12)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @str_sub(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %l = alloca i64, align 8
  %s = alloca i8*, align 8
  %start = alloca i64, align 8
  %end = alloca i64, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* %l)
  store i8* %call, i8** %s, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i64 @luaL_checkinteger(%struct.lua_State* %1, i32 2)
  %2 = load i64* %l, align 8
  %call2 = call i64 @posrelat(i64 %call1, i64 %2)
  store i64 %call2, i64* %start, align 8
  %3 = load %struct.lua_State** %L.addr, align 8
  %call3 = call i64 @luaL_optinteger(%struct.lua_State* %3, i32 3, i64 -1)
  %4 = load i64* %l, align 8
  %call4 = call i64 @posrelat(i64 %call3, i64 %4)
  store i64 %call4, i64* %end, align 8
  %5 = load i64* %start, align 8
  %cmp = icmp ult i64 %5, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 1, i64* %start, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load i64* %end, align 8
  %7 = load i64* %l, align 8
  %cmp5 = icmp ugt i64 %6, %7
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  %8 = load i64* %l, align 8
  store i64 %8, i64* %end, align 8
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %if.end
  %9 = load i64* %start, align 8
  %10 = load i64* %end, align 8
  %cmp8 = icmp ule i64 %9, %10
  br i1 %cmp8, label %if.then9, label %if.else

if.then9:                                         ; preds = %if.end7
  %11 = load %struct.lua_State** %L.addr, align 8
  %12 = load i8** %s, align 8
  %13 = load i64* %start, align 8
  %add.ptr = getelementptr inbounds i8* %12, i64 %13
  %add.ptr10 = getelementptr inbounds i8* %add.ptr, i64 -1
  %14 = load i64* %end, align 8
  %15 = load i64* %start, align 8
  %sub = sub i64 %14, %15
  %add = add i64 %sub, 1
  %call11 = call i8* @lua_pushlstring(%struct.lua_State* %11, i8* %add.ptr10, i64 %add)
  br label %if.end13

if.else:                                          ; preds = %if.end7
  %16 = load %struct.lua_State** %L.addr, align 8
  %call12 = call i8* @lua_pushlstring(%struct.lua_State* %16, i8* getelementptr inbounds ([1 x i8]* @.str660, i32 0, i32 0), i64 0)
  br label %if.end13

if.end13:                                         ; preds = %if.else, %if.then9
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @str_upper(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %l = alloca i64, align 8
  %i = alloca i64, align 8
  %b = alloca %struct.luaL_Buffer, align 8
  %s = alloca i8*, align 8
  %p = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* %l)
  store i8* %call, i8** %s, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load i64* %l, align 8
  %call1 = call i8* @luaL_buffinitsize(%struct.lua_State* %1, %struct.luaL_Buffer* %b, i64 %2)
  store i8* %call1, i8** %p, align 8
  store i64 0, i64* %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %3 = load i64* %i, align 8
  %4 = load i64* %l, align 8
  %cmp = icmp ult i64 %3, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load i64* %i, align 8
  %6 = load i8** %s, align 8
  %arrayidx = getelementptr inbounds i8* %6, i64 %5
  %7 = load i8* %arrayidx, align 1
  %conv = zext i8 %7 to i32
  %call2 = call i32 @toupper(i32 %conv) #1
  %conv3 = trunc i32 %call2 to i8
  %8 = load i64* %i, align 8
  %9 = load i8** %p, align 8
  %arrayidx4 = getelementptr inbounds i8* %9, i64 %8
  store i8 %conv3, i8* %arrayidx4, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i64* %i, align 8
  %inc = add i64 %10, 1
  store i64 %inc, i64* %i, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %11 = load i64* %l, align 8
  call void @luaL_pushresultsize(%struct.luaL_Buffer* %b, i64 %11)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal void @createmetatable(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 1)
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @lua_pushlstring(%struct.lua_State* %1, i8* getelementptr inbounds ([1 x i8]* @.str660, i32 0, i32 0), i64 0)
  %2 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushvalue(%struct.lua_State* %2, i32 -2)
  %3 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i32 @lua_setmetatable(%struct.lua_State* %3, i32 -2)
  %4 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %4, i32 -2)
  %5 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushvalue(%struct.lua_State* %5, i32 -2)
  %6 = load %struct.lua_State** %L.addr, align 8
  call void @lua_setfield(%struct.lua_State* %6, i32 -2, i8* getelementptr inbounds ([8 x i8]* @.str1661, i32 0, i32 0))
  %7 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %7, i32 -2)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @posrelat(i64 %pos, i64 %len) #0 {
entry:
  %retval = alloca i64, align 8
  %pos.addr = alloca i64, align 8
  %len.addr = alloca i64, align 8
  store i64 %pos, i64* %pos.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  %0 = load i64* %pos.addr, align 8
  %cmp = icmp sge i64 %0, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i64* %pos.addr, align 8
  store i64 %1, i64* %retval
  br label %return

if.else:                                          ; preds = %entry
  %2 = load i64* %pos.addr, align 8
  %sub = sub i64 0, %2
  %3 = load i64* %len.addr, align 8
  %cmp1 = icmp ugt i64 %sub, %3
  br i1 %cmp1, label %if.then2, label %if.else3

if.then2:                                         ; preds = %if.else
  store i64 0, i64* %retval
  br label %return

if.else3:                                         ; preds = %if.else
  %4 = load i64* %len.addr, align 8
  %5 = load i64* %pos.addr, align 8
  %sub4 = sub nsw i64 0, %5
  %sub5 = sub i64 %4, %sub4
  %add = add i64 %sub5, 1
  store i64 %add, i64* %retval
  br label %return

return:                                           ; preds = %if.else3, %if.then2, %if.then
  %6 = load i64* %retval
  ret i64 %6
}

; Function Attrs: nounwind uwtable
define internal i32 @writer(%struct.lua_State* %L, i8* %b, i64 %size, i8* %B) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %b.addr = alloca i8*, align 8
  %size.addr = alloca i64, align 8
  %B.addr = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %b, i8** %b.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i8* %B, i8** %B.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i8** %B.addr, align 8
  %2 = bitcast i8* %1 to %struct.luaL_Buffer*
  %3 = load i8** %b.addr, align 8
  %4 = load i64* %size.addr, align 8
  call void @luaL_addlstring(%struct.luaL_Buffer* %2, i8* %3, i64 %4)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @str_find_aux(%struct.lua_State* %L, i32 %find) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %find.addr = alloca i32, align 4
  %ls = alloca i64, align 8
  %lp = alloca i64, align 8
  %s = alloca i8*, align 8
  %p = alloca i8*, align 8
  %init = alloca i64, align 8
  %s2 = alloca i8*, align 8
  %ms = alloca %struct.MatchState, align 8
  %s1 = alloca i8*, align 8
  %anchor = alloca i32, align 4
  %res = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %find, i32* %find.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* %ls)
  store i8* %call, i8** %s, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i8* @luaL_checklstring(%struct.lua_State* %1, i32 2, i64* %lp)
  store i8* %call1, i8** %p, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %call2 = call i64 @luaL_optinteger(%struct.lua_State* %2, i32 3, i64 1)
  %3 = load i64* %ls, align 8
  %call3 = call i64 @posrelat(i64 %call2, i64 %3)
  store i64 %call3, i64* %init, align 8
  %4 = load i64* %init, align 8
  %cmp = icmp ult i64 %4, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i64 1, i64* %init, align 8
  br label %if.end6

if.else:                                          ; preds = %entry
  %5 = load i64* %init, align 8
  %6 = load i64* %ls, align 8
  %add = add i64 %6, 1
  %cmp4 = icmp ugt i64 %5, %add
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.else
  %7 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushnil(%struct.lua_State* %7)
  store i32 1, i32* %retval
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end6

if.end6:                                          ; preds = %if.end, %if.then
  %8 = load i32* %find.addr, align 4
  %tobool = icmp ne i32 %8, 0
  br i1 %tobool, label %land.lhs.true, label %if.else23

land.lhs.true:                                    ; preds = %if.end6
  %9 = load %struct.lua_State** %L.addr, align 8
  %call7 = call i32 @lua_toboolean(%struct.lua_State* %9, i32 4)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.then11, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %10 = load i8** %p, align 8
  %11 = load i64* %lp, align 8
  %call9 = call i32 @nospecials(i8* %10, i64 %11)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.then11, label %if.else23

if.then11:                                        ; preds = %lor.lhs.false, %land.lhs.true
  %12 = load i8** %s, align 8
  %13 = load i64* %init, align 8
  %add.ptr = getelementptr inbounds i8* %12, i64 %13
  %add.ptr12 = getelementptr inbounds i8* %add.ptr, i64 -1
  %14 = load i64* %ls, align 8
  %15 = load i64* %init, align 8
  %sub = sub i64 %14, %15
  %add13 = add i64 %sub, 1
  %16 = load i8** %p, align 8
  %17 = load i64* %lp, align 8
  %call14 = call i8* @lmemfind(i8* %add.ptr12, i64 %add13, i8* %16, i64 %17)
  store i8* %call14, i8** %s2, align 8
  %18 = load i8** %s2, align 8
  %tobool15 = icmp ne i8* %18, null
  br i1 %tobool15, label %if.then16, label %if.end22

if.then16:                                        ; preds = %if.then11
  %19 = load %struct.lua_State** %L.addr, align 8
  %20 = load i8** %s2, align 8
  %21 = load i8** %s, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %20 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %21 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %add17 = add nsw i64 %sub.ptr.sub, 1
  call void @lua_pushinteger(%struct.lua_State* %19, i64 %add17)
  %22 = load %struct.lua_State** %L.addr, align 8
  %23 = load i8** %s2, align 8
  %24 = load i8** %s, align 8
  %sub.ptr.lhs.cast18 = ptrtoint i8* %23 to i64
  %sub.ptr.rhs.cast19 = ptrtoint i8* %24 to i64
  %sub.ptr.sub20 = sub i64 %sub.ptr.lhs.cast18, %sub.ptr.rhs.cast19
  %25 = load i64* %lp, align 8
  %add21 = add i64 %sub.ptr.sub20, %25
  call void @lua_pushinteger(%struct.lua_State* %22, i64 %add21)
  store i32 2, i32* %retval
  br label %return

if.end22:                                         ; preds = %if.then11
  br label %if.end57

if.else23:                                        ; preds = %lor.lhs.false, %if.end6
  %26 = load i8** %s, align 8
  %27 = load i64* %init, align 8
  %add.ptr24 = getelementptr inbounds i8* %26, i64 %27
  %add.ptr25 = getelementptr inbounds i8* %add.ptr24, i64 -1
  store i8* %add.ptr25, i8** %s1, align 8
  %28 = load i8** %p, align 8
  %29 = load i8* %28, align 1
  %conv = sext i8 %29 to i32
  %cmp26 = icmp eq i32 %conv, 94
  %conv27 = zext i1 %cmp26 to i32
  store i32 %conv27, i32* %anchor, align 4
  %30 = load i32* %anchor, align 4
  %tobool28 = icmp ne i32 %30, 0
  br i1 %tobool28, label %if.then29, label %if.end30

if.then29:                                        ; preds = %if.else23
  %31 = load i8** %p, align 8
  %incdec.ptr = getelementptr inbounds i8* %31, i32 1
  store i8* %incdec.ptr, i8** %p, align 8
  %32 = load i64* %lp, align 8
  %dec = add i64 %32, -1
  store i64 %dec, i64* %lp, align 8
  br label %if.end30

if.end30:                                         ; preds = %if.then29, %if.else23
  %33 = load %struct.lua_State** %L.addr, align 8
  %L31 = getelementptr inbounds %struct.MatchState* %ms, i32 0, i32 4
  store %struct.lua_State* %33, %struct.lua_State** %L31, align 8
  %matchdepth = getelementptr inbounds %struct.MatchState* %ms, i32 0, i32 0
  store i32 200, i32* %matchdepth, align 4
  %34 = load i8** %s, align 8
  %src_init = getelementptr inbounds %struct.MatchState* %ms, i32 0, i32 1
  store i8* %34, i8** %src_init, align 8
  %35 = load i8** %s, align 8
  %36 = load i64* %ls, align 8
  %add.ptr32 = getelementptr inbounds i8* %35, i64 %36
  %src_end = getelementptr inbounds %struct.MatchState* %ms, i32 0, i32 2
  store i8* %add.ptr32, i8** %src_end, align 8
  %37 = load i8** %p, align 8
  %38 = load i64* %lp, align 8
  %add.ptr33 = getelementptr inbounds i8* %37, i64 %38
  %p_end = getelementptr inbounds %struct.MatchState* %ms, i32 0, i32 3
  store i8* %add.ptr33, i8** %p_end, align 8
  br label %do.body

do.body:                                          ; preds = %land.end, %if.end30
  %level = getelementptr inbounds %struct.MatchState* %ms, i32 0, i32 5
  store i32 0, i32* %level, align 4
  %39 = load i8** %s1, align 8
  %40 = load i8** %p, align 8
  %call34 = call i8* @match(%struct.MatchState* %ms, i8* %39, i8* %40)
  store i8* %call34, i8** %res, align 8
  %cmp35 = icmp ne i8* %call34, null
  br i1 %cmp35, label %if.then37, label %if.end51

if.then37:                                        ; preds = %do.body
  %41 = load i32* %find.addr, align 4
  %tobool38 = icmp ne i32 %41, 0
  br i1 %tobool38, label %if.then39, label %if.else49

if.then39:                                        ; preds = %if.then37
  %42 = load %struct.lua_State** %L.addr, align 8
  %43 = load i8** %s1, align 8
  %44 = load i8** %s, align 8
  %sub.ptr.lhs.cast40 = ptrtoint i8* %43 to i64
  %sub.ptr.rhs.cast41 = ptrtoint i8* %44 to i64
  %sub.ptr.sub42 = sub i64 %sub.ptr.lhs.cast40, %sub.ptr.rhs.cast41
  %add43 = add nsw i64 %sub.ptr.sub42, 1
  call void @lua_pushinteger(%struct.lua_State* %42, i64 %add43)
  %45 = load %struct.lua_State** %L.addr, align 8
  %46 = load i8** %res, align 8
  %47 = load i8** %s, align 8
  %sub.ptr.lhs.cast44 = ptrtoint i8* %46 to i64
  %sub.ptr.rhs.cast45 = ptrtoint i8* %47 to i64
  %sub.ptr.sub46 = sub i64 %sub.ptr.lhs.cast44, %sub.ptr.rhs.cast45
  call void @lua_pushinteger(%struct.lua_State* %45, i64 %sub.ptr.sub46)
  %call47 = call i32 @push_captures(%struct.MatchState* %ms, i8* null, i8* null)
  %add48 = add nsw i32 %call47, 2
  store i32 %add48, i32* %retval
  br label %return

if.else49:                                        ; preds = %if.then37
  %48 = load i8** %s1, align 8
  %49 = load i8** %res, align 8
  %call50 = call i32 @push_captures(%struct.MatchState* %ms, i8* %48, i8* %49)
  store i32 %call50, i32* %retval
  br label %return

if.end51:                                         ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end51
  %50 = load i8** %s1, align 8
  %incdec.ptr52 = getelementptr inbounds i8* %50, i32 1
  store i8* %incdec.ptr52, i8** %s1, align 8
  %src_end53 = getelementptr inbounds %struct.MatchState* %ms, i32 0, i32 2
  %51 = load i8** %src_end53, align 8
  %cmp54 = icmp ult i8* %50, %51
  br i1 %cmp54, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %do.cond
  %52 = load i32* %anchor, align 4
  %tobool56 = icmp ne i32 %52, 0
  %lnot = xor i1 %tobool56, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %do.cond
  %53 = phi i1 [ false, %do.cond ], [ %lnot, %land.rhs ]
  br i1 %53, label %do.body, label %do.end

do.end:                                           ; preds = %land.end
  br label %if.end57

if.end57:                                         ; preds = %do.end, %if.end22
  %54 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushnil(%struct.lua_State* %54)
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %if.end57, %if.else49, %if.then39, %if.then16, %if.then5
  %55 = load i32* %retval
  ret i32 %55
}

; Function Attrs: nounwind uwtable
define internal i8* @scanformat(%struct.lua_State* %L, i8* %strfrmt, i8* %form) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %strfrmt.addr = alloca i8*, align 8
  %form.addr = alloca i8*, align 8
  %p = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %strfrmt, i8** %strfrmt.addr, align 8
  store i8* %form, i8** %form.addr, align 8
  %0 = load i8** %strfrmt.addr, align 8
  store i8* %0, i8** %p, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %1 = load i8** %p, align 8
  %2 = load i8* %1, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %3 = load i8** %p, align 8
  %4 = load i8* %3, align 1
  %conv2 = sext i8 %4 to i32
  %call = call i8* @strchr(i8* getelementptr inbounds ([6 x i8]* @.str38698, i32 0, i32 0), i32 %conv2) #10
  %cmp3 = icmp ne i8* %call, null
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %5 = phi i1 [ false, %while.cond ], [ %cmp3, %land.rhs ]
  br i1 %5, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %6 = load i8** %p, align 8
  %incdec.ptr = getelementptr inbounds i8* %6, i32 1
  store i8* %incdec.ptr, i8** %p, align 8
  br label %while.cond

while.end:                                        ; preds = %land.end
  %7 = load i8** %p, align 8
  %8 = load i8** %strfrmt.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %7 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %8 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp5 = icmp uge i64 %sub.ptr.sub, 6
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %while.end
  %9 = load %struct.lua_State** %L.addr, align 8
  %call7 = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %9, i8* getelementptr inbounds ([32 x i8]* @.str39699, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %while.end
  %10 = load i8** %p, align 8
  %11 = load i8* %10, align 1
  %conv8 = zext i8 %11 to i32
  %idxprom = sext i32 %conv8 to i64
  %call9 = call i16** @__ctype_b_loc() #11
  %12 = load i16** %call9, align 8
  %arrayidx = getelementptr inbounds i16* %12, i64 %idxprom
  %13 = load i16* %arrayidx, align 2
  %conv10 = zext i16 %13 to i32
  %and = and i32 %conv10, 2048
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then11, label %if.end13

if.then11:                                        ; preds = %if.end
  %14 = load i8** %p, align 8
  %incdec.ptr12 = getelementptr inbounds i8* %14, i32 1
  store i8* %incdec.ptr12, i8** %p, align 8
  br label %if.end13

if.end13:                                         ; preds = %if.then11, %if.end
  %15 = load i8** %p, align 8
  %16 = load i8* %15, align 1
  %conv14 = zext i8 %16 to i32
  %idxprom15 = sext i32 %conv14 to i64
  %call16 = call i16** @__ctype_b_loc() #11
  %17 = load i16** %call16, align 8
  %arrayidx17 = getelementptr inbounds i16* %17, i64 %idxprom15
  %18 = load i16* %arrayidx17, align 2
  %conv18 = zext i16 %18 to i32
  %and19 = and i32 %conv18, 2048
  %tobool20 = icmp ne i32 %and19, 0
  br i1 %tobool20, label %if.then21, label %if.end23

if.then21:                                        ; preds = %if.end13
  %19 = load i8** %p, align 8
  %incdec.ptr22 = getelementptr inbounds i8* %19, i32 1
  store i8* %incdec.ptr22, i8** %p, align 8
  br label %if.end23

if.end23:                                         ; preds = %if.then21, %if.end13
  %20 = load i8** %p, align 8
  %21 = load i8* %20, align 1
  %conv24 = sext i8 %21 to i32
  %cmp25 = icmp eq i32 %conv24, 46
  br i1 %cmp25, label %if.then27, label %if.end49

if.then27:                                        ; preds = %if.end23
  %22 = load i8** %p, align 8
  %incdec.ptr28 = getelementptr inbounds i8* %22, i32 1
  store i8* %incdec.ptr28, i8** %p, align 8
  %23 = load i8** %p, align 8
  %24 = load i8* %23, align 1
  %conv29 = zext i8 %24 to i32
  %idxprom30 = sext i32 %conv29 to i64
  %call31 = call i16** @__ctype_b_loc() #11
  %25 = load i16** %call31, align 8
  %arrayidx32 = getelementptr inbounds i16* %25, i64 %idxprom30
  %26 = load i16* %arrayidx32, align 2
  %conv33 = zext i16 %26 to i32
  %and34 = and i32 %conv33, 2048
  %tobool35 = icmp ne i32 %and34, 0
  br i1 %tobool35, label %if.then36, label %if.end38

if.then36:                                        ; preds = %if.then27
  %27 = load i8** %p, align 8
  %incdec.ptr37 = getelementptr inbounds i8* %27, i32 1
  store i8* %incdec.ptr37, i8** %p, align 8
  br label %if.end38

if.end38:                                         ; preds = %if.then36, %if.then27
  %28 = load i8** %p, align 8
  %29 = load i8* %28, align 1
  %conv39 = zext i8 %29 to i32
  %idxprom40 = sext i32 %conv39 to i64
  %call41 = call i16** @__ctype_b_loc() #11
  %30 = load i16** %call41, align 8
  %arrayidx42 = getelementptr inbounds i16* %30, i64 %idxprom40
  %31 = load i16* %arrayidx42, align 2
  %conv43 = zext i16 %31 to i32
  %and44 = and i32 %conv43, 2048
  %tobool45 = icmp ne i32 %and44, 0
  br i1 %tobool45, label %if.then46, label %if.end48

if.then46:                                        ; preds = %if.end38
  %32 = load i8** %p, align 8
  %incdec.ptr47 = getelementptr inbounds i8* %32, i32 1
  store i8* %incdec.ptr47, i8** %p, align 8
  br label %if.end48

if.end48:                                         ; preds = %if.then46, %if.end38
  br label %if.end49

if.end49:                                         ; preds = %if.end48, %if.end23
  %33 = load i8** %p, align 8
  %34 = load i8* %33, align 1
  %conv50 = zext i8 %34 to i32
  %idxprom51 = sext i32 %conv50 to i64
  %call52 = call i16** @__ctype_b_loc() #11
  %35 = load i16** %call52, align 8
  %arrayidx53 = getelementptr inbounds i16* %35, i64 %idxprom51
  %36 = load i16* %arrayidx53, align 2
  %conv54 = zext i16 %36 to i32
  %and55 = and i32 %conv54, 2048
  %tobool56 = icmp ne i32 %and55, 0
  br i1 %tobool56, label %if.then57, label %if.end59

if.then57:                                        ; preds = %if.end49
  %37 = load %struct.lua_State** %L.addr, align 8
  %call58 = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %37, i8* getelementptr inbounds ([45 x i8]* @.str40700, i32 0, i32 0))
  br label %if.end59

if.end59:                                         ; preds = %if.then57, %if.end49
  %38 = load i8** %form.addr, align 8
  %incdec.ptr60 = getelementptr inbounds i8* %38, i32 1
  store i8* %incdec.ptr60, i8** %form.addr, align 8
  store i8 37, i8* %38, align 1
  %39 = load i8** %form.addr, align 8
  %40 = load i8** %strfrmt.addr, align 8
  %41 = load i8** %p, align 8
  %42 = load i8** %strfrmt.addr, align 8
  %sub.ptr.lhs.cast61 = ptrtoint i8* %41 to i64
  %sub.ptr.rhs.cast62 = ptrtoint i8* %42 to i64
  %sub.ptr.sub63 = sub i64 %sub.ptr.lhs.cast61, %sub.ptr.rhs.cast62
  %add = add nsw i64 %sub.ptr.sub63, 1
  %mul = mul i64 %add, 1
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %39, i8* %40, i64 %mul, i32 1, i1 false)
  %43 = load i8** %p, align 8
  %44 = load i8** %strfrmt.addr, align 8
  %sub.ptr.lhs.cast64 = ptrtoint i8* %43 to i64
  %sub.ptr.rhs.cast65 = ptrtoint i8* %44 to i64
  %sub.ptr.sub66 = sub i64 %sub.ptr.lhs.cast64, %sub.ptr.rhs.cast65
  %add67 = add nsw i64 %sub.ptr.sub66, 1
  %45 = load i8** %form.addr, align 8
  %add.ptr = getelementptr inbounds i8* %45, i64 %add67
  store i8* %add.ptr, i8** %form.addr, align 8
  %46 = load i8** %form.addr, align 8
  store i8 0, i8* %46, align 1
  %47 = load i8** %p, align 8
  ret i8* %47
}

; Function Attrs: nounwind uwtable
define internal void @addlenmod(i8* %form, i8* %lenmod) #0 {
entry:
  %form.addr = alloca i8*, align 8
  %lenmod.addr = alloca i8*, align 8
  %l = alloca i64, align 8
  %lm = alloca i64, align 8
  %spec = alloca i8, align 1
  store i8* %form, i8** %form.addr, align 8
  store i8* %lenmod, i8** %lenmod.addr, align 8
  %0 = load i8** %form.addr, align 8
  %call = call i64 @strlen(i8* %0) #10
  store i64 %call, i64* %l, align 8
  %1 = load i8** %lenmod.addr, align 8
  %call1 = call i64 @strlen(i8* %1) #10
  store i64 %call1, i64* %lm, align 8
  %2 = load i64* %l, align 8
  %sub = sub i64 %2, 1
  %3 = load i8** %form.addr, align 8
  %arrayidx = getelementptr inbounds i8* %3, i64 %sub
  %4 = load i8* %arrayidx, align 1
  store i8 %4, i8* %spec, align 1
  %5 = load i8** %form.addr, align 8
  %6 = load i64* %l, align 8
  %add.ptr = getelementptr inbounds i8* %5, i64 %6
  %add.ptr2 = getelementptr inbounds i8* %add.ptr, i64 -1
  %7 = load i8** %lenmod.addr, align 8
  %call3 = call i8* @strcpy(i8* %add.ptr2, i8* %7) #1
  %8 = load i8* %spec, align 1
  %9 = load i64* %l, align 8
  %10 = load i64* %lm, align 8
  %add = add i64 %9, %10
  %sub4 = sub i64 %add, 1
  %11 = load i8** %form.addr, align 8
  %arrayidx5 = getelementptr inbounds i8* %11, i64 %sub4
  store i8 %8, i8* %arrayidx5, align 1
  %12 = load i64* %l, align 8
  %13 = load i64* %lm, align 8
  %add6 = add i64 %12, %13
  %14 = load i8** %form.addr, align 8
  %arrayidx7 = getelementptr inbounds i8* %14, i64 %add6
  store i8 0, i8* %arrayidx7, align 1
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @addquoted(%struct.lua_State* %L, %struct.luaL_Buffer* %b, i32 %arg) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %b.addr = alloca %struct.luaL_Buffer*, align 8
  %arg.addr = alloca i32, align 4
  %l = alloca i64, align 8
  %s = alloca i8*, align 8
  %buff = alloca [10 x i8], align 1
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.luaL_Buffer* %b, %struct.luaL_Buffer** %b.addr, align 8
  store i32 %arg, i32* %arg.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %arg.addr, align 4
  %call = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 %1, i64* %l)
  store i8* %call, i8** %s, align 8
  %2 = load %struct.luaL_Buffer** %b.addr, align 8
  %n = getelementptr inbounds %struct.luaL_Buffer* %2, i32 0, i32 2
  %3 = load i64* %n, align 8
  %4 = load %struct.luaL_Buffer** %b.addr, align 8
  %size = getelementptr inbounds %struct.luaL_Buffer* %4, i32 0, i32 1
  %5 = load i64* %size, align 8
  %cmp = icmp ult i64 %3, %5
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %6 = load %struct.luaL_Buffer** %b.addr, align 8
  %call1 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* %6, i64 1)
  %tobool = icmp ne i8* %call1, null
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %7 = phi i1 [ true, %entry ], [ %tobool, %lor.rhs ]
  %lor.ext = zext i1 %7 to i32
  %8 = load %struct.luaL_Buffer** %b.addr, align 8
  %n2 = getelementptr inbounds %struct.luaL_Buffer* %8, i32 0, i32 2
  %9 = load i64* %n2, align 8
  %inc = add i64 %9, 1
  store i64 %inc, i64* %n2, align 8
  %10 = load %struct.luaL_Buffer** %b.addr, align 8
  %b3 = getelementptr inbounds %struct.luaL_Buffer* %10, i32 0, i32 0
  %11 = load i8** %b3, align 8
  %arrayidx = getelementptr inbounds i8* %11, i64 %9
  store i8 34, i8* %arrayidx, align 1
  br label %while.cond

while.cond:                                       ; preds = %if.end80, %lor.end
  %12 = load i64* %l, align 8
  %dec = add i64 %12, -1
  store i64 %dec, i64* %l, align 8
  %tobool4 = icmp ne i64 %12, 0
  br i1 %tobool4, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %13 = load i8** %s, align 8
  %14 = load i8* %13, align 1
  %conv = sext i8 %14 to i32
  %cmp5 = icmp eq i32 %conv, 34
  br i1 %cmp5, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.body
  %15 = load i8** %s, align 8
  %16 = load i8* %15, align 1
  %conv7 = sext i8 %16 to i32
  %cmp8 = icmp eq i32 %conv7, 92
  br i1 %cmp8, label %if.then, label %lor.lhs.false10

lor.lhs.false10:                                  ; preds = %lor.lhs.false
  %17 = load i8** %s, align 8
  %18 = load i8* %17, align 1
  %conv11 = sext i8 %18 to i32
  %cmp12 = icmp eq i32 %conv11, 10
  br i1 %cmp12, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false10, %lor.lhs.false, %while.body
  %19 = load %struct.luaL_Buffer** %b.addr, align 8
  %n14 = getelementptr inbounds %struct.luaL_Buffer* %19, i32 0, i32 2
  %20 = load i64* %n14, align 8
  %21 = load %struct.luaL_Buffer** %b.addr, align 8
  %size15 = getelementptr inbounds %struct.luaL_Buffer* %21, i32 0, i32 1
  %22 = load i64* %size15, align 8
  %cmp16 = icmp ult i64 %20, %22
  br i1 %cmp16, label %lor.end21, label %lor.rhs18

lor.rhs18:                                        ; preds = %if.then
  %23 = load %struct.luaL_Buffer** %b.addr, align 8
  %call19 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* %23, i64 1)
  %tobool20 = icmp ne i8* %call19, null
  br label %lor.end21

lor.end21:                                        ; preds = %lor.rhs18, %if.then
  %24 = phi i1 [ true, %if.then ], [ %tobool20, %lor.rhs18 ]
  %lor.ext22 = zext i1 %24 to i32
  %25 = load %struct.luaL_Buffer** %b.addr, align 8
  %n23 = getelementptr inbounds %struct.luaL_Buffer* %25, i32 0, i32 2
  %26 = load i64* %n23, align 8
  %inc24 = add i64 %26, 1
  store i64 %inc24, i64* %n23, align 8
  %27 = load %struct.luaL_Buffer** %b.addr, align 8
  %b25 = getelementptr inbounds %struct.luaL_Buffer* %27, i32 0, i32 0
  %28 = load i8** %b25, align 8
  %arrayidx26 = getelementptr inbounds i8* %28, i64 %26
  store i8 92, i8* %arrayidx26, align 1
  %29 = load %struct.luaL_Buffer** %b.addr, align 8
  %n27 = getelementptr inbounds %struct.luaL_Buffer* %29, i32 0, i32 2
  %30 = load i64* %n27, align 8
  %31 = load %struct.luaL_Buffer** %b.addr, align 8
  %size28 = getelementptr inbounds %struct.luaL_Buffer* %31, i32 0, i32 1
  %32 = load i64* %size28, align 8
  %cmp29 = icmp ult i64 %30, %32
  br i1 %cmp29, label %lor.end34, label %lor.rhs31

lor.rhs31:                                        ; preds = %lor.end21
  %33 = load %struct.luaL_Buffer** %b.addr, align 8
  %call32 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* %33, i64 1)
  %tobool33 = icmp ne i8* %call32, null
  br label %lor.end34

lor.end34:                                        ; preds = %lor.rhs31, %lor.end21
  %34 = phi i1 [ true, %lor.end21 ], [ %tobool33, %lor.rhs31 ]
  %lor.ext35 = zext i1 %34 to i32
  %35 = load i8** %s, align 8
  %36 = load i8* %35, align 1
  %37 = load %struct.luaL_Buffer** %b.addr, align 8
  %n36 = getelementptr inbounds %struct.luaL_Buffer* %37, i32 0, i32 2
  %38 = load i64* %n36, align 8
  %inc37 = add i64 %38, 1
  store i64 %inc37, i64* %n36, align 8
  %39 = load %struct.luaL_Buffer** %b.addr, align 8
  %b38 = getelementptr inbounds %struct.luaL_Buffer* %39, i32 0, i32 0
  %40 = load i8** %b38, align 8
  %arrayidx39 = getelementptr inbounds i8* %40, i64 %38
  store i8 %36, i8* %arrayidx39, align 1
  br label %if.end80

if.else:                                          ; preds = %lor.lhs.false10
  %41 = load i8** %s, align 8
  %42 = load i8* %41, align 1
  %conv40 = sext i8 %42 to i32
  %cmp41 = icmp eq i32 %conv40, 0
  br i1 %cmp41, label %if.then49, label %lor.lhs.false43

lor.lhs.false43:                                  ; preds = %if.else
  %43 = load i8** %s, align 8
  %44 = load i8* %43, align 1
  %conv44 = zext i8 %44 to i32
  %idxprom = sext i32 %conv44 to i64
  %call45 = call i16** @__ctype_b_loc() #11
  %45 = load i16** %call45, align 8
  %arrayidx46 = getelementptr inbounds i16* %45, i64 %idxprom
  %46 = load i16* %arrayidx46, align 2
  %conv47 = zext i16 %46 to i32
  %and = and i32 %conv47, 2
  %tobool48 = icmp ne i32 %and, 0
  br i1 %tobool48, label %if.then49, label %if.else65

if.then49:                                        ; preds = %lor.lhs.false43, %if.else
  %47 = load i8** %s, align 8
  %add.ptr = getelementptr inbounds i8* %47, i64 1
  %48 = load i8* %add.ptr, align 1
  %conv50 = zext i8 %48 to i32
  %idxprom51 = sext i32 %conv50 to i64
  %call52 = call i16** @__ctype_b_loc() #11
  %49 = load i16** %call52, align 8
  %arrayidx53 = getelementptr inbounds i16* %49, i64 %idxprom51
  %50 = load i16* %arrayidx53, align 2
  %conv54 = zext i16 %50 to i32
  %and55 = and i32 %conv54, 2048
  %tobool56 = icmp ne i32 %and55, 0
  br i1 %tobool56, label %if.else60, label %if.then57

if.then57:                                        ; preds = %if.then49
  %arraydecay = getelementptr inbounds [10 x i8]* %buff, i32 0, i32 0
  %51 = load i8** %s, align 8
  %52 = load i8* %51, align 1
  %conv58 = zext i8 %52 to i32
  %call59 = call i32 (i8*, i8*, ...)* @sprintf(i8* %arraydecay, i8* getelementptr inbounds ([4 x i8]* @.str36696, i32 0, i32 0), i32 %conv58) #1
  br label %if.end

if.else60:                                        ; preds = %if.then49
  %arraydecay61 = getelementptr inbounds [10 x i8]* %buff, i32 0, i32 0
  %53 = load i8** %s, align 8
  %54 = load i8* %53, align 1
  %conv62 = zext i8 %54 to i32
  %call63 = call i32 (i8*, i8*, ...)* @sprintf(i8* %arraydecay61, i8* getelementptr inbounds ([6 x i8]* @.str37697, i32 0, i32 0), i32 %conv62) #1
  br label %if.end

if.end:                                           ; preds = %if.else60, %if.then57
  %55 = load %struct.luaL_Buffer** %b.addr, align 8
  %arraydecay64 = getelementptr inbounds [10 x i8]* %buff, i32 0, i32 0
  call void @luaL_addstring(%struct.luaL_Buffer* %55, i8* %arraydecay64)
  br label %if.end79

if.else65:                                        ; preds = %lor.lhs.false43
  %56 = load %struct.luaL_Buffer** %b.addr, align 8
  %n66 = getelementptr inbounds %struct.luaL_Buffer* %56, i32 0, i32 2
  %57 = load i64* %n66, align 8
  %58 = load %struct.luaL_Buffer** %b.addr, align 8
  %size67 = getelementptr inbounds %struct.luaL_Buffer* %58, i32 0, i32 1
  %59 = load i64* %size67, align 8
  %cmp68 = icmp ult i64 %57, %59
  br i1 %cmp68, label %lor.end73, label %lor.rhs70

lor.rhs70:                                        ; preds = %if.else65
  %60 = load %struct.luaL_Buffer** %b.addr, align 8
  %call71 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* %60, i64 1)
  %tobool72 = icmp ne i8* %call71, null
  br label %lor.end73

lor.end73:                                        ; preds = %lor.rhs70, %if.else65
  %61 = phi i1 [ true, %if.else65 ], [ %tobool72, %lor.rhs70 ]
  %lor.ext74 = zext i1 %61 to i32
  %62 = load i8** %s, align 8
  %63 = load i8* %62, align 1
  %64 = load %struct.luaL_Buffer** %b.addr, align 8
  %n75 = getelementptr inbounds %struct.luaL_Buffer* %64, i32 0, i32 2
  %65 = load i64* %n75, align 8
  %inc76 = add i64 %65, 1
  store i64 %inc76, i64* %n75, align 8
  %66 = load %struct.luaL_Buffer** %b.addr, align 8
  %b77 = getelementptr inbounds %struct.luaL_Buffer* %66, i32 0, i32 0
  %67 = load i8** %b77, align 8
  %arrayidx78 = getelementptr inbounds i8* %67, i64 %65
  store i8 %63, i8* %arrayidx78, align 1
  br label %if.end79

if.end79:                                         ; preds = %lor.end73, %if.end
  br label %if.end80

if.end80:                                         ; preds = %if.end79, %lor.end34
  %68 = load i8** %s, align 8
  %incdec.ptr = getelementptr inbounds i8* %68, i32 1
  store i8* %incdec.ptr, i8** %s, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %69 = load %struct.luaL_Buffer** %b.addr, align 8
  %n81 = getelementptr inbounds %struct.luaL_Buffer* %69, i32 0, i32 2
  %70 = load i64* %n81, align 8
  %71 = load %struct.luaL_Buffer** %b.addr, align 8
  %size82 = getelementptr inbounds %struct.luaL_Buffer* %71, i32 0, i32 1
  %72 = load i64* %size82, align 8
  %cmp83 = icmp ult i64 %70, %72
  br i1 %cmp83, label %lor.end88, label %lor.rhs85

lor.rhs85:                                        ; preds = %while.end
  %73 = load %struct.luaL_Buffer** %b.addr, align 8
  %call86 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* %73, i64 1)
  %tobool87 = icmp ne i8* %call86, null
  br label %lor.end88

lor.end88:                                        ; preds = %lor.rhs85, %while.end
  %74 = phi i1 [ true, %while.end ], [ %tobool87, %lor.rhs85 ]
  %lor.ext89 = zext i1 %74 to i32
  %75 = load %struct.luaL_Buffer** %b.addr, align 8
  %n90 = getelementptr inbounds %struct.luaL_Buffer* %75, i32 0, i32 2
  %76 = load i64* %n90, align 8
  %inc91 = add i64 %76, 1
  store i64 %inc91, i64* %n90, align 8
  %77 = load %struct.luaL_Buffer** %b.addr, align 8
  %b92 = getelementptr inbounds %struct.luaL_Buffer* %77, i32 0, i32 0
  %78 = load i8** %b92, align 8
  %arrayidx93 = getelementptr inbounds i8* %78, i64 %76
  store i8 34, i8* %arrayidx93, align 1
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @gmatch_aux(%struct.lua_State* %L) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %ms = alloca %struct.MatchState, align 8
  %ls = alloca i64, align 8
  %lp = alloca i64, align 8
  %s = alloca i8*, align 8
  %p = alloca i8*, align 8
  %src = alloca i8*, align 8
  %e = alloca i8*, align 8
  %newstart = alloca i64, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1001001, i64* %ls)
  store i8* %call, i8** %s, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i8* @lua_tolstring(%struct.lua_State* %1, i32 -1001002, i64* %lp)
  store i8* %call1, i8** %p, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %L2 = getelementptr inbounds %struct.MatchState* %ms, i32 0, i32 4
  store %struct.lua_State* %2, %struct.lua_State** %L2, align 8
  %matchdepth = getelementptr inbounds %struct.MatchState* %ms, i32 0, i32 0
  store i32 200, i32* %matchdepth, align 4
  %3 = load i8** %s, align 8
  %src_init = getelementptr inbounds %struct.MatchState* %ms, i32 0, i32 1
  store i8* %3, i8** %src_init, align 8
  %4 = load i8** %s, align 8
  %5 = load i64* %ls, align 8
  %add.ptr = getelementptr inbounds i8* %4, i64 %5
  %src_end = getelementptr inbounds %struct.MatchState* %ms, i32 0, i32 2
  store i8* %add.ptr, i8** %src_end, align 8
  %6 = load i8** %p, align 8
  %7 = load i64* %lp, align 8
  %add.ptr3 = getelementptr inbounds i8* %6, i64 %7
  %p_end = getelementptr inbounds %struct.MatchState* %ms, i32 0, i32 3
  store i8* %add.ptr3, i8** %p_end, align 8
  %8 = load i8** %s, align 8
  %9 = load %struct.lua_State** %L.addr, align 8
  %call4 = call i64 @lua_tointegerx(%struct.lua_State* %9, i32 -1001003, i32* null)
  %add.ptr5 = getelementptr inbounds i8* %8, i64 %call4
  store i8* %add.ptr5, i8** %src, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i8** %src, align 8
  %src_end6 = getelementptr inbounds %struct.MatchState* %ms, i32 0, i32 2
  %11 = load i8** %src_end6, align 8
  %cmp = icmp ule i8* %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %level = getelementptr inbounds %struct.MatchState* %ms, i32 0, i32 5
  store i32 0, i32* %level, align 4
  %12 = load i8** %src, align 8
  %13 = load i8** %p, align 8
  %call7 = call i8* @match(%struct.MatchState* %ms, i8* %12, i8* %13)
  store i8* %call7, i8** %e, align 8
  %cmp8 = icmp ne i8* %call7, null
  br i1 %cmp8, label %if.then, label %if.end12

if.then:                                          ; preds = %for.body
  %14 = load i8** %e, align 8
  %15 = load i8** %s, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %14 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %15 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, i64* %newstart, align 8
  %16 = load i8** %e, align 8
  %17 = load i8** %src, align 8
  %cmp9 = icmp eq i8* %16, %17
  br i1 %cmp9, label %if.then10, label %if.end

if.then10:                                        ; preds = %if.then
  %18 = load i64* %newstart, align 8
  %inc = add nsw i64 %18, 1
  store i64 %inc, i64* %newstart, align 8
  br label %if.end

if.end:                                           ; preds = %if.then10, %if.then
  %19 = load %struct.lua_State** %L.addr, align 8
  %20 = load i64* %newstart, align 8
  call void @lua_pushinteger(%struct.lua_State* %19, i64 %20)
  %21 = load %struct.lua_State** %L.addr, align 8
  call void @lua_replace(%struct.lua_State* %21, i32 -1001003)
  %22 = load i8** %src, align 8
  %23 = load i8** %e, align 8
  %call11 = call i32 @push_captures(%struct.MatchState* %ms, i8* %22, i8* %23)
  store i32 %call11, i32* %retval
  br label %return

if.end12:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %24 = load i8** %src, align 8
  %incdec.ptr = getelementptr inbounds i8* %24, i32 1
  store i8* %incdec.ptr, i8** %src, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %for.end, %if.end
  %25 = load i32* %retval
  ret i32 %25
}

; Function Attrs: nounwind uwtable
define internal i8* @match(%struct.MatchState* %ms, i8* %s, i8* %p) #0 {
entry:
  %ms.addr = alloca %struct.MatchState*, align 8
  %s.addr = alloca i8*, align 8
  %p.addr = alloca i8*, align 8
  %ep = alloca i8*, align 8
  %previous = alloca i8, align 1
  %ep73 = alloca i8*, align 8
  %res = alloca i8*, align 8
  store %struct.MatchState* %ms, %struct.MatchState** %ms.addr, align 8
  store i8* %s, i8** %s.addr, align 8
  store i8* %p, i8** %p.addr, align 8
  %0 = load %struct.MatchState** %ms.addr, align 8
  %matchdepth = getelementptr inbounds %struct.MatchState* %0, i32 0, i32 0
  %1 = load i32* %matchdepth, align 4
  %dec = add nsw i32 %1, -1
  store i32 %dec, i32* %matchdepth, align 4
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.MatchState** %ms.addr, align 8
  %L = getelementptr inbounds %struct.MatchState* %2, i32 0, i32 4
  %3 = load %struct.lua_State** %L, align 8
  %call = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %3, i8* getelementptr inbounds ([20 x i8]* @.str20680, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  br label %init

init:                                             ; preds = %sw.default109, %if.else101, %if.then88, %if.then69, %if.then61, %if.then32, %if.end
  %4 = load i8** %p.addr, align 8
  %5 = load %struct.MatchState** %ms.addr, align 8
  %p_end = getelementptr inbounds %struct.MatchState* %5, i32 0, i32 3
  %6 = load i8** %p_end, align 8
  %cmp1 = icmp ne i8* %4, %6
  br i1 %cmp1, label %if.then2, label %if.end114

if.then2:                                         ; preds = %init
  %7 = load i8** %p.addr, align 8
  %8 = load i8* %7, align 1
  %conv = sext i8 %8 to i32
  switch i32 %conv, label %sw.default72 [
    i32 40, label %sw.bb
    i32 41, label %sw.bb12
    i32 36, label %sw.bb15
    i32 37, label %sw.bb24
  ]

sw.bb:                                            ; preds = %if.then2
  %9 = load i8** %p.addr, align 8
  %add.ptr = getelementptr inbounds i8* %9, i64 1
  %10 = load i8* %add.ptr, align 1
  %conv3 = sext i8 %10 to i32
  %cmp4 = icmp eq i32 %conv3, 41
  br i1 %cmp4, label %if.then6, label %if.else

if.then6:                                         ; preds = %sw.bb
  %11 = load %struct.MatchState** %ms.addr, align 8
  %12 = load i8** %s.addr, align 8
  %13 = load i8** %p.addr, align 8
  %add.ptr7 = getelementptr inbounds i8* %13, i64 2
  %call8 = call i8* @start_capture(%struct.MatchState* %11, i8* %12, i8* %add.ptr7, i32 -2)
  store i8* %call8, i8** %s.addr, align 8
  br label %if.end11

if.else:                                          ; preds = %sw.bb
  %14 = load %struct.MatchState** %ms.addr, align 8
  %15 = load i8** %s.addr, align 8
  %16 = load i8** %p.addr, align 8
  %add.ptr9 = getelementptr inbounds i8* %16, i64 1
  %call10 = call i8* @start_capture(%struct.MatchState* %14, i8* %15, i8* %add.ptr9, i32 -1)
  store i8* %call10, i8** %s.addr, align 8
  br label %if.end11

if.end11:                                         ; preds = %if.else, %if.then6
  br label %sw.epilog113

sw.bb12:                                          ; preds = %if.then2
  %17 = load %struct.MatchState** %ms.addr, align 8
  %18 = load i8** %s.addr, align 8
  %19 = load i8** %p.addr, align 8
  %add.ptr13 = getelementptr inbounds i8* %19, i64 1
  %call14 = call i8* @end_capture(%struct.MatchState* %17, i8* %18, i8* %add.ptr13)
  store i8* %call14, i8** %s.addr, align 8
  br label %sw.epilog113

sw.bb15:                                          ; preds = %if.then2
  %20 = load i8** %p.addr, align 8
  %add.ptr16 = getelementptr inbounds i8* %20, i64 1
  %21 = load %struct.MatchState** %ms.addr, align 8
  %p_end17 = getelementptr inbounds %struct.MatchState* %21, i32 0, i32 3
  %22 = load i8** %p_end17, align 8
  %cmp18 = icmp ne i8* %add.ptr16, %22
  br i1 %cmp18, label %if.then20, label %if.end21

if.then20:                                        ; preds = %sw.bb15
  br label %dflt

if.end21:                                         ; preds = %sw.bb15
  %23 = load i8** %s.addr, align 8
  %24 = load %struct.MatchState** %ms.addr, align 8
  %src_end = getelementptr inbounds %struct.MatchState* %24, i32 0, i32 2
  %25 = load i8** %src_end, align 8
  %cmp22 = icmp eq i8* %23, %25
  br i1 %cmp22, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end21
  %26 = load i8** %s.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end21
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %26, %cond.true ], [ null, %cond.false ]
  store i8* %cond, i8** %s.addr, align 8
  br label %sw.epilog113

sw.bb24:                                          ; preds = %if.then2
  %27 = load i8** %p.addr, align 8
  %add.ptr25 = getelementptr inbounds i8* %27, i64 1
  %28 = load i8* %add.ptr25, align 1
  %conv26 = sext i8 %28 to i32
  switch i32 %conv26, label %sw.default [
    i32 98, label %sw.bb27
    i32 102, label %sw.bb35
    i32 48, label %sw.bb63
    i32 49, label %sw.bb63
    i32 50, label %sw.bb63
    i32 51, label %sw.bb63
    i32 52, label %sw.bb63
    i32 53, label %sw.bb63
    i32 54, label %sw.bb63
    i32 55, label %sw.bb63
    i32 56, label %sw.bb63
    i32 57, label %sw.bb63
  ]

sw.bb27:                                          ; preds = %sw.bb24
  %29 = load %struct.MatchState** %ms.addr, align 8
  %30 = load i8** %s.addr, align 8
  %31 = load i8** %p.addr, align 8
  %add.ptr28 = getelementptr inbounds i8* %31, i64 2
  %call29 = call i8* @matchbalance(%struct.MatchState* %29, i8* %30, i8* %add.ptr28)
  store i8* %call29, i8** %s.addr, align 8
  %32 = load i8** %s.addr, align 8
  %cmp30 = icmp ne i8* %32, null
  br i1 %cmp30, label %if.then32, label %if.end34

if.then32:                                        ; preds = %sw.bb27
  %33 = load i8** %p.addr, align 8
  %add.ptr33 = getelementptr inbounds i8* %33, i64 4
  store i8* %add.ptr33, i8** %p.addr, align 8
  br label %init

if.end34:                                         ; preds = %sw.bb27
  br label %sw.epilog

sw.bb35:                                          ; preds = %sw.bb24
  %34 = load i8** %p.addr, align 8
  %add.ptr36 = getelementptr inbounds i8* %34, i64 2
  store i8* %add.ptr36, i8** %p.addr, align 8
  %35 = load i8** %p.addr, align 8
  %36 = load i8* %35, align 1
  %conv37 = sext i8 %36 to i32
  %cmp38 = icmp ne i32 %conv37, 91
  br i1 %cmp38, label %if.then40, label %if.end43

if.then40:                                        ; preds = %sw.bb35
  %37 = load %struct.MatchState** %ms.addr, align 8
  %L41 = getelementptr inbounds %struct.MatchState* %37, i32 0, i32 4
  %38 = load %struct.lua_State** %L41, align 8
  %call42 = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %38, i8* getelementptr inbounds ([35 x i8]* @.str21681, i32 0, i32 0))
  br label %if.end43

if.end43:                                         ; preds = %if.then40, %sw.bb35
  %39 = load %struct.MatchState** %ms.addr, align 8
  %40 = load i8** %p.addr, align 8
  %call44 = call i8* @classend(%struct.MatchState* %39, i8* %40)
  store i8* %call44, i8** %ep, align 8
  %41 = load i8** %s.addr, align 8
  %42 = load %struct.MatchState** %ms.addr, align 8
  %src_init = getelementptr inbounds %struct.MatchState* %42, i32 0, i32 1
  %43 = load i8** %src_init, align 8
  %cmp45 = icmp eq i8* %41, %43
  br i1 %cmp45, label %cond.true47, label %cond.false48

cond.true47:                                      ; preds = %if.end43
  br label %cond.end51

cond.false48:                                     ; preds = %if.end43
  %44 = load i8** %s.addr, align 8
  %add.ptr49 = getelementptr inbounds i8* %44, i64 -1
  %45 = load i8* %add.ptr49, align 1
  %conv50 = sext i8 %45 to i32
  br label %cond.end51

cond.end51:                                       ; preds = %cond.false48, %cond.true47
  %cond52 = phi i32 [ 0, %cond.true47 ], [ %conv50, %cond.false48 ]
  %conv53 = trunc i32 %cond52 to i8
  store i8 %conv53, i8* %previous, align 1
  %46 = load i8* %previous, align 1
  %conv54 = zext i8 %46 to i32
  %47 = load i8** %p.addr, align 8
  %48 = load i8** %ep, align 8
  %add.ptr55 = getelementptr inbounds i8* %48, i64 -1
  %call56 = call i32 @matchbracketclass(i32 %conv54, i8* %47, i8* %add.ptr55)
  %tobool = icmp ne i32 %call56, 0
  br i1 %tobool, label %if.end62, label %land.lhs.true

land.lhs.true:                                    ; preds = %cond.end51
  %49 = load i8** %s.addr, align 8
  %50 = load i8* %49, align 1
  %conv57 = zext i8 %50 to i32
  %51 = load i8** %p.addr, align 8
  %52 = load i8** %ep, align 8
  %add.ptr58 = getelementptr inbounds i8* %52, i64 -1
  %call59 = call i32 @matchbracketclass(i32 %conv57, i8* %51, i8* %add.ptr58)
  %tobool60 = icmp ne i32 %call59, 0
  br i1 %tobool60, label %if.then61, label %if.end62

if.then61:                                        ; preds = %land.lhs.true
  %53 = load i8** %ep, align 8
  store i8* %53, i8** %p.addr, align 8
  br label %init

if.end62:                                         ; preds = %land.lhs.true, %cond.end51
  store i8* null, i8** %s.addr, align 8
  br label %sw.epilog

sw.bb63:                                          ; preds = %sw.bb24, %sw.bb24, %sw.bb24, %sw.bb24, %sw.bb24, %sw.bb24, %sw.bb24, %sw.bb24, %sw.bb24, %sw.bb24
  %54 = load %struct.MatchState** %ms.addr, align 8
  %55 = load i8** %s.addr, align 8
  %56 = load i8** %p.addr, align 8
  %add.ptr64 = getelementptr inbounds i8* %56, i64 1
  %57 = load i8* %add.ptr64, align 1
  %conv65 = zext i8 %57 to i32
  %call66 = call i8* @match_capture(%struct.MatchState* %54, i8* %55, i32 %conv65)
  store i8* %call66, i8** %s.addr, align 8
  %58 = load i8** %s.addr, align 8
  %cmp67 = icmp ne i8* %58, null
  br i1 %cmp67, label %if.then69, label %if.end71

if.then69:                                        ; preds = %sw.bb63
  %59 = load i8** %p.addr, align 8
  %add.ptr70 = getelementptr inbounds i8* %59, i64 2
  store i8* %add.ptr70, i8** %p.addr, align 8
  br label %init

if.end71:                                         ; preds = %sw.bb63
  br label %sw.epilog

sw.default:                                       ; preds = %sw.bb24
  br label %dflt

sw.epilog:                                        ; preds = %if.end71, %if.end62, %if.end34
  br label %sw.epilog113

sw.default72:                                     ; preds = %if.then2
  br label %dflt

dflt:                                             ; preds = %sw.default72, %sw.default, %if.then20
  %60 = load %struct.MatchState** %ms.addr, align 8
  %61 = load i8** %p.addr, align 8
  %call74 = call i8* @classend(%struct.MatchState* %60, i8* %61)
  store i8* %call74, i8** %ep73, align 8
  %62 = load %struct.MatchState** %ms.addr, align 8
  %63 = load i8** %s.addr, align 8
  %64 = load i8** %p.addr, align 8
  %65 = load i8** %ep73, align 8
  %call75 = call i32 @singlematch(%struct.MatchState* %62, i8* %63, i8* %64, i8* %65)
  %tobool76 = icmp ne i32 %call75, 0
  br i1 %tobool76, label %if.else92, label %if.then77

if.then77:                                        ; preds = %dflt
  %66 = load i8** %ep73, align 8
  %67 = load i8* %66, align 1
  %conv78 = sext i8 %67 to i32
  %cmp79 = icmp eq i32 %conv78, 42
  br i1 %cmp79, label %if.then88, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then77
  %68 = load i8** %ep73, align 8
  %69 = load i8* %68, align 1
  %conv81 = sext i8 %69 to i32
  %cmp82 = icmp eq i32 %conv81, 63
  br i1 %cmp82, label %if.then88, label %lor.lhs.false84

lor.lhs.false84:                                  ; preds = %lor.lhs.false
  %70 = load i8** %ep73, align 8
  %71 = load i8* %70, align 1
  %conv85 = sext i8 %71 to i32
  %cmp86 = icmp eq i32 %conv85, 45
  br i1 %cmp86, label %if.then88, label %if.else90

if.then88:                                        ; preds = %lor.lhs.false84, %lor.lhs.false, %if.then77
  %72 = load i8** %ep73, align 8
  %add.ptr89 = getelementptr inbounds i8* %72, i64 1
  store i8* %add.ptr89, i8** %p.addr, align 8
  br label %init

if.else90:                                        ; preds = %lor.lhs.false84
  store i8* null, i8** %s.addr, align 8
  br label %if.end91

if.end91:                                         ; preds = %if.else90
  br label %if.end112

if.else92:                                        ; preds = %dflt
  %73 = load i8** %ep73, align 8
  %74 = load i8* %73, align 1
  %conv93 = sext i8 %74 to i32
  switch i32 %conv93, label %sw.default109 [
    i32 63, label %sw.bb94
    i32 43, label %sw.bb104
    i32 42, label %sw.bb105
    i32 45, label %sw.bb107
  ]

sw.bb94:                                          ; preds = %if.else92
  %75 = load %struct.MatchState** %ms.addr, align 8
  %76 = load i8** %s.addr, align 8
  %add.ptr95 = getelementptr inbounds i8* %76, i64 1
  %77 = load i8** %ep73, align 8
  %add.ptr96 = getelementptr inbounds i8* %77, i64 1
  %call97 = call i8* @match(%struct.MatchState* %75, i8* %add.ptr95, i8* %add.ptr96)
  store i8* %call97, i8** %res, align 8
  %cmp98 = icmp ne i8* %call97, null
  br i1 %cmp98, label %if.then100, label %if.else101

if.then100:                                       ; preds = %sw.bb94
  %78 = load i8** %res, align 8
  store i8* %78, i8** %s.addr, align 8
  br label %if.end103

if.else101:                                       ; preds = %sw.bb94
  %79 = load i8** %ep73, align 8
  %add.ptr102 = getelementptr inbounds i8* %79, i64 1
  store i8* %add.ptr102, i8** %p.addr, align 8
  br label %init

if.end103:                                        ; preds = %if.then100
  br label %sw.epilog111

sw.bb104:                                         ; preds = %if.else92
  %80 = load i8** %s.addr, align 8
  %incdec.ptr = getelementptr inbounds i8* %80, i32 1
  store i8* %incdec.ptr, i8** %s.addr, align 8
  br label %sw.bb105

sw.bb105:                                         ; preds = %sw.bb104, %if.else92
  %81 = load %struct.MatchState** %ms.addr, align 8
  %82 = load i8** %s.addr, align 8
  %83 = load i8** %p.addr, align 8
  %84 = load i8** %ep73, align 8
  %call106 = call i8* @max_expand(%struct.MatchState* %81, i8* %82, i8* %83, i8* %84)
  store i8* %call106, i8** %s.addr, align 8
  br label %sw.epilog111

sw.bb107:                                         ; preds = %if.else92
  %85 = load %struct.MatchState** %ms.addr, align 8
  %86 = load i8** %s.addr, align 8
  %87 = load i8** %p.addr, align 8
  %88 = load i8** %ep73, align 8
  %call108 = call i8* @min_expand(%struct.MatchState* %85, i8* %86, i8* %87, i8* %88)
  store i8* %call108, i8** %s.addr, align 8
  br label %sw.epilog111

sw.default109:                                    ; preds = %if.else92
  %89 = load i8** %s.addr, align 8
  %incdec.ptr110 = getelementptr inbounds i8* %89, i32 1
  store i8* %incdec.ptr110, i8** %s.addr, align 8
  %90 = load i8** %ep73, align 8
  store i8* %90, i8** %p.addr, align 8
  br label %init

sw.epilog111:                                     ; preds = %sw.bb107, %sw.bb105, %if.end103
  br label %if.end112

if.end112:                                        ; preds = %sw.epilog111, %if.end91
  br label %sw.epilog113

sw.epilog113:                                     ; preds = %if.end112, %sw.epilog, %cond.end, %sw.bb12, %if.end11
  br label %if.end114

if.end114:                                        ; preds = %sw.epilog113, %init
  %91 = load %struct.MatchState** %ms.addr, align 8
  %matchdepth115 = getelementptr inbounds %struct.MatchState* %91, i32 0, i32 0
  %92 = load i32* %matchdepth115, align 4
  %inc = add nsw i32 %92, 1
  store i32 %inc, i32* %matchdepth115, align 4
  %93 = load i8** %s.addr, align 8
  ret i8* %93
}

; Function Attrs: nounwind uwtable
define internal void @add_value(%struct.MatchState* %ms, %struct.luaL_Buffer* %b, i8* %s, i8* %e, i32 %tr) #0 {
entry:
  %ms.addr = alloca %struct.MatchState*, align 8
  %b.addr = alloca %struct.luaL_Buffer*, align 8
  %s.addr = alloca i8*, align 8
  %e.addr = alloca i8*, align 8
  %tr.addr = alloca i32, align 4
  %L = alloca %struct.lua_State*, align 8
  %n = alloca i32, align 4
  store %struct.MatchState* %ms, %struct.MatchState** %ms.addr, align 8
  store %struct.luaL_Buffer* %b, %struct.luaL_Buffer** %b.addr, align 8
  store i8* %s, i8** %s.addr, align 8
  store i8* %e, i8** %e.addr, align 8
  store i32 %tr, i32* %tr.addr, align 4
  %0 = load %struct.MatchState** %ms.addr, align 8
  %L1 = getelementptr inbounds %struct.MatchState* %0, i32 0, i32 4
  %1 = load %struct.lua_State** %L1, align 8
  store %struct.lua_State* %1, %struct.lua_State** %L, align 8
  %2 = load i32* %tr.addr, align 4
  switch i32 %2, label %sw.default [
    i32 6, label %sw.bb
    i32 5, label %sw.bb2
  ]

sw.bb:                                            ; preds = %entry
  %3 = load %struct.lua_State** %L, align 8
  call void @lua_pushvalue(%struct.lua_State* %3, i32 3)
  %4 = load %struct.MatchState** %ms.addr, align 8
  %5 = load i8** %s.addr, align 8
  %6 = load i8** %e.addr, align 8
  %call = call i32 @push_captures(%struct.MatchState* %4, i8* %5, i8* %6)
  store i32 %call, i32* %n, align 4
  %7 = load %struct.lua_State** %L, align 8
  %8 = load i32* %n, align 4
  call void @lua_callk(%struct.lua_State* %7, i32 %8, i32 1, i32 0, i32 (%struct.lua_State*)* null)
  br label %sw.epilog

sw.bb2:                                           ; preds = %entry
  %9 = load %struct.MatchState** %ms.addr, align 8
  %10 = load i8** %s.addr, align 8
  %11 = load i8** %e.addr, align 8
  call void @push_onecapture(%struct.MatchState* %9, i32 0, i8* %10, i8* %11)
  %12 = load %struct.lua_State** %L, align 8
  call void @lua_gettable(%struct.lua_State* %12, i32 3)
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %13 = load %struct.MatchState** %ms.addr, align 8
  %14 = load %struct.luaL_Buffer** %b.addr, align 8
  %15 = load i8** %s.addr, align 8
  %16 = load i8** %e.addr, align 8
  call void @add_s(%struct.MatchState* %13, %struct.luaL_Buffer* %14, i8* %15, i8* %16)
  br label %return

sw.epilog:                                        ; preds = %sw.bb2, %sw.bb
  %17 = load %struct.lua_State** %L, align 8
  %call3 = call i32 @lua_toboolean(%struct.lua_State* %17, i32 -1)
  %tobool = icmp ne i32 %call3, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %sw.epilog
  %18 = load %struct.lua_State** %L, align 8
  call void @lua_settop(%struct.lua_State* %18, i32 -2)
  %19 = load %struct.lua_State** %L, align 8
  %20 = load i8** %s.addr, align 8
  %21 = load i8** %e.addr, align 8
  %22 = load i8** %s.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %21 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %22 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %call4 = call i8* @lua_pushlstring(%struct.lua_State* %19, i8* %20, i64 %sub.ptr.sub)
  br label %if.end11

if.else:                                          ; preds = %sw.epilog
  %23 = load %struct.lua_State** %L, align 8
  %call5 = call i32 @lua_isstring(%struct.lua_State* %23, i32 -1)
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %if.end, label %if.then7

if.then7:                                         ; preds = %if.else
  %24 = load %struct.lua_State** %L, align 8
  %25 = load %struct.lua_State** %L, align 8
  %26 = load %struct.lua_State** %L, align 8
  %call8 = call i32 @lua_type(%struct.lua_State* %26, i32 -1)
  %call9 = call i8* @lua_typename(%struct.lua_State* %25, i32 %call8)
  %call10 = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %24, i8* getelementptr inbounds ([33 x i8]* @.str29689, i32 0, i32 0), i8* %call9)
  br label %if.end

if.end:                                           ; preds = %if.then7, %if.else
  br label %if.end11

if.end11:                                         ; preds = %if.end, %if.then
  %27 = load %struct.luaL_Buffer** %b.addr, align 8
  call void @luaL_addvalue(%struct.luaL_Buffer* %27)
  br label %return

return:                                           ; preds = %if.end11, %sw.default
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @nospecials(i8* %p, i64 %l) #0 {
entry:
  %retval = alloca i32, align 4
  %p.addr = alloca i8*, align 8
  %l.addr = alloca i64, align 8
  %upto = alloca i64, align 8
  store i8* %p, i8** %p.addr, align 8
  store i64 %l, i64* %l.addr, align 8
  store i64 0, i64* %upto, align 8
  br label %do.body

do.body:                                          ; preds = %do.cond, %entry
  %0 = load i8** %p.addr, align 8
  %1 = load i64* %upto, align 8
  %add.ptr = getelementptr inbounds i8* %0, i64 %1
  %call = call i8* @strpbrk(i8* %add.ptr, i8* getelementptr inbounds ([11 x i8]* @.str27687, i32 0, i32 0)) #10
  %tobool = icmp ne i8* %call, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 0, i32* %retval
  br label %return

if.end:                                           ; preds = %do.body
  %2 = load i8** %p.addr, align 8
  %3 = load i64* %upto, align 8
  %add.ptr1 = getelementptr inbounds i8* %2, i64 %3
  %call2 = call i64 @strlen(i8* %add.ptr1) #10
  %add = add i64 %call2, 1
  %4 = load i64* %upto, align 8
  %add3 = add i64 %4, %add
  store i64 %add3, i64* %upto, align 8
  br label %do.cond

do.cond:                                          ; preds = %if.end
  %5 = load i64* %upto, align 8
  %6 = load i64* %l.addr, align 8
  %cmp = icmp ule i64 %5, %6
  br i1 %cmp, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %do.end, %if.then
  %7 = load i32* %retval
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal i8* @lmemfind(i8* %s1, i64 %l1, i8* %s2, i64 %l2) #0 {
entry:
  %retval = alloca i8*, align 8
  %s1.addr = alloca i8*, align 8
  %l1.addr = alloca i64, align 8
  %s2.addr = alloca i8*, align 8
  %l2.addr = alloca i64, align 8
  %init = alloca i8*, align 8
  store i8* %s1, i8** %s1.addr, align 8
  store i64 %l1, i64* %l1.addr, align 8
  store i8* %s2, i8** %s2.addr, align 8
  store i64 %l2, i64* %l2.addr, align 8
  %0 = load i64* %l2.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i8** %s1.addr, align 8
  store i8* %1, i8** %retval
  br label %return

if.else:                                          ; preds = %entry
  %2 = load i64* %l2.addr, align 8
  %3 = load i64* %l1.addr, align 8
  %cmp1 = icmp ugt i64 %2, %3
  br i1 %cmp1, label %if.then2, label %if.else3

if.then2:                                         ; preds = %if.else
  store i8* null, i8** %retval
  br label %return

if.else3:                                         ; preds = %if.else
  %4 = load i64* %l2.addr, align 8
  %dec = add i64 %4, -1
  store i64 %dec, i64* %l2.addr, align 8
  %5 = load i64* %l1.addr, align 8
  %6 = load i64* %l2.addr, align 8
  %sub = sub i64 %5, %6
  store i64 %sub, i64* %l1.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end, %if.else3
  %7 = load i64* %l1.addr, align 8
  %cmp4 = icmp ugt i64 %7, 0
  br i1 %cmp4, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %8 = load i8** %s1.addr, align 8
  %9 = load i8** %s2.addr, align 8
  %10 = load i8* %9, align 1
  %conv = sext i8 %10 to i32
  %11 = load i64* %l1.addr, align 8
  %call = call i8* @memchr(i8* %8, i32 %conv, i64 %11) #10
  store i8* %call, i8** %init, align 8
  %cmp5 = icmp ne i8* %call, null
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %12 = phi i1 [ false, %while.cond ], [ %cmp5, %land.rhs ]
  br i1 %12, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %13 = load i8** %init, align 8
  %incdec.ptr = getelementptr inbounds i8* %13, i32 1
  store i8* %incdec.ptr, i8** %init, align 8
  %14 = load i8** %init, align 8
  %15 = load i8** %s2.addr, align 8
  %add.ptr = getelementptr inbounds i8* %15, i64 1
  %16 = load i64* %l2.addr, align 8
  %call7 = call i32 @memcmp(i8* %14, i8* %add.ptr, i64 %16) #10
  %cmp8 = icmp eq i32 %call7, 0
  br i1 %cmp8, label %if.then10, label %if.else12

if.then10:                                        ; preds = %while.body
  %17 = load i8** %init, align 8
  %add.ptr11 = getelementptr inbounds i8* %17, i64 -1
  store i8* %add.ptr11, i8** %retval
  br label %return

if.else12:                                        ; preds = %while.body
  %18 = load i8** %init, align 8
  %19 = load i8** %s1.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %18 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %19 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %20 = load i64* %l1.addr, align 8
  %sub13 = sub i64 %20, %sub.ptr.sub
  store i64 %sub13, i64* %l1.addr, align 8
  %21 = load i8** %init, align 8
  store i8* %21, i8** %s1.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.else12
  br label %while.cond

while.end:                                        ; preds = %land.end
  store i8* null, i8** %retval
  br label %return

return:                                           ; preds = %while.end, %if.then10, %if.then2, %if.then
  %22 = load i8** %retval
  ret i8* %22
}

; Function Attrs: nounwind uwtable
define internal i32 @push_captures(%struct.MatchState* %ms, i8* %s, i8* %e) #0 {
entry:
  %ms.addr = alloca %struct.MatchState*, align 8
  %s.addr = alloca i8*, align 8
  %e.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %nlevels = alloca i32, align 4
  store %struct.MatchState* %ms, %struct.MatchState** %ms.addr, align 8
  store i8* %s, i8** %s.addr, align 8
  store i8* %e, i8** %e.addr, align 8
  %0 = load %struct.MatchState** %ms.addr, align 8
  %level = getelementptr inbounds %struct.MatchState* %0, i32 0, i32 5
  %1 = load i32* %level, align 4
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %2 = load i8** %s.addr, align 8
  %tobool = icmp ne i8* %2, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %entry
  %3 = load %struct.MatchState** %ms.addr, align 8
  %level1 = getelementptr inbounds %struct.MatchState* %3, i32 0, i32 5
  %4 = load i32* %level1, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 1, %cond.true ], [ %4, %cond.false ]
  store i32 %cond, i32* %nlevels, align 4
  %5 = load %struct.MatchState** %ms.addr, align 8
  %L = getelementptr inbounds %struct.MatchState* %5, i32 0, i32 4
  %6 = load %struct.lua_State** %L, align 8
  %7 = load i32* %nlevels, align 4
  call void @luaL_checkstack(%struct.lua_State* %6, i32 %7, i8* getelementptr inbounds ([18 x i8]* @.str17677, i32 0, i32 0))
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %8 = load i32* %i, align 4
  %9 = load i32* %nlevels, align 4
  %cmp2 = icmp slt i32 %8, %9
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load %struct.MatchState** %ms.addr, align 8
  %11 = load i32* %i, align 4
  %12 = load i8** %s.addr, align 8
  %13 = load i8** %e.addr, align 8
  call void @push_onecapture(%struct.MatchState* %10, i32 %11, i8* %12, i8* %13)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %14 = load i32* %i, align 4
  %inc = add nsw i32 %14, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %15 = load i32* %nlevels, align 4
  ret i32 %15
}

; Function Attrs: nounwind uwtable
define internal i8* @start_capture(%struct.MatchState* %ms, i8* %s, i8* %p, i32 %what) #0 {
entry:
  %ms.addr = alloca %struct.MatchState*, align 8
  %s.addr = alloca i8*, align 8
  %p.addr = alloca i8*, align 8
  %what.addr = alloca i32, align 4
  %res = alloca i8*, align 8
  %level = alloca i32, align 4
  store %struct.MatchState* %ms, %struct.MatchState** %ms.addr, align 8
  store i8* %s, i8** %s.addr, align 8
  store i8* %p, i8** %p.addr, align 8
  store i32 %what, i32* %what.addr, align 4
  %0 = load %struct.MatchState** %ms.addr, align 8
  %level1 = getelementptr inbounds %struct.MatchState* %0, i32 0, i32 5
  %1 = load i32* %level1, align 4
  store i32 %1, i32* %level, align 4
  %2 = load i32* %level, align 4
  %cmp = icmp sge i32 %2, 32
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load %struct.MatchState** %ms.addr, align 8
  %L = getelementptr inbounds %struct.MatchState* %3, i32 0, i32 4
  %4 = load %struct.lua_State** %L, align 8
  %call = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %4, i8* getelementptr inbounds ([18 x i8]* @.str17677, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load i8** %s.addr, align 8
  %6 = load i32* %level, align 4
  %idxprom = sext i32 %6 to i64
  %7 = load %struct.MatchState** %ms.addr, align 8
  %capture = getelementptr inbounds %struct.MatchState* %7, i32 0, i32 6
  %arrayidx = getelementptr inbounds [32 x %struct.anon.374]* %capture, i32 0, i64 %idxprom
  %init = getelementptr inbounds %struct.anon.374* %arrayidx, i32 0, i32 0
  store i8* %5, i8** %init, align 8
  %8 = load i32* %what.addr, align 4
  %conv = sext i32 %8 to i64
  %9 = load i32* %level, align 4
  %idxprom2 = sext i32 %9 to i64
  %10 = load %struct.MatchState** %ms.addr, align 8
  %capture3 = getelementptr inbounds %struct.MatchState* %10, i32 0, i32 6
  %arrayidx4 = getelementptr inbounds [32 x %struct.anon.374]* %capture3, i32 0, i64 %idxprom2
  %len = getelementptr inbounds %struct.anon.374* %arrayidx4, i32 0, i32 1
  store i64 %conv, i64* %len, align 8
  %11 = load i32* %level, align 4
  %add = add nsw i32 %11, 1
  %12 = load %struct.MatchState** %ms.addr, align 8
  %level5 = getelementptr inbounds %struct.MatchState* %12, i32 0, i32 5
  store i32 %add, i32* %level5, align 4
  %13 = load %struct.MatchState** %ms.addr, align 8
  %14 = load i8** %s.addr, align 8
  %15 = load i8** %p.addr, align 8
  %call6 = call i8* @match(%struct.MatchState* %13, i8* %14, i8* %15)
  store i8* %call6, i8** %res, align 8
  %cmp7 = icmp eq i8* %call6, null
  br i1 %cmp7, label %if.then9, label %if.end11

if.then9:                                         ; preds = %if.end
  %16 = load %struct.MatchState** %ms.addr, align 8
  %level10 = getelementptr inbounds %struct.MatchState* %16, i32 0, i32 5
  %17 = load i32* %level10, align 4
  %dec = add nsw i32 %17, -1
  store i32 %dec, i32* %level10, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.then9, %if.end
  %18 = load i8** %res, align 8
  ret i8* %18
}

; Function Attrs: nounwind uwtable
define internal i8* @end_capture(%struct.MatchState* %ms, i8* %s, i8* %p) #0 {
entry:
  %ms.addr = alloca %struct.MatchState*, align 8
  %s.addr = alloca i8*, align 8
  %p.addr = alloca i8*, align 8
  %l = alloca i32, align 4
  %res = alloca i8*, align 8
  store %struct.MatchState* %ms, %struct.MatchState** %ms.addr, align 8
  store i8* %s, i8** %s.addr, align 8
  store i8* %p, i8** %p.addr, align 8
  %0 = load %struct.MatchState** %ms.addr, align 8
  %call = call i32 @capture_to_close(%struct.MatchState* %0)
  store i32 %call, i32* %l, align 4
  %1 = load i8** %s.addr, align 8
  %2 = load i32* %l, align 4
  %idxprom = sext i32 %2 to i64
  %3 = load %struct.MatchState** %ms.addr, align 8
  %capture = getelementptr inbounds %struct.MatchState* %3, i32 0, i32 6
  %arrayidx = getelementptr inbounds [32 x %struct.anon.374]* %capture, i32 0, i64 %idxprom
  %init = getelementptr inbounds %struct.anon.374* %arrayidx, i32 0, i32 0
  %4 = load i8** %init, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %1 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %4 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %5 = load i32* %l, align 4
  %idxprom1 = sext i32 %5 to i64
  %6 = load %struct.MatchState** %ms.addr, align 8
  %capture2 = getelementptr inbounds %struct.MatchState* %6, i32 0, i32 6
  %arrayidx3 = getelementptr inbounds [32 x %struct.anon.374]* %capture2, i32 0, i64 %idxprom1
  %len = getelementptr inbounds %struct.anon.374* %arrayidx3, i32 0, i32 1
  store i64 %sub.ptr.sub, i64* %len, align 8
  %7 = load %struct.MatchState** %ms.addr, align 8
  %8 = load i8** %s.addr, align 8
  %9 = load i8** %p.addr, align 8
  %call4 = call i8* @match(%struct.MatchState* %7, i8* %8, i8* %9)
  store i8* %call4, i8** %res, align 8
  %cmp = icmp eq i8* %call4, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %10 = load i32* %l, align 4
  %idxprom5 = sext i32 %10 to i64
  %11 = load %struct.MatchState** %ms.addr, align 8
  %capture6 = getelementptr inbounds %struct.MatchState* %11, i32 0, i32 6
  %arrayidx7 = getelementptr inbounds [32 x %struct.anon.374]* %capture6, i32 0, i64 %idxprom5
  %len8 = getelementptr inbounds %struct.anon.374* %arrayidx7, i32 0, i32 1
  store i64 -1, i64* %len8, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %12 = load i8** %res, align 8
  ret i8* %12
}

; Function Attrs: nounwind uwtable
define internal i8* @matchbalance(%struct.MatchState* %ms, i8* %s, i8* %p) #0 {
entry:
  %retval = alloca i8*, align 8
  %ms.addr = alloca %struct.MatchState*, align 8
  %s.addr = alloca i8*, align 8
  %p.addr = alloca i8*, align 8
  %b = alloca i32, align 4
  %e = alloca i32, align 4
  %cont = alloca i32, align 4
  store %struct.MatchState* %ms, %struct.MatchState** %ms.addr, align 8
  store i8* %s, i8** %s.addr, align 8
  store i8* %p, i8** %p.addr, align 8
  %0 = load i8** %p.addr, align 8
  %1 = load %struct.MatchState** %ms.addr, align 8
  %p_end = getelementptr inbounds %struct.MatchState* %1, i32 0, i32 3
  %2 = load i8** %p_end, align 8
  %add.ptr = getelementptr inbounds i8* %2, i64 -1
  %cmp = icmp uge i8* %0, %add.ptr
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load %struct.MatchState** %ms.addr, align 8
  %L = getelementptr inbounds %struct.MatchState* %3, i32 0, i32 4
  %4 = load %struct.lua_State** %L, align 8
  %call = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %4, i8* getelementptr inbounds ([47 x i8]* @.str25685, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load i8** %s.addr, align 8
  %6 = load i8* %5, align 1
  %conv = sext i8 %6 to i32
  %7 = load i8** %p.addr, align 8
  %8 = load i8* %7, align 1
  %conv1 = sext i8 %8 to i32
  %cmp2 = icmp ne i32 %conv, %conv1
  br i1 %cmp2, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.end
  store i8* null, i8** %retval
  br label %return

if.else:                                          ; preds = %if.end
  %9 = load i8** %p.addr, align 8
  %10 = load i8* %9, align 1
  %conv5 = sext i8 %10 to i32
  store i32 %conv5, i32* %b, align 4
  %11 = load i8** %p.addr, align 8
  %add.ptr6 = getelementptr inbounds i8* %11, i64 1
  %12 = load i8* %add.ptr6, align 1
  %conv7 = sext i8 %12 to i32
  store i32 %conv7, i32* %e, align 4
  store i32 1, i32* %cont, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end25, %if.else
  %13 = load i8** %s.addr, align 8
  %incdec.ptr = getelementptr inbounds i8* %13, i32 1
  store i8* %incdec.ptr, i8** %s.addr, align 8
  %14 = load %struct.MatchState** %ms.addr, align 8
  %src_end = getelementptr inbounds %struct.MatchState* %14, i32 0, i32 2
  %15 = load i8** %src_end, align 8
  %cmp8 = icmp ult i8* %incdec.ptr, %15
  br i1 %cmp8, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %16 = load i8** %s.addr, align 8
  %17 = load i8* %16, align 1
  %conv10 = sext i8 %17 to i32
  %18 = load i32* %e, align 4
  %cmp11 = icmp eq i32 %conv10, %18
  br i1 %cmp11, label %if.then13, label %if.else19

if.then13:                                        ; preds = %while.body
  %19 = load i32* %cont, align 4
  %dec = add nsw i32 %19, -1
  store i32 %dec, i32* %cont, align 4
  %cmp14 = icmp eq i32 %dec, 0
  br i1 %cmp14, label %if.then16, label %if.end18

if.then16:                                        ; preds = %if.then13
  %20 = load i8** %s.addr, align 8
  %add.ptr17 = getelementptr inbounds i8* %20, i64 1
  store i8* %add.ptr17, i8** %retval
  br label %return

if.end18:                                         ; preds = %if.then13
  br label %if.end25

if.else19:                                        ; preds = %while.body
  %21 = load i8** %s.addr, align 8
  %22 = load i8* %21, align 1
  %conv20 = sext i8 %22 to i32
  %23 = load i32* %b, align 4
  %cmp21 = icmp eq i32 %conv20, %23
  br i1 %cmp21, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.else19
  %24 = load i32* %cont, align 4
  %inc = add nsw i32 %24, 1
  store i32 %inc, i32* %cont, align 4
  br label %if.end24

if.end24:                                         ; preds = %if.then23, %if.else19
  br label %if.end25

if.end25:                                         ; preds = %if.end24, %if.end18
  br label %while.cond

while.end:                                        ; preds = %while.cond
  br label %if.end26

if.end26:                                         ; preds = %while.end
  store i8* null, i8** %retval
  br label %return

return:                                           ; preds = %if.end26, %if.then16, %if.then4
  %25 = load i8** %retval
  ret i8* %25
}

; Function Attrs: nounwind uwtable
define internal i8* @classend(%struct.MatchState* %ms, i8* %p) #0 {
entry:
  %retval = alloca i8*, align 8
  %ms.addr = alloca %struct.MatchState*, align 8
  %p.addr = alloca i8*, align 8
  store %struct.MatchState* %ms, %struct.MatchState** %ms.addr, align 8
  store i8* %p, i8** %p.addr, align 8
  %0 = load i8** %p.addr, align 8
  %incdec.ptr = getelementptr inbounds i8* %0, i32 1
  store i8* %incdec.ptr, i8** %p.addr, align 8
  %1 = load i8* %0, align 1
  %conv = sext i8 %1 to i32
  switch i32 %conv, label %sw.default [
    i32 37, label %sw.bb
    i32 91, label %sw.bb2
  ]

sw.bb:                                            ; preds = %entry
  %2 = load i8** %p.addr, align 8
  %3 = load %struct.MatchState** %ms.addr, align 8
  %p_end = getelementptr inbounds %struct.MatchState* %3, i32 0, i32 3
  %4 = load i8** %p_end, align 8
  %cmp = icmp eq i8* %2, %4
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  %5 = load %struct.MatchState** %ms.addr, align 8
  %L = getelementptr inbounds %struct.MatchState* %5, i32 0, i32 4
  %6 = load %struct.lua_State** %L, align 8
  %call = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %6, i8* getelementptr inbounds ([35 x i8]* @.str23683, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %sw.bb
  %7 = load i8** %p.addr, align 8
  %add.ptr = getelementptr inbounds i8* %7, i64 1
  store i8* %add.ptr, i8** %retval
  br label %return

sw.bb2:                                           ; preds = %entry
  %8 = load i8** %p.addr, align 8
  %9 = load i8* %8, align 1
  %conv3 = sext i8 %9 to i32
  %cmp4 = icmp eq i32 %conv3, 94
  br i1 %cmp4, label %if.then6, label %if.end8

if.then6:                                         ; preds = %sw.bb2
  %10 = load i8** %p.addr, align 8
  %incdec.ptr7 = getelementptr inbounds i8* %10, i32 1
  store i8* %incdec.ptr7, i8** %p.addr, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %sw.bb2
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.end8
  %11 = load i8** %p.addr, align 8
  %12 = load %struct.MatchState** %ms.addr, align 8
  %p_end9 = getelementptr inbounds %struct.MatchState* %12, i32 0, i32 3
  %13 = load i8** %p_end9, align 8
  %cmp10 = icmp eq i8* %11, %13
  br i1 %cmp10, label %if.then12, label %if.end15

if.then12:                                        ; preds = %do.body
  %14 = load %struct.MatchState** %ms.addr, align 8
  %L13 = getelementptr inbounds %struct.MatchState* %14, i32 0, i32 4
  %15 = load %struct.lua_State** %L13, align 8
  %call14 = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %15, i8* getelementptr inbounds ([32 x i8]* @.str24684, i32 0, i32 0))
  br label %if.end15

if.end15:                                         ; preds = %if.then12, %do.body
  %16 = load i8** %p.addr, align 8
  %incdec.ptr16 = getelementptr inbounds i8* %16, i32 1
  store i8* %incdec.ptr16, i8** %p.addr, align 8
  %17 = load i8* %16, align 1
  %conv17 = sext i8 %17 to i32
  %cmp18 = icmp eq i32 %conv17, 37
  br i1 %cmp18, label %land.lhs.true, label %if.end25

land.lhs.true:                                    ; preds = %if.end15
  %18 = load i8** %p.addr, align 8
  %19 = load %struct.MatchState** %ms.addr, align 8
  %p_end20 = getelementptr inbounds %struct.MatchState* %19, i32 0, i32 3
  %20 = load i8** %p_end20, align 8
  %cmp21 = icmp ult i8* %18, %20
  br i1 %cmp21, label %if.then23, label %if.end25

if.then23:                                        ; preds = %land.lhs.true
  %21 = load i8** %p.addr, align 8
  %incdec.ptr24 = getelementptr inbounds i8* %21, i32 1
  store i8* %incdec.ptr24, i8** %p.addr, align 8
  br label %if.end25

if.end25:                                         ; preds = %if.then23, %land.lhs.true, %if.end15
  br label %do.cond

do.cond:                                          ; preds = %if.end25
  %22 = load i8** %p.addr, align 8
  %23 = load i8* %22, align 1
  %conv26 = sext i8 %23 to i32
  %cmp27 = icmp ne i32 %conv26, 93
  br i1 %cmp27, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  %24 = load i8** %p.addr, align 8
  %add.ptr29 = getelementptr inbounds i8* %24, i64 1
  store i8* %add.ptr29, i8** %retval
  br label %return

sw.default:                                       ; preds = %entry
  %25 = load i8** %p.addr, align 8
  store i8* %25, i8** %retval
  br label %return

return:                                           ; preds = %sw.default, %do.end, %if.end
  %26 = load i8** %retval
  ret i8* %26
}

; Function Attrs: nounwind uwtable
define internal i32 @matchbracketclass(i32 %c, i8* %p, i8* %ec) #0 {
entry:
  %retval = alloca i32, align 4
  %c.addr = alloca i32, align 4
  %p.addr = alloca i8*, align 8
  %ec.addr = alloca i8*, align 8
  %sig = alloca i32, align 4
  store i32 %c, i32* %c.addr, align 4
  store i8* %p, i8** %p.addr, align 8
  store i8* %ec, i8** %ec.addr, align 8
  store i32 1, i32* %sig, align 4
  %0 = load i8** %p.addr, align 8
  %add.ptr = getelementptr inbounds i8* %0, i64 1
  %1 = load i8* %add.ptr, align 1
  %conv = sext i8 %1 to i32
  %cmp = icmp eq i32 %conv, 94
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %sig, align 4
  %2 = load i8** %p.addr, align 8
  %incdec.ptr = getelementptr inbounds i8* %2, i32 1
  store i8* %incdec.ptr, i8** %p.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  br label %while.cond

while.cond:                                       ; preds = %if.end39, %if.end
  %3 = load i8** %p.addr, align 8
  %incdec.ptr2 = getelementptr inbounds i8* %3, i32 1
  store i8* %incdec.ptr2, i8** %p.addr, align 8
  %4 = load i8** %ec.addr, align 8
  %cmp3 = icmp ult i8* %incdec.ptr2, %4
  br i1 %cmp3, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %5 = load i8** %p.addr, align 8
  %6 = load i8* %5, align 1
  %conv5 = sext i8 %6 to i32
  %cmp6 = icmp eq i32 %conv5, 37
  br i1 %cmp6, label %if.then8, label %if.else

if.then8:                                         ; preds = %while.body
  %7 = load i8** %p.addr, align 8
  %incdec.ptr9 = getelementptr inbounds i8* %7, i32 1
  store i8* %incdec.ptr9, i8** %p.addr, align 8
  %8 = load i32* %c.addr, align 4
  %9 = load i8** %p.addr, align 8
  %10 = load i8* %9, align 1
  %conv10 = zext i8 %10 to i32
  %call = call i32 @match_class(i32 %8, i32 %conv10)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.then8
  %11 = load i32* %sig, align 4
  store i32 %11, i32* %retval
  br label %return

if.end12:                                         ; preds = %if.then8
  br label %if.end39

if.else:                                          ; preds = %while.body
  %12 = load i8** %p.addr, align 8
  %add.ptr13 = getelementptr inbounds i8* %12, i64 1
  %13 = load i8* %add.ptr13, align 1
  %conv14 = sext i8 %13 to i32
  %cmp15 = icmp eq i32 %conv14, 45
  br i1 %cmp15, label %land.lhs.true, label %if.else32

land.lhs.true:                                    ; preds = %if.else
  %14 = load i8** %p.addr, align 8
  %add.ptr17 = getelementptr inbounds i8* %14, i64 2
  %15 = load i8** %ec.addr, align 8
  %cmp18 = icmp ult i8* %add.ptr17, %15
  br i1 %cmp18, label %if.then20, label %if.else32

if.then20:                                        ; preds = %land.lhs.true
  %16 = load i8** %p.addr, align 8
  %add.ptr21 = getelementptr inbounds i8* %16, i64 2
  store i8* %add.ptr21, i8** %p.addr, align 8
  %17 = load i8** %p.addr, align 8
  %add.ptr22 = getelementptr inbounds i8* %17, i64 -2
  %18 = load i8* %add.ptr22, align 1
  %conv23 = zext i8 %18 to i32
  %19 = load i32* %c.addr, align 4
  %cmp24 = icmp sle i32 %conv23, %19
  br i1 %cmp24, label %land.lhs.true26, label %if.end31

land.lhs.true26:                                  ; preds = %if.then20
  %20 = load i32* %c.addr, align 4
  %21 = load i8** %p.addr, align 8
  %22 = load i8* %21, align 1
  %conv27 = zext i8 %22 to i32
  %cmp28 = icmp sle i32 %20, %conv27
  br i1 %cmp28, label %if.then30, label %if.end31

if.then30:                                        ; preds = %land.lhs.true26
  %23 = load i32* %sig, align 4
  store i32 %23, i32* %retval
  br label %return

if.end31:                                         ; preds = %land.lhs.true26, %if.then20
  br label %if.end38

if.else32:                                        ; preds = %land.lhs.true, %if.else
  %24 = load i8** %p.addr, align 8
  %25 = load i8* %24, align 1
  %conv33 = zext i8 %25 to i32
  %26 = load i32* %c.addr, align 4
  %cmp34 = icmp eq i32 %conv33, %26
  br i1 %cmp34, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.else32
  %27 = load i32* %sig, align 4
  store i32 %27, i32* %retval
  br label %return

if.end37:                                         ; preds = %if.else32
  br label %if.end38

if.end38:                                         ; preds = %if.end37, %if.end31
  br label %if.end39

if.end39:                                         ; preds = %if.end38, %if.end12
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %28 = load i32* %sig, align 4
  %tobool40 = icmp ne i32 %28, 0
  %lnot = xor i1 %tobool40, true
  %lnot.ext = zext i1 %lnot to i32
  store i32 %lnot.ext, i32* %retval
  br label %return

return:                                           ; preds = %while.end, %if.then36, %if.then30, %if.then11
  %29 = load i32* %retval
  ret i32 %29
}

; Function Attrs: nounwind uwtable
define internal i8* @match_capture(%struct.MatchState* %ms, i8* %s, i32 %l) #0 {
entry:
  %retval = alloca i8*, align 8
  %ms.addr = alloca %struct.MatchState*, align 8
  %s.addr = alloca i8*, align 8
  %l.addr = alloca i32, align 4
  %len = alloca i64, align 8
  store %struct.MatchState* %ms, %struct.MatchState** %ms.addr, align 8
  store i8* %s, i8** %s.addr, align 8
  store i32 %l, i32* %l.addr, align 4
  %0 = load %struct.MatchState** %ms.addr, align 8
  %1 = load i32* %l.addr, align 4
  %call = call i32 @check_capture(%struct.MatchState* %0, i32 %1)
  store i32 %call, i32* %l.addr, align 4
  %2 = load i32* %l.addr, align 4
  %idxprom = sext i32 %2 to i64
  %3 = load %struct.MatchState** %ms.addr, align 8
  %capture = getelementptr inbounds %struct.MatchState* %3, i32 0, i32 6
  %arrayidx = getelementptr inbounds [32 x %struct.anon.374]* %capture, i32 0, i64 %idxprom
  %len1 = getelementptr inbounds %struct.anon.374* %arrayidx, i32 0, i32 1
  %4 = load i64* %len1, align 8
  store i64 %4, i64* %len, align 8
  %5 = load %struct.MatchState** %ms.addr, align 8
  %src_end = getelementptr inbounds %struct.MatchState* %5, i32 0, i32 2
  %6 = load i8** %src_end, align 8
  %7 = load i8** %s.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %6 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %7 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %8 = load i64* %len, align 8
  %cmp = icmp uge i64 %sub.ptr.sub, %8
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %9 = load i32* %l.addr, align 4
  %idxprom2 = sext i32 %9 to i64
  %10 = load %struct.MatchState** %ms.addr, align 8
  %capture3 = getelementptr inbounds %struct.MatchState* %10, i32 0, i32 6
  %arrayidx4 = getelementptr inbounds [32 x %struct.anon.374]* %capture3, i32 0, i64 %idxprom2
  %init = getelementptr inbounds %struct.anon.374* %arrayidx4, i32 0, i32 0
  %11 = load i8** %init, align 8
  %12 = load i8** %s.addr, align 8
  %13 = load i64* %len, align 8
  %call5 = call i32 @memcmp(i8* %11, i8* %12, i64 %13) #10
  %cmp6 = icmp eq i32 %call5, 0
  br i1 %cmp6, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %14 = load i8** %s.addr, align 8
  %15 = load i64* %len, align 8
  %add.ptr = getelementptr inbounds i8* %14, i64 %15
  store i8* %add.ptr, i8** %retval
  br label %return

if.else:                                          ; preds = %land.lhs.true, %entry
  store i8* null, i8** %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %16 = load i8** %retval
  ret i8* %16
}

; Function Attrs: nounwind uwtable
define internal i32 @singlematch(%struct.MatchState* %ms, i8* %s, i8* %p, i8* %ep) #0 {
entry:
  %retval = alloca i32, align 4
  %ms.addr = alloca %struct.MatchState*, align 8
  %s.addr = alloca i8*, align 8
  %p.addr = alloca i8*, align 8
  %ep.addr = alloca i8*, align 8
  %c = alloca i32, align 4
  store %struct.MatchState* %ms, %struct.MatchState** %ms.addr, align 8
  store i8* %s, i8** %s.addr, align 8
  store i8* %p, i8** %p.addr, align 8
  store i8* %ep, i8** %ep.addr, align 8
  %0 = load i8** %s.addr, align 8
  %1 = load %struct.MatchState** %ms.addr, align 8
  %src_end = getelementptr inbounds %struct.MatchState* %1, i32 0, i32 2
  %2 = load i8** %src_end, align 8
  %cmp = icmp uge i8* %0, %2
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval
  br label %return

if.else:                                          ; preds = %entry
  %3 = load i8** %s.addr, align 8
  %4 = load i8* %3, align 1
  %conv = zext i8 %4 to i32
  store i32 %conv, i32* %c, align 4
  %5 = load i8** %p.addr, align 8
  %6 = load i8* %5, align 1
  %conv1 = sext i8 %6 to i32
  switch i32 %conv1, label %sw.default [
    i32 46, label %sw.bb
    i32 37, label %sw.bb2
    i32 91, label %sw.bb4
  ]

sw.bb:                                            ; preds = %if.else
  store i32 1, i32* %retval
  br label %return

sw.bb2:                                           ; preds = %if.else
  %7 = load i32* %c, align 4
  %8 = load i8** %p.addr, align 8
  %add.ptr = getelementptr inbounds i8* %8, i64 1
  %9 = load i8* %add.ptr, align 1
  %conv3 = zext i8 %9 to i32
  %call = call i32 @match_class(i32 %7, i32 %conv3)
  store i32 %call, i32* %retval
  br label %return

sw.bb4:                                           ; preds = %if.else
  %10 = load i32* %c, align 4
  %11 = load i8** %p.addr, align 8
  %12 = load i8** %ep.addr, align 8
  %add.ptr5 = getelementptr inbounds i8* %12, i64 -1
  %call6 = call i32 @matchbracketclass(i32 %10, i8* %11, i8* %add.ptr5)
  store i32 %call6, i32* %retval
  br label %return

sw.default:                                       ; preds = %if.else
  %13 = load i8** %p.addr, align 8
  %14 = load i8* %13, align 1
  %conv7 = zext i8 %14 to i32
  %15 = load i32* %c, align 4
  %cmp8 = icmp eq i32 %conv7, %15
  %conv9 = zext i1 %cmp8 to i32
  store i32 %conv9, i32* %retval
  br label %return

return:                                           ; preds = %sw.default, %sw.bb4, %sw.bb2, %sw.bb, %if.then
  %16 = load i32* %retval
  ret i32 %16
}

; Function Attrs: nounwind uwtable
define internal i8* @max_expand(%struct.MatchState* %ms, i8* %s, i8* %p, i8* %ep) #0 {
entry:
  %retval = alloca i8*, align 8
  %ms.addr = alloca %struct.MatchState*, align 8
  %s.addr = alloca i8*, align 8
  %p.addr = alloca i8*, align 8
  %ep.addr = alloca i8*, align 8
  %i = alloca i64, align 8
  %res = alloca i8*, align 8
  store %struct.MatchState* %ms, %struct.MatchState** %ms.addr, align 8
  store i8* %s, i8** %s.addr, align 8
  store i8* %p, i8** %p.addr, align 8
  store i8* %ep, i8** %ep.addr, align 8
  store i64 0, i64* %i, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load %struct.MatchState** %ms.addr, align 8
  %1 = load i8** %s.addr, align 8
  %2 = load i64* %i, align 8
  %add.ptr = getelementptr inbounds i8* %1, i64 %2
  %3 = load i8** %p.addr, align 8
  %4 = load i8** %ep.addr, align 8
  %call = call i32 @singlematch(%struct.MatchState* %0, i8* %add.ptr, i8* %3, i8* %4)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %5 = load i64* %i, align 8
  %inc = add nsw i64 %5, 1
  store i64 %inc, i64* %i, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  br label %while.cond1

while.cond1:                                      ; preds = %if.end, %while.end
  %6 = load i64* %i, align 8
  %cmp = icmp sge i64 %6, 0
  br i1 %cmp, label %while.body2, label %while.end7

while.body2:                                      ; preds = %while.cond1
  %7 = load %struct.MatchState** %ms.addr, align 8
  %8 = load i8** %s.addr, align 8
  %9 = load i64* %i, align 8
  %add.ptr3 = getelementptr inbounds i8* %8, i64 %9
  %10 = load i8** %ep.addr, align 8
  %add.ptr4 = getelementptr inbounds i8* %10, i64 1
  %call5 = call i8* @match(%struct.MatchState* %7, i8* %add.ptr3, i8* %add.ptr4)
  store i8* %call5, i8** %res, align 8
  %11 = load i8** %res, align 8
  %tobool6 = icmp ne i8* %11, null
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %while.body2
  %12 = load i8** %res, align 8
  store i8* %12, i8** %retval
  br label %return

if.end:                                           ; preds = %while.body2
  %13 = load i64* %i, align 8
  %dec = add nsw i64 %13, -1
  store i64 %dec, i64* %i, align 8
  br label %while.cond1

while.end7:                                       ; preds = %while.cond1
  store i8* null, i8** %retval
  br label %return

return:                                           ; preds = %while.end7, %if.then
  %14 = load i8** %retval
  ret i8* %14
}

; Function Attrs: nounwind uwtable
define internal i8* @min_expand(%struct.MatchState* %ms, i8* %s, i8* %p, i8* %ep) #0 {
entry:
  %retval = alloca i8*, align 8
  %ms.addr = alloca %struct.MatchState*, align 8
  %s.addr = alloca i8*, align 8
  %p.addr = alloca i8*, align 8
  %ep.addr = alloca i8*, align 8
  %res = alloca i8*, align 8
  store %struct.MatchState* %ms, %struct.MatchState** %ms.addr, align 8
  store i8* %s, i8** %s.addr, align 8
  store i8* %p, i8** %p.addr, align 8
  store i8* %ep, i8** %ep.addr, align 8
  br label %for.cond

for.cond:                                         ; preds = %if.end4, %entry
  %0 = load %struct.MatchState** %ms.addr, align 8
  %1 = load i8** %s.addr, align 8
  %2 = load i8** %ep.addr, align 8
  %add.ptr = getelementptr inbounds i8* %2, i64 1
  %call = call i8* @match(%struct.MatchState* %0, i8* %1, i8* %add.ptr)
  store i8* %call, i8** %res, align 8
  %3 = load i8** %res, align 8
  %cmp = icmp ne i8* %3, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %for.cond
  %4 = load i8** %res, align 8
  store i8* %4, i8** %retval
  br label %return

if.else:                                          ; preds = %for.cond
  %5 = load %struct.MatchState** %ms.addr, align 8
  %6 = load i8** %s.addr, align 8
  %7 = load i8** %p.addr, align 8
  %8 = load i8** %ep.addr, align 8
  %call1 = call i32 @singlematch(%struct.MatchState* %5, i8* %6, i8* %7, i8* %8)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then2, label %if.else3

if.then2:                                         ; preds = %if.else
  %9 = load i8** %s.addr, align 8
  %incdec.ptr = getelementptr inbounds i8* %9, i32 1
  store i8* %incdec.ptr, i8** %s.addr, align 8
  br label %if.end

if.else3:                                         ; preds = %if.else
  store i8* null, i8** %retval
  br label %return

if.end:                                           ; preds = %if.then2
  br label %if.end4

if.end4:                                          ; preds = %if.end
  br label %for.cond

return:                                           ; preds = %if.else3, %if.then
  %10 = load i8** %retval
  ret i8* %10
}

; Function Attrs: nounwind uwtable
define internal void @push_onecapture(%struct.MatchState* %ms, i32 %i, i8* %s, i8* %e) #0 {
entry:
  %ms.addr = alloca %struct.MatchState*, align 8
  %i.addr = alloca i32, align 4
  %s.addr = alloca i8*, align 8
  %e.addr = alloca i8*, align 8
  %l = alloca i64, align 8
  store %struct.MatchState* %ms, %struct.MatchState** %ms.addr, align 8
  store i32 %i, i32* %i.addr, align 4
  store i8* %s, i8** %s.addr, align 8
  store i8* %e, i8** %e.addr, align 8
  %0 = load i32* %i.addr, align 4
  %1 = load %struct.MatchState** %ms.addr, align 8
  %level = getelementptr inbounds %struct.MatchState* %1, i32 0, i32 5
  %2 = load i32* %level, align 4
  %cmp = icmp sge i32 %0, %2
  br i1 %cmp, label %if.then, label %if.else5

if.then:                                          ; preds = %entry
  %3 = load i32* %i.addr, align 4
  %cmp1 = icmp eq i32 %3, 0
  br i1 %cmp1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  %4 = load %struct.MatchState** %ms.addr, align 8
  %L = getelementptr inbounds %struct.MatchState* %4, i32 0, i32 4
  %5 = load %struct.lua_State** %L, align 8
  %6 = load i8** %s.addr, align 8
  %7 = load i8** %e.addr, align 8
  %8 = load i8** %s.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %7 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %8 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %call = call i8* @lua_pushlstring(%struct.lua_State* %5, i8* %6, i64 %sub.ptr.sub)
  br label %if.end

if.else:                                          ; preds = %if.then
  %9 = load %struct.MatchState** %ms.addr, align 8
  %L3 = getelementptr inbounds %struct.MatchState* %9, i32 0, i32 4
  %10 = load %struct.lua_State** %L3, align 8
  %call4 = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %10, i8* getelementptr inbounds ([22 x i8]* @.str18678, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then2
  br label %if.end28

if.else5:                                         ; preds = %entry
  %11 = load i32* %i.addr, align 4
  %idxprom = sext i32 %11 to i64
  %12 = load %struct.MatchState** %ms.addr, align 8
  %capture = getelementptr inbounds %struct.MatchState* %12, i32 0, i32 6
  %arrayidx = getelementptr inbounds [32 x %struct.anon.374]* %capture, i32 0, i64 %idxprom
  %len = getelementptr inbounds %struct.anon.374* %arrayidx, i32 0, i32 1
  %13 = load i64* %len, align 8
  store i64 %13, i64* %l, align 8
  %14 = load i64* %l, align 8
  %cmp6 = icmp eq i64 %14, -1
  br i1 %cmp6, label %if.then7, label %if.end10

if.then7:                                         ; preds = %if.else5
  %15 = load %struct.MatchState** %ms.addr, align 8
  %L8 = getelementptr inbounds %struct.MatchState* %15, i32 0, i32 4
  %16 = load %struct.lua_State** %L8, align 8
  %call9 = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %16, i8* getelementptr inbounds ([19 x i8]* @.str19679, i32 0, i32 0))
  br label %if.end10

if.end10:                                         ; preds = %if.then7, %if.else5
  %17 = load i64* %l, align 8
  %cmp11 = icmp eq i64 %17, -2
  br i1 %cmp11, label %if.then12, label %if.else20

if.then12:                                        ; preds = %if.end10
  %18 = load %struct.MatchState** %ms.addr, align 8
  %L13 = getelementptr inbounds %struct.MatchState* %18, i32 0, i32 4
  %19 = load %struct.lua_State** %L13, align 8
  %20 = load i32* %i.addr, align 4
  %idxprom14 = sext i32 %20 to i64
  %21 = load %struct.MatchState** %ms.addr, align 8
  %capture15 = getelementptr inbounds %struct.MatchState* %21, i32 0, i32 6
  %arrayidx16 = getelementptr inbounds [32 x %struct.anon.374]* %capture15, i32 0, i64 %idxprom14
  %init = getelementptr inbounds %struct.anon.374* %arrayidx16, i32 0, i32 0
  %22 = load i8** %init, align 8
  %23 = load %struct.MatchState** %ms.addr, align 8
  %src_init = getelementptr inbounds %struct.MatchState* %23, i32 0, i32 1
  %24 = load i8** %src_init, align 8
  %sub.ptr.lhs.cast17 = ptrtoint i8* %22 to i64
  %sub.ptr.rhs.cast18 = ptrtoint i8* %24 to i64
  %sub.ptr.sub19 = sub i64 %sub.ptr.lhs.cast17, %sub.ptr.rhs.cast18
  %add = add nsw i64 %sub.ptr.sub19, 1
  call void @lua_pushinteger(%struct.lua_State* %19, i64 %add)
  br label %if.end27

if.else20:                                        ; preds = %if.end10
  %25 = load %struct.MatchState** %ms.addr, align 8
  %L21 = getelementptr inbounds %struct.MatchState* %25, i32 0, i32 4
  %26 = load %struct.lua_State** %L21, align 8
  %27 = load i32* %i.addr, align 4
  %idxprom22 = sext i32 %27 to i64
  %28 = load %struct.MatchState** %ms.addr, align 8
  %capture23 = getelementptr inbounds %struct.MatchState* %28, i32 0, i32 6
  %arrayidx24 = getelementptr inbounds [32 x %struct.anon.374]* %capture23, i32 0, i64 %idxprom22
  %init25 = getelementptr inbounds %struct.anon.374* %arrayidx24, i32 0, i32 0
  %29 = load i8** %init25, align 8
  %30 = load i64* %l, align 8
  %call26 = call i8* @lua_pushlstring(%struct.lua_State* %26, i8* %29, i64 %30)
  br label %if.end27

if.end27:                                         ; preds = %if.else20, %if.then12
  br label %if.end28

if.end28:                                         ; preds = %if.end27, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @add_s(%struct.MatchState* %ms, %struct.luaL_Buffer* %b, i8* %s, i8* %e) #0 {
entry:
  %ms.addr = alloca %struct.MatchState*, align 8
  %b.addr = alloca %struct.luaL_Buffer*, align 8
  %s.addr = alloca i8*, align 8
  %e.addr = alloca i8*, align 8
  %l = alloca i64, align 8
  %i = alloca i64, align 8
  %news = alloca i8*, align 8
  store %struct.MatchState* %ms, %struct.MatchState** %ms.addr, align 8
  store %struct.luaL_Buffer* %b, %struct.luaL_Buffer** %b.addr, align 8
  store i8* %s, i8** %s.addr, align 8
  store i8* %e, i8** %e.addr, align 8
  %0 = load %struct.MatchState** %ms.addr, align 8
  %L = getelementptr inbounds %struct.MatchState* %0, i32 0, i32 4
  %1 = load %struct.lua_State** %L, align 8
  %call = call i8* @lua_tolstring(%struct.lua_State* %1, i32 3, i64* %l)
  store i8* %call, i8** %news, align 8
  store i64 0, i64* %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i64* %i, align 8
  %3 = load i64* %l, align 8
  %cmp = icmp ult i64 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load i64* %i, align 8
  %5 = load i8** %news, align 8
  %arrayidx = getelementptr inbounds i8* %5, i64 %4
  %6 = load i8* %arrayidx, align 1
  %conv = sext i8 %6 to i32
  %cmp1 = icmp ne i32 %conv, 37
  br i1 %cmp1, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %7 = load %struct.luaL_Buffer** %b.addr, align 8
  %n = getelementptr inbounds %struct.luaL_Buffer* %7, i32 0, i32 2
  %8 = load i64* %n, align 8
  %9 = load %struct.luaL_Buffer** %b.addr, align 8
  %size = getelementptr inbounds %struct.luaL_Buffer* %9, i32 0, i32 1
  %10 = load i64* %size, align 8
  %cmp3 = icmp ult i64 %8, %10
  br i1 %cmp3, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.then
  %11 = load %struct.luaL_Buffer** %b.addr, align 8
  %call5 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* %11, i64 1)
  %tobool = icmp ne i8* %call5, null
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.then
  %12 = phi i1 [ true, %if.then ], [ %tobool, %lor.rhs ]
  %lor.ext = zext i1 %12 to i32
  %13 = load i64* %i, align 8
  %14 = load i8** %news, align 8
  %arrayidx6 = getelementptr inbounds i8* %14, i64 %13
  %15 = load i8* %arrayidx6, align 1
  %16 = load %struct.luaL_Buffer** %b.addr, align 8
  %n7 = getelementptr inbounds %struct.luaL_Buffer* %16, i32 0, i32 2
  %17 = load i64* %n7, align 8
  %inc = add i64 %17, 1
  store i64 %inc, i64* %n7, align 8
  %18 = load %struct.luaL_Buffer** %b.addr, align 8
  %b8 = getelementptr inbounds %struct.luaL_Buffer* %18, i32 0, i32 0
  %19 = load i8** %b8, align 8
  %arrayidx9 = getelementptr inbounds i8* %19, i64 %17
  store i8 %15, i8* %arrayidx9, align 1
  br label %if.end50

if.else:                                          ; preds = %for.body
  %20 = load i64* %i, align 8
  %inc10 = add i64 %20, 1
  store i64 %inc10, i64* %i, align 8
  %21 = load i64* %i, align 8
  %22 = load i8** %news, align 8
  %arrayidx11 = getelementptr inbounds i8* %22, i64 %21
  %23 = load i8* %arrayidx11, align 1
  %conv12 = zext i8 %23 to i32
  %idxprom = sext i32 %conv12 to i64
  %call13 = call i16** @__ctype_b_loc() #11
  %24 = load i16** %call13, align 8
  %arrayidx14 = getelementptr inbounds i16* %24, i64 %idxprom
  %25 = load i16* %arrayidx14, align 2
  %conv15 = zext i16 %25 to i32
  %and = and i32 %conv15, 2048
  %tobool16 = icmp ne i32 %and, 0
  br i1 %tobool16, label %if.else39, label %if.then17

if.then17:                                        ; preds = %if.else
  %26 = load i64* %i, align 8
  %27 = load i8** %news, align 8
  %arrayidx18 = getelementptr inbounds i8* %27, i64 %26
  %28 = load i8* %arrayidx18, align 1
  %conv19 = sext i8 %28 to i32
  %cmp20 = icmp ne i32 %conv19, 37
  br i1 %cmp20, label %if.then22, label %if.end

if.then22:                                        ; preds = %if.then17
  %29 = load %struct.MatchState** %ms.addr, align 8
  %L23 = getelementptr inbounds %struct.MatchState* %29, i32 0, i32 4
  %30 = load %struct.lua_State** %L23, align 8
  %call24 = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %30, i8* getelementptr inbounds ([42 x i8]* @.str30690, i32 0, i32 0), i32 37)
  br label %if.end

if.end:                                           ; preds = %if.then22, %if.then17
  %31 = load %struct.luaL_Buffer** %b.addr, align 8
  %n25 = getelementptr inbounds %struct.luaL_Buffer* %31, i32 0, i32 2
  %32 = load i64* %n25, align 8
  %33 = load %struct.luaL_Buffer** %b.addr, align 8
  %size26 = getelementptr inbounds %struct.luaL_Buffer* %33, i32 0, i32 1
  %34 = load i64* %size26, align 8
  %cmp27 = icmp ult i64 %32, %34
  br i1 %cmp27, label %lor.end32, label %lor.rhs29

lor.rhs29:                                        ; preds = %if.end
  %35 = load %struct.luaL_Buffer** %b.addr, align 8
  %call30 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* %35, i64 1)
  %tobool31 = icmp ne i8* %call30, null
  br label %lor.end32

lor.end32:                                        ; preds = %lor.rhs29, %if.end
  %36 = phi i1 [ true, %if.end ], [ %tobool31, %lor.rhs29 ]
  %lor.ext33 = zext i1 %36 to i32
  %37 = load i64* %i, align 8
  %38 = load i8** %news, align 8
  %arrayidx34 = getelementptr inbounds i8* %38, i64 %37
  %39 = load i8* %arrayidx34, align 1
  %40 = load %struct.luaL_Buffer** %b.addr, align 8
  %n35 = getelementptr inbounds %struct.luaL_Buffer* %40, i32 0, i32 2
  %41 = load i64* %n35, align 8
  %inc36 = add i64 %41, 1
  store i64 %inc36, i64* %n35, align 8
  %42 = load %struct.luaL_Buffer** %b.addr, align 8
  %b37 = getelementptr inbounds %struct.luaL_Buffer* %42, i32 0, i32 0
  %43 = load i8** %b37, align 8
  %arrayidx38 = getelementptr inbounds i8* %43, i64 %41
  store i8 %39, i8* %arrayidx38, align 1
  br label %if.end49

if.else39:                                        ; preds = %if.else
  %44 = load i64* %i, align 8
  %45 = load i8** %news, align 8
  %arrayidx40 = getelementptr inbounds i8* %45, i64 %44
  %46 = load i8* %arrayidx40, align 1
  %conv41 = sext i8 %46 to i32
  %cmp42 = icmp eq i32 %conv41, 48
  br i1 %cmp42, label %if.then44, label %if.else45

if.then44:                                        ; preds = %if.else39
  %47 = load %struct.luaL_Buffer** %b.addr, align 8
  %48 = load i8** %s.addr, align 8
  %49 = load i8** %e.addr, align 8
  %50 = load i8** %s.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %49 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %50 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  call void @luaL_addlstring(%struct.luaL_Buffer* %47, i8* %48, i64 %sub.ptr.sub)
  br label %if.end48

if.else45:                                        ; preds = %if.else39
  %51 = load %struct.MatchState** %ms.addr, align 8
  %52 = load i64* %i, align 8
  %53 = load i8** %news, align 8
  %arrayidx46 = getelementptr inbounds i8* %53, i64 %52
  %54 = load i8* %arrayidx46, align 1
  %conv47 = sext i8 %54 to i32
  %sub = sub nsw i32 %conv47, 49
  %55 = load i8** %s.addr, align 8
  %56 = load i8** %e.addr, align 8
  call void @push_onecapture(%struct.MatchState* %51, i32 %sub, i8* %55, i8* %56)
  %57 = load %struct.luaL_Buffer** %b.addr, align 8
  call void @luaL_addvalue(%struct.luaL_Buffer* %57)
  br label %if.end48

if.end48:                                         ; preds = %if.else45, %if.then44
  br label %if.end49

if.end49:                                         ; preds = %if.end48, %lor.end32
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %lor.end
  br label %for.inc

for.inc:                                          ; preds = %if.end50
  %58 = load i64* %i, align 8
  %inc51 = add i64 %58, 1
  store i64 %inc51, i64* %i, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @capture_to_close(%struct.MatchState* %ms) #0 {
entry:
  %retval = alloca i32, align 4
  %ms.addr = alloca %struct.MatchState*, align 8
  %level = alloca i32, align 4
  store %struct.MatchState* %ms, %struct.MatchState** %ms.addr, align 8
  %0 = load %struct.MatchState** %ms.addr, align 8
  %level1 = getelementptr inbounds %struct.MatchState* %0, i32 0, i32 5
  %1 = load i32* %level1, align 4
  store i32 %1, i32* %level, align 4
  %2 = load i32* %level, align 4
  %dec = add nsw i32 %2, -1
  store i32 %dec, i32* %level, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %3 = load i32* %level, align 4
  %cmp = icmp sge i32 %3, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load i32* %level, align 4
  %idxprom = sext i32 %4 to i64
  %5 = load %struct.MatchState** %ms.addr, align 8
  %capture = getelementptr inbounds %struct.MatchState* %5, i32 0, i32 6
  %arrayidx = getelementptr inbounds [32 x %struct.anon.374]* %capture, i32 0, i64 %idxprom
  %len = getelementptr inbounds %struct.anon.374* %arrayidx, i32 0, i32 1
  %6 = load i64* %len, align 8
  %cmp2 = icmp eq i64 %6, -1
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %7 = load i32* %level, align 4
  store i32 %7, i32* %retval
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %8 = load i32* %level, align 4
  %dec3 = add nsw i32 %8, -1
  store i32 %dec3, i32* %level, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %9 = load %struct.MatchState** %ms.addr, align 8
  %L = getelementptr inbounds %struct.MatchState* %9, i32 0, i32 4
  %10 = load %struct.lua_State** %L, align 8
  %call = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %10, i8* getelementptr inbounds ([24 x i8]* @.str26686, i32 0, i32 0))
  store i32 %call, i32* %retval
  br label %return

return:                                           ; preds = %for.end, %if.then
  %11 = load i32* %retval
  ret i32 %11
}

; Function Attrs: nounwind uwtable
define internal i32 @match_class(i32 %c, i32 %cl) #0 {
entry:
  %retval = alloca i32, align 4
  %c.addr = alloca i32, align 4
  %cl.addr = alloca i32, align 4
  %res = alloca i32, align 4
  store i32 %c, i32* %c.addr, align 4
  store i32 %cl, i32* %cl.addr, align 4
  %0 = load i32* %cl.addr, align 4
  %call = call i32 @tolower(i32 %0) #1
  switch i32 %call, label %sw.default [
    i32 97, label %sw.bb
    i32 99, label %sw.bb2
    i32 100, label %sw.bb8
    i32 103, label %sw.bb14
    i32 108, label %sw.bb20
    i32 112, label %sw.bb26
    i32 115, label %sw.bb32
    i32 117, label %sw.bb38
    i32 119, label %sw.bb44
    i32 120, label %sw.bb50
    i32 122, label %sw.bb56
  ]

sw.bb:                                            ; preds = %entry
  %1 = load i32* %c.addr, align 4
  %idxprom = sext i32 %1 to i64
  %call1 = call i16** @__ctype_b_loc() #11
  %2 = load i16** %call1, align 8
  %arrayidx = getelementptr inbounds i16* %2, i64 %idxprom
  %3 = load i16* %arrayidx, align 2
  %conv = zext i16 %3 to i32
  %and = and i32 %conv, 1024
  store i32 %and, i32* %res, align 4
  br label %sw.epilog

sw.bb2:                                           ; preds = %entry
  %4 = load i32* %c.addr, align 4
  %idxprom3 = sext i32 %4 to i64
  %call4 = call i16** @__ctype_b_loc() #11
  %5 = load i16** %call4, align 8
  %arrayidx5 = getelementptr inbounds i16* %5, i64 %idxprom3
  %6 = load i16* %arrayidx5, align 2
  %conv6 = zext i16 %6 to i32
  %and7 = and i32 %conv6, 2
  store i32 %and7, i32* %res, align 4
  br label %sw.epilog

sw.bb8:                                           ; preds = %entry
  %7 = load i32* %c.addr, align 4
  %idxprom9 = sext i32 %7 to i64
  %call10 = call i16** @__ctype_b_loc() #11
  %8 = load i16** %call10, align 8
  %arrayidx11 = getelementptr inbounds i16* %8, i64 %idxprom9
  %9 = load i16* %arrayidx11, align 2
  %conv12 = zext i16 %9 to i32
  %and13 = and i32 %conv12, 2048
  store i32 %and13, i32* %res, align 4
  br label %sw.epilog

sw.bb14:                                          ; preds = %entry
  %10 = load i32* %c.addr, align 4
  %idxprom15 = sext i32 %10 to i64
  %call16 = call i16** @__ctype_b_loc() #11
  %11 = load i16** %call16, align 8
  %arrayidx17 = getelementptr inbounds i16* %11, i64 %idxprom15
  %12 = load i16* %arrayidx17, align 2
  %conv18 = zext i16 %12 to i32
  %and19 = and i32 %conv18, 32768
  store i32 %and19, i32* %res, align 4
  br label %sw.epilog

sw.bb20:                                          ; preds = %entry
  %13 = load i32* %c.addr, align 4
  %idxprom21 = sext i32 %13 to i64
  %call22 = call i16** @__ctype_b_loc() #11
  %14 = load i16** %call22, align 8
  %arrayidx23 = getelementptr inbounds i16* %14, i64 %idxprom21
  %15 = load i16* %arrayidx23, align 2
  %conv24 = zext i16 %15 to i32
  %and25 = and i32 %conv24, 512
  store i32 %and25, i32* %res, align 4
  br label %sw.epilog

sw.bb26:                                          ; preds = %entry
  %16 = load i32* %c.addr, align 4
  %idxprom27 = sext i32 %16 to i64
  %call28 = call i16** @__ctype_b_loc() #11
  %17 = load i16** %call28, align 8
  %arrayidx29 = getelementptr inbounds i16* %17, i64 %idxprom27
  %18 = load i16* %arrayidx29, align 2
  %conv30 = zext i16 %18 to i32
  %and31 = and i32 %conv30, 4
  store i32 %and31, i32* %res, align 4
  br label %sw.epilog

sw.bb32:                                          ; preds = %entry
  %19 = load i32* %c.addr, align 4
  %idxprom33 = sext i32 %19 to i64
  %call34 = call i16** @__ctype_b_loc() #11
  %20 = load i16** %call34, align 8
  %arrayidx35 = getelementptr inbounds i16* %20, i64 %idxprom33
  %21 = load i16* %arrayidx35, align 2
  %conv36 = zext i16 %21 to i32
  %and37 = and i32 %conv36, 8192
  store i32 %and37, i32* %res, align 4
  br label %sw.epilog

sw.bb38:                                          ; preds = %entry
  %22 = load i32* %c.addr, align 4
  %idxprom39 = sext i32 %22 to i64
  %call40 = call i16** @__ctype_b_loc() #11
  %23 = load i16** %call40, align 8
  %arrayidx41 = getelementptr inbounds i16* %23, i64 %idxprom39
  %24 = load i16* %arrayidx41, align 2
  %conv42 = zext i16 %24 to i32
  %and43 = and i32 %conv42, 256
  store i32 %and43, i32* %res, align 4
  br label %sw.epilog

sw.bb44:                                          ; preds = %entry
  %25 = load i32* %c.addr, align 4
  %idxprom45 = sext i32 %25 to i64
  %call46 = call i16** @__ctype_b_loc() #11
  %26 = load i16** %call46, align 8
  %arrayidx47 = getelementptr inbounds i16* %26, i64 %idxprom45
  %27 = load i16* %arrayidx47, align 2
  %conv48 = zext i16 %27 to i32
  %and49 = and i32 %conv48, 8
  store i32 %and49, i32* %res, align 4
  br label %sw.epilog

sw.bb50:                                          ; preds = %entry
  %28 = load i32* %c.addr, align 4
  %idxprom51 = sext i32 %28 to i64
  %call52 = call i16** @__ctype_b_loc() #11
  %29 = load i16** %call52, align 8
  %arrayidx53 = getelementptr inbounds i16* %29, i64 %idxprom51
  %30 = load i16* %arrayidx53, align 2
  %conv54 = zext i16 %30 to i32
  %and55 = and i32 %conv54, 4096
  store i32 %and55, i32* %res, align 4
  br label %sw.epilog

sw.bb56:                                          ; preds = %entry
  %31 = load i32* %c.addr, align 4
  %cmp = icmp eq i32 %31, 0
  %conv57 = zext i1 %cmp to i32
  store i32 %conv57, i32* %res, align 4
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %32 = load i32* %cl.addr, align 4
  %33 = load i32* %c.addr, align 4
  %cmp58 = icmp eq i32 %32, %33
  %conv59 = zext i1 %cmp58 to i32
  store i32 %conv59, i32* %retval
  br label %return

sw.epilog:                                        ; preds = %sw.bb56, %sw.bb50, %sw.bb44, %sw.bb38, %sw.bb32, %sw.bb26, %sw.bb20, %sw.bb14, %sw.bb8, %sw.bb2, %sw.bb
  %34 = load i32* %cl.addr, align 4
  %idxprom60 = sext i32 %34 to i64
  %call61 = call i16** @__ctype_b_loc() #11
  %35 = load i16** %call61, align 8
  %arrayidx62 = getelementptr inbounds i16* %35, i64 %idxprom60
  %36 = load i16* %arrayidx62, align 2
  %conv63 = zext i16 %36 to i32
  %and64 = and i32 %conv63, 512
  %tobool = icmp ne i32 %and64, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %sw.epilog
  %37 = load i32* %res, align 4
  br label %cond.end

cond.false:                                       ; preds = %sw.epilog
  %38 = load i32* %res, align 4
  %tobool65 = icmp ne i32 %38, 0
  %lnot = xor i1 %tobool65, true
  %lnot.ext = zext i1 %lnot to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %37, %cond.true ], [ %lnot.ext, %cond.false ]
  store i32 %cond, i32* %retval
  br label %return

return:                                           ; preds = %cond.end, %sw.default
  %39 = load i32* %retval
  ret i32 %39
}

; Function Attrs: nounwind uwtable
define internal i32 @check_capture(%struct.MatchState* %ms, i32 %l) #0 {
entry:
  %retval = alloca i32, align 4
  %ms.addr = alloca %struct.MatchState*, align 8
  %l.addr = alloca i32, align 4
  store %struct.MatchState* %ms, %struct.MatchState** %ms.addr, align 8
  store i32 %l, i32* %l.addr, align 4
  %0 = load i32* %l.addr, align 4
  %sub = sub nsw i32 %0, 49
  store i32 %sub, i32* %l.addr, align 4
  %1 = load i32* %l.addr, align 4
  %cmp = icmp slt i32 %1, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load i32* %l.addr, align 4
  %3 = load %struct.MatchState** %ms.addr, align 8
  %level = getelementptr inbounds %struct.MatchState* %3, i32 0, i32 5
  %4 = load i32* %level, align 4
  %cmp1 = icmp sge i32 %2, %4
  br i1 %cmp1, label %if.then, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %5 = load i32* %l.addr, align 4
  %idxprom = sext i32 %5 to i64
  %6 = load %struct.MatchState** %ms.addr, align 8
  %capture = getelementptr inbounds %struct.MatchState* %6, i32 0, i32 6
  %arrayidx = getelementptr inbounds [32 x %struct.anon.374]* %capture, i32 0, i64 %idxprom
  %len = getelementptr inbounds %struct.anon.374* %arrayidx, i32 0, i32 1
  %7 = load i64* %len, align 8
  %cmp3 = icmp eq i64 %7, -1
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false2, %lor.lhs.false, %entry
  %8 = load %struct.MatchState** %ms.addr, align 8
  %L = getelementptr inbounds %struct.MatchState* %8, i32 0, i32 4
  %9 = load %struct.lua_State** %L, align 8
  %10 = load i32* %l.addr, align 4
  %add = add nsw i32 %10, 1
  %call = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %9, i8* getelementptr inbounds ([27 x i8]* @.str22682, i32 0, i32 0), i32 %add)
  store i32 %call, i32* %retval
  br label %return

if.end:                                           ; preds = %lor.lhs.false2
  %11 = load i32* %l.addr, align 4
  store i32 %11, i32* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %12 = load i32* %retval
  ret i32 %12
}

; Function Attrs: nounwind uwtable
define hidden i32 @luaH_next(%struct.lua_State* %L, %struct.Table* %t, %struct.lua_TValue* %key) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %t.addr = alloca %struct.Table*, align 8
  %key.addr = alloca %struct.lua_TValue*, align 8
  %i = alloca i32, align 4
  %io = alloca %struct.lua_TValue*, align 8
  %io2 = alloca %struct.lua_TValue*, align 8
  %io1 = alloca %struct.lua_TValue*, align 8
  %io223 = alloca %struct.lua_TValue*, align 8
  %io127 = alloca %struct.lua_TValue*, align 8
  %io232 = alloca %struct.lua_TValue*, align 8
  %io137 = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.Table* %t, %struct.Table** %t.addr, align 8
  store %struct.lua_TValue* %key, %struct.lua_TValue** %key.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load %struct.Table** %t.addr, align 8
  %2 = load %struct.lua_TValue** %key.addr, align 8
  %call = call i32 @findindex(%struct.lua_State* %0, %struct.Table* %1, %struct.lua_TValue* %2)
  store i32 %call, i32* %i, align 4
  %3 = load i32* %i, align 4
  %inc = add nsw i32 %3, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %4 = load i32* %i, align 4
  %5 = load %struct.Table** %t.addr, align 8
  %sizearray = getelementptr inbounds %struct.Table* %5, i32 0, i32 10
  %6 = load i32* %sizearray, align 4
  %cmp = icmp slt i32 %4, %6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load i32* %i, align 4
  %idxprom = sext i32 %7 to i64
  %8 = load %struct.Table** %t.addr, align 8
  %array = getelementptr inbounds %struct.Table* %8, i32 0, i32 6
  %9 = load %struct.lua_TValue** %array, align 8
  %arrayidx = getelementptr inbounds %struct.lua_TValue* %9, i64 %idxprom
  %tt_ = getelementptr inbounds %struct.lua_TValue* %arrayidx, i32 0, i32 1
  %10 = load i32* %tt_, align 4
  %cmp1 = icmp eq i32 %10, 0
  br i1 %cmp1, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  %11 = load %struct.lua_TValue** %key.addr, align 8
  store %struct.lua_TValue* %11, %struct.lua_TValue** %io, align 8
  %12 = load i32* %i, align 4
  %add = add nsw i32 %12, 1
  %conv = sitofp i32 %add to double
  %13 = load %struct.lua_TValue** %io, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %13, i32 0, i32 0
  %n = bitcast %union.Value* %value_ to double*
  store double %conv, double* %n, align 8
  %14 = load %struct.lua_TValue** %io, align 8
  %tt_2 = getelementptr inbounds %struct.lua_TValue* %14, i32 0, i32 1
  store i32 3, i32* %tt_2, align 4
  %15 = load i32* %i, align 4
  %idxprom3 = sext i32 %15 to i64
  %16 = load %struct.Table** %t.addr, align 8
  %array4 = getelementptr inbounds %struct.Table* %16, i32 0, i32 6
  %17 = load %struct.lua_TValue** %array4, align 8
  %arrayidx5 = getelementptr inbounds %struct.lua_TValue* %17, i64 %idxprom3
  store %struct.lua_TValue* %arrayidx5, %struct.lua_TValue** %io2, align 8
  %18 = load %struct.lua_TValue** %key.addr, align 8
  %add.ptr = getelementptr inbounds %struct.lua_TValue* %18, i64 1
  store %struct.lua_TValue* %add.ptr, %struct.lua_TValue** %io1, align 8
  %19 = load %struct.lua_TValue** %io1, align 8
  %value_6 = getelementptr inbounds %struct.lua_TValue* %19, i32 0, i32 0
  %20 = load %struct.lua_TValue** %io2, align 8
  %value_7 = getelementptr inbounds %struct.lua_TValue* %20, i32 0, i32 0
  %21 = bitcast %union.Value* %value_6 to i8*
  %22 = bitcast %union.Value* %value_7 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %21, i8* %22, i64 8, i32 8, i1 false)
  %23 = load %struct.lua_TValue** %io2, align 8
  %tt_8 = getelementptr inbounds %struct.lua_TValue* %23, i32 0, i32 1
  %24 = load i32* %tt_8, align 4
  %25 = load %struct.lua_TValue** %io1, align 8
  %tt_9 = getelementptr inbounds %struct.lua_TValue* %25, i32 0, i32 1
  store i32 %24, i32* %tt_9, align 4
  store i32 1, i32* %retval
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %26 = load i32* %i, align 4
  %inc10 = add nsw i32 %26, 1
  store i32 %inc10, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %27 = load %struct.Table** %t.addr, align 8
  %sizearray11 = getelementptr inbounds %struct.Table* %27, i32 0, i32 10
  %28 = load i32* %sizearray11, align 4
  %29 = load i32* %i, align 4
  %sub = sub nsw i32 %29, %28
  store i32 %sub, i32* %i, align 4
  br label %for.cond12

for.cond12:                                       ; preds = %for.inc44, %for.end
  %30 = load i32* %i, align 4
  %31 = load %struct.Table** %t.addr, align 8
  %lsizenode = getelementptr inbounds %struct.Table* %31, i32 0, i32 4
  %32 = load i8* %lsizenode, align 1
  %conv13 = zext i8 %32 to i32
  %shl = shl i32 1, %conv13
  %cmp14 = icmp slt i32 %30, %shl
  br i1 %cmp14, label %for.body16, label %for.end46

for.body16:                                       ; preds = %for.cond12
  %33 = load i32* %i, align 4
  %idxprom17 = sext i32 %33 to i64
  %34 = load %struct.Table** %t.addr, align 8
  %node = getelementptr inbounds %struct.Table* %34, i32 0, i32 7
  %35 = load %struct.Node** %node, align 8
  %arrayidx18 = getelementptr inbounds %struct.Node* %35, i64 %idxprom17
  %i_val = getelementptr inbounds %struct.Node* %arrayidx18, i32 0, i32 0
  %tt_19 = getelementptr inbounds %struct.lua_TValue* %i_val, i32 0, i32 1
  %36 = load i32* %tt_19, align 4
  %cmp20 = icmp eq i32 %36, 0
  br i1 %cmp20, label %if.end43, label %if.then22

if.then22:                                        ; preds = %for.body16
  %37 = load i32* %i, align 4
  %idxprom24 = sext i32 %37 to i64
  %38 = load %struct.Table** %t.addr, align 8
  %node25 = getelementptr inbounds %struct.Table* %38, i32 0, i32 7
  %39 = load %struct.Node** %node25, align 8
  %arrayidx26 = getelementptr inbounds %struct.Node* %39, i64 %idxprom24
  %i_key = getelementptr inbounds %struct.Node* %arrayidx26, i32 0, i32 1
  %tvk = bitcast %union.TKey* %i_key to %struct.lua_TValue*
  store %struct.lua_TValue* %tvk, %struct.lua_TValue** %io223, align 8
  %40 = load %struct.lua_TValue** %key.addr, align 8
  store %struct.lua_TValue* %40, %struct.lua_TValue** %io127, align 8
  %41 = load %struct.lua_TValue** %io127, align 8
  %value_28 = getelementptr inbounds %struct.lua_TValue* %41, i32 0, i32 0
  %42 = load %struct.lua_TValue** %io223, align 8
  %value_29 = getelementptr inbounds %struct.lua_TValue* %42, i32 0, i32 0
  %43 = bitcast %union.Value* %value_28 to i8*
  %44 = bitcast %union.Value* %value_29 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %43, i8* %44, i64 8, i32 8, i1 false)
  %45 = load %struct.lua_TValue** %io223, align 8
  %tt_30 = getelementptr inbounds %struct.lua_TValue* %45, i32 0, i32 1
  %46 = load i32* %tt_30, align 4
  %47 = load %struct.lua_TValue** %io127, align 8
  %tt_31 = getelementptr inbounds %struct.lua_TValue* %47, i32 0, i32 1
  store i32 %46, i32* %tt_31, align 4
  %48 = load i32* %i, align 4
  %idxprom33 = sext i32 %48 to i64
  %49 = load %struct.Table** %t.addr, align 8
  %node34 = getelementptr inbounds %struct.Table* %49, i32 0, i32 7
  %50 = load %struct.Node** %node34, align 8
  %arrayidx35 = getelementptr inbounds %struct.Node* %50, i64 %idxprom33
  %i_val36 = getelementptr inbounds %struct.Node* %arrayidx35, i32 0, i32 0
  store %struct.lua_TValue* %i_val36, %struct.lua_TValue** %io232, align 8
  %51 = load %struct.lua_TValue** %key.addr, align 8
  %add.ptr38 = getelementptr inbounds %struct.lua_TValue* %51, i64 1
  store %struct.lua_TValue* %add.ptr38, %struct.lua_TValue** %io137, align 8
  %52 = load %struct.lua_TValue** %io137, align 8
  %value_39 = getelementptr inbounds %struct.lua_TValue* %52, i32 0, i32 0
  %53 = load %struct.lua_TValue** %io232, align 8
  %value_40 = getelementptr inbounds %struct.lua_TValue* %53, i32 0, i32 0
  %54 = bitcast %union.Value* %value_39 to i8*
  %55 = bitcast %union.Value* %value_40 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %54, i8* %55, i64 8, i32 8, i1 false)
  %56 = load %struct.lua_TValue** %io232, align 8
  %tt_41 = getelementptr inbounds %struct.lua_TValue* %56, i32 0, i32 1
  %57 = load i32* %tt_41, align 4
  %58 = load %struct.lua_TValue** %io137, align 8
  %tt_42 = getelementptr inbounds %struct.lua_TValue* %58, i32 0, i32 1
  store i32 %57, i32* %tt_42, align 4
  store i32 1, i32* %retval
  br label %return

if.end43:                                         ; preds = %for.body16
  br label %for.inc44

for.inc44:                                        ; preds = %if.end43
  %59 = load i32* %i, align 4
  %inc45 = add nsw i32 %59, 1
  store i32 %inc45, i32* %i, align 4
  br label %for.cond12

for.end46:                                        ; preds = %for.cond12
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %for.end46, %if.then22, %if.then
  %60 = load i32* %retval
  ret i32 %60
}

; Function Attrs: nounwind uwtable
define hidden void @luaH_resize(%struct.lua_State* %L, %struct.Table* %t, i32 %nasize, i32 %nhsize) #0 {
entry:
  %retval.i = alloca %struct.lua_TValue*, align 8
  %L.addr.i = alloca %struct.lua_State*, align 8
  %t.addr.i = alloca %struct.Table*, align 8
  %key.addr.i = alloca %struct.lua_TValue*, align 8
  %p.i = alloca %struct.lua_TValue*, align 8
  %L.addr = alloca %struct.lua_State*, align 8
  %t.addr = alloca %struct.Table*, align 8
  %nasize.addr = alloca i32, align 4
  %nhsize.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %oldasize = alloca i32, align 4
  %oldhsize = alloca i32, align 4
  %nold = alloca %struct.Node*, align 8
  %old = alloca %struct.Node*, align 8
  %io2 = alloca %struct.lua_TValue*, align 8
  %io1 = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.Table* %t, %struct.Table** %t.addr, align 8
  store i32 %nasize, i32* %nasize.addr, align 4
  store i32 %nhsize, i32* %nhsize.addr, align 4
  %0 = load %struct.Table** %t.addr, align 8
  %sizearray = getelementptr inbounds %struct.Table* %0, i32 0, i32 10
  %1 = load i32* %sizearray, align 4
  store i32 %1, i32* %oldasize, align 4
  %2 = load %struct.Table** %t.addr, align 8
  %lsizenode = getelementptr inbounds %struct.Table* %2, i32 0, i32 4
  %3 = load i8* %lsizenode, align 1
  %conv = zext i8 %3 to i32
  store i32 %conv, i32* %oldhsize, align 4
  %4 = load %struct.Table** %t.addr, align 8
  %node = getelementptr inbounds %struct.Table* %4, i32 0, i32 7
  %5 = load %struct.Node** %node, align 8
  store %struct.Node* %5, %struct.Node** %nold, align 8
  %6 = load i32* %nasize.addr, align 4
  %7 = load i32* %oldasize, align 4
  %cmp = icmp sgt i32 %6, %7
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %8 = load %struct.lua_State** %L.addr, align 8
  %9 = load %struct.Table** %t.addr, align 8
  %10 = load i32* %nasize.addr, align 4
  call void @setarrayvector(%struct.lua_State* %8, %struct.Table* %9, i32 %10)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %11 = load %struct.lua_State** %L.addr, align 8
  %12 = load %struct.Table** %t.addr, align 8
  %13 = load i32* %nhsize.addr, align 4
  call void @setnodevector(%struct.lua_State* %11, %struct.Table* %12, i32 %13)
  %14 = load i32* %nasize.addr, align 4
  %15 = load i32* %oldasize, align 4
  %cmp2 = icmp slt i32 %14, %15
  br i1 %cmp2, label %if.then4, label %if.end24

if.then4:                                         ; preds = %if.end
  %16 = load i32* %nasize.addr, align 4
  %17 = load %struct.Table** %t.addr, align 8
  %sizearray5 = getelementptr inbounds %struct.Table* %17, i32 0, i32 10
  store i32 %16, i32* %sizearray5, align 4
  %18 = load i32* %nasize.addr, align 4
  store i32 %18, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then4
  %19 = load i32* %i, align 4
  %20 = load i32* %oldasize, align 4
  %cmp6 = icmp slt i32 %19, %20
  br i1 %cmp6, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %21 = load i32* %i, align 4
  %idxprom = sext i32 %21 to i64
  %22 = load %struct.Table** %t.addr, align 8
  %array = getelementptr inbounds %struct.Table* %22, i32 0, i32 6
  %23 = load %struct.lua_TValue** %array, align 8
  %arrayidx = getelementptr inbounds %struct.lua_TValue* %23, i64 %idxprom
  %tt_ = getelementptr inbounds %struct.lua_TValue* %arrayidx, i32 0, i32 1
  %24 = load i32* %tt_, align 4
  %cmp8 = icmp eq i32 %24, 0
  br i1 %cmp8, label %if.end14, label %if.then10

if.then10:                                        ; preds = %for.body
  %25 = load %struct.lua_State** %L.addr, align 8
  %26 = load %struct.Table** %t.addr, align 8
  %27 = load i32* %i, align 4
  %add = add nsw i32 %27, 1
  %28 = load i32* %i, align 4
  %idxprom11 = sext i32 %28 to i64
  %29 = load %struct.Table** %t.addr, align 8
  %array12 = getelementptr inbounds %struct.Table* %29, i32 0, i32 6
  %30 = load %struct.lua_TValue** %array12, align 8
  %arrayidx13 = getelementptr inbounds %struct.lua_TValue* %30, i64 %idxprom11
  call void @luaH_setint(%struct.lua_State* %25, %struct.Table* %26, i32 %add, %struct.lua_TValue* %arrayidx13)
  br label %if.end14

if.end14:                                         ; preds = %if.then10, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end14
  %31 = load i32* %i, align 4
  %inc = add nsw i32 %31, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %32 = load i32* %nasize.addr, align 4
  %add15 = add nsw i32 %32, 1
  %conv16 = sext i32 %add15 to i64
  %cmp17 = icmp ugt i64 %conv16, 1152921504606846975
  br i1 %cmp17, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.end
  %33 = load %struct.lua_State** %L.addr, align 8
  call void @luaM_toobig(%struct.lua_State* %33) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.false:                                       ; preds = %for.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %34
  %cond = phi i32 [ 0, %34 ], [ 0, %cond.false ]
  %35 = load %struct.lua_State** %L.addr, align 8
  %36 = load %struct.Table** %t.addr, align 8
  %array19 = getelementptr inbounds %struct.Table* %36, i32 0, i32 6
  %37 = load %struct.lua_TValue** %array19, align 8
  %38 = bitcast %struct.lua_TValue* %37 to i8*
  %39 = load i32* %oldasize, align 4
  %conv20 = sext i32 %39 to i64
  %mul = mul i64 %conv20, 16
  %40 = load i32* %nasize.addr, align 4
  %conv21 = sext i32 %40 to i64
  %mul22 = mul i64 %conv21, 16
  %call = call i8* @luaM_realloc_(%struct.lua_State* %35, i8* %38, i64 %mul, i64 %mul22)
  %41 = bitcast i8* %call to %struct.lua_TValue*
  %42 = load %struct.Table** %t.addr, align 8
  %array23 = getelementptr inbounds %struct.Table* %42, i32 0, i32 6
  store %struct.lua_TValue* %41, %struct.lua_TValue** %array23, align 8
  br label %if.end24

if.end24:                                         ; preds = %cond.end, %if.end
  %43 = load i32* %oldhsize, align 4
  %shl = shl i32 1, %43
  %sub = sub nsw i32 %shl, 1
  store i32 %sub, i32* %i, align 4
  br label %for.cond25

for.cond25:                                       ; preds = %for.inc39, %if.end24
  %44 = load i32* %i, align 4
  %cmp26 = icmp sge i32 %44, 0
  br i1 %cmp26, label %for.body28, label %for.end40

for.body28:                                       ; preds = %for.cond25
  %45 = load %struct.Node** %nold, align 8
  %46 = load i32* %i, align 4
  %idx.ext = sext i32 %46 to i64
  %add.ptr = getelementptr inbounds %struct.Node* %45, i64 %idx.ext
  store %struct.Node* %add.ptr, %struct.Node** %old, align 8
  %47 = load %struct.Node** %old, align 8
  %i_val = getelementptr inbounds %struct.Node* %47, i32 0, i32 0
  %tt_29 = getelementptr inbounds %struct.lua_TValue* %i_val, i32 0, i32 1
  %48 = load i32* %tt_29, align 4
  %cmp30 = icmp eq i32 %48, 0
  br i1 %cmp30, label %if.end38, label %if.then32

if.then32:                                        ; preds = %for.body28
  %49 = load %struct.Node** %old, align 8
  %i_val33 = getelementptr inbounds %struct.Node* %49, i32 0, i32 0
  store %struct.lua_TValue* %i_val33, %struct.lua_TValue** %io2, align 8
  %50 = load %struct.lua_State** %L.addr, align 8
  %51 = load %struct.Table** %t.addr, align 8
  %52 = load %struct.Node** %old, align 8
  %i_key = getelementptr inbounds %struct.Node* %52, i32 0, i32 1
  %tvk = bitcast %union.TKey* %i_key to %struct.lua_TValue*
  %53 = bitcast %struct.lua_TValue** %retval.i to i8*
  call void @llvm.lifetime.start(i64 8, i8* %53) #1
  %54 = bitcast %struct.lua_State** %L.addr.i to i8*
  call void @llvm.lifetime.start(i64 8, i8* %54) #1
  %55 = bitcast %struct.Table** %t.addr.i to i8*
  call void @llvm.lifetime.start(i64 8, i8* %55) #1
  %56 = bitcast %struct.lua_TValue** %key.addr.i to i8*
  call void @llvm.lifetime.start(i64 8, i8* %56) #1
  %57 = bitcast %struct.lua_TValue** %p.i to i8*
  call void @llvm.lifetime.start(i64 8, i8* %57) #1
  store %struct.lua_State* %50, %struct.lua_State** %L.addr.i, align 8
  store %struct.Table* %51, %struct.Table** %t.addr.i, align 8
  store %struct.lua_TValue* %tvk, %struct.lua_TValue** %key.addr.i, align 8
  %58 = load %struct.Table** %t.addr.i, align 8
  %59 = load %struct.lua_TValue** %key.addr.i, align 8
  %call.i = call %struct.lua_TValue* @luaH_get(%struct.Table* %58, %struct.lua_TValue* %59) #1
  store %struct.lua_TValue* %call.i, %struct.lua_TValue** %p.i, align 8
  %60 = load %struct.lua_TValue** %p.i, align 8
  %cmp.i = icmp ne %struct.lua_TValue* %60, bitcast ({ %union.Value.281, i32, [4 x i8] }* @luaO_nilobject_ to %struct.lua_TValue*)
  br i1 %cmp.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %if.then32
  %61 = load %struct.lua_TValue** %p.i, align 8
  store %struct.lua_TValue* %61, %struct.lua_TValue** %retval.i
  br label %luaH_set.exit

if.else.i:                                        ; preds = %if.then32
  %62 = load %struct.lua_State** %L.addr.i, align 8
  %63 = load %struct.Table** %t.addr.i, align 8
  %64 = load %struct.lua_TValue** %key.addr.i, align 8
  %call1.i = call %struct.lua_TValue* @luaH_newkey(%struct.lua_State* %62, %struct.Table* %63, %struct.lua_TValue* %64) #1
  store %struct.lua_TValue* %call1.i, %struct.lua_TValue** %retval.i
  br label %luaH_set.exit

luaH_set.exit:                                    ; preds = %if.else.i, %if.then.i
  %65 = load %struct.lua_TValue** %retval.i
  %66 = bitcast %struct.lua_TValue** %retval.i to i8*
  call void @llvm.lifetime.end(i64 8, i8* %66) #1
  %67 = bitcast %struct.lua_State** %L.addr.i to i8*
  call void @llvm.lifetime.end(i64 8, i8* %67) #1
  %68 = bitcast %struct.Table** %t.addr.i to i8*
  call void @llvm.lifetime.end(i64 8, i8* %68) #1
  %69 = bitcast %struct.lua_TValue** %key.addr.i to i8*
  call void @llvm.lifetime.end(i64 8, i8* %69) #1
  %70 = bitcast %struct.lua_TValue** %p.i to i8*
  call void @llvm.lifetime.end(i64 8, i8* %70) #1
  store %struct.lua_TValue* %65, %struct.lua_TValue** %io1, align 8
  %71 = load %struct.lua_TValue** %io1, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %71, i32 0, i32 0
  %72 = load %struct.lua_TValue** %io2, align 8
  %value_35 = getelementptr inbounds %struct.lua_TValue* %72, i32 0, i32 0
  %73 = bitcast %union.Value* %value_ to i8*
  %74 = bitcast %union.Value* %value_35 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %73, i8* %74, i64 8, i32 8, i1 false)
  %75 = load %struct.lua_TValue** %io2, align 8
  %tt_36 = getelementptr inbounds %struct.lua_TValue* %75, i32 0, i32 1
  %76 = load i32* %tt_36, align 4
  %77 = load %struct.lua_TValue** %io1, align 8
  %tt_37 = getelementptr inbounds %struct.lua_TValue* %77, i32 0, i32 1
  store i32 %76, i32* %tt_37, align 4
  br label %if.end38

if.end38:                                         ; preds = %luaH_set.exit, %for.body28
  br label %for.inc39

for.inc39:                                        ; preds = %if.end38
  %78 = load i32* %i, align 4
  %dec = add nsw i32 %78, -1
  store i32 %dec, i32* %i, align 4
  br label %for.cond25

for.end40:                                        ; preds = %for.cond25
  %79 = load %struct.Node** %nold, align 8
  %cmp41 = icmp eq %struct.Node* %79, bitcast ({ { %union.Value, i32, [4 x i8] }, %union.TKey }* @dummynode_ to %struct.Node*)
  br i1 %cmp41, label %if.end48, label %if.then43

if.then43:                                        ; preds = %for.end40
  %80 = load %struct.lua_State** %L.addr, align 8
  %81 = load %struct.Node** %nold, align 8
  %82 = bitcast %struct.Node* %81 to i8*
  %83 = load i32* %oldhsize, align 4
  %shl44 = shl i32 1, %83
  %conv45 = sext i32 %shl44 to i64
  %mul46 = mul i64 %conv45, 40
  %call47 = call i8* @luaM_realloc_(%struct.lua_State* %80, i8* %82, i64 %mul46, i64 0)
  br label %if.end48

if.end48:                                         ; preds = %if.then43, %for.end40
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @luaH_setint(%struct.lua_State* %L, %struct.Table* %t, i32 %key, %struct.lua_TValue* %value) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %t.addr = alloca %struct.Table*, align 8
  %key.addr = alloca i32, align 4
  %value.addr = alloca %struct.lua_TValue*, align 8
  %p = alloca %struct.lua_TValue*, align 8
  %cell = alloca %struct.lua_TValue*, align 8
  %k = alloca %struct.lua_TValue, align 8
  %io = alloca %struct.lua_TValue*, align 8
  %io2 = alloca %struct.lua_TValue*, align 8
  %io1 = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.Table* %t, %struct.Table** %t.addr, align 8
  store i32 %key, i32* %key.addr, align 4
  store %struct.lua_TValue* %value, %struct.lua_TValue** %value.addr, align 8
  %0 = load %struct.Table** %t.addr, align 8
  %1 = load i32* %key.addr, align 4
  %call = call %struct.lua_TValue* @luaH_getint(%struct.Table* %0, i32 %1)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %p, align 8
  %2 = load %struct.lua_TValue** %p, align 8
  %cmp = icmp ne %struct.lua_TValue* %2, bitcast ({ %union.Value.281, i32, [4 x i8] }* @luaO_nilobject_ to %struct.lua_TValue*)
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load %struct.lua_TValue** %p, align 8
  store %struct.lua_TValue* %3, %struct.lua_TValue** %cell, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  store %struct.lua_TValue* %k, %struct.lua_TValue** %io, align 8
  %4 = load i32* %key.addr, align 4
  %conv = sitofp i32 %4 to double
  %5 = load %struct.lua_TValue** %io, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %5, i32 0, i32 0
  %n = bitcast %union.Value* %value_ to double*
  store double %conv, double* %n, align 8
  %6 = load %struct.lua_TValue** %io, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %6, i32 0, i32 1
  store i32 3, i32* %tt_, align 4
  %7 = load %struct.lua_State** %L.addr, align 8
  %8 = load %struct.Table** %t.addr, align 8
  %call1 = call %struct.lua_TValue* @luaH_newkey(%struct.lua_State* %7, %struct.Table* %8, %struct.lua_TValue* %k)
  store %struct.lua_TValue* %call1, %struct.lua_TValue** %cell, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %9 = load %struct.lua_TValue** %value.addr, align 8
  store %struct.lua_TValue* %9, %struct.lua_TValue** %io2, align 8
  %10 = load %struct.lua_TValue** %cell, align 8
  store %struct.lua_TValue* %10, %struct.lua_TValue** %io1, align 8
  %11 = load %struct.lua_TValue** %io1, align 8
  %value_2 = getelementptr inbounds %struct.lua_TValue* %11, i32 0, i32 0
  %12 = load %struct.lua_TValue** %io2, align 8
  %value_3 = getelementptr inbounds %struct.lua_TValue* %12, i32 0, i32 0
  %13 = bitcast %union.Value* %value_2 to i8*
  %14 = bitcast %union.Value* %value_3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %13, i8* %14, i64 8, i32 8, i1 false)
  %15 = load %struct.lua_TValue** %io2, align 8
  %tt_4 = getelementptr inbounds %struct.lua_TValue* %15, i32 0, i32 1
  %16 = load i32* %tt_4, align 4
  %17 = load %struct.lua_TValue** %io1, align 8
  %tt_5 = getelementptr inbounds %struct.lua_TValue* %17, i32 0, i32 1
  store i32 %16, i32* %tt_5, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define hidden %struct.lua_TValue* @luaH_set(%struct.lua_State* %L, %struct.Table* %t, %struct.lua_TValue* %key) #0 {
entry:
  %retval = alloca %struct.lua_TValue*, align 8
  %L.addr = alloca %struct.lua_State*, align 8
  %t.addr = alloca %struct.Table*, align 8
  %key.addr = alloca %struct.lua_TValue*, align 8
  %p = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.Table* %t, %struct.Table** %t.addr, align 8
  store %struct.lua_TValue* %key, %struct.lua_TValue** %key.addr, align 8
  %0 = load %struct.Table** %t.addr, align 8
  %1 = load %struct.lua_TValue** %key.addr, align 8
  %call = call %struct.lua_TValue* @luaH_get(%struct.Table* %0, %struct.lua_TValue* %1)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %p, align 8
  %2 = load %struct.lua_TValue** %p, align 8
  %cmp = icmp ne %struct.lua_TValue* %2, bitcast ({ %union.Value.281, i32, [4 x i8] }* @luaO_nilobject_ to %struct.lua_TValue*)
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load %struct.lua_TValue** %p, align 8
  store %struct.lua_TValue* %3, %struct.lua_TValue** %retval
  br label %return

if.else:                                          ; preds = %entry
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load %struct.Table** %t.addr, align 8
  %6 = load %struct.lua_TValue** %key.addr, align 8
  %call1 = call %struct.lua_TValue* @luaH_newkey(%struct.lua_State* %4, %struct.Table* %5, %struct.lua_TValue* %6)
  store %struct.lua_TValue* %call1, %struct.lua_TValue** %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %7 = load %struct.lua_TValue** %retval
  ret %struct.lua_TValue* %7
}

; Function Attrs: nounwind uwtable
define hidden void @luaH_resizearray(%struct.lua_State* %L, %struct.Table* %t, i32 %nasize) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %t.addr = alloca %struct.Table*, align 8
  %nasize.addr = alloca i32, align 4
  %nsize = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.Table* %t, %struct.Table** %t.addr, align 8
  store i32 %nasize, i32* %nasize.addr, align 4
  %0 = load %struct.Table** %t.addr, align 8
  %node = getelementptr inbounds %struct.Table* %0, i32 0, i32 7
  %1 = load %struct.Node** %node, align 8
  %cmp = icmp eq %struct.Node* %1, bitcast ({ { %union.Value, i32, [4 x i8] }, %union.TKey }* @dummynode_ to %struct.Node*)
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %2 = load %struct.Table** %t.addr, align 8
  %lsizenode = getelementptr inbounds %struct.Table* %2, i32 0, i32 4
  %3 = load i8* %lsizenode, align 1
  %conv = zext i8 %3 to i32
  %shl = shl i32 1, %conv
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 0, %cond.true ], [ %shl, %cond.false ]
  store i32 %cond, i32* %nsize, align 4
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load %struct.Table** %t.addr, align 8
  %6 = load i32* %nasize.addr, align 4
  %7 = load i32* %nsize, align 4
  call void @luaH_resize(%struct.lua_State* %4, %struct.Table* %5, i32 %6, i32 %7)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden %struct.Table* @luaH_new(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %t = alloca %struct.Table*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call %union.GCObject* @luaC_newobj(%struct.lua_State* %0, i32 5, i64 64, %union.GCObject** null, i32 0)
  %h = bitcast %union.GCObject* %call to %struct.Table*
  store %struct.Table* %h, %struct.Table** %t, align 8
  %1 = load %struct.Table** %t, align 8
  %metatable = getelementptr inbounds %struct.Table* %1, i32 0, i32 5
  store %struct.Table* null, %struct.Table** %metatable, align 8
  %2 = load %struct.Table** %t, align 8
  %flags = getelementptr inbounds %struct.Table* %2, i32 0, i32 3
  store i8 -1, i8* %flags, align 1
  %3 = load %struct.Table** %t, align 8
  %array = getelementptr inbounds %struct.Table* %3, i32 0, i32 6
  store %struct.lua_TValue* null, %struct.lua_TValue** %array, align 8
  %4 = load %struct.Table** %t, align 8
  %sizearray = getelementptr inbounds %struct.Table* %4, i32 0, i32 10
  store i32 0, i32* %sizearray, align 4
  %5 = load %struct.lua_State** %L.addr, align 8
  %6 = load %struct.Table** %t, align 8
  call void @setnodevector(%struct.lua_State* %5, %struct.Table* %6, i32 0)
  %7 = load %struct.Table** %t, align 8
  ret %struct.Table* %7
}

; Function Attrs: nounwind uwtable
define hidden void @luaH_free(%struct.lua_State* %L, %struct.Table* %t) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %t.addr = alloca %struct.Table*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.Table* %t, %struct.Table** %t.addr, align 8
  %0 = load %struct.Table** %t.addr, align 8
  %node = getelementptr inbounds %struct.Table* %0, i32 0, i32 7
  %1 = load %struct.Node** %node, align 8
  %cmp = icmp eq %struct.Node* %1, bitcast ({ { %union.Value, i32, [4 x i8] }, %union.TKey }* @dummynode_ to %struct.Node*)
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load %struct.Table** %t.addr, align 8
  %node1 = getelementptr inbounds %struct.Table* %3, i32 0, i32 7
  %4 = load %struct.Node** %node1, align 8
  %5 = bitcast %struct.Node* %4 to i8*
  %6 = load %struct.Table** %t.addr, align 8
  %lsizenode = getelementptr inbounds %struct.Table* %6, i32 0, i32 4
  %7 = load i8* %lsizenode, align 1
  %conv = zext i8 %7 to i32
  %shl = shl i32 1, %conv
  %conv2 = sext i32 %shl to i64
  %mul = mul i64 %conv2, 40
  %call = call i8* @luaM_realloc_(%struct.lua_State* %2, i8* %5, i64 %mul, i64 0)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %8 = load %struct.lua_State** %L.addr, align 8
  %9 = load %struct.Table** %t.addr, align 8
  %array = getelementptr inbounds %struct.Table* %9, i32 0, i32 6
  %10 = load %struct.lua_TValue** %array, align 8
  %11 = bitcast %struct.lua_TValue* %10 to i8*
  %12 = load %struct.Table** %t.addr, align 8
  %sizearray = getelementptr inbounds %struct.Table* %12, i32 0, i32 10
  %13 = load i32* %sizearray, align 4
  %conv3 = sext i32 %13 to i64
  %mul4 = mul i64 %conv3, 16
  %call5 = call i8* @luaM_realloc_(%struct.lua_State* %8, i8* %11, i64 %mul4, i64 0)
  %14 = load %struct.lua_State** %L.addr, align 8
  %15 = load %struct.Table** %t.addr, align 8
  %16 = bitcast %struct.Table* %15 to i8*
  %call6 = call i8* @luaM_realloc_(%struct.lua_State* %14, i8* %16, i64 64, i64 0)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden %struct.lua_TValue* @luaH_newkey(%struct.lua_State* %L, %struct.Table* %t, %struct.lua_TValue* %key) #0 {
entry:
  %retval.i = alloca %struct.lua_TValue*, align 8
  %L.addr.i = alloca %struct.lua_State*, align 8
  %t.addr.i = alloca %struct.Table*, align 8
  %key.addr.i = alloca %struct.lua_TValue*, align 8
  %p.i = alloca %struct.lua_TValue*, align 8
  %retval = alloca %struct.lua_TValue*, align 8
  %L.addr = alloca %struct.lua_State*, align 8
  %t.addr = alloca %struct.Table*, align 8
  %key.addr = alloca %struct.lua_TValue*, align 8
  %mp = alloca %struct.Node*, align 8
  %othern = alloca %struct.Node*, align 8
  %n12 = alloca %struct.Node*, align 8
  %io2 = alloca %struct.lua_TValue*, align 8
  %io1 = alloca %struct.lua_TValue*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.Table* %t, %struct.Table** %t.addr, align 8
  store %struct.lua_TValue* %key, %struct.lua_TValue** %key.addr, align 8
  %0 = load %struct.lua_TValue** %key.addr, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %0, i32 0, i32 1
  %1 = load i32* %tt_, align 4
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load %struct.lua_State** %L.addr, align 8
  call void (%struct.lua_State*, i8*, ...)* @luaG_runerror(%struct.lua_State* %2, i8* getelementptr inbounds ([19 x i8]* @.str706, i32 0, i32 0)) #9
  unreachable

if.else:                                          ; preds = %entry
  %3 = load %struct.lua_TValue** %key.addr, align 8
  %tt_1 = getelementptr inbounds %struct.lua_TValue* %3, i32 0, i32 1
  %4 = load i32* %tt_1, align 4
  %cmp2 = icmp eq i32 %4, 3
  br i1 %cmp2, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct.lua_TValue** %key.addr, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %5, i32 0, i32 0
  %n = bitcast %union.Value* %value_ to double*
  %6 = load double* %n, align 8
  %7 = load %struct.lua_TValue** %key.addr, align 8
  %value_3 = getelementptr inbounds %struct.lua_TValue* %7, i32 0, i32 0
  %n4 = bitcast %union.Value* %value_3 to double*
  %8 = load double* %n4, align 8
  %cmp5 = fcmp oeq double %6, %8
  br i1 %cmp5, label %if.end, label %if.then6

if.then6:                                         ; preds = %land.lhs.true
  %9 = load %struct.lua_State** %L.addr, align 8
  call void (%struct.lua_State*, i8*, ...)* @luaG_runerror(%struct.lua_State* %9, i8* getelementptr inbounds ([19 x i8]* @.str1707, i32 0, i32 0)) #9
  unreachable

if.end:                                           ; preds = %land.lhs.true, %if.else
  br label %if.end7

if.end7:                                          ; preds = %if.end
  %10 = load %struct.Table** %t.addr, align 8
  %11 = load %struct.lua_TValue** %key.addr, align 8
  %call = call %struct.Node* @mainposition(%struct.Table* %10, %struct.lua_TValue* %11)
  store %struct.Node* %call, %struct.Node** %mp, align 8
  %12 = load %struct.Node** %mp, align 8
  %i_val = getelementptr inbounds %struct.Node* %12, i32 0, i32 0
  %tt_8 = getelementptr inbounds %struct.lua_TValue* %i_val, i32 0, i32 1
  %13 = load i32* %tt_8, align 4
  %cmp9 = icmp eq i32 %13, 0
  br i1 %cmp9, label %lor.lhs.false, label %if.then11

lor.lhs.false:                                    ; preds = %if.end7
  %14 = load %struct.Node** %mp, align 8
  %cmp10 = icmp eq %struct.Node* %14, bitcast ({ { %union.Value, i32, [4 x i8] }, %union.TKey }* @dummynode_ to %struct.Node*)
  br i1 %cmp10, label %if.then11, label %if.end45

if.then11:                                        ; preds = %lor.lhs.false, %if.end7
  %15 = load %struct.Table** %t.addr, align 8
  %call13 = call %struct.Node* @getfreepos(%struct.Table* %15)
  store %struct.Node* %call13, %struct.Node** %n12, align 8
  %16 = load %struct.Node** %n12, align 8
  %cmp14 = icmp eq %struct.Node* %16, null
  br i1 %cmp14, label %if.then15, label %if.end17

if.then15:                                        ; preds = %if.then11
  %17 = load %struct.lua_State** %L.addr, align 8
  %18 = load %struct.Table** %t.addr, align 8
  %19 = load %struct.lua_TValue** %key.addr, align 8
  call void @rehash(%struct.lua_State* %17, %struct.Table* %18, %struct.lua_TValue* %19)
  %20 = load %struct.lua_State** %L.addr, align 8
  %21 = load %struct.Table** %t.addr, align 8
  %22 = load %struct.lua_TValue** %key.addr, align 8
  %23 = bitcast %struct.lua_TValue** %retval.i to i8*
  call void @llvm.lifetime.start(i64 8, i8* %23) #1
  %24 = bitcast %struct.lua_State** %L.addr.i to i8*
  call void @llvm.lifetime.start(i64 8, i8* %24) #1
  %25 = bitcast %struct.Table** %t.addr.i to i8*
  call void @llvm.lifetime.start(i64 8, i8* %25) #1
  %26 = bitcast %struct.lua_TValue** %key.addr.i to i8*
  call void @llvm.lifetime.start(i64 8, i8* %26) #1
  %27 = bitcast %struct.lua_TValue** %p.i to i8*
  call void @llvm.lifetime.start(i64 8, i8* %27) #1
  store %struct.lua_State* %20, %struct.lua_State** %L.addr.i, align 8
  store %struct.Table* %21, %struct.Table** %t.addr.i, align 8
  store %struct.lua_TValue* %22, %struct.lua_TValue** %key.addr.i, align 8
  %28 = load %struct.Table** %t.addr.i, align 8
  %29 = load %struct.lua_TValue** %key.addr.i, align 8
  %call.i = call %struct.lua_TValue* @luaH_get(%struct.Table* %28, %struct.lua_TValue* %29) #1
  store %struct.lua_TValue* %call.i, %struct.lua_TValue** %p.i, align 8
  %30 = load %struct.lua_TValue** %p.i, align 8
  %cmp.i = icmp ne %struct.lua_TValue* %30, bitcast ({ %union.Value.281, i32, [4 x i8] }* @luaO_nilobject_ to %struct.lua_TValue*)
  br i1 %cmp.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %if.then15
  %31 = load %struct.lua_TValue** %p.i, align 8
  store %struct.lua_TValue* %31, %struct.lua_TValue** %retval.i
  br label %luaH_set.exit

if.else.i:                                        ; preds = %if.then15
  %32 = load %struct.lua_State** %L.addr.i, align 8
  %33 = load %struct.Table** %t.addr.i, align 8
  %34 = load %struct.lua_TValue** %key.addr.i, align 8
  %call1.i = call %struct.lua_TValue* @luaH_newkey(%struct.lua_State* %32, %struct.Table* %33, %struct.lua_TValue* %34) #1
  store %struct.lua_TValue* %call1.i, %struct.lua_TValue** %retval.i
  br label %luaH_set.exit

luaH_set.exit:                                    ; preds = %if.else.i, %if.then.i
  %35 = load %struct.lua_TValue** %retval.i
  %36 = bitcast %struct.lua_TValue** %retval.i to i8*
  call void @llvm.lifetime.end(i64 8, i8* %36) #1
  %37 = bitcast %struct.lua_State** %L.addr.i to i8*
  call void @llvm.lifetime.end(i64 8, i8* %37) #1
  %38 = bitcast %struct.Table** %t.addr.i to i8*
  call void @llvm.lifetime.end(i64 8, i8* %38) #1
  %39 = bitcast %struct.lua_TValue** %key.addr.i to i8*
  call void @llvm.lifetime.end(i64 8, i8* %39) #1
  %40 = bitcast %struct.lua_TValue** %p.i to i8*
  call void @llvm.lifetime.end(i64 8, i8* %40) #1
  store %struct.lua_TValue* %35, %struct.lua_TValue** %retval
  br label %return

if.end17:                                         ; preds = %if.then11
  %41 = load %struct.Table** %t.addr, align 8
  %42 = load %struct.Node** %mp, align 8
  %i_key = getelementptr inbounds %struct.Node* %42, i32 0, i32 1
  %tvk = bitcast %union.TKey* %i_key to %struct.lua_TValue*
  %call18 = call %struct.Node* @mainposition(%struct.Table* %41, %struct.lua_TValue* %tvk)
  store %struct.Node* %call18, %struct.Node** %othern, align 8
  %43 = load %struct.Node** %othern, align 8
  %44 = load %struct.Node** %mp, align 8
  %cmp19 = icmp ne %struct.Node* %43, %44
  br i1 %cmp19, label %if.then20, label %if.else34

if.then20:                                        ; preds = %if.end17
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then20
  %45 = load %struct.Node** %othern, align 8
  %i_key21 = getelementptr inbounds %struct.Node* %45, i32 0, i32 1
  %nk = bitcast %union.TKey* %i_key21 to %struct.anon.1*
  %next = getelementptr inbounds %struct.anon.1* %nk, i32 0, i32 2
  %46 = load %struct.Node** %next, align 8
  %47 = load %struct.Node** %mp, align 8
  %cmp22 = icmp ne %struct.Node* %46, %47
  br i1 %cmp22, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %48 = load %struct.Node** %othern, align 8
  %i_key23 = getelementptr inbounds %struct.Node* %48, i32 0, i32 1
  %nk24 = bitcast %union.TKey* %i_key23 to %struct.anon.1*
  %next25 = getelementptr inbounds %struct.anon.1* %nk24, i32 0, i32 2
  %49 = load %struct.Node** %next25, align 8
  store %struct.Node* %49, %struct.Node** %othern, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %50 = load %struct.Node** %n12, align 8
  %51 = load %struct.Node** %othern, align 8
  %i_key26 = getelementptr inbounds %struct.Node* %51, i32 0, i32 1
  %nk27 = bitcast %union.TKey* %i_key26 to %struct.anon.1*
  %next28 = getelementptr inbounds %struct.anon.1* %nk27, i32 0, i32 2
  store %struct.Node* %50, %struct.Node** %next28, align 8
  %52 = load %struct.Node** %n12, align 8
  %53 = load %struct.Node** %mp, align 8
  %54 = bitcast %struct.Node* %52 to i8*
  %55 = bitcast %struct.Node* %53 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %54, i8* %55, i64 40, i32 8, i1 false)
  %56 = load %struct.Node** %mp, align 8
  %i_key29 = getelementptr inbounds %struct.Node* %56, i32 0, i32 1
  %nk30 = bitcast %union.TKey* %i_key29 to %struct.anon.1*
  %next31 = getelementptr inbounds %struct.anon.1* %nk30, i32 0, i32 2
  store %struct.Node* null, %struct.Node** %next31, align 8
  %57 = load %struct.Node** %mp, align 8
  %i_val32 = getelementptr inbounds %struct.Node* %57, i32 0, i32 0
  %tt_33 = getelementptr inbounds %struct.lua_TValue* %i_val32, i32 0, i32 1
  store i32 0, i32* %tt_33, align 4
  br label %if.end44

if.else34:                                        ; preds = %if.end17
  %58 = load %struct.Node** %mp, align 8
  %i_key35 = getelementptr inbounds %struct.Node* %58, i32 0, i32 1
  %nk36 = bitcast %union.TKey* %i_key35 to %struct.anon.1*
  %next37 = getelementptr inbounds %struct.anon.1* %nk36, i32 0, i32 2
  %59 = load %struct.Node** %next37, align 8
  %60 = load %struct.Node** %n12, align 8
  %i_key38 = getelementptr inbounds %struct.Node* %60, i32 0, i32 1
  %nk39 = bitcast %union.TKey* %i_key38 to %struct.anon.1*
  %next40 = getelementptr inbounds %struct.anon.1* %nk39, i32 0, i32 2
  store %struct.Node* %59, %struct.Node** %next40, align 8
  %61 = load %struct.Node** %n12, align 8
  %62 = load %struct.Node** %mp, align 8
  %i_key41 = getelementptr inbounds %struct.Node* %62, i32 0, i32 1
  %nk42 = bitcast %union.TKey* %i_key41 to %struct.anon.1*
  %next43 = getelementptr inbounds %struct.anon.1* %nk42, i32 0, i32 2
  store %struct.Node* %61, %struct.Node** %next43, align 8
  %63 = load %struct.Node** %n12, align 8
  store %struct.Node* %63, %struct.Node** %mp, align 8
  br label %if.end44

if.end44:                                         ; preds = %if.else34, %while.end
  br label %if.end45

if.end45:                                         ; preds = %if.end44, %lor.lhs.false
  %64 = load %struct.lua_TValue** %key.addr, align 8
  store %struct.lua_TValue* %64, %struct.lua_TValue** %io2, align 8
  %65 = load %struct.Node** %mp, align 8
  %i_key46 = getelementptr inbounds %struct.Node* %65, i32 0, i32 1
  %tvk47 = bitcast %union.TKey* %i_key46 to %struct.lua_TValue*
  store %struct.lua_TValue* %tvk47, %struct.lua_TValue** %io1, align 8
  %66 = load %struct.lua_TValue** %io1, align 8
  %value_48 = getelementptr inbounds %struct.lua_TValue* %66, i32 0, i32 0
  %67 = load %struct.lua_TValue** %io2, align 8
  %value_49 = getelementptr inbounds %struct.lua_TValue* %67, i32 0, i32 0
  %68 = bitcast %union.Value* %value_48 to i8*
  %69 = bitcast %union.Value* %value_49 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %68, i8* %69, i64 8, i32 8, i1 false)
  %70 = load %struct.lua_TValue** %io2, align 8
  %tt_50 = getelementptr inbounds %struct.lua_TValue* %70, i32 0, i32 1
  %71 = load i32* %tt_50, align 4
  %72 = load %struct.lua_TValue** %io1, align 8
  %tt_51 = getelementptr inbounds %struct.lua_TValue* %72, i32 0, i32 1
  store i32 %71, i32* %tt_51, align 4
  %73 = load %struct.lua_TValue** %key.addr, align 8
  %tt_52 = getelementptr inbounds %struct.lua_TValue* %73, i32 0, i32 1
  %74 = load i32* %tt_52, align 4
  %and = and i32 %74, 64
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true53, label %if.end64

land.lhs.true53:                                  ; preds = %if.end45
  %75 = load %struct.lua_TValue** %key.addr, align 8
  %value_54 = getelementptr inbounds %struct.lua_TValue* %75, i32 0, i32 0
  %gc = bitcast %union.Value* %value_54 to %union.GCObject**
  %76 = load %union.GCObject** %gc, align 8
  %gch = bitcast %union.GCObject* %76 to %struct.GCheader*
  %marked = getelementptr inbounds %struct.GCheader* %gch, i32 0, i32 2
  %77 = load i8* %marked, align 1
  %conv = zext i8 %77 to i32
  %and55 = and i32 %conv, 3
  %tobool56 = icmp ne i32 %and55, 0
  br i1 %tobool56, label %land.lhs.true57, label %if.end64

land.lhs.true57:                                  ; preds = %land.lhs.true53
  %78 = load %struct.Table** %t.addr, align 8
  %79 = bitcast %struct.Table* %78 to %union.GCObject*
  %gch58 = bitcast %union.GCObject* %79 to %struct.GCheader*
  %marked59 = getelementptr inbounds %struct.GCheader* %gch58, i32 0, i32 2
  %80 = load i8* %marked59, align 1
  %conv60 = zext i8 %80 to i32
  %and61 = and i32 %conv60, 4
  %tobool62 = icmp ne i32 %and61, 0
  br i1 %tobool62, label %if.then63, label %if.end64

if.then63:                                        ; preds = %land.lhs.true57
  %81 = load %struct.lua_State** %L.addr, align 8
  %82 = load %struct.Table** %t.addr, align 8
  %83 = bitcast %struct.Table* %82 to %union.GCObject*
  call void @luaC_barrierback_(%struct.lua_State* %81, %union.GCObject* %83)
  br label %if.end64

if.end64:                                         ; preds = %if.then63, %land.lhs.true57, %land.lhs.true53, %if.end45
  %84 = load %struct.Node** %mp, align 8
  %i_val65 = getelementptr inbounds %struct.Node* %84, i32 0, i32 0
  store %struct.lua_TValue* %i_val65, %struct.lua_TValue** %retval
  br label %return

return:                                           ; preds = %if.end64, %luaH_set.exit
  %85 = load %struct.lua_TValue** %retval
  ret %struct.lua_TValue* %85
}

; Function Attrs: nounwind uwtable
define hidden %struct.lua_TValue* @luaH_getint(%struct.Table* %t, i32 %key) #0 {
entry:
  %t.addr.i = alloca %struct.Table*, align 8
  %n.addr.i = alloca double, align 8
  %i.i = alloca i32, align 4
  %u.i = alloca %union.luai_Cast, align 8
  %retval = alloca %struct.lua_TValue*, align 8
  %t.addr = alloca %struct.Table*, align 8
  %key.addr = alloca i32, align 4
  %nk = alloca double, align 8
  %n = alloca %struct.Node*, align 8
  store %struct.Table* %t, %struct.Table** %t.addr, align 8
  store i32 %key, i32* %key.addr, align 4
  %0 = load i32* %key.addr, align 4
  %sub = sub nsw i32 %0, 1
  %1 = load %struct.Table** %t.addr, align 8
  %sizearray = getelementptr inbounds %struct.Table* %1, i32 0, i32 10
  %2 = load i32* %sizearray, align 4
  %cmp = icmp ult i32 %sub, %2
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load i32* %key.addr, align 4
  %sub1 = sub nsw i32 %3, 1
  %idxprom = sext i32 %sub1 to i64
  %4 = load %struct.Table** %t.addr, align 8
  %array = getelementptr inbounds %struct.Table* %4, i32 0, i32 6
  %5 = load %struct.lua_TValue** %array, align 8
  %arrayidx = getelementptr inbounds %struct.lua_TValue* %5, i64 %idxprom
  store %struct.lua_TValue* %arrayidx, %struct.lua_TValue** %retval
  br label %return

if.else:                                          ; preds = %entry
  %6 = load i32* %key.addr, align 4
  %conv = sitofp i32 %6 to double
  store double %conv, double* %nk, align 8
  %7 = load %struct.Table** %t.addr, align 8
  %8 = load double* %nk, align 8
  %9 = bitcast %struct.Table** %t.addr.i to i8*
  call void @llvm.lifetime.start(i64 8, i8* %9)
  %10 = bitcast double* %n.addr.i to i8*
  call void @llvm.lifetime.start(i64 8, i8* %10)
  %11 = bitcast i32* %i.i to i8*
  call void @llvm.lifetime.start(i64 4, i8* %11)
  %12 = bitcast %union.luai_Cast* %u.i to i8*
  call void @llvm.lifetime.start(i64 8, i8* %12)
  store %struct.Table* %7, %struct.Table** %t.addr.i, align 8
  store double %8, double* %n.addr.i, align 8
  %13 = load double* %n.addr.i, align 8
  %add.i = fadd double %13, 1.000000e+00
  %l_d.i = bitcast %union.luai_Cast* %u.i to double*
  store volatile double %add.i, double* %l_d.i, align 8
  %l_p.i = bitcast %union.luai_Cast* %u.i to [2 x i32]*
  %arrayidx.i = getelementptr inbounds [2 x i32]* %l_p.i, i32 0, i64 0
  %14 = load volatile i32* %arrayidx.i, align 4
  store i32 %14, i32* %i.i, align 4
  %l_p1.i = bitcast %union.luai_Cast* %u.i to [2 x i32]*
  %arrayidx2.i = getelementptr inbounds [2 x i32]* %l_p1.i, i32 0, i64 1
  %15 = load volatile i32* %arrayidx2.i, align 4
  %16 = load i32* %i.i, align 4
  %add3.i = add nsw i32 %16, %15
  store i32 %add3.i, i32* %i.i, align 4
  %17 = load i32* %i.i, align 4
  %cmp.i = icmp slt i32 %17, 0
  br i1 %cmp.i, label %if.then.i, label %hashnum.exit

if.then.i:                                        ; preds = %if.else
  %18 = load i32* %i.i, align 4
  %19 = load i32* %i.i, align 4
  %sub.i = sub i32 0, %19
  %cmp4.i = icmp eq i32 %18, %sub.i
  br i1 %cmp4.i, label %if.then5.i, label %if.end.i

if.then5.i:                                       ; preds = %if.then.i
  store i32 0, i32* %i.i, align 4
  br label %if.end.i

if.end.i:                                         ; preds = %if.then5.i, %if.then.i
  %20 = load i32* %i.i, align 4
  %sub6.i = sub nsw i32 0, %20
  store i32 %sub6.i, i32* %i.i, align 4
  br label %hashnum.exit

hashnum.exit:                                     ; preds = %if.end.i, %if.else
  %21 = load i32* %i.i, align 4
  %22 = load %struct.Table** %t.addr.i, align 8
  %lsizenode.i = getelementptr inbounds %struct.Table* %22, i32 0, i32 4
  %23 = load i8* %lsizenode.i, align 1
  %conv.i = zext i8 %23 to i32
  %shl.i = shl i32 1, %conv.i
  %sub8.i = sub nsw i32 %shl.i, 1
  %or.i = or i32 %sub8.i, 1
  %rem.i = srem i32 %21, %or.i
  %idxprom.i = sext i32 %rem.i to i64
  %24 = load %struct.Table** %t.addr.i, align 8
  %node.i = getelementptr inbounds %struct.Table* %24, i32 0, i32 7
  %25 = load %struct.Node** %node.i, align 8
  %arrayidx9.i = getelementptr inbounds %struct.Node* %25, i64 %idxprom.i
  %26 = bitcast %struct.Table** %t.addr.i to i8*
  call void @llvm.lifetime.end(i64 8, i8* %26)
  %27 = bitcast double* %n.addr.i to i8*
  call void @llvm.lifetime.end(i64 8, i8* %27)
  %28 = bitcast i32* %i.i to i8*
  call void @llvm.lifetime.end(i64 4, i8* %28)
  %29 = bitcast %union.luai_Cast* %u.i to i8*
  call void @llvm.lifetime.end(i64 8, i8* %29)
  store %struct.Node* %arrayidx9.i, %struct.Node** %n, align 8
  br label %do.body

do.body:                                          ; preds = %do.cond, %hashnum.exit
  %30 = load %struct.Node** %n, align 8
  %i_key = getelementptr inbounds %struct.Node* %30, i32 0, i32 1
  %tvk = bitcast %union.TKey* %i_key to %struct.lua_TValue*
  %tt_ = getelementptr inbounds %struct.lua_TValue* %tvk, i32 0, i32 1
  %31 = load i32* %tt_, align 4
  %cmp2 = icmp eq i32 %31, 3
  br i1 %cmp2, label %land.lhs.true, label %if.else10

land.lhs.true:                                    ; preds = %do.body
  %32 = load %struct.Node** %n, align 8
  %i_key4 = getelementptr inbounds %struct.Node* %32, i32 0, i32 1
  %tvk5 = bitcast %union.TKey* %i_key4 to %struct.lua_TValue*
  %value_ = getelementptr inbounds %struct.lua_TValue* %tvk5, i32 0, i32 0
  %n6 = bitcast %union.Value* %value_ to double*
  %33 = load double* %n6, align 8
  %34 = load double* %nk, align 8
  %cmp7 = fcmp oeq double %33, %34
  br i1 %cmp7, label %if.then9, label %if.else10

if.then9:                                         ; preds = %land.lhs.true
  %35 = load %struct.Node** %n, align 8
  %i_val = getelementptr inbounds %struct.Node* %35, i32 0, i32 0
  store %struct.lua_TValue* %i_val, %struct.lua_TValue** %retval
  br label %return

if.else10:                                        ; preds = %land.lhs.true, %do.body
  %36 = load %struct.Node** %n, align 8
  %i_key11 = getelementptr inbounds %struct.Node* %36, i32 0, i32 1
  %nk12 = bitcast %union.TKey* %i_key11 to %struct.anon.1*
  %next = getelementptr inbounds %struct.anon.1* %nk12, i32 0, i32 2
  %37 = load %struct.Node** %next, align 8
  store %struct.Node* %37, %struct.Node** %n, align 8
  br label %if.end

if.end:                                           ; preds = %if.else10
  br label %do.cond

do.cond:                                          ; preds = %if.end
  %38 = load %struct.Node** %n, align 8
  %tobool = icmp ne %struct.Node* %38, null
  br i1 %tobool, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  store %struct.lua_TValue* bitcast ({ %union.Value.281, i32, [4 x i8] }* @luaO_nilobject_ to %struct.lua_TValue*), %struct.lua_TValue** %retval
  br label %return

return:                                           ; preds = %do.end, %if.then9, %if.then
  %39 = load %struct.lua_TValue** %retval
  ret %struct.lua_TValue* %39
}

; Function Attrs: nounwind uwtable
define hidden %struct.lua_TValue* @luaH_getstr(%struct.Table* %t, %union.TString* %key) #0 {
entry:
  %retval = alloca %struct.lua_TValue*, align 8
  %t.addr = alloca %struct.Table*, align 8
  %key.addr = alloca %union.TString*, align 8
  %n = alloca %struct.Node*, align 8
  store %struct.Table* %t, %struct.Table** %t.addr, align 8
  store %union.TString* %key, %union.TString** %key.addr, align 8
  %0 = load %union.TString** %key.addr, align 8
  %tsv = bitcast %union.TString* %0 to %struct.anon.0*
  %hash = getelementptr inbounds %struct.anon.0* %tsv, i32 0, i32 4
  %1 = load i32* %hash, align 4
  %2 = load %struct.Table** %t.addr, align 8
  %lsizenode = getelementptr inbounds %struct.Table* %2, i32 0, i32 4
  %3 = load i8* %lsizenode, align 1
  %conv = zext i8 %3 to i32
  %shl = shl i32 1, %conv
  %sub = sub nsw i32 %shl, 1
  %and = and i32 %1, %sub
  %idxprom = sext i32 %and to i64
  %4 = load %struct.Table** %t.addr, align 8
  %node = getelementptr inbounds %struct.Table* %4, i32 0, i32 7
  %5 = load %struct.Node** %node, align 8
  %arrayidx = getelementptr inbounds %struct.Node* %5, i64 %idxprom
  store %struct.Node* %arrayidx, %struct.Node** %n, align 8
  br label %do.body

do.body:                                          ; preds = %do.cond, %entry
  %6 = load %struct.Node** %n, align 8
  %i_key = getelementptr inbounds %struct.Node* %6, i32 0, i32 1
  %tvk = bitcast %union.TKey* %i_key to %struct.lua_TValue*
  %tt_ = getelementptr inbounds %struct.lua_TValue* %tvk, i32 0, i32 1
  %7 = load i32* %tt_, align 4
  %cmp = icmp eq i32 %7, 68
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %do.body
  %8 = load %struct.Node** %n, align 8
  %i_key2 = getelementptr inbounds %struct.Node* %8, i32 0, i32 1
  %tvk3 = bitcast %union.TKey* %i_key2 to %struct.lua_TValue*
  %value_ = getelementptr inbounds %struct.lua_TValue* %tvk3, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %9 = load %union.GCObject** %gc, align 8
  %ts = bitcast %union.GCObject* %9 to %union.TString*
  %10 = load %union.TString** %key.addr, align 8
  %cmp4 = icmp eq %union.TString* %ts, %10
  br i1 %cmp4, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %11 = load %struct.Node** %n, align 8
  %i_val = getelementptr inbounds %struct.Node* %11, i32 0, i32 0
  store %struct.lua_TValue* %i_val, %struct.lua_TValue** %retval
  br label %return

if.else:                                          ; preds = %land.lhs.true, %do.body
  %12 = load %struct.Node** %n, align 8
  %i_key6 = getelementptr inbounds %struct.Node* %12, i32 0, i32 1
  %nk = bitcast %union.TKey* %i_key6 to %struct.anon.1*
  %next = getelementptr inbounds %struct.anon.1* %nk, i32 0, i32 2
  %13 = load %struct.Node** %next, align 8
  store %struct.Node* %13, %struct.Node** %n, align 8
  br label %if.end

if.end:                                           ; preds = %if.else
  br label %do.cond

do.cond:                                          ; preds = %if.end
  %14 = load %struct.Node** %n, align 8
  %tobool = icmp ne %struct.Node* %14, null
  br i1 %tobool, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  store %struct.lua_TValue* bitcast ({ %union.Value.281, i32, [4 x i8] }* @luaO_nilobject_ to %struct.lua_TValue*), %struct.lua_TValue** %retval
  br label %return

return:                                           ; preds = %do.end, %if.then
  %15 = load %struct.lua_TValue** %retval
  ret %struct.lua_TValue* %15
}

; Function Attrs: nounwind uwtable
define hidden %struct.lua_TValue* @luaH_get(%struct.Table* %t, %struct.lua_TValue* %key) #0 {
entry:
  %retval = alloca %struct.lua_TValue*, align 8
  %t.addr = alloca %struct.Table*, align 8
  %key.addr = alloca %struct.lua_TValue*, align 8
  %k = alloca i32, align 4
  %n = alloca double, align 8
  %u = alloca %union.luai_Cast, align 8
  %n7 = alloca %struct.Node*, align 8
  store %struct.Table* %t, %struct.Table** %t.addr, align 8
  store %struct.lua_TValue* %key, %struct.lua_TValue** %key.addr, align 8
  %0 = load %struct.lua_TValue** %key.addr, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %0, i32 0, i32 1
  %1 = load i32* %tt_, align 4
  %and = and i32 %1, 63
  switch i32 %and, label %sw.default [
    i32 4, label %sw.bb
    i32 0, label %sw.bb1
    i32 3, label %sw.bb2
  ]

sw.bb:                                            ; preds = %entry
  %2 = load %struct.Table** %t.addr, align 8
  %3 = load %struct.lua_TValue** %key.addr, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %3, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %4 = load %union.GCObject** %gc, align 8
  %ts = bitcast %union.GCObject* %4 to %union.TString*
  %call = call %struct.lua_TValue* @luaH_getstr(%struct.Table* %2, %union.TString* %ts)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %retval
  br label %return

sw.bb1:                                           ; preds = %entry
  store %struct.lua_TValue* bitcast ({ %union.Value.281, i32, [4 x i8] }* @luaO_nilobject_ to %struct.lua_TValue*), %struct.lua_TValue** %retval
  br label %return

sw.bb2:                                           ; preds = %entry
  %5 = load %struct.lua_TValue** %key.addr, align 8
  %value_3 = getelementptr inbounds %struct.lua_TValue* %5, i32 0, i32 0
  %n4 = bitcast %union.Value* %value_3 to double*
  %6 = load double* %n4, align 8
  store double %6, double* %n, align 8
  %7 = load double* %n, align 8
  %add = fadd double %7, 0x4338000000000000
  %l_d = bitcast %union.luai_Cast* %u to double*
  store volatile double %add, double* %l_d, align 8
  %l_p = bitcast %union.luai_Cast* %u to [2 x i32]*
  %arrayidx = getelementptr inbounds [2 x i32]* %l_p, i32 0, i64 0
  %8 = load volatile i32* %arrayidx, align 4
  store i32 %8, i32* %k, align 4
  %9 = load i32* %k, align 4
  %conv = sitofp i32 %9 to double
  %10 = load double* %n, align 8
  %cmp = fcmp oeq double %conv, %10
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb2
  %11 = load %struct.Table** %t.addr, align 8
  %12 = load i32* %k, align 4
  %call6 = call %struct.lua_TValue* @luaH_getint(%struct.Table* %11, i32 %12)
  store %struct.lua_TValue* %call6, %struct.lua_TValue** %retval
  br label %return

if.end:                                           ; preds = %sw.bb2
  br label %sw.default

sw.default:                                       ; preds = %if.end, %entry
  %13 = load %struct.Table** %t.addr, align 8
  %14 = load %struct.lua_TValue** %key.addr, align 8
  %call8 = call %struct.Node* @mainposition(%struct.Table* %13, %struct.lua_TValue* %14)
  store %struct.Node* %call8, %struct.Node** %n7, align 8
  br label %do.body

do.body:                                          ; preds = %do.cond, %sw.default
  %15 = load %struct.Node** %n7, align 8
  %i_key = getelementptr inbounds %struct.Node* %15, i32 0, i32 1
  %tvk = bitcast %union.TKey* %i_key to %struct.lua_TValue*
  %tt_9 = getelementptr inbounds %struct.lua_TValue* %tvk, i32 0, i32 1
  %16 = load i32* %tt_9, align 4
  %17 = load %struct.lua_TValue** %key.addr, align 8
  %tt_10 = getelementptr inbounds %struct.lua_TValue* %17, i32 0, i32 1
  %18 = load i32* %tt_10, align 4
  %cmp11 = icmp eq i32 %16, %18
  br i1 %cmp11, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %do.body
  %19 = load %struct.Node** %n7, align 8
  %i_key13 = getelementptr inbounds %struct.Node* %19, i32 0, i32 1
  %tvk14 = bitcast %union.TKey* %i_key13 to %struct.lua_TValue*
  %20 = load %struct.lua_TValue** %key.addr, align 8
  %call15 = call i32 bitcast (i32 (%struct.lua_State.364*, %struct.lua_TValue.349*, %struct.lua_TValue.349*)* @luaV_equalobj_ to i32 (%struct.lua_State*, %struct.lua_TValue*, %struct.lua_TValue*)*)(%struct.lua_State* null, %struct.lua_TValue* %tvk14, %struct.lua_TValue* %20)
  %tobool = icmp ne i32 %call15, 0
  br i1 %tobool, label %if.then16, label %if.else

if.then16:                                        ; preds = %land.lhs.true
  %21 = load %struct.Node** %n7, align 8
  %i_val = getelementptr inbounds %struct.Node* %21, i32 0, i32 0
  store %struct.lua_TValue* %i_val, %struct.lua_TValue** %retval
  br label %return

if.else:                                          ; preds = %land.lhs.true, %do.body
  %22 = load %struct.Node** %n7, align 8
  %i_key17 = getelementptr inbounds %struct.Node* %22, i32 0, i32 1
  %nk = bitcast %union.TKey* %i_key17 to %struct.anon.1*
  %next = getelementptr inbounds %struct.anon.1* %nk, i32 0, i32 2
  %23 = load %struct.Node** %next, align 8
  store %struct.Node* %23, %struct.Node** %n7, align 8
  br label %if.end18

if.end18:                                         ; preds = %if.else
  br label %do.cond

do.cond:                                          ; preds = %if.end18
  %24 = load %struct.Node** %n7, align 8
  %tobool19 = icmp ne %struct.Node* %24, null
  br i1 %tobool19, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  store %struct.lua_TValue* bitcast ({ %union.Value.281, i32, [4 x i8] }* @luaO_nilobject_ to %struct.lua_TValue*), %struct.lua_TValue** %retval
  br label %return

return:                                           ; preds = %do.end, %if.then16, %if.then, %sw.bb1, %sw.bb
  %25 = load %struct.lua_TValue** %retval
  ret %struct.lua_TValue* %25
}

; Function Attrs: nounwind uwtable
define hidden i32 @luaH_getn(%struct.Table* %t) #0 {
entry:
  %retval = alloca i32, align 4
  %t.addr = alloca %struct.Table*, align 8
  %j = alloca i32, align 4
  %i = alloca i32, align 4
  %m = alloca i32, align 4
  store %struct.Table* %t, %struct.Table** %t.addr, align 8
  %0 = load %struct.Table** %t.addr, align 8
  %sizearray = getelementptr inbounds %struct.Table* %0, i32 0, i32 10
  %1 = load i32* %sizearray, align 4
  store i32 %1, i32* %j, align 4
  %2 = load i32* %j, align 4
  %cmp = icmp ugt i32 %2, 0
  br i1 %cmp, label %land.lhs.true, label %if.else11

land.lhs.true:                                    ; preds = %entry
  %3 = load i32* %j, align 4
  %sub = sub i32 %3, 1
  %idxprom = zext i32 %sub to i64
  %4 = load %struct.Table** %t.addr, align 8
  %array = getelementptr inbounds %struct.Table* %4, i32 0, i32 6
  %5 = load %struct.lua_TValue** %array, align 8
  %arrayidx = getelementptr inbounds %struct.lua_TValue* %5, i64 %idxprom
  %tt_ = getelementptr inbounds %struct.lua_TValue* %arrayidx, i32 0, i32 1
  %6 = load i32* %tt_, align 4
  %cmp1 = icmp eq i32 %6, 0
  br i1 %cmp1, label %if.then, label %if.else11

if.then:                                          ; preds = %land.lhs.true
  store i32 0, i32* %i, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end, %if.then
  %7 = load i32* %j, align 4
  %8 = load i32* %i, align 4
  %sub2 = sub i32 %7, %8
  %cmp3 = icmp ugt i32 %sub2, 1
  br i1 %cmp3, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %9 = load i32* %i, align 4
  %10 = load i32* %j, align 4
  %add = add i32 %9, %10
  %div = udiv i32 %add, 2
  store i32 %div, i32* %m, align 4
  %11 = load i32* %m, align 4
  %sub4 = sub i32 %11, 1
  %idxprom5 = zext i32 %sub4 to i64
  %12 = load %struct.Table** %t.addr, align 8
  %array6 = getelementptr inbounds %struct.Table* %12, i32 0, i32 6
  %13 = load %struct.lua_TValue** %array6, align 8
  %arrayidx7 = getelementptr inbounds %struct.lua_TValue* %13, i64 %idxprom5
  %tt_8 = getelementptr inbounds %struct.lua_TValue* %arrayidx7, i32 0, i32 1
  %14 = load i32* %tt_8, align 4
  %cmp9 = icmp eq i32 %14, 0
  br i1 %cmp9, label %if.then10, label %if.else

if.then10:                                        ; preds = %while.body
  %15 = load i32* %m, align 4
  store i32 %15, i32* %j, align 4
  br label %if.end

if.else:                                          ; preds = %while.body
  %16 = load i32* %m, align 4
  store i32 %16, i32* %i, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then10
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %17 = load i32* %i, align 4
  store i32 %17, i32* %retval
  br label %return

if.else11:                                        ; preds = %land.lhs.true, %entry
  %18 = load %struct.Table** %t.addr, align 8
  %node = getelementptr inbounds %struct.Table* %18, i32 0, i32 7
  %19 = load %struct.Node** %node, align 8
  %cmp12 = icmp eq %struct.Node* %19, bitcast ({ { %union.Value, i32, [4 x i8] }, %union.TKey }* @dummynode_ to %struct.Node*)
  br i1 %cmp12, label %if.then13, label %if.else14

if.then13:                                        ; preds = %if.else11
  %20 = load i32* %j, align 4
  store i32 %20, i32* %retval
  br label %return

if.else14:                                        ; preds = %if.else11
  %21 = load %struct.Table** %t.addr, align 8
  %22 = load i32* %j, align 4
  %call = call i32 @unbound_search(%struct.Table* %21, i32 %22)
  store i32 %call, i32* %retval
  br label %return

return:                                           ; preds = %if.else14, %if.then13, %while.end
  %23 = load i32* %retval
  ret i32 %23
}

; Function Attrs: nounwind uwtable
define internal i32 @findindex(%struct.lua_State* %L, %struct.Table* %t, %struct.lua_TValue* %key) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %t.addr = alloca %struct.Table*, align 8
  %key.addr = alloca %struct.lua_TValue*, align 8
  %i = alloca i32, align 4
  %n = alloca %struct.Node*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.Table* %t, %struct.Table** %t.addr, align 8
  store %struct.lua_TValue* %key, %struct.lua_TValue** %key.addr, align 8
  %0 = load %struct.lua_TValue** %key.addr, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %0, i32 0, i32 1
  %1 = load i32* %tt_, align 4
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -1, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.lua_TValue** %key.addr, align 8
  %call = call i32 @arrayindex(%struct.lua_TValue* %2)
  store i32 %call, i32* %i, align 4
  %3 = load i32* %i, align 4
  %cmp1 = icmp slt i32 0, %3
  br i1 %cmp1, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.end
  %4 = load i32* %i, align 4
  %5 = load %struct.Table** %t.addr, align 8
  %sizearray = getelementptr inbounds %struct.Table* %5, i32 0, i32 10
  %6 = load i32* %sizearray, align 4
  %cmp2 = icmp sle i32 %4, %6
  br i1 %cmp2, label %if.then3, label %if.else

if.then3:                                         ; preds = %land.lhs.true
  %7 = load i32* %i, align 4
  %sub = sub nsw i32 %7, 1
  store i32 %sub, i32* %retval
  br label %return

if.else:                                          ; preds = %land.lhs.true, %if.end
  %8 = load %struct.Table** %t.addr, align 8
  %9 = load %struct.lua_TValue** %key.addr, align 8
  %call4 = call %struct.Node* @mainposition(%struct.Table* %8, %struct.lua_TValue* %9)
  store %struct.Node* %call4, %struct.Node** %n, align 8
  br label %for.cond

for.cond:                                         ; preds = %if.end33, %if.else
  %10 = load %struct.Node** %n, align 8
  %i_key = getelementptr inbounds %struct.Node* %10, i32 0, i32 1
  %tvk = bitcast %union.TKey* %i_key to %struct.lua_TValue*
  %tt_5 = getelementptr inbounds %struct.lua_TValue* %tvk, i32 0, i32 1
  %11 = load i32* %tt_5, align 4
  %12 = load %struct.lua_TValue** %key.addr, align 8
  %tt_6 = getelementptr inbounds %struct.lua_TValue* %12, i32 0, i32 1
  %13 = load i32* %tt_6, align 4
  %cmp7 = icmp eq i32 %11, %13
  br i1 %cmp7, label %land.lhs.true8, label %lor.lhs.false

land.lhs.true8:                                   ; preds = %for.cond
  %14 = load %struct.Node** %n, align 8
  %i_key9 = getelementptr inbounds %struct.Node* %14, i32 0, i32 1
  %tvk10 = bitcast %union.TKey* %i_key9 to %struct.lua_TValue*
  %15 = load %struct.lua_TValue** %key.addr, align 8
  %call11 = call i32 bitcast (i32 (%struct.lua_State.364*, %struct.lua_TValue.349*, %struct.lua_TValue.349*)* @luaV_equalobj_ to i32 (%struct.lua_State*, %struct.lua_TValue*, %struct.lua_TValue*)*)(%struct.lua_State* null, %struct.lua_TValue* %tvk10, %struct.lua_TValue* %15)
  %tobool = icmp ne i32 %call11, 0
  br i1 %tobool, label %if.then25, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true8, %for.cond
  %16 = load %struct.Node** %n, align 8
  %i_key12 = getelementptr inbounds %struct.Node* %16, i32 0, i32 1
  %tvk13 = bitcast %union.TKey* %i_key12 to %struct.lua_TValue*
  %tt_14 = getelementptr inbounds %struct.lua_TValue* %tvk13, i32 0, i32 1
  %17 = load i32* %tt_14, align 4
  %cmp15 = icmp eq i32 %17, 11
  br i1 %cmp15, label %land.lhs.true16, label %if.else27

land.lhs.true16:                                  ; preds = %lor.lhs.false
  %18 = load %struct.lua_TValue** %key.addr, align 8
  %tt_17 = getelementptr inbounds %struct.lua_TValue* %18, i32 0, i32 1
  %19 = load i32* %tt_17, align 4
  %and = and i32 %19, 64
  %tobool18 = icmp ne i32 %and, 0
  br i1 %tobool18, label %land.lhs.true19, label %if.else27

land.lhs.true19:                                  ; preds = %land.lhs.true16
  %20 = load %struct.Node** %n, align 8
  %i_key20 = getelementptr inbounds %struct.Node* %20, i32 0, i32 1
  %tvk21 = bitcast %union.TKey* %i_key20 to %struct.lua_TValue*
  %value_ = getelementptr inbounds %struct.lua_TValue* %tvk21, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %21 = load %union.GCObject** %gc, align 8
  %22 = bitcast %union.GCObject* %21 to i8*
  %23 = load %struct.lua_TValue** %key.addr, align 8
  %value_22 = getelementptr inbounds %struct.lua_TValue* %23, i32 0, i32 0
  %gc23 = bitcast %union.Value* %value_22 to %union.GCObject**
  %24 = load %union.GCObject** %gc23, align 8
  %25 = bitcast %union.GCObject* %24 to i8*
  %cmp24 = icmp eq i8* %22, %25
  br i1 %cmp24, label %if.then25, label %if.else27

if.then25:                                        ; preds = %land.lhs.true19, %land.lhs.true8
  %26 = load %struct.Node** %n, align 8
  %27 = load %struct.Table** %t.addr, align 8
  %node = getelementptr inbounds %struct.Table* %27, i32 0, i32 7
  %28 = load %struct.Node** %node, align 8
  %arrayidx = getelementptr inbounds %struct.Node* %28, i64 0
  %sub.ptr.lhs.cast = ptrtoint %struct.Node* %26 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.Node* %arrayidx to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 40
  %conv = trunc i64 %sub.ptr.div to i32
  store i32 %conv, i32* %i, align 4
  %29 = load i32* %i, align 4
  %30 = load %struct.Table** %t.addr, align 8
  %sizearray26 = getelementptr inbounds %struct.Table* %30, i32 0, i32 10
  %31 = load i32* %sizearray26, align 4
  %add = add nsw i32 %29, %31
  store i32 %add, i32* %retval
  br label %return

if.else27:                                        ; preds = %land.lhs.true19, %land.lhs.true16, %lor.lhs.false
  %32 = load %struct.Node** %n, align 8
  %i_key28 = getelementptr inbounds %struct.Node* %32, i32 0, i32 1
  %nk = bitcast %union.TKey* %i_key28 to %struct.anon.1*
  %next = getelementptr inbounds %struct.anon.1* %nk, i32 0, i32 2
  %33 = load %struct.Node** %next, align 8
  store %struct.Node* %33, %struct.Node** %n, align 8
  br label %if.end29

if.end29:                                         ; preds = %if.else27
  %34 = load %struct.Node** %n, align 8
  %cmp30 = icmp eq %struct.Node* %34, null
  br i1 %cmp30, label %if.then32, label %if.end33

if.then32:                                        ; preds = %if.end29
  %35 = load %struct.lua_State** %L.addr, align 8
  call void (%struct.lua_State*, i8*, ...)* @luaG_runerror(%struct.lua_State* %35, i8* getelementptr inbounds ([22 x i8]* @.str3709, i32 0, i32 0)) #9
  unreachable

if.end33:                                         ; preds = %if.end29
  br label %for.cond

return:                                           ; preds = %if.then25, %if.then3, %if.then
  %36 = load i32* %retval
  ret i32 %36
}

; Function Attrs: nounwind uwtable
define internal void @setarrayvector(%struct.lua_State* %L, %struct.Table* %t, i32 %size) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %t.addr = alloca %struct.Table*, align 8
  %size.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.Table* %t, %struct.Table** %t.addr, align 8
  store i32 %size, i32* %size.addr, align 4
  %0 = load i32* %size.addr, align 4
  %add = add nsw i32 %0, 1
  %conv = sext i32 %add to i64
  %cmp = icmp ugt i64 %conv, 1152921504606846975
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load %struct.lua_State** %L.addr, align 8
  call void @luaM_toobig(%struct.lua_State* %1) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %2
  %cond = phi i32 [ 0, %2 ], [ 0, %cond.false ]
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load %struct.Table** %t.addr, align 8
  %array = getelementptr inbounds %struct.Table* %4, i32 0, i32 6
  %5 = load %struct.lua_TValue** %array, align 8
  %6 = bitcast %struct.lua_TValue* %5 to i8*
  %7 = load %struct.Table** %t.addr, align 8
  %sizearray = getelementptr inbounds %struct.Table* %7, i32 0, i32 10
  %8 = load i32* %sizearray, align 4
  %conv2 = sext i32 %8 to i64
  %mul = mul i64 %conv2, 16
  %9 = load i32* %size.addr, align 4
  %conv3 = sext i32 %9 to i64
  %mul4 = mul i64 %conv3, 16
  %call = call i8* @luaM_realloc_(%struct.lua_State* %3, i8* %6, i64 %mul, i64 %mul4)
  %10 = bitcast i8* %call to %struct.lua_TValue*
  %11 = load %struct.Table** %t.addr, align 8
  %array5 = getelementptr inbounds %struct.Table* %11, i32 0, i32 6
  store %struct.lua_TValue* %10, %struct.lua_TValue** %array5, align 8
  %12 = load %struct.Table** %t.addr, align 8
  %sizearray6 = getelementptr inbounds %struct.Table* %12, i32 0, i32 10
  %13 = load i32* %sizearray6, align 4
  store i32 %13, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %14 = load i32* %i, align 4
  %15 = load i32* %size.addr, align 4
  %cmp7 = icmp slt i32 %14, %15
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load i32* %i, align 4
  %idxprom = sext i32 %16 to i64
  %17 = load %struct.Table** %t.addr, align 8
  %array9 = getelementptr inbounds %struct.Table* %17, i32 0, i32 6
  %18 = load %struct.lua_TValue** %array9, align 8
  %arrayidx = getelementptr inbounds %struct.lua_TValue* %18, i64 %idxprom
  %tt_ = getelementptr inbounds %struct.lua_TValue* %arrayidx, i32 0, i32 1
  store i32 0, i32* %tt_, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %19 = load i32* %i, align 4
  %inc = add nsw i32 %19, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %20 = load i32* %size.addr, align 4
  %21 = load %struct.Table** %t.addr, align 8
  %sizearray10 = getelementptr inbounds %struct.Table* %21, i32 0, i32 10
  store i32 %20, i32* %sizearray10, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @setnodevector(%struct.lua_State* %L, %struct.Table* %t, i32 %size) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %t.addr = alloca %struct.Table*, align 8
  %size.addr = alloca i32, align 4
  %lsize = alloca i32, align 4
  %i = alloca i32, align 4
  %n = alloca %struct.Node*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.Table* %t, %struct.Table** %t.addr, align 8
  store i32 %size, i32* %size.addr, align 4
  %0 = load i32* %size.addr, align 4
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load %struct.Table** %t.addr, align 8
  %node = getelementptr inbounds %struct.Table* %1, i32 0, i32 7
  store %struct.Node* bitcast ({ { %union.Value, i32, [4 x i8] }, %union.TKey }* @dummynode_ to %struct.Node*), %struct.Node** %node, align 8
  store i32 0, i32* %lsize, align 4
  br label %if.end13

if.else:                                          ; preds = %entry
  %2 = load i32* %size.addr, align 4
  %call = call i32 @luaO_ceillog2(i32 %2)
  store i32 %call, i32* %lsize, align 4
  %3 = load i32* %lsize, align 4
  %cmp1 = icmp sgt i32 %3, 30
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.else
  %4 = load %struct.lua_State** %L.addr, align 8
  call void (%struct.lua_State*, i8*, ...)* @luaG_runerror(%struct.lua_State* %4, i8* getelementptr inbounds ([15 x i8]* @.str2708, i32 0, i32 0)) #9
  unreachable

if.end:                                           ; preds = %if.else
  %5 = load i32* %lsize, align 4
  %shl = shl i32 1, %5
  store i32 %shl, i32* %size.addr, align 4
  %6 = load i32* %size.addr, align 4
  %add = add nsw i32 %6, 1
  %conv = sext i32 %add to i64
  %cmp3 = icmp ugt i64 %conv, 461168601842738790
  br i1 %cmp3, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %7 = load %struct.lua_State** %L.addr, align 8
  call void @luaM_toobig(%struct.lua_State* %7) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.false:                                       ; preds = %if.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %8
  %cond = phi i32 [ 0, %8 ], [ 0, %cond.false ]
  %9 = load %struct.lua_State** %L.addr, align 8
  %10 = load i32* %size.addr, align 4
  %conv5 = sext i32 %10 to i64
  %mul = mul i64 %conv5, 40
  %call6 = call i8* @luaM_realloc_(%struct.lua_State* %9, i8* null, i64 0, i64 %mul)
  %11 = bitcast i8* %call6 to %struct.Node*
  %12 = load %struct.Table** %t.addr, align 8
  %node7 = getelementptr inbounds %struct.Table* %12, i32 0, i32 7
  store %struct.Node* %11, %struct.Node** %node7, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %13 = load i32* %i, align 4
  %14 = load i32* %size.addr, align 4
  %cmp8 = icmp slt i32 %13, %14
  br i1 %cmp8, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %15 = load i32* %i, align 4
  %idxprom = sext i32 %15 to i64
  %16 = load %struct.Table** %t.addr, align 8
  %node10 = getelementptr inbounds %struct.Table* %16, i32 0, i32 7
  %17 = load %struct.Node** %node10, align 8
  %arrayidx = getelementptr inbounds %struct.Node* %17, i64 %idxprom
  store %struct.Node* %arrayidx, %struct.Node** %n, align 8
  %18 = load %struct.Node** %n, align 8
  %i_key = getelementptr inbounds %struct.Node* %18, i32 0, i32 1
  %nk = bitcast %union.TKey* %i_key to %struct.anon.1*
  %next = getelementptr inbounds %struct.anon.1* %nk, i32 0, i32 2
  store %struct.Node* null, %struct.Node** %next, align 8
  %19 = load %struct.Node** %n, align 8
  %i_key11 = getelementptr inbounds %struct.Node* %19, i32 0, i32 1
  %tvk = bitcast %union.TKey* %i_key11 to %struct.lua_TValue*
  %tt_ = getelementptr inbounds %struct.lua_TValue* %tvk, i32 0, i32 1
  store i32 0, i32* %tt_, align 4
  %20 = load %struct.Node** %n, align 8
  %i_val = getelementptr inbounds %struct.Node* %20, i32 0, i32 0
  %tt_12 = getelementptr inbounds %struct.lua_TValue* %i_val, i32 0, i32 1
  store i32 0, i32* %tt_12, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %21 = load i32* %i, align 4
  %inc = add nsw i32 %21, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end13

if.end13:                                         ; preds = %for.end, %if.then
  %22 = load i32* %lsize, align 4
  %conv14 = trunc i32 %22 to i8
  %23 = load %struct.Table** %t.addr, align 8
  %lsizenode = getelementptr inbounds %struct.Table* %23, i32 0, i32 4
  store i8 %conv14, i8* %lsizenode, align 1
  %24 = load i32* %size.addr, align 4
  %idxprom15 = sext i32 %24 to i64
  %25 = load %struct.Table** %t.addr, align 8
  %node16 = getelementptr inbounds %struct.Table* %25, i32 0, i32 7
  %26 = load %struct.Node** %node16, align 8
  %arrayidx17 = getelementptr inbounds %struct.Node* %26, i64 %idxprom15
  %27 = load %struct.Table** %t.addr, align 8
  %lastfree = getelementptr inbounds %struct.Table* %27, i32 0, i32 8
  store %struct.Node* %arrayidx17, %struct.Node** %lastfree, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal %struct.Node* @mainposition(%struct.Table* %t, %struct.lua_TValue* %key) #0 {
entry:
  %retval = alloca %struct.Node*, align 8
  %t.addr = alloca %struct.Table*, align 8
  %key.addr = alloca %struct.lua_TValue*, align 8
  %s = alloca %union.TString*, align 8
  store %struct.Table* %t, %struct.Table** %t.addr, align 8
  store %struct.lua_TValue* %key, %struct.lua_TValue** %key.addr, align 8
  %0 = load %struct.lua_TValue** %key.addr, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %0, i32 0, i32 1
  %1 = load i32* %tt_, align 4
  %and = and i32 %1, 63
  switch i32 %and, label %sw.default [
    i32 3, label %sw.bb
    i32 20, label %sw.bb1
    i32 4, label %sw.bb18
    i32 1, label %sw.bb32
    i32 2, label %sw.bb42
    i32 22, label %sw.bb52
  ]

sw.bb:                                            ; preds = %entry
  %2 = load %struct.Table** %t.addr, align 8
  %3 = load %struct.lua_TValue** %key.addr, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %3, i32 0, i32 0
  %n = bitcast %union.Value* %value_ to double*
  %4 = load double* %n, align 8
  %call = call %struct.Node* @hashnum(%struct.Table* %2, double %4)
  store %struct.Node* %call, %struct.Node** %retval
  br label %return

sw.bb1:                                           ; preds = %entry
  %5 = load %struct.lua_TValue** %key.addr, align 8
  %value_2 = getelementptr inbounds %struct.lua_TValue* %5, i32 0, i32 0
  %gc = bitcast %union.Value* %value_2 to %union.GCObject**
  %6 = load %union.GCObject** %gc, align 8
  %ts = bitcast %union.GCObject* %6 to %union.TString*
  store %union.TString* %ts, %union.TString** %s, align 8
  %7 = load %union.TString** %s, align 8
  %tsv = bitcast %union.TString* %7 to %struct.anon.0*
  %extra = getelementptr inbounds %struct.anon.0* %tsv, i32 0, i32 3
  %8 = load i8* %extra, align 1
  %conv = zext i8 %8 to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb1
  %9 = load %union.TString** %s, align 8
  %add.ptr = getelementptr inbounds %union.TString* %9, i64 1
  %10 = bitcast %union.TString* %add.ptr to i8*
  %11 = load %union.TString** %s, align 8
  %tsv4 = bitcast %union.TString* %11 to %struct.anon.0*
  %len = getelementptr inbounds %struct.anon.0* %tsv4, i32 0, i32 5
  %12 = load i64* %len, align 8
  %13 = load %union.TString** %s, align 8
  %tsv5 = bitcast %union.TString* %13 to %struct.anon.0*
  %hash = getelementptr inbounds %struct.anon.0* %tsv5, i32 0, i32 4
  %14 = load i32* %hash, align 4
  %call6 = call i32 @luaS_hash(i8* %10, i64 %12, i32 %14)
  %15 = load %union.TString** %s, align 8
  %tsv7 = bitcast %union.TString* %15 to %struct.anon.0*
  %hash8 = getelementptr inbounds %struct.anon.0* %tsv7, i32 0, i32 4
  store i32 %call6, i32* %hash8, align 4
  %16 = load %union.TString** %s, align 8
  %tsv9 = bitcast %union.TString* %16 to %struct.anon.0*
  %extra10 = getelementptr inbounds %struct.anon.0* %tsv9, i32 0, i32 3
  store i8 1, i8* %extra10, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %sw.bb1
  %17 = load %struct.lua_TValue** %key.addr, align 8
  %value_11 = getelementptr inbounds %struct.lua_TValue* %17, i32 0, i32 0
  %gc12 = bitcast %union.Value* %value_11 to %union.GCObject**
  %18 = load %union.GCObject** %gc12, align 8
  %ts13 = bitcast %union.GCObject* %18 to %union.TString*
  %tsv14 = bitcast %union.TString* %ts13 to %struct.anon.0*
  %hash15 = getelementptr inbounds %struct.anon.0* %tsv14, i32 0, i32 4
  %19 = load i32* %hash15, align 4
  %20 = load %struct.Table** %t.addr, align 8
  %lsizenode = getelementptr inbounds %struct.Table* %20, i32 0, i32 4
  %21 = load i8* %lsizenode, align 1
  %conv16 = zext i8 %21 to i32
  %shl = shl i32 1, %conv16
  %sub = sub nsw i32 %shl, 1
  %and17 = and i32 %19, %sub
  %idxprom = sext i32 %and17 to i64
  %22 = load %struct.Table** %t.addr, align 8
  %node = getelementptr inbounds %struct.Table* %22, i32 0, i32 7
  %23 = load %struct.Node** %node, align 8
  %arrayidx = getelementptr inbounds %struct.Node* %23, i64 %idxprom
  store %struct.Node* %arrayidx, %struct.Node** %retval
  br label %return

sw.bb18:                                          ; preds = %entry
  %24 = load %struct.lua_TValue** %key.addr, align 8
  %value_19 = getelementptr inbounds %struct.lua_TValue* %24, i32 0, i32 0
  %gc20 = bitcast %union.Value* %value_19 to %union.GCObject**
  %25 = load %union.GCObject** %gc20, align 8
  %ts21 = bitcast %union.GCObject* %25 to %union.TString*
  %tsv22 = bitcast %union.TString* %ts21 to %struct.anon.0*
  %hash23 = getelementptr inbounds %struct.anon.0* %tsv22, i32 0, i32 4
  %26 = load i32* %hash23, align 4
  %27 = load %struct.Table** %t.addr, align 8
  %lsizenode24 = getelementptr inbounds %struct.Table* %27, i32 0, i32 4
  %28 = load i8* %lsizenode24, align 1
  %conv25 = zext i8 %28 to i32
  %shl26 = shl i32 1, %conv25
  %sub27 = sub nsw i32 %shl26, 1
  %and28 = and i32 %26, %sub27
  %idxprom29 = sext i32 %and28 to i64
  %29 = load %struct.Table** %t.addr, align 8
  %node30 = getelementptr inbounds %struct.Table* %29, i32 0, i32 7
  %30 = load %struct.Node** %node30, align 8
  %arrayidx31 = getelementptr inbounds %struct.Node* %30, i64 %idxprom29
  store %struct.Node* %arrayidx31, %struct.Node** %retval
  br label %return

sw.bb32:                                          ; preds = %entry
  %31 = load %struct.lua_TValue** %key.addr, align 8
  %value_33 = getelementptr inbounds %struct.lua_TValue* %31, i32 0, i32 0
  %b = bitcast %union.Value* %value_33 to i32*
  %32 = load i32* %b, align 4
  %33 = load %struct.Table** %t.addr, align 8
  %lsizenode34 = getelementptr inbounds %struct.Table* %33, i32 0, i32 4
  %34 = load i8* %lsizenode34, align 1
  %conv35 = zext i8 %34 to i32
  %shl36 = shl i32 1, %conv35
  %sub37 = sub nsw i32 %shl36, 1
  %and38 = and i32 %32, %sub37
  %idxprom39 = sext i32 %and38 to i64
  %35 = load %struct.Table** %t.addr, align 8
  %node40 = getelementptr inbounds %struct.Table* %35, i32 0, i32 7
  %36 = load %struct.Node** %node40, align 8
  %arrayidx41 = getelementptr inbounds %struct.Node* %36, i64 %idxprom39
  store %struct.Node* %arrayidx41, %struct.Node** %retval
  br label %return

sw.bb42:                                          ; preds = %entry
  %37 = load %struct.lua_TValue** %key.addr, align 8
  %value_43 = getelementptr inbounds %struct.lua_TValue* %37, i32 0, i32 0
  %p = bitcast %union.Value* %value_43 to i8**
  %38 = load i8** %p, align 8
  %39 = ptrtoint i8* %38 to i64
  %conv44 = trunc i64 %39 to i32
  %40 = load %struct.Table** %t.addr, align 8
  %lsizenode45 = getelementptr inbounds %struct.Table* %40, i32 0, i32 4
  %41 = load i8* %lsizenode45, align 1
  %conv46 = zext i8 %41 to i32
  %shl47 = shl i32 1, %conv46
  %sub48 = sub nsw i32 %shl47, 1
  %or = or i32 %sub48, 1
  %rem = urem i32 %conv44, %or
  %idxprom49 = zext i32 %rem to i64
  %42 = load %struct.Table** %t.addr, align 8
  %node50 = getelementptr inbounds %struct.Table* %42, i32 0, i32 7
  %43 = load %struct.Node** %node50, align 8
  %arrayidx51 = getelementptr inbounds %struct.Node* %43, i64 %idxprom49
  store %struct.Node* %arrayidx51, %struct.Node** %retval
  br label %return

sw.bb52:                                          ; preds = %entry
  %44 = load %struct.lua_TValue** %key.addr, align 8
  %value_53 = getelementptr inbounds %struct.lua_TValue* %44, i32 0, i32 0
  %f = bitcast %union.Value* %value_53 to i32 (%struct.lua_State*)**
  %45 = load i32 (%struct.lua_State*)** %f, align 8
  %46 = ptrtoint i32 (%struct.lua_State*)* %45 to i64
  %conv54 = trunc i64 %46 to i32
  %47 = load %struct.Table** %t.addr, align 8
  %lsizenode55 = getelementptr inbounds %struct.Table* %47, i32 0, i32 4
  %48 = load i8* %lsizenode55, align 1
  %conv56 = zext i8 %48 to i32
  %shl57 = shl i32 1, %conv56
  %sub58 = sub nsw i32 %shl57, 1
  %or59 = or i32 %sub58, 1
  %rem60 = urem i32 %conv54, %or59
  %idxprom61 = zext i32 %rem60 to i64
  %49 = load %struct.Table** %t.addr, align 8
  %node62 = getelementptr inbounds %struct.Table* %49, i32 0, i32 7
  %50 = load %struct.Node** %node62, align 8
  %arrayidx63 = getelementptr inbounds %struct.Node* %50, i64 %idxprom61
  store %struct.Node* %arrayidx63, %struct.Node** %retval
  br label %return

sw.default:                                       ; preds = %entry
  %51 = load %struct.lua_TValue** %key.addr, align 8
  %value_64 = getelementptr inbounds %struct.lua_TValue* %51, i32 0, i32 0
  %gc65 = bitcast %union.Value* %value_64 to %union.GCObject**
  %52 = load %union.GCObject** %gc65, align 8
  %53 = ptrtoint %union.GCObject* %52 to i64
  %conv66 = trunc i64 %53 to i32
  %54 = load %struct.Table** %t.addr, align 8
  %lsizenode67 = getelementptr inbounds %struct.Table* %54, i32 0, i32 4
  %55 = load i8* %lsizenode67, align 1
  %conv68 = zext i8 %55 to i32
  %shl69 = shl i32 1, %conv68
  %sub70 = sub nsw i32 %shl69, 1
  %or71 = or i32 %sub70, 1
  %rem72 = urem i32 %conv66, %or71
  %idxprom73 = zext i32 %rem72 to i64
  %56 = load %struct.Table** %t.addr, align 8
  %node74 = getelementptr inbounds %struct.Table* %56, i32 0, i32 7
  %57 = load %struct.Node** %node74, align 8
  %arrayidx75 = getelementptr inbounds %struct.Node* %57, i64 %idxprom73
  store %struct.Node* %arrayidx75, %struct.Node** %retval
  br label %return

return:                                           ; preds = %sw.default, %sw.bb52, %sw.bb42, %sw.bb32, %sw.bb18, %if.end, %sw.bb
  %58 = load %struct.Node** %retval
  ret %struct.Node* %58
}

; Function Attrs: nounwind uwtable
define internal %struct.Node* @getfreepos(%struct.Table* %t) #0 {
entry:
  %retval = alloca %struct.Node*, align 8
  %t.addr = alloca %struct.Table*, align 8
  store %struct.Table* %t, %struct.Table** %t.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %0 = load %struct.Table** %t.addr, align 8
  %lastfree = getelementptr inbounds %struct.Table* %0, i32 0, i32 8
  %1 = load %struct.Node** %lastfree, align 8
  %2 = load %struct.Table** %t.addr, align 8
  %node = getelementptr inbounds %struct.Table* %2, i32 0, i32 7
  %3 = load %struct.Node** %node, align 8
  %cmp = icmp ugt %struct.Node* %1, %3
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %4 = load %struct.Table** %t.addr, align 8
  %lastfree1 = getelementptr inbounds %struct.Table* %4, i32 0, i32 8
  %5 = load %struct.Node** %lastfree1, align 8
  %incdec.ptr = getelementptr inbounds %struct.Node* %5, i32 -1
  store %struct.Node* %incdec.ptr, %struct.Node** %lastfree1, align 8
  %6 = load %struct.Table** %t.addr, align 8
  %lastfree2 = getelementptr inbounds %struct.Table* %6, i32 0, i32 8
  %7 = load %struct.Node** %lastfree2, align 8
  %i_key = getelementptr inbounds %struct.Node* %7, i32 0, i32 1
  %tvk = bitcast %union.TKey* %i_key to %struct.lua_TValue*
  %tt_ = getelementptr inbounds %struct.lua_TValue* %tvk, i32 0, i32 1
  %8 = load i32* %tt_, align 4
  %cmp3 = icmp eq i32 %8, 0
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %9 = load %struct.Table** %t.addr, align 8
  %lastfree4 = getelementptr inbounds %struct.Table* %9, i32 0, i32 8
  %10 = load %struct.Node** %lastfree4, align 8
  store %struct.Node* %10, %struct.Node** %retval
  br label %return

if.end:                                           ; preds = %while.body
  br label %while.cond

while.end:                                        ; preds = %while.cond
  store %struct.Node* null, %struct.Node** %retval
  br label %return

return:                                           ; preds = %while.end, %if.then
  %11 = load %struct.Node** %retval
  ret %struct.Node* %11
}

; Function Attrs: nounwind uwtable
define internal void @rehash(%struct.lua_State* %L, %struct.Table* %t, %struct.lua_TValue* %ek) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %t.addr = alloca %struct.Table*, align 8
  %ek.addr = alloca %struct.lua_TValue*, align 8
  %nasize = alloca i32, align 4
  %na = alloca i32, align 4
  %nums = alloca [31 x i32], align 16
  %i = alloca i32, align 4
  %totaluse = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.Table* %t, %struct.Table** %t.addr, align 8
  store %struct.lua_TValue* %ek, %struct.lua_TValue** %ek.addr, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32* %i, align 4
  %cmp = icmp sle i32 %0, 30
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load i32* %i, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds [31 x i32]* %nums, i32 0, i64 %idxprom
  store i32 0, i32* %arrayidx, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %2 = load i32* %i, align 4
  %inc = add nsw i32 %2, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %3 = load %struct.Table** %t.addr, align 8
  %arraydecay = getelementptr inbounds [31 x i32]* %nums, i32 0, i32 0
  %call = call i32 @numusearray(%struct.Table* %3, i32* %arraydecay)
  store i32 %call, i32* %nasize, align 4
  %4 = load i32* %nasize, align 4
  store i32 %4, i32* %totaluse, align 4
  %5 = load %struct.Table** %t.addr, align 8
  %arraydecay1 = getelementptr inbounds [31 x i32]* %nums, i32 0, i32 0
  %call2 = call i32 @numusehash(%struct.Table* %5, i32* %arraydecay1, i32* %nasize)
  %6 = load i32* %totaluse, align 4
  %add = add nsw i32 %6, %call2
  store i32 %add, i32* %totaluse, align 4
  %7 = load %struct.lua_TValue** %ek.addr, align 8
  %arraydecay3 = getelementptr inbounds [31 x i32]* %nums, i32 0, i32 0
  %call4 = call i32 @countint(%struct.lua_TValue* %7, i32* %arraydecay3)
  %8 = load i32* %nasize, align 4
  %add5 = add nsw i32 %8, %call4
  store i32 %add5, i32* %nasize, align 4
  %9 = load i32* %totaluse, align 4
  %inc6 = add nsw i32 %9, 1
  store i32 %inc6, i32* %totaluse, align 4
  %arraydecay7 = getelementptr inbounds [31 x i32]* %nums, i32 0, i32 0
  %call8 = call i32 @computesizes(i32* %arraydecay7, i32* %nasize)
  store i32 %call8, i32* %na, align 4
  %10 = load %struct.lua_State** %L.addr, align 8
  %11 = load %struct.Table** %t.addr, align 8
  %12 = load i32* %nasize, align 4
  %13 = load i32* %totaluse, align 4
  %14 = load i32* %na, align 4
  %sub = sub nsw i32 %13, %14
  call void @luaH_resize(%struct.lua_State* %10, %struct.Table* %11, i32 %12, i32 %sub)
  ret void
}

; Function Attrs: nounwind uwtable
define internal %struct.Node* @hashnum(%struct.Table* %t, double %n) #0 {
entry:
  %t.addr = alloca %struct.Table*, align 8
  %n.addr = alloca double, align 8
  %i = alloca i32, align 4
  %u = alloca %union.luai_Cast, align 8
  store %struct.Table* %t, %struct.Table** %t.addr, align 8
  store double %n, double* %n.addr, align 8
  %0 = load double* %n.addr, align 8
  %add = fadd double %0, 1.000000e+00
  %l_d = bitcast %union.luai_Cast* %u to double*
  store volatile double %add, double* %l_d, align 8
  %l_p = bitcast %union.luai_Cast* %u to [2 x i32]*
  %arrayidx = getelementptr inbounds [2 x i32]* %l_p, i32 0, i64 0
  %1 = load volatile i32* %arrayidx, align 4
  store i32 %1, i32* %i, align 4
  %l_p1 = bitcast %union.luai_Cast* %u to [2 x i32]*
  %arrayidx2 = getelementptr inbounds [2 x i32]* %l_p1, i32 0, i64 1
  %2 = load volatile i32* %arrayidx2, align 4
  %3 = load i32* %i, align 4
  %add3 = add nsw i32 %3, %2
  store i32 %add3, i32* %i, align 4
  %4 = load i32* %i, align 4
  %cmp = icmp slt i32 %4, 0
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %5 = load i32* %i, align 4
  %6 = load i32* %i, align 4
  %sub = sub i32 0, %6
  %cmp4 = icmp eq i32 %5, %sub
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.then
  store i32 0, i32* %i, align 4
  br label %if.end

if.end:                                           ; preds = %if.then5, %if.then
  %7 = load i32* %i, align 4
  %sub6 = sub nsw i32 0, %7
  store i32 %sub6, i32* %i, align 4
  br label %if.end7

if.end7:                                          ; preds = %if.end, %entry
  %8 = load i32* %i, align 4
  %9 = load %struct.Table** %t.addr, align 8
  %lsizenode = getelementptr inbounds %struct.Table* %9, i32 0, i32 4
  %10 = load i8* %lsizenode, align 1
  %conv = zext i8 %10 to i32
  %shl = shl i32 1, %conv
  %sub8 = sub nsw i32 %shl, 1
  %or = or i32 %sub8, 1
  %rem = srem i32 %8, %or
  %idxprom = sext i32 %rem to i64
  %11 = load %struct.Table** %t.addr, align 8
  %node = getelementptr inbounds %struct.Table* %11, i32 0, i32 7
  %12 = load %struct.Node** %node, align 8
  %arrayidx9 = getelementptr inbounds %struct.Node* %12, i64 %idxprom
  ret %struct.Node* %arrayidx9
}

; Function Attrs: nounwind uwtable
define internal i32 @unbound_search(%struct.Table* %t, i32 %j) #0 {
entry:
  %retval = alloca i32, align 4
  %t.addr = alloca %struct.Table*, align 8
  %j.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %m = alloca i32, align 4
  store %struct.Table* %t, %struct.Table** %t.addr, align 8
  store i32 %j, i32* %j.addr, align 4
  %0 = load i32* %j.addr, align 4
  store i32 %0, i32* %i, align 4
  %1 = load i32* %j.addr, align 4
  %inc = add i32 %1, 1
  store i32 %inc, i32* %j.addr, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %2 = load %struct.Table** %t.addr, align 8
  %3 = load i32* %j.addr, align 4
  %call = call %struct.lua_TValue* @luaH_getint(%struct.Table* %2, i32 %3)
  %tt_ = getelementptr inbounds %struct.lua_TValue* %call, i32 0, i32 1
  %4 = load i32* %tt_, align 4
  %cmp = icmp eq i32 %4, 0
  %lnot = xor i1 %cmp, true
  br i1 %lnot, label %while.body, label %while.end9

while.body:                                       ; preds = %while.cond
  %5 = load i32* %j.addr, align 4
  store i32 %5, i32* %i, align 4
  %6 = load i32* %j.addr, align 4
  %mul = mul i32 %6, 2
  store i32 %mul, i32* %j.addr, align 4
  %7 = load i32* %j.addr, align 4
  %cmp1 = icmp ugt i32 %7, 2147483645
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  store i32 1, i32* %i, align 4
  br label %while.cond2

while.cond2:                                      ; preds = %while.body7, %if.then
  %8 = load %struct.Table** %t.addr, align 8
  %9 = load i32* %i, align 4
  %call3 = call %struct.lua_TValue* @luaH_getint(%struct.Table* %8, i32 %9)
  %tt_4 = getelementptr inbounds %struct.lua_TValue* %call3, i32 0, i32 1
  %10 = load i32* %tt_4, align 4
  %cmp5 = icmp eq i32 %10, 0
  %lnot6 = xor i1 %cmp5, true
  br i1 %lnot6, label %while.body7, label %while.end

while.body7:                                      ; preds = %while.cond2
  %11 = load i32* %i, align 4
  %inc8 = add i32 %11, 1
  store i32 %inc8, i32* %i, align 4
  br label %while.cond2

while.end:                                        ; preds = %while.cond2
  %12 = load i32* %i, align 4
  %sub = sub i32 %12, 1
  store i32 %sub, i32* %retval
  br label %return

if.end:                                           ; preds = %while.body
  br label %while.cond

while.end9:                                       ; preds = %while.cond
  br label %while.cond10

while.cond10:                                     ; preds = %if.end18, %while.end9
  %13 = load i32* %j.addr, align 4
  %14 = load i32* %i, align 4
  %sub11 = sub i32 %13, %14
  %cmp12 = icmp ugt i32 %sub11, 1
  br i1 %cmp12, label %while.body13, label %while.end19

while.body13:                                     ; preds = %while.cond10
  %15 = load i32* %i, align 4
  %16 = load i32* %j.addr, align 4
  %add = add i32 %15, %16
  %div = udiv i32 %add, 2
  store i32 %div, i32* %m, align 4
  %17 = load %struct.Table** %t.addr, align 8
  %18 = load i32* %m, align 4
  %call14 = call %struct.lua_TValue* @luaH_getint(%struct.Table* %17, i32 %18)
  %tt_15 = getelementptr inbounds %struct.lua_TValue* %call14, i32 0, i32 1
  %19 = load i32* %tt_15, align 4
  %cmp16 = icmp eq i32 %19, 0
  br i1 %cmp16, label %if.then17, label %if.else

if.then17:                                        ; preds = %while.body13
  %20 = load i32* %m, align 4
  store i32 %20, i32* %j.addr, align 4
  br label %if.end18

if.else:                                          ; preds = %while.body13
  %21 = load i32* %m, align 4
  store i32 %21, i32* %i, align 4
  br label %if.end18

if.end18:                                         ; preds = %if.else, %if.then17
  br label %while.cond10

while.end19:                                      ; preds = %while.cond10
  %22 = load i32* %i, align 4
  store i32 %22, i32* %retval
  br label %return

return:                                           ; preds = %while.end19, %while.end
  %23 = load i32* %retval
  ret i32 %23
}

; Function Attrs: nounwind uwtable
define internal i32 @arrayindex(%struct.lua_TValue* %key) #0 {
entry:
  %retval = alloca i32, align 4
  %key.addr = alloca %struct.lua_TValue*, align 8
  %n = alloca double, align 8
  %k = alloca i32, align 4
  %u = alloca %union.luai_Cast, align 8
  store %struct.lua_TValue* %key, %struct.lua_TValue** %key.addr, align 8
  %0 = load %struct.lua_TValue** %key.addr, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %0, i32 0, i32 1
  %1 = load i32* %tt_, align 4
  %cmp = icmp eq i32 %1, 3
  br i1 %cmp, label %if.then, label %if.end5

if.then:                                          ; preds = %entry
  %2 = load %struct.lua_TValue** %key.addr, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %2, i32 0, i32 0
  %n1 = bitcast %union.Value* %value_ to double*
  %3 = load double* %n1, align 8
  store double %3, double* %n, align 8
  %4 = load double* %n, align 8
  %add = fadd double %4, 0x4338000000000000
  %l_d = bitcast %union.luai_Cast* %u to double*
  store volatile double %add, double* %l_d, align 8
  %l_p = bitcast %union.luai_Cast* %u to [2 x i32]*
  %arrayidx = getelementptr inbounds [2 x i32]* %l_p, i32 0, i64 0
  %5 = load volatile i32* %arrayidx, align 4
  store i32 %5, i32* %k, align 4
  %6 = load i32* %k, align 4
  %conv = sitofp i32 %6 to double
  %7 = load double* %n, align 8
  %cmp2 = fcmp oeq double %conv, %7
  br i1 %cmp2, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  %8 = load i32* %k, align 4
  store i32 %8, i32* %retval
  br label %return

if.end:                                           ; preds = %if.then
  br label %if.end5

if.end5:                                          ; preds = %if.end, %entry
  store i32 -1, i32* %retval
  br label %return

return:                                           ; preds = %if.end5, %if.then4
  %9 = load i32* %retval
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define internal i32 @numusearray(%struct.Table* %t, i32* %nums) #0 {
entry:
  %t.addr = alloca %struct.Table*, align 8
  %nums.addr = alloca i32*, align 8
  %lg = alloca i32, align 4
  %ttlg = alloca i32, align 4
  %ause = alloca i32, align 4
  %i = alloca i32, align 4
  %lc = alloca i32, align 4
  %lim = alloca i32, align 4
  store %struct.Table* %t, %struct.Table** %t.addr, align 8
  store i32* %nums, i32** %nums.addr, align 8
  store i32 0, i32* %ause, align 4
  store i32 1, i32* %i, align 4
  store i32 0, i32* %lg, align 4
  store i32 1, i32* %ttlg, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc16, %entry
  %0 = load i32* %lg, align 4
  %cmp = icmp sle i32 %0, 30
  br i1 %cmp, label %for.body, label %for.end18

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %lc, align 4
  %1 = load i32* %ttlg, align 4
  store i32 %1, i32* %lim, align 4
  %2 = load i32* %lim, align 4
  %3 = load %struct.Table** %t.addr, align 8
  %sizearray = getelementptr inbounds %struct.Table* %3, i32 0, i32 10
  %4 = load i32* %sizearray, align 4
  %cmp1 = icmp sgt i32 %2, %4
  br i1 %cmp1, label %if.then, label %if.end5

if.then:                                          ; preds = %for.body
  %5 = load %struct.Table** %t.addr, align 8
  %sizearray2 = getelementptr inbounds %struct.Table* %5, i32 0, i32 10
  %6 = load i32* %sizearray2, align 4
  store i32 %6, i32* %lim, align 4
  %7 = load i32* %i, align 4
  %8 = load i32* %lim, align 4
  %cmp3 = icmp sgt i32 %7, %8
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  br label %for.end18

if.end:                                           ; preds = %if.then
  br label %if.end5

if.end5:                                          ; preds = %if.end, %for.body
  br label %for.cond6

for.cond6:                                        ; preds = %for.inc, %if.end5
  %9 = load i32* %i, align 4
  %10 = load i32* %lim, align 4
  %cmp7 = icmp sle i32 %9, %10
  br i1 %cmp7, label %for.body8, label %for.end

for.body8:                                        ; preds = %for.cond6
  %11 = load i32* %i, align 4
  %sub = sub nsw i32 %11, 1
  %idxprom = sext i32 %sub to i64
  %12 = load %struct.Table** %t.addr, align 8
  %array = getelementptr inbounds %struct.Table* %12, i32 0, i32 6
  %13 = load %struct.lua_TValue** %array, align 8
  %arrayidx = getelementptr inbounds %struct.lua_TValue* %13, i64 %idxprom
  %tt_ = getelementptr inbounds %struct.lua_TValue* %arrayidx, i32 0, i32 1
  %14 = load i32* %tt_, align 4
  %cmp9 = icmp eq i32 %14, 0
  br i1 %cmp9, label %if.end11, label %if.then10

if.then10:                                        ; preds = %for.body8
  %15 = load i32* %lc, align 4
  %inc = add nsw i32 %15, 1
  store i32 %inc, i32* %lc, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %for.body8
  br label %for.inc

for.inc:                                          ; preds = %if.end11
  %16 = load i32* %i, align 4
  %inc12 = add nsw i32 %16, 1
  store i32 %inc12, i32* %i, align 4
  br label %for.cond6

for.end:                                          ; preds = %for.cond6
  %17 = load i32* %lc, align 4
  %18 = load i32* %lg, align 4
  %idxprom13 = sext i32 %18 to i64
  %19 = load i32** %nums.addr, align 8
  %arrayidx14 = getelementptr inbounds i32* %19, i64 %idxprom13
  %20 = load i32* %arrayidx14, align 4
  %add = add nsw i32 %20, %17
  store i32 %add, i32* %arrayidx14, align 4
  %21 = load i32* %lc, align 4
  %22 = load i32* %ause, align 4
  %add15 = add nsw i32 %22, %21
  store i32 %add15, i32* %ause, align 4
  br label %for.inc16

for.inc16:                                        ; preds = %for.end
  %23 = load i32* %lg, align 4
  %inc17 = add nsw i32 %23, 1
  store i32 %inc17, i32* %lg, align 4
  %24 = load i32* %ttlg, align 4
  %mul = mul nsw i32 %24, 2
  store i32 %mul, i32* %ttlg, align 4
  br label %for.cond

for.end18:                                        ; preds = %if.then4, %for.cond
  %25 = load i32* %ause, align 4
  ret i32 %25
}

; Function Attrs: nounwind uwtable
define internal i32 @numusehash(%struct.Table* %t, i32* %nums, i32* %pnasize) #0 {
entry:
  %t.addr = alloca %struct.Table*, align 8
  %nums.addr = alloca i32*, align 8
  %pnasize.addr = alloca i32*, align 8
  %totaluse = alloca i32, align 4
  %ause = alloca i32, align 4
  %i = alloca i32, align 4
  %n = alloca %struct.Node*, align 8
  store %struct.Table* %t, %struct.Table** %t.addr, align 8
  store i32* %nums, i32** %nums.addr, align 8
  store i32* %pnasize, i32** %pnasize.addr, align 8
  store i32 0, i32* %totaluse, align 4
  store i32 0, i32* %ause, align 4
  %0 = load %struct.Table** %t.addr, align 8
  %lsizenode = getelementptr inbounds %struct.Table* %0, i32 0, i32 4
  %1 = load i8* %lsizenode, align 1
  %conv = zext i8 %1 to i32
  %shl = shl i32 1, %conv
  store i32 %shl, i32* %i, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %2 = load i32* %i, align 4
  %dec = add nsw i32 %2, -1
  store i32 %dec, i32* %i, align 4
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load i32* %i, align 4
  %idxprom = sext i32 %3 to i64
  %4 = load %struct.Table** %t.addr, align 8
  %node = getelementptr inbounds %struct.Table* %4, i32 0, i32 7
  %5 = load %struct.Node** %node, align 8
  %arrayidx = getelementptr inbounds %struct.Node* %5, i64 %idxprom
  store %struct.Node* %arrayidx, %struct.Node** %n, align 8
  %6 = load %struct.Node** %n, align 8
  %i_val = getelementptr inbounds %struct.Node* %6, i32 0, i32 0
  %tt_ = getelementptr inbounds %struct.lua_TValue* %i_val, i32 0, i32 1
  %7 = load i32* %tt_, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %while.body
  %8 = load %struct.Node** %n, align 8
  %i_key = getelementptr inbounds %struct.Node* %8, i32 0, i32 1
  %tvk = bitcast %union.TKey* %i_key to %struct.lua_TValue*
  %9 = load i32** %nums.addr, align 8
  %call = call i32 @countint(%struct.lua_TValue* %tvk, i32* %9)
  %10 = load i32* %ause, align 4
  %add = add nsw i32 %10, %call
  store i32 %add, i32* %ause, align 4
  %11 = load i32* %totaluse, align 4
  %inc = add nsw i32 %11, 1
  store i32 %inc, i32* %totaluse, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %12 = load i32* %ause, align 4
  %13 = load i32** %pnasize.addr, align 8
  %14 = load i32* %13, align 4
  %add2 = add nsw i32 %14, %12
  store i32 %add2, i32* %13, align 4
  %15 = load i32* %totaluse, align 4
  ret i32 %15
}

; Function Attrs: nounwind uwtable
define internal i32 @countint(%struct.lua_TValue* %key, i32* %nums) #0 {
entry:
  %retval.i = alloca i32, align 4
  %key.addr.i = alloca %struct.lua_TValue*, align 8
  %n.i = alloca double, align 8
  %k.i = alloca i32, align 4
  %u.i = alloca %union.luai_Cast, align 8
  %retval = alloca i32, align 4
  %key.addr = alloca %struct.lua_TValue*, align 8
  %nums.addr = alloca i32*, align 8
  %k = alloca i32, align 4
  store %struct.lua_TValue* %key, %struct.lua_TValue** %key.addr, align 8
  store i32* %nums, i32** %nums.addr, align 8
  %0 = load %struct.lua_TValue** %key.addr, align 8
  %1 = bitcast i32* %retval.i to i8*
  call void @llvm.lifetime.start(i64 4, i8* %1)
  %2 = bitcast %struct.lua_TValue** %key.addr.i to i8*
  call void @llvm.lifetime.start(i64 8, i8* %2)
  %3 = bitcast double* %n.i to i8*
  call void @llvm.lifetime.start(i64 8, i8* %3)
  %4 = bitcast i32* %k.i to i8*
  call void @llvm.lifetime.start(i64 4, i8* %4)
  %5 = bitcast %union.luai_Cast* %u.i to i8*
  call void @llvm.lifetime.start(i64 8, i8* %5)
  store %struct.lua_TValue* %0, %struct.lua_TValue** %key.addr.i, align 8
  %6 = load %struct.lua_TValue** %key.addr.i, align 8
  %tt_.i = getelementptr inbounds %struct.lua_TValue* %6, i32 0, i32 1
  %7 = load i32* %tt_.i, align 4
  %cmp.i = icmp eq i32 %7, 3
  br i1 %cmp.i, label %if.then.i, label %if.end5.i

if.then.i:                                        ; preds = %entry
  %8 = load %struct.lua_TValue** %key.addr.i, align 8
  %value_.i = getelementptr inbounds %struct.lua_TValue* %8, i32 0, i32 0
  %n1.i = bitcast %union.Value* %value_.i to double*
  %9 = load double* %n1.i, align 8
  store double %9, double* %n.i, align 8
  %10 = load double* %n.i, align 8
  %add.i = fadd double %10, 0x4338000000000000
  %l_d.i = bitcast %union.luai_Cast* %u.i to double*
  store volatile double %add.i, double* %l_d.i, align 8
  %l_p.i = bitcast %union.luai_Cast* %u.i to [2 x i32]*
  %arrayidx.i = getelementptr inbounds [2 x i32]* %l_p.i, i32 0, i64 0
  %11 = load volatile i32* %arrayidx.i, align 4
  store i32 %11, i32* %k.i, align 4
  %12 = load i32* %k.i, align 4
  %conv.i = sitofp i32 %12 to double
  %13 = load double* %n.i, align 8
  %cmp2.i = fcmp oeq double %conv.i, %13
  br i1 %cmp2.i, label %if.then4.i, label %if.end.i

if.then4.i:                                       ; preds = %if.then.i
  %14 = load i32* %k.i, align 4
  store i32 %14, i32* %retval.i
  br label %arrayindex.exit

if.end.i:                                         ; preds = %if.then.i
  br label %if.end5.i

if.end5.i:                                        ; preds = %if.end.i, %entry
  store i32 -1, i32* %retval.i
  br label %arrayindex.exit

arrayindex.exit:                                  ; preds = %if.end5.i, %if.then4.i
  %15 = load i32* %retval.i
  %16 = bitcast i32* %retval.i to i8*
  call void @llvm.lifetime.end(i64 4, i8* %16)
  %17 = bitcast %struct.lua_TValue** %key.addr.i to i8*
  call void @llvm.lifetime.end(i64 8, i8* %17)
  %18 = bitcast double* %n.i to i8*
  call void @llvm.lifetime.end(i64 8, i8* %18)
  %19 = bitcast i32* %k.i to i8*
  call void @llvm.lifetime.end(i64 4, i8* %19)
  %20 = bitcast %union.luai_Cast* %u.i to i8*
  call void @llvm.lifetime.end(i64 8, i8* %20)
  store i32 %15, i32* %k, align 4
  %21 = load i32* %k, align 4
  %cmp = icmp slt i32 0, %21
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %arrayindex.exit
  %22 = load i32* %k, align 4
  %cmp1 = icmp sle i32 %22, 1073741824
  br i1 %cmp1, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %23 = load i32* %k, align 4
  %call2 = call i32 @luaO_ceillog2(i32 %23)
  %idxprom = sext i32 %call2 to i64
  %24 = load i32** %nums.addr, align 8
  %arrayidx = getelementptr inbounds i32* %24, i64 %idxprom
  %25 = load i32* %arrayidx, align 4
  %inc = add nsw i32 %25, 1
  store i32 %inc, i32* %arrayidx, align 4
  store i32 1, i32* %retval
  br label %return

if.else:                                          ; preds = %land.lhs.true, %arrayindex.exit
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %26 = load i32* %retval
  ret i32 %26
}

; Function Attrs: nounwind uwtable
define internal i32 @computesizes(i32* %nums, i32* %narray) #0 {
entry:
  %nums.addr = alloca i32*, align 8
  %narray.addr = alloca i32*, align 8
  %i = alloca i32, align 4
  %twotoi = alloca i32, align 4
  %a = alloca i32, align 4
  %na = alloca i32, align 4
  %n = alloca i32, align 4
  store i32* %nums, i32** %nums.addr, align 8
  store i32* %narray, i32** %narray.addr, align 8
  store i32 0, i32* %a, align 4
  store i32 0, i32* %na, align 4
  store i32 0, i32* %n, align 4
  store i32 0, i32* %i, align 4
  store i32 1, i32* %twotoi, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32* %twotoi, align 4
  %div = sdiv i32 %0, 2
  %1 = load i32** %narray.addr, align 8
  %2 = load i32* %1, align 4
  %cmp = icmp slt i32 %div, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i32* %i, align 4
  %idxprom = sext i32 %3 to i64
  %4 = load i32** %nums.addr, align 8
  %arrayidx = getelementptr inbounds i32* %4, i64 %idxprom
  %5 = load i32* %arrayidx, align 4
  %cmp1 = icmp sgt i32 %5, 0
  br i1 %cmp1, label %if.then, label %if.end7

if.then:                                          ; preds = %for.body
  %6 = load i32* %i, align 4
  %idxprom2 = sext i32 %6 to i64
  %7 = load i32** %nums.addr, align 8
  %arrayidx3 = getelementptr inbounds i32* %7, i64 %idxprom2
  %8 = load i32* %arrayidx3, align 4
  %9 = load i32* %a, align 4
  %add = add nsw i32 %9, %8
  store i32 %add, i32* %a, align 4
  %10 = load i32* %a, align 4
  %11 = load i32* %twotoi, align 4
  %div4 = sdiv i32 %11, 2
  %cmp5 = icmp sgt i32 %10, %div4
  br i1 %cmp5, label %if.then6, label %if.end

if.then6:                                         ; preds = %if.then
  %12 = load i32* %twotoi, align 4
  store i32 %12, i32* %n, align 4
  %13 = load i32* %a, align 4
  store i32 %13, i32* %na, align 4
  br label %if.end

if.end:                                           ; preds = %if.then6, %if.then
  br label %if.end7

if.end7:                                          ; preds = %if.end, %for.body
  %14 = load i32* %a, align 4
  %15 = load i32** %narray.addr, align 8
  %16 = load i32* %15, align 4
  %cmp8 = icmp eq i32 %14, %16
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end7
  br label %for.end

if.end10:                                         ; preds = %if.end7
  br label %for.inc

for.inc:                                          ; preds = %if.end10
  %17 = load i32* %i, align 4
  %inc = add nsw i32 %17, 1
  store i32 %inc, i32* %i, align 4
  %18 = load i32* %twotoi, align 4
  %mul = mul nsw i32 %18, 2
  store i32 %mul, i32* %twotoi, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then9, %for.cond
  %19 = load i32* %n, align 4
  %20 = load i32** %narray.addr, align 8
  store i32 %19, i32* %20, align 4
  %21 = load i32* %na, align 4
  ret i32 %21
}

; Function Attrs: nounwind uwtable
define i32 @luaopen_table(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 6)
  %1 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_setfuncs(%struct.lua_State* %1, %struct.luaL_Reg* getelementptr inbounds ([7 x %struct.luaL_Reg]* @tab_funcs, i32 0, i32 0), i32 0)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @tconcat(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %b = alloca %struct.luaL_Buffer, align 8
  %lsep = alloca i64, align 8
  %i = alloca i32, align 4
  %last = alloca i32, align 4
  %sep = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @luaL_optlstring(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([1 x i8]* @.str6734, i32 0, i32 0), i64* %lsep)
  store i8* %call, i8** %sep, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_checktype(%struct.lua_State* %1, i32 1, i32 5)
  %2 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i64 @luaL_optinteger(%struct.lua_State* %2, i32 3, i64 1)
  %conv = trunc i64 %call1 to i32
  store i32 %conv, i32* %i, align 4
  %3 = load %struct.lua_State** %L.addr, align 8
  %call2 = call i32 @lua_type(%struct.lua_State* %3, i32 4)
  %cmp = icmp sle i32 %call2, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %4 = load %struct.lua_State** %L.addr, align 8
  %call4 = call i32 @luaL_len(%struct.lua_State* %4, i32 1)
  br label %cond.end

cond.false:                                       ; preds = %entry
  %5 = load %struct.lua_State** %L.addr, align 8
  %call5 = call i64 @luaL_checkinteger(%struct.lua_State* %5, i32 4)
  %conv6 = trunc i64 %call5 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %call4, %cond.true ], [ %conv6, %cond.false ]
  store i32 %cond, i32* %last, align 4
  %6 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_buffinit(%struct.lua_State* %6, %struct.luaL_Buffer* %b)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %7 = load i32* %i, align 4
  %8 = load i32* %last, align 4
  %cmp7 = icmp slt i32 %7, %8
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load %struct.lua_State** %L.addr, align 8
  %10 = load i32* %i, align 4
  call void @addfield(%struct.lua_State* %9, %struct.luaL_Buffer* %b, i32 %10)
  %11 = load i8** %sep, align 8
  %12 = load i64* %lsep, align 8
  call void @luaL_addlstring(%struct.luaL_Buffer* %b, i8* %11, i64 %12)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %13 = load i32* %i, align 4
  %inc = add nsw i32 %13, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %14 = load i32* %i, align 4
  %15 = load i32* %last, align 4
  %cmp9 = icmp eq i32 %14, %15
  br i1 %cmp9, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  %16 = load %struct.lua_State** %L.addr, align 8
  %17 = load i32* %i, align 4
  call void @addfield(%struct.lua_State* %16, %struct.luaL_Buffer* %b, i32 %17)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.end
  call void @luaL_pushresult(%struct.luaL_Buffer* %b)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @tinsert(%struct.lua_State* %L) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %e = alloca i32, align 4
  %pos = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_checktype(%struct.lua_State* %0, i32 1, i32 5)
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @luaL_len(%struct.lua_State* %1, i32 1)
  %add = add nsw i32 %call, 1
  store i32 %add, i32* %e, align 4
  %2 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i32 @lua_gettop(%struct.lua_State* %2)
  switch i32 %call1, label %sw.default [
    i32 2, label %sw.bb
    i32 3, label %sw.bb2
  ]

sw.bb:                                            ; preds = %entry
  %3 = load i32* %e, align 4
  store i32 %3, i32* %pos, align 4
  br label %sw.epilog

sw.bb2:                                           ; preds = %entry
  %4 = load %struct.lua_State** %L.addr, align 8
  %call3 = call i64 @luaL_checkinteger(%struct.lua_State* %4, i32 2)
  %conv = trunc i64 %call3 to i32
  store i32 %conv, i32* %pos, align 4
  %5 = load i32* %pos, align 4
  %cmp = icmp sle i32 1, %5
  br i1 %cmp, label %land.lhs.true, label %lor.rhs

land.lhs.true:                                    ; preds = %sw.bb2
  %6 = load i32* %pos, align 4
  %7 = load i32* %e, align 4
  %cmp5 = icmp sle i32 %6, %7
  br i1 %cmp5, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.lhs.true, %sw.bb2
  %8 = load %struct.lua_State** %L.addr, align 8
  %call7 = call i32 @luaL_argerror(%struct.lua_State* %8, i32 2, i8* getelementptr inbounds ([23 x i8]* @.str8736, i32 0, i32 0))
  %tobool = icmp ne i32 %call7, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.lhs.true
  %9 = phi i1 [ true, %land.lhs.true ], [ %tobool, %lor.rhs ]
  %lor.ext = zext i1 %9 to i32
  %10 = load i32* %e, align 4
  store i32 %10, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %lor.end
  %11 = load i32* %i, align 4
  %12 = load i32* %pos, align 4
  %cmp8 = icmp sgt i32 %11, %12
  br i1 %cmp8, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %13 = load %struct.lua_State** %L.addr, align 8
  %14 = load i32* %i, align 4
  %sub = sub nsw i32 %14, 1
  call void @lua_rawgeti(%struct.lua_State* %13, i32 1, i32 %sub)
  %15 = load %struct.lua_State** %L.addr, align 8
  %16 = load i32* %i, align 4
  call void @lua_rawseti(%struct.lua_State* %15, i32 1, i32 %16)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %17 = load i32* %i, align 4
  %dec = add nsw i32 %17, -1
  store i32 %dec, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %18 = load %struct.lua_State** %L.addr, align 8
  %call10 = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %18, i8* getelementptr inbounds ([38 x i8]* @.str11739, i32 0, i32 0))
  store i32 %call10, i32* %retval
  br label %return

sw.epilog:                                        ; preds = %for.end, %sw.bb
  %19 = load %struct.lua_State** %L.addr, align 8
  %20 = load i32* %pos, align 4
  call void @lua_rawseti(%struct.lua_State* %19, i32 1, i32 %20)
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %sw.epilog, %sw.default
  %21 = load i32* %retval
  ret i32 %21
}

; Function Attrs: nounwind uwtable
define internal i32 @pack(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %n = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_gettop(%struct.lua_State* %0)
  store i32 %call, i32* %n, align 4
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load i32* %n, align 4
  call void @lua_createtable(%struct.lua_State* %1, i32 %2, i32 1)
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load i32* %n, align 4
  %conv = sext i32 %4 to i64
  call void @lua_pushinteger(%struct.lua_State* %3, i64 %conv)
  %5 = load %struct.lua_State** %L.addr, align 8
  call void @lua_setfield(%struct.lua_State* %5, i32 -2, i8* getelementptr inbounds ([2 x i8]* @.str10738, i32 0, i32 0))
  %6 = load i32* %n, align 4
  %cmp = icmp sgt i32 %6, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %7 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushvalue(%struct.lua_State* %7, i32 1)
  %8 = load %struct.lua_State** %L.addr, align 8
  call void @lua_rawseti(%struct.lua_State* %8, i32 -2, i32 1)
  %9 = load %struct.lua_State** %L.addr, align 8
  call void @lua_replace(%struct.lua_State* %9, i32 1)
  %10 = load i32* %n, align 4
  store i32 %10, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %11 = load i32* %i, align 4
  %cmp2 = icmp sge i32 %11, 2
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load %struct.lua_State** %L.addr, align 8
  %13 = load i32* %i, align 4
  call void @lua_rawseti(%struct.lua_State* %12, i32 1, i32 %13)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %14 = load i32* %i, align 4
  %dec = add nsw i32 %14, -1
  store i32 %dec, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end

if.end:                                           ; preds = %for.end, %entry
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @unpack(%struct.lua_State* %L) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %i = alloca i32, align 4
  %e = alloca i32, align 4
  %n = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_checktype(%struct.lua_State* %0, i32 1, i32 5)
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call i64 @luaL_optinteger(%struct.lua_State* %1, i32 2, i64 1)
  %conv = trunc i64 %call to i32
  store i32 %conv, i32* %i, align 4
  %2 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i32 @lua_type(%struct.lua_State* %2, i32 3)
  %cmp = icmp sle i32 %call1, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load %struct.lua_State** %L.addr, align 8
  %call3 = call i32 @luaL_len(%struct.lua_State* %3, i32 1)
  br label %cond.end

cond.false:                                       ; preds = %entry
  %4 = load %struct.lua_State** %L.addr, align 8
  %call4 = call i64 @luaL_checkinteger(%struct.lua_State* %4, i32 3)
  %conv5 = trunc i64 %call4 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %call3, %cond.true ], [ %conv5, %cond.false ]
  store i32 %cond, i32* %e, align 4
  %5 = load i32* %i, align 4
  %6 = load i32* %e, align 4
  %cmp6 = icmp sgt i32 %5, %6
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  store i32 0, i32* %retval
  br label %return

if.end:                                           ; preds = %cond.end
  %7 = load i32* %e, align 4
  %8 = load i32* %i, align 4
  %sub = sub nsw i32 %7, %8
  %add = add nsw i32 %sub, 1
  store i32 %add, i32* %n, align 4
  %9 = load i32* %n, align 4
  %cmp8 = icmp sle i32 %9, 0
  br i1 %cmp8, label %if.then11, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %10 = load %struct.lua_State** %L.addr, align 8
  %11 = load i32* %n, align 4
  %call10 = call i32 @lua_checkstack(%struct.lua_State* %10, i32 %11)
  %tobool = icmp ne i32 %call10, 0
  br i1 %tobool, label %if.end13, label %if.then11

if.then11:                                        ; preds = %lor.lhs.false, %if.end
  %12 = load %struct.lua_State** %L.addr, align 8
  %call12 = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %12, i8* getelementptr inbounds ([27 x i8]* @.str9737, i32 0, i32 0))
  store i32 %call12, i32* %retval
  br label %return

if.end13:                                         ; preds = %lor.lhs.false
  %13 = load %struct.lua_State** %L.addr, align 8
  %14 = load i32* %i, align 4
  call void @lua_rawgeti(%struct.lua_State* %13, i32 1, i32 %14)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end13
  %15 = load i32* %i, align 4
  %inc = add nsw i32 %15, 1
  store i32 %inc, i32* %i, align 4
  %16 = load i32* %e, align 4
  %cmp14 = icmp slt i32 %15, %16
  br i1 %cmp14, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %17 = load %struct.lua_State** %L.addr, align 8
  %18 = load i32* %i, align 4
  call void @lua_rawgeti(%struct.lua_State* %17, i32 1, i32 %18)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %19 = load i32* %n, align 4
  store i32 %19, i32* %retval
  br label %return

return:                                           ; preds = %while.end, %if.then11, %if.then
  %20 = load i32* %retval
  ret i32 %20
}

; Function Attrs: nounwind uwtable
define internal i32 @tremove(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %size = alloca i32, align 4
  %pos = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_checktype(%struct.lua_State* %0, i32 1, i32 5)
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @luaL_len(%struct.lua_State* %1, i32 1)
  store i32 %call, i32* %size, align 4
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load i32* %size, align 4
  %conv = sext i32 %3 to i64
  %call1 = call i64 @luaL_optinteger(%struct.lua_State* %2, i32 2, i64 %conv)
  %conv2 = trunc i64 %call1 to i32
  store i32 %conv2, i32* %pos, align 4
  %4 = load i32* %pos, align 4
  %5 = load i32* %size, align 4
  %cmp = icmp ne i32 %4, %5
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load i32* %pos, align 4
  %cmp4 = icmp sle i32 1, %6
  br i1 %cmp4, label %land.lhs.true, label %lor.rhs

land.lhs.true:                                    ; preds = %if.then
  %7 = load i32* %pos, align 4
  %8 = load i32* %size, align 4
  %add = add nsw i32 %8, 1
  %cmp6 = icmp sle i32 %7, %add
  br i1 %cmp6, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.lhs.true, %if.then
  %9 = load %struct.lua_State** %L.addr, align 8
  %call8 = call i32 @luaL_argerror(%struct.lua_State* %9, i32 1, i8* getelementptr inbounds ([23 x i8]* @.str8736, i32 0, i32 0))
  %tobool = icmp ne i32 %call8, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.lhs.true
  %10 = phi i1 [ true, %land.lhs.true ], [ %tobool, %lor.rhs ]
  %lor.ext = zext i1 %10 to i32
  br label %if.end

if.end:                                           ; preds = %lor.end, %entry
  %11 = load %struct.lua_State** %L.addr, align 8
  %12 = load i32* %pos, align 4
  call void @lua_rawgeti(%struct.lua_State* %11, i32 1, i32 %12)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %13 = load i32* %pos, align 4
  %14 = load i32* %size, align 4
  %cmp9 = icmp slt i32 %13, %14
  br i1 %cmp9, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %15 = load %struct.lua_State** %L.addr, align 8
  %16 = load i32* %pos, align 4
  %add11 = add nsw i32 %16, 1
  call void @lua_rawgeti(%struct.lua_State* %15, i32 1, i32 %add11)
  %17 = load %struct.lua_State** %L.addr, align 8
  %18 = load i32* %pos, align 4
  call void @lua_rawseti(%struct.lua_State* %17, i32 1, i32 %18)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %19 = load i32* %pos, align 4
  %inc = add nsw i32 %19, 1
  store i32 %inc, i32* %pos, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %20 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushnil(%struct.lua_State* %20)
  %21 = load %struct.lua_State** %L.addr, align 8
  %22 = load i32* %pos, align 4
  call void @lua_rawseti(%struct.lua_State* %21, i32 1, i32 %22)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @sort(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %n = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_checktype(%struct.lua_State* %0, i32 1, i32 5)
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @luaL_len(%struct.lua_State* %1, i32 1)
  store i32 %call, i32* %n, align 4
  %2 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_checkstack(%struct.lua_State* %2, i32 40, i8* getelementptr inbounds ([1 x i8]* @.str6734, i32 0, i32 0))
  %3 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i32 @lua_type(%struct.lua_State* %3, i32 2)
  %cmp = icmp sle i32 %call1, 0
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %4 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_checktype(%struct.lua_State* %4, i32 2, i32 6)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %5, i32 2)
  %6 = load %struct.lua_State** %L.addr, align 8
  %7 = load i32* %n, align 4
  call void @auxsort(%struct.lua_State* %6, i32 1, i32 %7)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal void @addfield(%struct.lua_State* %L, %struct.luaL_Buffer* %b, i32 %i) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %b.addr = alloca %struct.luaL_Buffer*, align 8
  %i.addr = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.luaL_Buffer* %b, %struct.luaL_Buffer** %b.addr, align 8
  store i32 %i, i32* %i.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %i.addr, align 4
  call void @lua_rawgeti(%struct.lua_State* %0, i32 1, i32 %1)
  %2 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_isstring(%struct.lua_State* %2, i32 -1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i32 @lua_type(%struct.lua_State* %5, i32 -1)
  %call2 = call i8* @lua_typename(%struct.lua_State* %4, i32 %call1)
  %6 = load i32* %i.addr, align 4
  %call3 = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %3, i8* getelementptr inbounds ([53 x i8]* @.str12740, i32 0, i32 0), i8* %call2, i32 %6)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %7 = load %struct.luaL_Buffer** %b.addr, align 8
  call void @luaL_addvalue(%struct.luaL_Buffer* %7)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @auxsort(%struct.lua_State* %L, i32 %l, i32 %u) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %l.addr = alloca i32, align 4
  %u.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %l, i32* %l.addr, align 4
  store i32 %u, i32* %u.addr, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end52, %entry
  %0 = load i32* %l.addr, align 4
  %1 = load i32* %u.addr, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %while.body, label %while.end53

while.body:                                       ; preds = %while.cond
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load i32* %l.addr, align 4
  call void @lua_rawgeti(%struct.lua_State* %2, i32 1, i32 %3)
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load i32* %u.addr, align 4
  call void @lua_rawgeti(%struct.lua_State* %4, i32 1, i32 %5)
  %6 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @sort_comp(%struct.lua_State* %6, i32 -1, i32 -2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %while.body
  %7 = load %struct.lua_State** %L.addr, align 8
  %8 = load i32* %l.addr, align 4
  %9 = load i32* %u.addr, align 4
  call void @set2(%struct.lua_State* %7, i32 %8, i32 %9)
  br label %if.end

if.else:                                          ; preds = %while.body
  %10 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %10, i32 -3)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %11 = load i32* %u.addr, align 4
  %12 = load i32* %l.addr, align 4
  %sub = sub nsw i32 %11, %12
  %cmp1 = icmp eq i32 %sub, 1
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  br label %while.end53

if.end3:                                          ; preds = %if.end
  %13 = load i32* %l.addr, align 4
  %14 = load i32* %u.addr, align 4
  %add = add nsw i32 %13, %14
  %div = sdiv i32 %add, 2
  store i32 %div, i32* %i, align 4
  %15 = load %struct.lua_State** %L.addr, align 8
  %16 = load i32* %i, align 4
  call void @lua_rawgeti(%struct.lua_State* %15, i32 1, i32 %16)
  %17 = load %struct.lua_State** %L.addr, align 8
  %18 = load i32* %l.addr, align 4
  call void @lua_rawgeti(%struct.lua_State* %17, i32 1, i32 %18)
  %19 = load %struct.lua_State** %L.addr, align 8
  %call4 = call i32 @sort_comp(%struct.lua_State* %19, i32 -2, i32 -1)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.then6, label %if.else7

if.then6:                                         ; preds = %if.end3
  %20 = load %struct.lua_State** %L.addr, align 8
  %21 = load i32* %i, align 4
  %22 = load i32* %l.addr, align 4
  call void @set2(%struct.lua_State* %20, i32 %21, i32 %22)
  br label %if.end13

if.else7:                                         ; preds = %if.end3
  %23 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %23, i32 -2)
  %24 = load %struct.lua_State** %L.addr, align 8
  %25 = load i32* %u.addr, align 4
  call void @lua_rawgeti(%struct.lua_State* %24, i32 1, i32 %25)
  %26 = load %struct.lua_State** %L.addr, align 8
  %call8 = call i32 @sort_comp(%struct.lua_State* %26, i32 -1, i32 -2)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.then10, label %if.else11

if.then10:                                        ; preds = %if.else7
  %27 = load %struct.lua_State** %L.addr, align 8
  %28 = load i32* %i, align 4
  %29 = load i32* %u.addr, align 4
  call void @set2(%struct.lua_State* %27, i32 %28, i32 %29)
  br label %if.end12

if.else11:                                        ; preds = %if.else7
  %30 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %30, i32 -3)
  br label %if.end12

if.end12:                                         ; preds = %if.else11, %if.then10
  br label %if.end13

if.end13:                                         ; preds = %if.end12, %if.then6
  %31 = load i32* %u.addr, align 4
  %32 = load i32* %l.addr, align 4
  %sub14 = sub nsw i32 %31, %32
  %cmp15 = icmp eq i32 %sub14, 2
  br i1 %cmp15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.end13
  br label %while.end53

if.end17:                                         ; preds = %if.end13
  %33 = load %struct.lua_State** %L.addr, align 8
  %34 = load i32* %i, align 4
  call void @lua_rawgeti(%struct.lua_State* %33, i32 1, i32 %34)
  %35 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushvalue(%struct.lua_State* %35, i32 -1)
  %36 = load %struct.lua_State** %L.addr, align 8
  %37 = load i32* %u.addr, align 4
  %sub18 = sub nsw i32 %37, 1
  call void @lua_rawgeti(%struct.lua_State* %36, i32 1, i32 %sub18)
  %38 = load %struct.lua_State** %L.addr, align 8
  %39 = load i32* %i, align 4
  %40 = load i32* %u.addr, align 4
  %sub19 = sub nsw i32 %40, 1
  call void @set2(%struct.lua_State* %38, i32 %39, i32 %sub19)
  %41 = load i32* %l.addr, align 4
  store i32 %41, i32* %i, align 4
  %42 = load i32* %u.addr, align 4
  %sub20 = sub nsw i32 %42, 1
  store i32 %sub20, i32* %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %if.end40, %if.end17
  br label %while.cond21

while.cond21:                                     ; preds = %if.end28, %for.cond
  %43 = load %struct.lua_State** %L.addr, align 8
  %44 = load i32* %i, align 4
  %inc = add nsw i32 %44, 1
  store i32 %inc, i32* %i, align 4
  call void @lua_rawgeti(%struct.lua_State* %43, i32 1, i32 %inc)
  %45 = load %struct.lua_State** %L.addr, align 8
  %call22 = call i32 @sort_comp(%struct.lua_State* %45, i32 -1, i32 -2)
  %tobool23 = icmp ne i32 %call22, 0
  br i1 %tobool23, label %while.body24, label %while.end

while.body24:                                     ; preds = %while.cond21
  %46 = load i32* %i, align 4
  %47 = load i32* %u.addr, align 4
  %cmp25 = icmp sge i32 %46, %47
  br i1 %cmp25, label %if.then26, label %if.end28

if.then26:                                        ; preds = %while.body24
  %48 = load %struct.lua_State** %L.addr, align 8
  %call27 = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %48, i8* getelementptr inbounds ([35 x i8]* @.str7735, i32 0, i32 0))
  br label %if.end28

if.end28:                                         ; preds = %if.then26, %while.body24
  %49 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %49, i32 -2)
  br label %while.cond21

while.end:                                        ; preds = %while.cond21
  br label %while.cond29

while.cond29:                                     ; preds = %if.end36, %while.end
  %50 = load %struct.lua_State** %L.addr, align 8
  %51 = load i32* %j, align 4
  %dec = add nsw i32 %51, -1
  store i32 %dec, i32* %j, align 4
  call void @lua_rawgeti(%struct.lua_State* %50, i32 1, i32 %dec)
  %52 = load %struct.lua_State** %L.addr, align 8
  %call30 = call i32 @sort_comp(%struct.lua_State* %52, i32 -3, i32 -1)
  %tobool31 = icmp ne i32 %call30, 0
  br i1 %tobool31, label %while.body32, label %while.end37

while.body32:                                     ; preds = %while.cond29
  %53 = load i32* %j, align 4
  %54 = load i32* %l.addr, align 4
  %cmp33 = icmp sle i32 %53, %54
  br i1 %cmp33, label %if.then34, label %if.end36

if.then34:                                        ; preds = %while.body32
  %55 = load %struct.lua_State** %L.addr, align 8
  %call35 = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %55, i8* getelementptr inbounds ([35 x i8]* @.str7735, i32 0, i32 0))
  br label %if.end36

if.end36:                                         ; preds = %if.then34, %while.body32
  %56 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %56, i32 -2)
  br label %while.cond29

while.end37:                                      ; preds = %while.cond29
  %57 = load i32* %j, align 4
  %58 = load i32* %i, align 4
  %cmp38 = icmp slt i32 %57, %58
  br i1 %cmp38, label %if.then39, label %if.end40

if.then39:                                        ; preds = %while.end37
  %59 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %59, i32 -4)
  br label %for.end

if.end40:                                         ; preds = %while.end37
  %60 = load %struct.lua_State** %L.addr, align 8
  %61 = load i32* %i, align 4
  %62 = load i32* %j, align 4
  call void @set2(%struct.lua_State* %60, i32 %61, i32 %62)
  br label %for.cond

for.end:                                          ; preds = %if.then39
  %63 = load %struct.lua_State** %L.addr, align 8
  %64 = load i32* %u.addr, align 4
  %sub41 = sub nsw i32 %64, 1
  call void @lua_rawgeti(%struct.lua_State* %63, i32 1, i32 %sub41)
  %65 = load %struct.lua_State** %L.addr, align 8
  %66 = load i32* %i, align 4
  call void @lua_rawgeti(%struct.lua_State* %65, i32 1, i32 %66)
  %67 = load %struct.lua_State** %L.addr, align 8
  %68 = load i32* %u.addr, align 4
  %sub42 = sub nsw i32 %68, 1
  %69 = load i32* %i, align 4
  call void @set2(%struct.lua_State* %67, i32 %sub42, i32 %69)
  %70 = load i32* %i, align 4
  %71 = load i32* %l.addr, align 4
  %sub43 = sub nsw i32 %70, %71
  %72 = load i32* %u.addr, align 4
  %73 = load i32* %i, align 4
  %sub44 = sub nsw i32 %72, %73
  %cmp45 = icmp slt i32 %sub43, %sub44
  br i1 %cmp45, label %if.then46, label %if.else49

if.then46:                                        ; preds = %for.end
  %74 = load i32* %l.addr, align 4
  store i32 %74, i32* %j, align 4
  %75 = load i32* %i, align 4
  %sub47 = sub nsw i32 %75, 1
  store i32 %sub47, i32* %i, align 4
  %76 = load i32* %i, align 4
  %add48 = add nsw i32 %76, 2
  store i32 %add48, i32* %l.addr, align 4
  br label %if.end52

if.else49:                                        ; preds = %for.end
  %77 = load i32* %i, align 4
  %add50 = add nsw i32 %77, 1
  store i32 %add50, i32* %j, align 4
  %78 = load i32* %u.addr, align 4
  store i32 %78, i32* %i, align 4
  %79 = load i32* %j, align 4
  %sub51 = sub nsw i32 %79, 2
  store i32 %sub51, i32* %u.addr, align 4
  br label %if.end52

if.end52:                                         ; preds = %if.else49, %if.then46
  %80 = load %struct.lua_State** %L.addr, align 8
  %81 = load i32* %j, align 4
  %82 = load i32* %i, align 4
  call void @auxsort(%struct.lua_State* %80, i32 %81, i32 %82)
  br label %while.cond

while.end53:                                      ; preds = %if.then16, %if.then2, %while.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @sort_comp(%struct.lua_State* %L, i32 %a, i32 %b) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %res = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %a, i32* %a.addr, align 4
  store i32 %b, i32* %b.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_type(%struct.lua_State* %0, i32 2)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %1 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushvalue(%struct.lua_State* %1, i32 2)
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load i32* %a.addr, align 4
  %sub = sub nsw i32 %3, 1
  call void @lua_pushvalue(%struct.lua_State* %2, i32 %sub)
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load i32* %b.addr, align 4
  %sub1 = sub nsw i32 %5, 2
  call void @lua_pushvalue(%struct.lua_State* %4, i32 %sub1)
  %6 = load %struct.lua_State** %L.addr, align 8
  call void @lua_callk(%struct.lua_State* %6, i32 2, i32 1, i32 0, i32 (%struct.lua_State*)* null)
  %7 = load %struct.lua_State** %L.addr, align 8
  %call2 = call i32 @lua_toboolean(%struct.lua_State* %7, i32 -1)
  store i32 %call2, i32* %res, align 4
  %8 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %8, i32 -2)
  %9 = load i32* %res, align 4
  store i32 %9, i32* %retval
  br label %return

if.else:                                          ; preds = %entry
  %10 = load %struct.lua_State** %L.addr, align 8
  %11 = load i32* %a.addr, align 4
  %12 = load i32* %b.addr, align 4
  %call3 = call i32 @lua_compare(%struct.lua_State* %10, i32 %11, i32 %12, i32 1)
  store i32 %call3, i32* %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %13 = load i32* %retval
  ret i32 %13
}

; Function Attrs: nounwind uwtable
define internal void @set2(%struct.lua_State* %L, i32 %i, i32 %j) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %i.addr = alloca i32, align 4
  %j.addr = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %i, i32* %i.addr, align 4
  store i32 %j, i32* %j.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %i.addr, align 4
  call void @lua_rawseti(%struct.lua_State* %0, i32 1, i32 %1)
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load i32* %j.addr, align 4
  call void @lua_rawseti(%struct.lua_State* %2, i32 1, i32 %3)
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @luaT_init(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %i = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32* %i, align 4
  %cmp = icmp slt i32 %0, 17
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load i32* %i, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [17 x i8*]* @luaT_init.luaT_eventname, i32 0, i64 %idxprom
  %3 = load i8** %arrayidx, align 8
  %call = call %union.TString* bitcast (%union.TString.367* (%struct.lua_State.364*, i8*)* @luaS_new to %union.TString* (%struct.lua_State*, i8*)*)(%struct.lua_State* %1, i8* %3)
  %4 = load i32* %i, align 4
  %idxprom1 = sext i32 %4 to i64
  %5 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %5, i32 0, i32 5
  %6 = load %struct.global_State** %l_G, align 8
  %tmname = getelementptr inbounds %struct.global_State* %6, i32 0, i32 33
  %arrayidx2 = getelementptr inbounds [17 x %union.TString*]* %tmname, i32 0, i64 %idxprom1
  store %union.TString* %call, %union.TString** %arrayidx2, align 8
  %7 = load i32* %i, align 4
  %idxprom3 = sext i32 %7 to i64
  %8 = load %struct.lua_State** %L.addr, align 8
  %l_G4 = getelementptr inbounds %struct.lua_State* %8, i32 0, i32 5
  %9 = load %struct.global_State** %l_G4, align 8
  %tmname5 = getelementptr inbounds %struct.global_State* %9, i32 0, i32 33
  %arrayidx6 = getelementptr inbounds [17 x %union.TString*]* %tmname5, i32 0, i64 %idxprom3
  %10 = load %union.TString** %arrayidx6, align 8
  %tsv = bitcast %union.TString* %10 to %struct.anon.0*
  %marked = getelementptr inbounds %struct.anon.0* %tsv, i32 0, i32 2
  %11 = load i8* %marked, align 1
  %conv = zext i8 %11 to i32
  %or = or i32 %conv, 32
  %conv7 = trunc i32 %or to i8
  store i8 %conv7, i8* %marked, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %12 = load i32* %i, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define hidden %struct.lua_TValue* @luaT_gettm(%struct.Table* %events, i32 %event, %union.TString* %ename) #0 {
entry:
  %retval = alloca %struct.lua_TValue*, align 8
  %events.addr = alloca %struct.Table*, align 8
  %event.addr = alloca i32, align 4
  %ename.addr = alloca %union.TString*, align 8
  %tm = alloca %struct.lua_TValue*, align 8
  store %struct.Table* %events, %struct.Table** %events.addr, align 8
  store i32 %event, i32* %event.addr, align 4
  store %union.TString* %ename, %union.TString** %ename.addr, align 8
  %0 = load %struct.Table** %events.addr, align 8
  %1 = load %union.TString** %ename.addr, align 8
  %call = call %struct.lua_TValue* @luaH_getstr(%struct.Table* %0, %union.TString* %1)
  store %struct.lua_TValue* %call, %struct.lua_TValue** %tm, align 8
  %2 = load %struct.lua_TValue** %tm, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %2, i32 0, i32 1
  %3 = load i32* %tt_, align 4
  %cmp = icmp eq i32 %3, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %4 = load i32* %event.addr, align 4
  %shl = shl i32 1, %4
  %conv = trunc i32 %shl to i8
  %conv1 = zext i8 %conv to i32
  %5 = load %struct.Table** %events.addr, align 8
  %flags = getelementptr inbounds %struct.Table* %5, i32 0, i32 3
  %6 = load i8* %flags, align 1
  %conv2 = zext i8 %6 to i32
  %or = or i32 %conv2, %conv1
  %conv3 = trunc i32 %or to i8
  store i8 %conv3, i8* %flags, align 1
  store %struct.lua_TValue* null, %struct.lua_TValue** %retval
  br label %return

if.else:                                          ; preds = %entry
  %7 = load %struct.lua_TValue** %tm, align 8
  store %struct.lua_TValue* %7, %struct.lua_TValue** %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %8 = load %struct.lua_TValue** %retval
  ret %struct.lua_TValue* %8
}

; Function Attrs: nounwind uwtable
define hidden %struct.lua_TValue* @luaT_gettmbyobj(%struct.lua_State* %L, %struct.lua_TValue* %o, i32 %event) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %o.addr = alloca %struct.lua_TValue*, align 8
  %event.addr = alloca i32, align 4
  %mt = alloca %struct.Table*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.lua_TValue* %o, %struct.lua_TValue** %o.addr, align 8
  store i32 %event, i32* %event.addr, align 4
  %0 = load %struct.lua_TValue** %o.addr, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue* %0, i32 0, i32 1
  %1 = load i32* %tt_, align 4
  %and = and i32 %1, 15
  switch i32 %and, label %sw.default [
    i32 5, label %sw.bb
    i32 7, label %sw.bb1
  ]

sw.bb:                                            ; preds = %entry
  %2 = load %struct.lua_TValue** %o.addr, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue* %2, i32 0, i32 0
  %gc = bitcast %union.Value* %value_ to %union.GCObject**
  %3 = load %union.GCObject** %gc, align 8
  %h = bitcast %union.GCObject* %3 to %struct.Table*
  %metatable = getelementptr inbounds %struct.Table* %h, i32 0, i32 5
  %4 = load %struct.Table** %metatable, align 8
  store %struct.Table* %4, %struct.Table** %mt, align 8
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  %5 = load %struct.lua_TValue** %o.addr, align 8
  %value_2 = getelementptr inbounds %struct.lua_TValue* %5, i32 0, i32 0
  %gc3 = bitcast %union.Value* %value_2 to %union.GCObject**
  %6 = load %union.GCObject** %gc3, align 8
  %u = bitcast %union.GCObject* %6 to %union.Udata*
  %uv = bitcast %union.Udata* %u to %struct.anon.5*
  %metatable4 = getelementptr inbounds %struct.anon.5* %uv, i32 0, i32 3
  %7 = load %struct.Table** %metatable4, align 8
  store %struct.Table* %7, %struct.Table** %mt, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %8 = load %struct.lua_TValue** %o.addr, align 8
  %tt_5 = getelementptr inbounds %struct.lua_TValue* %8, i32 0, i32 1
  %9 = load i32* %tt_5, align 4
  %and6 = and i32 %9, 15
  %idxprom = sext i32 %and6 to i64
  %10 = load %struct.lua_State** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State* %10, i32 0, i32 5
  %11 = load %struct.global_State** %l_G, align 8
  %mt7 = getelementptr inbounds %struct.global_State* %11, i32 0, i32 34
  %arrayidx = getelementptr inbounds [9 x %struct.Table*]* %mt7, i32 0, i64 %idxprom
  %12 = load %struct.Table** %arrayidx, align 8
  store %struct.Table* %12, %struct.Table** %mt, align 8
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb1, %sw.bb
  %13 = load %struct.Table** %mt, align 8
  %tobool = icmp ne %struct.Table* %13, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %sw.epilog
  %14 = load %struct.Table** %mt, align 8
  %15 = load i32* %event.addr, align 4
  %idxprom8 = zext i32 %15 to i64
  %16 = load %struct.lua_State** %L.addr, align 8
  %l_G9 = getelementptr inbounds %struct.lua_State* %16, i32 0, i32 5
  %17 = load %struct.global_State** %l_G9, align 8
  %tmname = getelementptr inbounds %struct.global_State* %17, i32 0, i32 33
  %arrayidx10 = getelementptr inbounds [17 x %union.TString*]* %tmname, i32 0, i64 %idxprom8
  %18 = load %union.TString** %arrayidx10, align 8
  %call = call %struct.lua_TValue* @luaH_getstr(%struct.Table* %14, %union.TString* %18)
  br label %cond.end

cond.false:                                       ; preds = %sw.epilog
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.lua_TValue* [ %call, %cond.true ], [ bitcast ({ %union.Value.281, i32, [4 x i8] }* @luaO_nilobject_ to %struct.lua_TValue*), %cond.false ]
  ret %struct.lua_TValue* %cond
}

; Function Attrs: nounwind uwtable
define i32 @main(i32 %argc, i8** %argv) #0 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca i8**, align 8
  %status = alloca i32, align 4
  %result = alloca i32, align 4
  %L = alloca %struct.lua_State*, align 8
  store i32 0, i32* %retval
  store i32 %argc, i32* %argc.addr, align 4
  store i8** %argv, i8*** %argv.addr, align 8
  %call = call %struct.lua_State* @luaL_newstate()
  store %struct.lua_State* %call, %struct.lua_State** %L, align 8
  %0 = load %struct.lua_State** %L, align 8
  %cmp = icmp eq %struct.lua_State* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i8*** %argv.addr, align 8
  %arrayidx = getelementptr inbounds i8** %1, i64 0
  %2 = load i8** %arrayidx, align 8
  call void @l_message(i8* %2, i8* getelementptr inbounds ([39 x i8]* @.str778, i32 0, i32 0))
  store i32 1, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %3 = load %struct.lua_State** %L, align 8
  call void @lua_pushcclosure(%struct.lua_State* %3, i32 (%struct.lua_State*)* @pmain, i32 0)
  %4 = load %struct.lua_State** %L, align 8
  %5 = load i32* %argc.addr, align 4
  %conv = sext i32 %5 to i64
  call void @lua_pushinteger(%struct.lua_State* %4, i64 %conv)
  %6 = load %struct.lua_State** %L, align 8
  %7 = load i8*** %argv.addr, align 8
  %8 = bitcast i8** %7 to i8*
  call void @lua_pushlightuserdata(%struct.lua_State* %6, i8* %8)
  %9 = load %struct.lua_State** %L, align 8
  %call1 = call i32 @lua_pcallk(%struct.lua_State* %9, i32 2, i32 1, i32 0, i32 0, i32 (%struct.lua_State*)* null)
  store i32 %call1, i32* %status, align 4
  %10 = load %struct.lua_State** %L, align 8
  %call2 = call i32 @lua_toboolean(%struct.lua_State* %10, i32 -1)
  store i32 %call2, i32* %result, align 4
  %11 = load %struct.lua_State** %L, align 8
  %12 = load i32* %status, align 4
  call void @finalreport(%struct.lua_State* %11, i32 %12)
  %13 = load %struct.lua_State** %L, align 8
  call void bitcast (void (%struct.lua_State.343*)* @lua_close to void (%struct.lua_State*)*)(%struct.lua_State* %13)
  %14 = load i32* %result, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end
  %15 = load i32* %status, align 4
  %cmp3 = icmp eq i32 %15, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end
  %16 = phi i1 [ false, %if.end ], [ %cmp3, %land.rhs ]
  %cond = select i1 %16, i32 0, i32 1
  store i32 %cond, i32* %retval
  br label %return

return:                                           ; preds = %land.end, %if.then
  %17 = load i32* %retval
  ret i32 %17
}

; Function Attrs: nounwind
declare i32 @isatty(i32) #4

; Function Attrs: nounwind
declare void (i32)* @signal(i32, void (i32)*) #4

declare void @add_history(i8*) #5

declare i8* @readline(i8*) #5

; Function Attrs: nounwind uwtable
define internal void @l_message(i8* %pname, i8* %msg) #0 {
entry:
  %pname.addr = alloca i8*, align 8
  %msg.addr = alloca i8*, align 8
  store i8* %pname, i8** %pname.addr, align 8
  store i8* %msg, i8** %msg.addr, align 8
  %0 = load i8** %pname.addr, align 8
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct._IO_FILE** @stderr, align 8
  %2 = load i8** %pname.addr, align 8
  %call = call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %1, i8* getelementptr inbounds ([5 x i8]* @.str27806, i32 0, i32 0), i8* %2)
  %3 = load %struct._IO_FILE** @stderr, align 8
  %call1 = call i32 @fflush(%struct._IO_FILE* %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load %struct._IO_FILE** @stderr, align 8
  %5 = load i8** %msg.addr, align 8
  %call2 = call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %4, i8* getelementptr inbounds ([4 x i8]* @.str31810, i32 0, i32 0), i8* %5)
  %6 = load %struct._IO_FILE** @stderr, align 8
  %call3 = call i32 @fflush(%struct._IO_FILE* %6)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @pmain(%struct.lua_State* %L) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %argc = alloca i32, align 4
  %argv = alloca i8**, align 8
  %script = alloca i32, align 4
  %args = alloca [4 x i32], align 16
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i64 @lua_tointegerx(%struct.lua_State* %0, i32 1, i32* null)
  %conv = trunc i64 %call to i32
  store i32 %conv, i32* %argc, align 4
  %1 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i8* @lua_touserdata(%struct.lua_State* %1, i32 2)
  %2 = bitcast i8* %call1 to i8**
  store i8** %2, i8*** %argv, align 8
  %arrayidx = getelementptr inbounds [4 x i32]* %args, i32 0, i64 3
  store i32 0, i32* %arrayidx, align 4
  %arrayidx2 = getelementptr inbounds [4 x i32]* %args, i32 0, i64 2
  store i32 0, i32* %arrayidx2, align 4
  %arrayidx3 = getelementptr inbounds [4 x i32]* %args, i32 0, i64 1
  store i32 0, i32* %arrayidx3, align 4
  %arrayidx4 = getelementptr inbounds [4 x i32]* %args, i32 0, i64 0
  store i32 0, i32* %arrayidx4, align 4
  %3 = load i8*** %argv, align 8
  %arrayidx5 = getelementptr inbounds i8** %3, i64 0
  %4 = load i8** %arrayidx5, align 8
  %tobool = icmp ne i8* %4, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %5 = load i8*** %argv, align 8
  %arrayidx6 = getelementptr inbounds i8** %5, i64 0
  %6 = load i8** %arrayidx6, align 8
  %arrayidx7 = getelementptr inbounds i8* %6, i64 0
  %7 = load i8* %arrayidx7, align 1
  %conv8 = sext i8 %7 to i32
  %tobool9 = icmp ne i32 %conv8, 0
  br i1 %tobool9, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %8 = load i8*** %argv, align 8
  %arrayidx10 = getelementptr inbounds i8** %8, i64 0
  %9 = load i8** %arrayidx10, align 8
  store i8* %9, i8** @progname, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %10 = load i8*** %argv, align 8
  %arraydecay = getelementptr inbounds [4 x i32]* %args, i32 0, i32 0
  %call11 = call i32 @collectargs(i8** %10, i32* %arraydecay)
  store i32 %call11, i32* %script, align 4
  %11 = load i32* %script, align 4
  %cmp = icmp slt i32 %11, 0
  br i1 %cmp, label %if.then13, label %if.end15

if.then13:                                        ; preds = %if.end
  %12 = load i32* %script, align 4
  %sub = sub nsw i32 0, %12
  %idxprom = sext i32 %sub to i64
  %13 = load i8*** %argv, align 8
  %arrayidx14 = getelementptr inbounds i8** %13, i64 %idxprom
  %14 = load i8** %arrayidx14, align 8
  call void @print_usage(i8* %14)
  store i32 0, i32* %retval
  br label %return

if.end15:                                         ; preds = %if.end
  %arrayidx16 = getelementptr inbounds [4 x i32]* %args, i32 0, i64 1
  %15 = load i32* %arrayidx16, align 4
  %tobool17 = icmp ne i32 %15, 0
  br i1 %tobool17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end15
  call void @print_version()
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.end15
  %arrayidx20 = getelementptr inbounds [4 x i32]* %args, i32 0, i64 3
  %16 = load i32* %arrayidx20, align 4
  %tobool21 = icmp ne i32 %16, 0
  br i1 %tobool21, label %if.then22, label %if.end23

if.then22:                                        ; preds = %if.end19
  %17 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushboolean(%struct.lua_State* %17, i32 1)
  %18 = load %struct.lua_State** %L.addr, align 8
  call void @lua_setfield(%struct.lua_State* %18, i32 -1001000, i8* getelementptr inbounds ([10 x i8]* @.str3782, i32 0, i32 0))
  br label %if.end23

if.end23:                                         ; preds = %if.then22, %if.end19
  %19 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_checkversion_(%struct.lua_State* %19, double 5.020000e+02)
  %20 = load %struct.lua_State** %L.addr, align 8
  %call24 = call i32 @lua_gc(%struct.lua_State* %20, i32 0, i32 0)
  %21 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_openlibs(%struct.lua_State* %21)
  %22 = load %struct.lua_State** %L.addr, align 8
  %call25 = call i32 @lua_gc(%struct.lua_State* %22, i32 1, i32 0)
  %arrayidx26 = getelementptr inbounds [4 x i32]* %args, i32 0, i64 3
  %23 = load i32* %arrayidx26, align 4
  %tobool27 = icmp ne i32 %23, 0
  br i1 %tobool27, label %if.end33, label %land.lhs.true28

land.lhs.true28:                                  ; preds = %if.end23
  %24 = load %struct.lua_State** %L.addr, align 8
  %call29 = call i32 @handle_luainit(%struct.lua_State* %24)
  %cmp30 = icmp ne i32 %call29, 0
  br i1 %cmp30, label %if.then32, label %if.end33

if.then32:                                        ; preds = %land.lhs.true28
  store i32 0, i32* %retval
  br label %return

if.end33:                                         ; preds = %land.lhs.true28, %if.end23
  %25 = load %struct.lua_State** %L.addr, align 8
  %26 = load i8*** %argv, align 8
  %27 = load i32* %script, align 4
  %cmp34 = icmp sgt i32 %27, 0
  br i1 %cmp34, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end33
  %28 = load i32* %script, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end33
  %29 = load i32* %argc, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %28, %cond.true ], [ %29, %cond.false ]
  %call36 = call i32 @runargs(%struct.lua_State* %25, i8** %26, i32 %cond)
  %tobool37 = icmp ne i32 %call36, 0
  br i1 %tobool37, label %if.end39, label %if.then38

if.then38:                                        ; preds = %cond.end
  store i32 0, i32* %retval
  br label %return

if.end39:                                         ; preds = %cond.end
  %30 = load i32* %script, align 4
  %tobool40 = icmp ne i32 %30, 0
  br i1 %tobool40, label %land.lhs.true41, label %if.end46

land.lhs.true41:                                  ; preds = %if.end39
  %31 = load %struct.lua_State** %L.addr, align 8
  %32 = load i8*** %argv, align 8
  %33 = load i32* %script, align 4
  %call42 = call i32 @handle_script(%struct.lua_State* %31, i8** %32, i32 %33)
  %cmp43 = icmp ne i32 %call42, 0
  br i1 %cmp43, label %if.then45, label %if.end46

if.then45:                                        ; preds = %land.lhs.true41
  store i32 0, i32* %retval
  br label %return

if.end46:                                         ; preds = %land.lhs.true41, %if.end39
  %arrayidx47 = getelementptr inbounds [4 x i32]* %args, i32 0, i64 0
  %34 = load i32* %arrayidx47, align 4
  %tobool48 = icmp ne i32 %34, 0
  br i1 %tobool48, label %if.then49, label %if.else

if.then49:                                        ; preds = %if.end46
  %35 = load %struct.lua_State** %L.addr, align 8
  call void @dotty(%struct.lua_State* %35)
  br label %if.end66

if.else:                                          ; preds = %if.end46
  %36 = load i32* %script, align 4
  %cmp50 = icmp eq i32 %36, 0
  br i1 %cmp50, label %land.lhs.true52, label %if.end65

land.lhs.true52:                                  ; preds = %if.else
  %arrayidx53 = getelementptr inbounds [4 x i32]* %args, i32 0, i64 2
  %37 = load i32* %arrayidx53, align 4
  %tobool54 = icmp ne i32 %37, 0
  br i1 %tobool54, label %if.end65, label %land.lhs.true55

land.lhs.true55:                                  ; preds = %land.lhs.true52
  %arrayidx56 = getelementptr inbounds [4 x i32]* %args, i32 0, i64 1
  %38 = load i32* %arrayidx56, align 4
  %tobool57 = icmp ne i32 %38, 0
  br i1 %tobool57, label %if.end65, label %if.then58

if.then58:                                        ; preds = %land.lhs.true55
  %call59 = call i32 @isatty(i32 0) #1
  %tobool60 = icmp ne i32 %call59, 0
  br i1 %tobool60, label %if.then61, label %if.else62

if.then61:                                        ; preds = %if.then58
  call void @print_version()
  %39 = load %struct.lua_State** %L.addr, align 8
  call void @dotty(%struct.lua_State* %39)
  br label %if.end64

if.else62:                                        ; preds = %if.then58
  %40 = load %struct.lua_State** %L.addr, align 8
  %call63 = call i32 @dofile(%struct.lua_State* %40, i8* null)
  br label %if.end64

if.end64:                                         ; preds = %if.else62, %if.then61
  br label %if.end65

if.end65:                                         ; preds = %if.end64, %land.lhs.true55, %land.lhs.true52, %if.else
  br label %if.end66

if.end66:                                         ; preds = %if.end65, %if.then49
  %41 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushboolean(%struct.lua_State* %41, i32 1)
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %if.end66, %if.then45, %if.then38, %if.then32, %if.then13
  %42 = load i32* %retval
  ret i32 %42
}

; Function Attrs: nounwind uwtable
define internal void @finalreport(%struct.lua_State* %L, i32 %status) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %status.addr = alloca i32, align 4
  %msg = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %status, i32* %status.addr, align 4
  %0 = load i32* %status.addr, align 4
  %cmp = icmp ne i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end5

if.then:                                          ; preds = %entry
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_type(%struct.lua_State* %1, i32 -1)
  %cmp1 = icmp eq i32 %call, 4
  br i1 %cmp1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  %2 = load %struct.lua_State** %L.addr, align 8
  %call2 = call i8* @lua_tolstring(%struct.lua_State* %2, i32 -1, i64* null)
  br label %cond.end

cond.false:                                       ; preds = %if.then
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %call2, %cond.true ], [ null, %cond.false ]
  store i8* %cond, i8** %msg, align 8
  %3 = load i8** %msg, align 8
  %cmp3 = icmp eq i8* %3, null
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %cond.end
  store i8* getelementptr inbounds ([31 x i8]* @.str1779, i32 0, i32 0), i8** %msg, align 8
  br label %if.end

if.end:                                           ; preds = %if.then4, %cond.end
  %4 = load i8** @progname, align 8
  %5 = load i8** %msg, align 8
  call void @l_message(i8* %4, i8* %5)
  %6 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %6, i32 -2)
  br label %if.end5

if.end5:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @collectargs(i8** %argv, i32* %args) #0 {
entry:
  %retval = alloca i32, align 4
  %argv.addr = alloca i8**, align 8
  %args.addr = alloca i32*, align 8
  %i = alloca i32, align 4
  store i8** %argv, i8*** %argv.addr, align 8
  store i32* %args, i32** %args.addr, align 8
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32* %i, align 4
  %idxprom = sext i32 %0 to i64
  %1 = load i8*** %argv.addr, align 8
  %arrayidx = getelementptr inbounds i8** %1, i64 %idxprom
  %2 = load i8** %arrayidx, align 8
  %cmp = icmp ne i8* %2, null
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i32* %i, align 4
  %idxprom1 = sext i32 %3 to i64
  %4 = load i8*** %argv.addr, align 8
  %arrayidx2 = getelementptr inbounds i8** %4, i64 %idxprom1
  %5 = load i8** %arrayidx2, align 8
  %arrayidx3 = getelementptr inbounds i8* %5, i64 0
  %6 = load i8* %arrayidx3, align 1
  %conv = sext i8 %6 to i32
  %cmp4 = icmp ne i32 %conv, 45
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %7 = load i32* %i, align 4
  store i32 %7, i32* %retval
  br label %return

if.end:                                           ; preds = %for.body
  %8 = load i32* %i, align 4
  %idxprom6 = sext i32 %8 to i64
  %9 = load i8*** %argv.addr, align 8
  %arrayidx7 = getelementptr inbounds i8** %9, i64 %idxprom6
  %10 = load i8** %arrayidx7, align 8
  %arrayidx8 = getelementptr inbounds i8* %10, i64 1
  %11 = load i8* %arrayidx8, align 1
  %conv9 = sext i8 %11 to i32
  switch i32 %conv9, label %sw.default [
    i32 45, label %sw.bb
    i32 0, label %sw.bb23
    i32 69, label %sw.bb24
    i32 105, label %sw.bb26
    i32 118, label %sw.bb36
    i32 101, label %sw.bb46
    i32 108, label %sw.bb48
  ]

sw.bb:                                            ; preds = %if.end
  %12 = load i32* %i, align 4
  %idxprom10 = sext i32 %12 to i64
  %13 = load i8*** %argv.addr, align 8
  %arrayidx11 = getelementptr inbounds i8** %13, i64 %idxprom10
  %14 = load i8** %arrayidx11, align 8
  %arrayidx12 = getelementptr inbounds i8* %14, i64 2
  %15 = load i8* %arrayidx12, align 1
  %conv13 = sext i8 %15 to i32
  %cmp14 = icmp ne i32 %conv13, 0
  br i1 %cmp14, label %if.then16, label %if.end17

if.then16:                                        ; preds = %sw.bb
  store i32 -1, i32* %retval
  br label %return

if.end17:                                         ; preds = %sw.bb
  %16 = load i32* %i, align 4
  %add = add nsw i32 %16, 1
  %idxprom18 = sext i32 %add to i64
  %17 = load i8*** %argv.addr, align 8
  %arrayidx19 = getelementptr inbounds i8** %17, i64 %idxprom18
  %18 = load i8** %arrayidx19, align 8
  %cmp20 = icmp ne i8* %18, null
  br i1 %cmp20, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end17
  %19 = load i32* %i, align 4
  %add22 = add nsw i32 %19, 1
  br label %cond.end

cond.false:                                       ; preds = %if.end17
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %add22, %cond.true ], [ 0, %cond.false ]
  store i32 %cond, i32* %retval
  br label %return

sw.bb23:                                          ; preds = %if.end
  %20 = load i32* %i, align 4
  store i32 %20, i32* %retval
  br label %return

sw.bb24:                                          ; preds = %if.end
  %21 = load i32** %args.addr, align 8
  %arrayidx25 = getelementptr inbounds i32* %21, i64 3
  store i32 1, i32* %arrayidx25, align 4
  br label %sw.epilog

sw.bb26:                                          ; preds = %if.end
  %22 = load i32* %i, align 4
  %idxprom27 = sext i32 %22 to i64
  %23 = load i8*** %argv.addr, align 8
  %arrayidx28 = getelementptr inbounds i8** %23, i64 %idxprom27
  %24 = load i8** %arrayidx28, align 8
  %arrayidx29 = getelementptr inbounds i8* %24, i64 2
  %25 = load i8* %arrayidx29, align 1
  %conv30 = sext i8 %25 to i32
  %cmp31 = icmp ne i32 %conv30, 0
  br i1 %cmp31, label %if.then33, label %if.end34

if.then33:                                        ; preds = %sw.bb26
  store i32 -1, i32* %retval
  br label %return

if.end34:                                         ; preds = %sw.bb26
  %26 = load i32** %args.addr, align 8
  %arrayidx35 = getelementptr inbounds i32* %26, i64 0
  store i32 1, i32* %arrayidx35, align 4
  br label %sw.bb36

sw.bb36:                                          ; preds = %if.end34, %if.end
  %27 = load i32* %i, align 4
  %idxprom37 = sext i32 %27 to i64
  %28 = load i8*** %argv.addr, align 8
  %arrayidx38 = getelementptr inbounds i8** %28, i64 %idxprom37
  %29 = load i8** %arrayidx38, align 8
  %arrayidx39 = getelementptr inbounds i8* %29, i64 2
  %30 = load i8* %arrayidx39, align 1
  %conv40 = sext i8 %30 to i32
  %cmp41 = icmp ne i32 %conv40, 0
  br i1 %cmp41, label %if.then43, label %if.end44

if.then43:                                        ; preds = %sw.bb36
  store i32 -1, i32* %retval
  br label %return

if.end44:                                         ; preds = %sw.bb36
  %31 = load i32** %args.addr, align 8
  %arrayidx45 = getelementptr inbounds i32* %31, i64 1
  store i32 1, i32* %arrayidx45, align 4
  br label %sw.epilog

sw.bb46:                                          ; preds = %if.end
  %32 = load i32** %args.addr, align 8
  %arrayidx47 = getelementptr inbounds i32* %32, i64 2
  store i32 1, i32* %arrayidx47, align 4
  br label %sw.bb48

sw.bb48:                                          ; preds = %sw.bb46, %if.end
  %33 = load i32* %i, align 4
  %idxprom49 = sext i32 %33 to i64
  %34 = load i8*** %argv.addr, align 8
  %arrayidx50 = getelementptr inbounds i8** %34, i64 %idxprom49
  %35 = load i8** %arrayidx50, align 8
  %arrayidx51 = getelementptr inbounds i8* %35, i64 2
  %36 = load i8* %arrayidx51, align 1
  %conv52 = sext i8 %36 to i32
  %cmp53 = icmp eq i32 %conv52, 0
  br i1 %cmp53, label %if.then55, label %if.end69

if.then55:                                        ; preds = %sw.bb48
  %37 = load i32* %i, align 4
  %inc = add nsw i32 %37, 1
  store i32 %inc, i32* %i, align 4
  %38 = load i32* %i, align 4
  %idxprom56 = sext i32 %38 to i64
  %39 = load i8*** %argv.addr, align 8
  %arrayidx57 = getelementptr inbounds i8** %39, i64 %idxprom56
  %40 = load i8** %arrayidx57, align 8
  %cmp58 = icmp eq i8* %40, null
  br i1 %cmp58, label %if.then66, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then55
  %41 = load i32* %i, align 4
  %idxprom60 = sext i32 %41 to i64
  %42 = load i8*** %argv.addr, align 8
  %arrayidx61 = getelementptr inbounds i8** %42, i64 %idxprom60
  %43 = load i8** %arrayidx61, align 8
  %arrayidx62 = getelementptr inbounds i8* %43, i64 0
  %44 = load i8* %arrayidx62, align 1
  %conv63 = sext i8 %44 to i32
  %cmp64 = icmp eq i32 %conv63, 45
  br i1 %cmp64, label %if.then66, label %if.end68

if.then66:                                        ; preds = %lor.lhs.false, %if.then55
  %45 = load i32* %i, align 4
  %sub = sub nsw i32 %45, 1
  %sub67 = sub nsw i32 0, %sub
  store i32 %sub67, i32* %retval
  br label %return

if.end68:                                         ; preds = %lor.lhs.false
  br label %if.end69

if.end69:                                         ; preds = %if.end68, %sw.bb48
  br label %sw.epilog

sw.default:                                       ; preds = %if.end
  %46 = load i32* %i, align 4
  %sub70 = sub nsw i32 0, %46
  store i32 %sub70, i32* %retval
  br label %return

sw.epilog:                                        ; preds = %if.end69, %if.end44, %sw.bb24
  br label %for.inc

for.inc:                                          ; preds = %sw.epilog
  %47 = load i32* %i, align 4
  %inc71 = add nsw i32 %47, 1
  store i32 %inc71, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %for.end, %sw.default, %if.then66, %if.then43, %if.then33, %sw.bb23, %cond.end, %if.then16, %if.then
  %48 = load i32* %retval
  ret i32 %48
}

; Function Attrs: nounwind uwtable
define internal void @print_usage(i8* %badoption) #0 {
entry:
  %badoption.addr = alloca i8*, align 8
  store i8* %badoption, i8** %badoption.addr, align 8
  %0 = load %struct._IO_FILE** @stderr, align 8
  %1 = load i8** @progname, align 8
  %call = call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %0, i8* getelementptr inbounds ([5 x i8]* @.str27806, i32 0, i32 0), i8* %1)
  %2 = load %struct._IO_FILE** @stderr, align 8
  %call1 = call i32 @fflush(%struct._IO_FILE* %2)
  %3 = load i8** %badoption.addr, align 8
  %arrayidx = getelementptr inbounds i8* %3, i64 1
  %4 = load i8* %arrayidx, align 1
  %conv = sext i8 %4 to i32
  %cmp = icmp eq i32 %conv, 101
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %5 = load i8** %badoption.addr, align 8
  %arrayidx3 = getelementptr inbounds i8* %5, i64 1
  %6 = load i8* %arrayidx3, align 1
  %conv4 = sext i8 %6 to i32
  %cmp5 = icmp eq i32 %conv4, 108
  br i1 %cmp5, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  %7 = load %struct._IO_FILE** @stderr, align 8
  %8 = load i8** %badoption.addr, align 8
  %call7 = call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %7, i8* getelementptr inbounds ([21 x i8]* @.str28807, i32 0, i32 0), i8* %8)
  %9 = load %struct._IO_FILE** @stderr, align 8
  %call8 = call i32 @fflush(%struct._IO_FILE* %9)
  br label %if.end

if.else:                                          ; preds = %lor.lhs.false
  %10 = load %struct._IO_FILE** @stderr, align 8
  %11 = load i8** %badoption.addr, align 8
  %call9 = call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %10, i8* getelementptr inbounds ([26 x i8]* @.str29808, i32 0, i32 0), i8* %11)
  %12 = load %struct._IO_FILE** @stderr, align 8
  %call10 = call i32 @fflush(%struct._IO_FILE* %12)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %13 = load %struct._IO_FILE** @stderr, align 8
  %14 = load i8** @progname, align 8
  %call11 = call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %13, i8* getelementptr inbounds ([346 x i8]* @.str30809, i32 0, i32 0), i8* %14)
  %15 = load %struct._IO_FILE** @stderr, align 8
  %call12 = call i32 @fflush(%struct._IO_FILE* %15)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @print_version() #0 {
entry:
  %0 = load %struct._IO_FILE** @stdout, align 8
  %call = call i64 @fwrite(i8* getelementptr inbounds ([52 x i8]* @.str26805, i32 0, i32 0), i64 1, i64 51, %struct._IO_FILE* %0)
  %1 = load %struct._IO_FILE** @stdout, align 8
  %call1 = call i64 @fwrite(i8* getelementptr inbounds ([2 x i8]* @.str10789, i32 0, i32 0), i64 1, i64 1, %struct._IO_FILE* %1)
  %2 = load %struct._IO_FILE** @stdout, align 8
  %call2 = call i32 @fflush(%struct._IO_FILE* %2)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @handle_luainit(%struct.lua_State* %L) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %name = alloca i8*, align 8
  %init = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* getelementptr inbounds ([14 x i8]* @.str24803, i32 0, i32 0), i8** %name, align 8
  %0 = load i8** %name, align 8
  %add.ptr = getelementptr inbounds i8* %0, i64 1
  %call = call i8* @getenv(i8* %add.ptr) #1
  store i8* %call, i8** %init, align 8
  %1 = load i8** %init, align 8
  %cmp = icmp eq i8* %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i8* getelementptr inbounds ([10 x i8]* @.str25804, i32 0, i32 0), i8** %name, align 8
  %2 = load i8** %name, align 8
  %add.ptr1 = getelementptr inbounds i8* %2, i64 1
  %call2 = call i8* @getenv(i8* %add.ptr1) #1
  store i8* %call2, i8** %init, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i8** %init, align 8
  %cmp3 = icmp eq i8* %3, null
  br i1 %cmp3, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.end
  store i32 0, i32* %retval
  br label %return

if.else:                                          ; preds = %if.end
  %4 = load i8** %init, align 8
  %arrayidx = getelementptr inbounds i8* %4, i64 0
  %5 = load i8* %arrayidx, align 1
  %conv = sext i8 %5 to i32
  %cmp5 = icmp eq i32 %conv, 64
  br i1 %cmp5, label %if.then7, label %if.else10

if.then7:                                         ; preds = %if.else
  %6 = load %struct.lua_State** %L.addr, align 8
  %7 = load i8** %init, align 8
  %add.ptr8 = getelementptr inbounds i8* %7, i64 1
  %call9 = call i32 @dofile(%struct.lua_State* %6, i8* %add.ptr8)
  store i32 %call9, i32* %retval
  br label %return

if.else10:                                        ; preds = %if.else
  %8 = load %struct.lua_State** %L.addr, align 8
  %9 = load i8** %init, align 8
  %10 = load i8** %name, align 8
  %call11 = call i32 @dostring(%struct.lua_State* %8, i8* %9, i8* %10)
  store i32 %call11, i32* %retval
  br label %return

return:                                           ; preds = %if.else10, %if.then7, %if.then4
  %11 = load i32* %retval
  ret i32 %11
}

; Function Attrs: nounwind uwtable
define internal i32 @runargs(%struct.lua_State* %L, i8** %argv, i32 %n) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %argv.addr = alloca i8**, align 8
  %n.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %chunk = alloca i8*, align 8
  %filename = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8** %argv, i8*** %argv.addr, align 8
  store i32 %n, i32* %n.addr, align 4
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32* %i, align 4
  %1 = load i32* %n.addr, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i32* %i, align 4
  %idxprom = sext i32 %2 to i64
  %3 = load i8*** %argv.addr, align 8
  %arrayidx = getelementptr inbounds i8** %3, i64 %idxprom
  %4 = load i8** %arrayidx, align 8
  %arrayidx1 = getelementptr inbounds i8* %4, i64 1
  %5 = load i8* %arrayidx1, align 1
  %conv = sext i8 %5 to i32
  switch i32 %conv, label %sw.default [
    i32 101, label %sw.bb
    i32 108, label %sw.bb13
  ]

sw.bb:                                            ; preds = %for.body
  %6 = load i32* %i, align 4
  %idxprom2 = sext i32 %6 to i64
  %7 = load i8*** %argv.addr, align 8
  %arrayidx3 = getelementptr inbounds i8** %7, i64 %idxprom2
  %8 = load i8** %arrayidx3, align 8
  %add.ptr = getelementptr inbounds i8* %8, i64 2
  store i8* %add.ptr, i8** %chunk, align 8
  %9 = load i8** %chunk, align 8
  %10 = load i8* %9, align 1
  %conv4 = sext i8 %10 to i32
  %cmp5 = icmp eq i32 %conv4, 0
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  %11 = load i32* %i, align 4
  %inc = add nsw i32 %11, 1
  store i32 %inc, i32* %i, align 4
  %idxprom7 = sext i32 %inc to i64
  %12 = load i8*** %argv.addr, align 8
  %arrayidx8 = getelementptr inbounds i8** %12, i64 %idxprom7
  %13 = load i8** %arrayidx8, align 8
  store i8* %13, i8** %chunk, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %sw.bb
  %14 = load %struct.lua_State** %L.addr, align 8
  %15 = load i8** %chunk, align 8
  %call = call i32 @dostring(%struct.lua_State* %14, i8* %15, i8* getelementptr inbounds ([16 x i8]* @.str22801, i32 0, i32 0))
  %cmp9 = icmp ne i32 %call, 0
  br i1 %cmp9, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end
  store i32 0, i32* %retval
  br label %return

if.end12:                                         ; preds = %if.end
  br label %sw.epilog

sw.bb13:                                          ; preds = %for.body
  %16 = load i32* %i, align 4
  %idxprom14 = sext i32 %16 to i64
  %17 = load i8*** %argv.addr, align 8
  %arrayidx15 = getelementptr inbounds i8** %17, i64 %idxprom14
  %18 = load i8** %arrayidx15, align 8
  %add.ptr16 = getelementptr inbounds i8* %18, i64 2
  store i8* %add.ptr16, i8** %filename, align 8
  %19 = load i8** %filename, align 8
  %20 = load i8* %19, align 1
  %conv17 = sext i8 %20 to i32
  %cmp18 = icmp eq i32 %conv17, 0
  br i1 %cmp18, label %if.then20, label %if.end24

if.then20:                                        ; preds = %sw.bb13
  %21 = load i32* %i, align 4
  %inc21 = add nsw i32 %21, 1
  store i32 %inc21, i32* %i, align 4
  %idxprom22 = sext i32 %inc21 to i64
  %22 = load i8*** %argv.addr, align 8
  %arrayidx23 = getelementptr inbounds i8** %22, i64 %idxprom22
  %23 = load i8** %arrayidx23, align 8
  store i8* %23, i8** %filename, align 8
  br label %if.end24

if.end24:                                         ; preds = %if.then20, %sw.bb13
  %24 = load %struct.lua_State** %L.addr, align 8
  %25 = load i8** %filename, align 8
  %call25 = call i32 @dolibrary(%struct.lua_State* %24, i8* %25)
  %cmp26 = icmp ne i32 %call25, 0
  br i1 %cmp26, label %if.then28, label %if.end29

if.then28:                                        ; preds = %if.end24
  store i32 0, i32* %retval
  br label %return

if.end29:                                         ; preds = %if.end24
  br label %sw.epilog

sw.default:                                       ; preds = %for.body
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.end29, %if.end12
  br label %for.inc

for.inc:                                          ; preds = %sw.epilog
  %26 = load i32* %i, align 4
  %inc30 = add nsw i32 %26, 1
  store i32 %inc30, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %for.end, %if.then28, %if.then11
  %27 = load i32* %retval
  ret i32 %27
}

; Function Attrs: nounwind uwtable
define internal i32 @handle_script(%struct.lua_State* %L, i8** %argv, i32 %n) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %argv.addr = alloca i8**, align 8
  %n.addr = alloca i32, align 4
  %status = alloca i32, align 4
  %fname = alloca i8*, align 8
  %narg = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8** %argv, i8*** %argv.addr, align 8
  store i32 %n, i32* %n.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i8*** %argv.addr, align 8
  %2 = load i32* %n.addr, align 4
  %call = call i32 @getargs(%struct.lua_State* %0, i8** %1, i32 %2)
  store i32 %call, i32* %narg, align 4
  %3 = load %struct.lua_State** %L.addr, align 8
  call void @lua_setglobal(%struct.lua_State* %3, i8* getelementptr inbounds ([4 x i8]* @.str18797, i32 0, i32 0))
  %4 = load i32* %n.addr, align 4
  %idxprom = sext i32 %4 to i64
  %5 = load i8*** %argv.addr, align 8
  %arrayidx = getelementptr inbounds i8** %5, i64 %idxprom
  %6 = load i8** %arrayidx, align 8
  store i8* %6, i8** %fname, align 8
  %7 = load i8** %fname, align 8
  %call1 = call i32 @strcmp(i8* %7, i8* getelementptr inbounds ([2 x i8]* @.str19798, i32 0, i32 0)) #10
  %cmp = icmp eq i32 %call1, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %8 = load i32* %n.addr, align 4
  %sub = sub nsw i32 %8, 1
  %idxprom2 = sext i32 %sub to i64
  %9 = load i8*** %argv.addr, align 8
  %arrayidx3 = getelementptr inbounds i8** %9, i64 %idxprom2
  %10 = load i8** %arrayidx3, align 8
  %call4 = call i32 @strcmp(i8* %10, i8* getelementptr inbounds ([3 x i8]* @.str20799, i32 0, i32 0)) #10
  %cmp5 = icmp ne i32 %call4, 0
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store i8* null, i8** %fname, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %11 = load %struct.lua_State** %L.addr, align 8
  %12 = load i8** %fname, align 8
  %call6 = call i32 @luaL_loadfilex(%struct.lua_State* %11, i8* %12, i8* null)
  store i32 %call6, i32* %status, align 4
  %13 = load %struct.lua_State** %L.addr, align 8
  %14 = load i32* %narg, align 4
  %add = add nsw i32 %14, 1
  %sub7 = sub nsw i32 0, %add
  call void @lua_insert(%struct.lua_State* %13, i32 %sub7)
  %15 = load i32* %status, align 4
  %cmp8 = icmp eq i32 %15, 0
  br i1 %cmp8, label %if.then9, label %if.else

if.then9:                                         ; preds = %if.end
  %16 = load %struct.lua_State** %L.addr, align 8
  %17 = load i32* %narg, align 4
  %call10 = call i32 @docall(%struct.lua_State* %16, i32 %17, i32 -1)
  store i32 %call10, i32* %status, align 4
  br label %if.end13

if.else:                                          ; preds = %if.end
  %18 = load %struct.lua_State** %L.addr, align 8
  %19 = load i32* %narg, align 4
  %sub11 = sub nsw i32 0, %19
  %sub12 = sub nsw i32 %sub11, 1
  call void @lua_settop(%struct.lua_State* %18, i32 %sub12)
  br label %if.end13

if.end13:                                         ; preds = %if.else, %if.then9
  %20 = load %struct.lua_State** %L.addr, align 8
  %21 = load i32* %status, align 4
  %call14 = call i32 @report(%struct.lua_State* %20, i32 %21)
  ret i32 %call14
}

; Function Attrs: nounwind uwtable
define internal void @dotty(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %status = alloca i32, align 4
  %oldprogname = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load i8** @progname, align 8
  store i8* %0, i8** %oldprogname, align 8
  store i8* null, i8** @progname, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end15, %entry
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @loadline(%struct.lua_State* %1)
  store i32 %call, i32* %status, align 4
  %cmp = icmp ne i32 %call, -1
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load i32* %status, align 4
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %3 = load %struct.lua_State** %L.addr, align 8
  %call2 = call i32 @docall(%struct.lua_State* %3, i32 0, i32 -1)
  store i32 %call2, i32* %status, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load i32* %status, align 4
  %call3 = call i32 @report(%struct.lua_State* %4, i32 %5)
  %6 = load i32* %status, align 4
  %cmp4 = icmp eq i32 %6, 0
  br i1 %cmp4, label %land.lhs.true, label %if.end15

land.lhs.true:                                    ; preds = %if.end
  %7 = load %struct.lua_State** %L.addr, align 8
  %call5 = call i32 @lua_gettop(%struct.lua_State* %7)
  %cmp6 = icmp sgt i32 %call5, 0
  br i1 %cmp6, label %if.then7, label %if.end15

if.then7:                                         ; preds = %land.lhs.true
  %8 = load %struct.lua_State** %L.addr, align 8
  call void @luaL_checkstack(%struct.lua_State* %8, i32 20, i8* getelementptr inbounds ([26 x i8]* @.str7786, i32 0, i32 0))
  %9 = load %struct.lua_State** %L.addr, align 8
  call void @lua_getglobal(%struct.lua_State* %9, i8* getelementptr inbounds ([6 x i8]* @.str8787, i32 0, i32 0))
  %10 = load %struct.lua_State** %L.addr, align 8
  call void @lua_insert(%struct.lua_State* %10, i32 1)
  %11 = load %struct.lua_State** %L.addr, align 8
  %12 = load %struct.lua_State** %L.addr, align 8
  %call8 = call i32 @lua_gettop(%struct.lua_State* %12)
  %sub = sub nsw i32 %call8, 1
  %call9 = call i32 @lua_pcallk(%struct.lua_State* %11, i32 %sub, i32 0, i32 0, i32 0, i32 (%struct.lua_State*)* null)
  %cmp10 = icmp ne i32 %call9, 0
  br i1 %cmp10, label %if.then11, label %if.end14

if.then11:                                        ; preds = %if.then7
  %13 = load i8** @progname, align 8
  %14 = load %struct.lua_State** %L.addr, align 8
  %15 = load %struct.lua_State** %L.addr, align 8
  %call12 = call i8* @lua_tolstring(%struct.lua_State* %15, i32 -1, i64* null)
  %call13 = call i8* (%struct.lua_State*, i8*, ...)* @lua_pushfstring(%struct.lua_State* %14, i8* getelementptr inbounds ([27 x i8]* @.str9788, i32 0, i32 0), i8* %call12)
  call void @l_message(i8* %13, i8* %call13)
  br label %if.end14

if.end14:                                         ; preds = %if.then11, %if.then7
  br label %if.end15

if.end15:                                         ; preds = %if.end14, %land.lhs.true, %if.end
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %16 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %16, i32 0)
  %17 = load %struct._IO_FILE** @stdout, align 8
  %call16 = call i64 @fwrite(i8* getelementptr inbounds ([2 x i8]* @.str10789, i32 0, i32 0), i64 1, i64 1, %struct._IO_FILE* %17)
  %18 = load %struct._IO_FILE** @stdout, align 8
  %call17 = call i32 @fflush(%struct._IO_FILE* %18)
  %19 = load i8** %oldprogname, align 8
  store i8* %19, i8** @progname, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @dofile(%struct.lua_State* %L, i8* %name) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %name.addr = alloca i8*, align 8
  %status = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %name, i8** %name.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i8** %name.addr, align 8
  %call = call i32 @luaL_loadfilex(%struct.lua_State* %0, i8* %1, i8* null)
  store i32 %call, i32* %status, align 4
  %2 = load i32* %status, align 4
  %cmp = icmp eq i32 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i32 @docall(%struct.lua_State* %3, i32 0, i32 0)
  store i32 %call1, i32* %status, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load %struct.lua_State** %L.addr, align 8
  %5 = load i32* %status, align 4
  %call2 = call i32 @report(%struct.lua_State* %4, i32 %5)
  ret i32 %call2
}

; Function Attrs: nounwind uwtable
define internal i32 @dostring(%struct.lua_State* %L, i8* %s, i8* %name) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %s.addr = alloca i8*, align 8
  %name.addr = alloca i8*, align 8
  %status = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %s, i8** %s.addr, align 8
  store i8* %name, i8** %name.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i8** %s.addr, align 8
  %2 = load i8** %s.addr, align 8
  %call = call i64 @strlen(i8* %2) #10
  %3 = load i8** %name.addr, align 8
  %call1 = call i32 @luaL_loadbufferx(%struct.lua_State* %0, i8* %1, i64 %call, i8* %3, i8* null)
  store i32 %call1, i32* %status, align 4
  %4 = load i32* %status, align 4
  %cmp = icmp eq i32 %4, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load %struct.lua_State** %L.addr, align 8
  %call2 = call i32 @docall(%struct.lua_State* %5, i32 0, i32 0)
  store i32 %call2, i32* %status, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load %struct.lua_State** %L.addr, align 8
  %7 = load i32* %status, align 4
  %call3 = call i32 @report(%struct.lua_State* %6, i32 %7)
  ret i32 %call3
}

; Function Attrs: nounwind uwtable
define internal i32 @dolibrary(%struct.lua_State* %L, i8* %name) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %name.addr = alloca i8*, align 8
  %status = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8* %name, i8** %name.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  call void @lua_getglobal(%struct.lua_State* %0, i8* getelementptr inbounds ([8 x i8]* @.str23802, i32 0, i32 0))
  %1 = load %struct.lua_State** %L.addr, align 8
  %2 = load i8** %name.addr, align 8
  %call = call i8* @lua_pushstring(%struct.lua_State* %1, i8* %2)
  %3 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i32 @docall(%struct.lua_State* %3, i32 1, i32 1)
  store i32 %call1, i32* %status, align 4
  %4 = load i32* %status, align 4
  %cmp = icmp eq i32 %4, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load %struct.lua_State** %L.addr, align 8
  %6 = load i8** %name.addr, align 8
  call void @lua_setglobal(%struct.lua_State* %5, i8* %6)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %7 = load %struct.lua_State** %L.addr, align 8
  %8 = load i32* %status, align 4
  %call2 = call i32 @report(%struct.lua_State* %7, i32 %8)
  ret i32 %call2
}

; Function Attrs: nounwind uwtable
define internal i32 @getargs(%struct.lua_State* %L, i8** %argv, i32 %n) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %argv.addr = alloca i8**, align 8
  %n.addr = alloca i32, align 4
  %narg = alloca i32, align 4
  %i = alloca i32, align 4
  %argc = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i8** %argv, i8*** %argv.addr, align 8
  store i32 %n, i32* %n.addr, align 4
  store i32 0, i32* %argc, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load i32* %argc, align 4
  %idxprom = sext i32 %0 to i64
  %1 = load i8*** %argv.addr, align 8
  %arrayidx = getelementptr inbounds i8** %1, i64 %idxprom
  %2 = load i8** %arrayidx, align 8
  %tobool = icmp ne i8* %2, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load i32* %argc, align 4
  %inc = add nsw i32 %3, 1
  store i32 %inc, i32* %argc, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %4 = load i32* %argc, align 4
  %5 = load i32* %n.addr, align 4
  %add = add nsw i32 %5, 1
  %sub = sub nsw i32 %4, %add
  store i32 %sub, i32* %narg, align 4
  %6 = load %struct.lua_State** %L.addr, align 8
  %7 = load i32* %narg, align 4
  %add1 = add nsw i32 %7, 3
  call void @luaL_checkstack(%struct.lua_State* %6, i32 %add1, i8* getelementptr inbounds ([29 x i8]* @.str21800, i32 0, i32 0))
  %8 = load i32* %n.addr, align 4
  %add2 = add nsw i32 %8, 1
  store i32 %add2, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %while.end
  %9 = load i32* %i, align 4
  %10 = load i32* %argc, align 4
  %cmp = icmp slt i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load %struct.lua_State** %L.addr, align 8
  %12 = load i32* %i, align 4
  %idxprom3 = sext i32 %12 to i64
  %13 = load i8*** %argv.addr, align 8
  %arrayidx4 = getelementptr inbounds i8** %13, i64 %idxprom3
  %14 = load i8** %arrayidx4, align 8
  %call = call i8* @lua_pushstring(%struct.lua_State* %11, i8* %14)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %15 = load i32* %i, align 4
  %inc5 = add nsw i32 %15, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %16 = load %struct.lua_State** %L.addr, align 8
  %17 = load i32* %narg, align 4
  %18 = load i32* %n.addr, align 4
  %add6 = add nsw i32 %18, 1
  call void @lua_createtable(%struct.lua_State* %16, i32 %17, i32 %add6)
  store i32 0, i32* %i, align 4
  br label %for.cond7

for.cond7:                                        ; preds = %for.inc14, %for.end
  %19 = load i32* %i, align 4
  %20 = load i32* %argc, align 4
  %cmp8 = icmp slt i32 %19, %20
  br i1 %cmp8, label %for.body9, label %for.end16

for.body9:                                        ; preds = %for.cond7
  %21 = load %struct.lua_State** %L.addr, align 8
  %22 = load i32* %i, align 4
  %idxprom10 = sext i32 %22 to i64
  %23 = load i8*** %argv.addr, align 8
  %arrayidx11 = getelementptr inbounds i8** %23, i64 %idxprom10
  %24 = load i8** %arrayidx11, align 8
  %call12 = call i8* @lua_pushstring(%struct.lua_State* %21, i8* %24)
  %25 = load %struct.lua_State** %L.addr, align 8
  %26 = load i32* %i, align 4
  %27 = load i32* %n.addr, align 4
  %sub13 = sub nsw i32 %26, %27
  call void @lua_rawseti(%struct.lua_State* %25, i32 -2, i32 %sub13)
  br label %for.inc14

for.inc14:                                        ; preds = %for.body9
  %28 = load i32* %i, align 4
  %inc15 = add nsw i32 %28, 1
  store i32 %inc15, i32* %i, align 4
  br label %for.cond7

for.end16:                                        ; preds = %for.cond7
  %29 = load i32* %narg, align 4
  ret i32 %29
}

; Function Attrs: nounwind uwtable
define internal i32 @docall(%struct.lua_State* %L, i32 %narg, i32 %nres) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %narg.addr = alloca i32, align 4
  %nres.addr = alloca i32, align 4
  %status = alloca i32, align 4
  %base = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %narg, i32* %narg.addr, align 4
  store i32 %nres, i32* %nres.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_gettop(%struct.lua_State* %0)
  %1 = load i32* %narg.addr, align 4
  %sub = sub nsw i32 %call, %1
  store i32 %sub, i32* %base, align 4
  %2 = load %struct.lua_State** %L.addr, align 8
  call void @lua_pushcclosure(%struct.lua_State* %2, i32 (%struct.lua_State*)* @traceback, i32 0)
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load i32* %base, align 4
  call void @lua_insert(%struct.lua_State* %3, i32 %4)
  %5 = load %struct.lua_State** %L.addr, align 8
  store %struct.lua_State* %5, %struct.lua_State** @globalL, align 8
  %call1 = call void (i32)* (i32, void (i32)*)* @signal(i32 2, void (i32)* @laction) #1
  %6 = load %struct.lua_State** %L.addr, align 8
  %7 = load i32* %narg.addr, align 4
  %8 = load i32* %nres.addr, align 4
  %9 = load i32* %base, align 4
  %call2 = call i32 @lua_pcallk(%struct.lua_State* %6, i32 %7, i32 %8, i32 %9, i32 0, i32 (%struct.lua_State*)* null)
  store i32 %call2, i32* %status, align 4
  %call3 = call void (i32)* (i32, void (i32)*)* @signal(i32 2, void (i32)* null) #1
  %10 = load %struct.lua_State** %L.addr, align 8
  %11 = load i32* %base, align 4
  call void @lua_remove(%struct.lua_State* %10, i32 %11)
  %12 = load i32* %status, align 4
  ret i32 %12
}

; Function Attrs: nounwind uwtable
define internal i32 @report(%struct.lua_State* %L, i32 %status) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %status.addr = alloca i32, align 4
  %msg = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %status, i32* %status.addr, align 4
  %0 = load i32* %status.addr, align 4
  %cmp = icmp ne i32 %0, 0
  br i1 %cmp, label %land.lhs.true, label %if.end6

land.lhs.true:                                    ; preds = %entry
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_type(%struct.lua_State* %1, i32 -1)
  %cmp1 = icmp eq i32 %call, 0
  br i1 %cmp1, label %if.end6, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %2 = load %struct.lua_State** %L.addr, align 8
  %call2 = call i8* @lua_tolstring(%struct.lua_State* %2, i32 -1, i64* null)
  store i8* %call2, i8** %msg, align 8
  %3 = load i8** %msg, align 8
  %cmp3 = icmp eq i8* %3, null
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  store i8* getelementptr inbounds ([31 x i8]* @.str1779, i32 0, i32 0), i8** %msg, align 8
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then
  %4 = load i8** @progname, align 8
  %5 = load i8** %msg, align 8
  call void @l_message(i8* %4, i8* %5)
  %6 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %6, i32 -2)
  %7 = load %struct.lua_State** %L.addr, align 8
  %call5 = call i32 @lua_gc(%struct.lua_State* %7, i32 2, i32 0)
  br label %if.end6

if.end6:                                          ; preds = %if.end, %land.lhs.true, %entry
  %8 = load i32* %status.addr, align 4
  ret i32 %8
}

; Function Attrs: nounwind uwtable
define internal i32 @loadline(%struct.lua_State* %L) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %status = alloca i32, align 4
  %l = alloca i64, align 8
  %line = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %0, i32 0)
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @pushline(%struct.lua_State* %1, i32 1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 -1, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %if.end10, %if.end
  %2 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i8* @lua_tolstring(%struct.lua_State* %2, i32 1, i64* %l)
  store i8* %call1, i8** %line, align 8
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load i8** %line, align 8
  %5 = load i64* %l, align 8
  %call2 = call i32 @luaL_loadbufferx(%struct.lua_State* %3, i8* %4, i64 %5, i8* getelementptr inbounds ([7 x i8]* @.str11790, i32 0, i32 0), i8* null)
  store i32 %call2, i32* %status, align 4
  %6 = load %struct.lua_State** %L.addr, align 8
  %7 = load i32* %status, align 4
  %call3 = call i32 @incomplete(%struct.lua_State* %6, i32 %7)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.end6, label %if.then5

if.then5:                                         ; preds = %for.cond
  br label %for.end

if.end6:                                          ; preds = %for.cond
  %8 = load %struct.lua_State** %L.addr, align 8
  %call7 = call i32 @pushline(%struct.lua_State* %8, i32 0)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end10, label %if.then9

if.then9:                                         ; preds = %if.end6
  store i32 -1, i32* %retval
  br label %return

if.end10:                                         ; preds = %if.end6
  %9 = load %struct.lua_State** %L.addr, align 8
  %call11 = call i8* @lua_pushlstring(%struct.lua_State* %9, i8* getelementptr inbounds ([2 x i8]* @.str10789, i32 0, i32 0), i64 1)
  %10 = load %struct.lua_State** %L.addr, align 8
  call void @lua_insert(%struct.lua_State* %10, i32 -2)
  %11 = load %struct.lua_State** %L.addr, align 8
  call void @lua_concat(%struct.lua_State* %11, i32 3)
  br label %for.cond

for.end:                                          ; preds = %if.then5
  %12 = load %struct.lua_State** %L.addr, align 8
  %call12 = call i64 @lua_rawlen(%struct.lua_State* %12, i32 1)
  %cmp = icmp ugt i64 %call12, 0
  br i1 %cmp, label %if.then13, label %if.end15

if.then13:                                        ; preds = %for.end
  %13 = load %struct.lua_State** %L.addr, align 8
  %call14 = call i8* @lua_tolstring(%struct.lua_State* %13, i32 1, i64* null)
  call void @add_history(i8* %call14)
  br label %if.end15

if.end15:                                         ; preds = %if.then13, %for.end
  %14 = load %struct.lua_State** %L.addr, align 8
  call void @lua_remove(%struct.lua_State* %14, i32 1)
  %15 = load i32* %status, align 4
  store i32 %15, i32* %retval
  br label %return

return:                                           ; preds = %if.end15, %if.then9, %if.then
  %16 = load i32* %retval
  ret i32 %16
}

; Function Attrs: nounwind uwtable
define internal i32 @traceback(%struct.lua_State* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %msg = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @lua_tolstring(%struct.lua_State* %0, i32 1, i64* null)
  store i8* %call, i8** %msg, align 8
  %1 = load i8** %msg, align 8
  %tobool = icmp ne i8* %1, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load %struct.lua_State** %L.addr, align 8
  %4 = load i8** %msg, align 8
  call void @luaL_traceback(%struct.lua_State* %2, %struct.lua_State* %3, i8* %4, i32 1)
  br label %if.end8

if.else:                                          ; preds = %entry
  %5 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i32 @lua_type(%struct.lua_State* %5, i32 1)
  %cmp = icmp sle i32 %call1, 0
  br i1 %cmp, label %if.end7, label %if.then2

if.then2:                                         ; preds = %if.else
  %6 = load %struct.lua_State** %L.addr, align 8
  %call3 = call i32 @luaL_callmeta(%struct.lua_State* %6, i32 1, i8* getelementptr inbounds ([11 x i8]* @.str5784, i32 0, i32 0))
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.end, label %if.then5

if.then5:                                         ; preds = %if.then2
  %7 = load %struct.lua_State** %L.addr, align 8
  %call6 = call i8* @lua_pushlstring(%struct.lua_State* %7, i8* getelementptr inbounds ([19 x i8]* @.str6785, i32 0, i32 0), i64 18)
  br label %if.end

if.end:                                           ; preds = %if.then5, %if.then2
  br label %if.end7

if.end7:                                          ; preds = %if.end, %if.else
  br label %if.end8

if.end8:                                          ; preds = %if.end7, %if.then
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal void @laction(i32 %i) #0 {
entry:
  %i.addr = alloca i32, align 4
  store i32 %i, i32* %i.addr, align 4
  %0 = load i32* %i.addr, align 4
  %call = call void (i32)* (i32, void (i32)*)* @signal(i32 %0, void (i32)* null) #1
  %1 = load %struct.lua_State** @globalL, align 8
  %call1 = call i32 @lua_sethook(%struct.lua_State* %1, void (%struct.lua_State*, %struct.lua_Debug*)* @lstop, i32 11, i32 1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @pushline(%struct.lua_State* %L, i32 %firstline) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %firstline.addr = alloca i32, align 4
  %buffer = alloca [512 x i8], align 16
  %b = alloca i8*, align 8
  %l = alloca i64, align 8
  %prmt = alloca i8*, align 8
  %readstatus = alloca i32, align 4
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %firstline, i32* %firstline.addr, align 4
  %arraydecay = getelementptr inbounds [512 x i8]* %buffer, i32 0, i32 0
  store i8* %arraydecay, i8** %b, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %firstline.addr, align 4
  %call = call i8* @get_prompt(%struct.lua_State* %0, i32 %1)
  store i8* %call, i8** %prmt, align 8
  %2 = load %struct.lua_State** %L.addr, align 8
  %3 = load i8** %prmt, align 8
  %call1 = call i8* @readline(i8* %3)
  store i8* %call1, i8** %b, align 8
  %cmp = icmp ne i8* %call1, null
  %conv = zext i1 %cmp to i32
  store i32 %conv, i32* %readstatus, align 4
  %4 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %4, i32 -2)
  %5 = load i32* %readstatus, align 4
  %cmp2 = icmp eq i32 %5, 0
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %6 = load i8** %b, align 8
  %call4 = call i64 @strlen(i8* %6) #10
  store i64 %call4, i64* %l, align 8
  %7 = load i64* %l, align 8
  %cmp5 = icmp ugt i64 %7, 0
  br i1 %cmp5, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %if.end
  %8 = load i64* %l, align 8
  %sub = sub i64 %8, 1
  %9 = load i8** %b, align 8
  %arrayidx = getelementptr inbounds i8* %9, i64 %sub
  %10 = load i8* %arrayidx, align 1
  %conv7 = sext i8 %10 to i32
  %cmp8 = icmp eq i32 %conv7, 10
  br i1 %cmp8, label %if.then10, label %if.end13

if.then10:                                        ; preds = %land.lhs.true
  %11 = load i64* %l, align 8
  %sub11 = sub i64 %11, 1
  %12 = load i8** %b, align 8
  %arrayidx12 = getelementptr inbounds i8* %12, i64 %sub11
  store i8 0, i8* %arrayidx12, align 1
  br label %if.end13

if.end13:                                         ; preds = %if.then10, %land.lhs.true, %if.end
  %13 = load i32* %firstline.addr, align 4
  %tobool = icmp ne i32 %13, 0
  br i1 %tobool, label %land.lhs.true14, label %if.else

land.lhs.true14:                                  ; preds = %if.end13
  %14 = load i8** %b, align 8
  %arrayidx15 = getelementptr inbounds i8* %14, i64 0
  %15 = load i8* %arrayidx15, align 1
  %conv16 = sext i8 %15 to i32
  %cmp17 = icmp eq i32 %conv16, 61
  br i1 %cmp17, label %if.then19, label %if.else

if.then19:                                        ; preds = %land.lhs.true14
  %16 = load %struct.lua_State** %L.addr, align 8
  %17 = load i8** %b, align 8
  %add.ptr = getelementptr inbounds i8* %17, i64 1
  %call20 = call i8* (%struct.lua_State*, i8*, ...)* @lua_pushfstring(%struct.lua_State* %16, i8* getelementptr inbounds ([10 x i8]* @.str13792, i32 0, i32 0), i8* %add.ptr)
  br label %if.end22

if.else:                                          ; preds = %land.lhs.true14, %if.end13
  %18 = load %struct.lua_State** %L.addr, align 8
  %19 = load i8** %b, align 8
  %call21 = call i8* @lua_pushstring(%struct.lua_State* %18, i8* %19)
  br label %if.end22

if.end22:                                         ; preds = %if.else, %if.then19
  %20 = load %struct.lua_State** %L.addr, align 8
  %21 = load i8** %b, align 8
  call void @free(i8* %21) #1
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %if.end22, %if.then
  %22 = load i32* %retval
  ret i32 %22
}

; Function Attrs: nounwind uwtable
define internal i32 @incomplete(%struct.lua_State* %L, i32 %status) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State*, align 8
  %status.addr = alloca i32, align 4
  %lmsg = alloca i64, align 8
  %msg = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %status, i32* %status.addr, align 4
  %0 = load i32* %status.addr, align 4
  %cmp = icmp eq i32 %0, 3
  br i1 %cmp, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @lua_tolstring(%struct.lua_State* %1, i32 -1, i64* %lmsg)
  store i8* %call, i8** %msg, align 8
  %2 = load i64* %lmsg, align 8
  %cmp1 = icmp uge i64 %2, 5
  br i1 %cmp1, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then
  %3 = load i8** %msg, align 8
  %4 = load i64* %lmsg, align 8
  %add.ptr = getelementptr inbounds i8* %3, i64 %4
  %add.ptr2 = getelementptr inbounds i8* %add.ptr, i64 -5
  %call3 = call i32 @strcmp(i8* %add.ptr2, i8* getelementptr inbounds ([6 x i8]* @.str12791, i32 0, i32 0)) #10
  %cmp4 = icmp eq i32 %call3, 0
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %land.lhs.true
  %5 = load %struct.lua_State** %L.addr, align 8
  call void @lua_settop(%struct.lua_State* %5, i32 -2)
  store i32 1, i32* %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true, %if.then
  br label %if.end6

if.end6:                                          ; preds = %if.end, %entry
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.end6, %if.then5
  %6 = load i32* %retval
  ret i32 %6
}

; Function Attrs: nounwind uwtable
define internal void @lstop(%struct.lua_State* %L, %struct.lua_Debug* %ar) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %ar.addr = alloca %struct.lua_Debug*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.lua_Debug* %ar, %struct.lua_Debug** %ar.addr, align 8
  %0 = load %struct.lua_Debug** %ar.addr, align 8
  %1 = load %struct.lua_State** %L.addr, align 8
  %call = call i32 @lua_sethook(%struct.lua_State* %1, void (%struct.lua_State*, %struct.lua_Debug*)* null, i32 0, i32 0)
  %2 = load %struct.lua_State** %L.addr, align 8
  %call1 = call i32 (%struct.lua_State*, i8*, ...)* @luaL_error(%struct.lua_State* %2, i8* getelementptr inbounds ([13 x i8]* @.str4783, i32 0, i32 0))
  ret void
}

; Function Attrs: nounwind uwtable
define internal i8* @get_prompt(%struct.lua_State* %L, i32 %firstline) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %firstline.addr = alloca i32, align 4
  %p = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store i32 %firstline, i32* %firstline.addr, align 4
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load i32* %firstline.addr, align 4
  %tobool = icmp ne i32 %1, 0
  %cond = select i1 %tobool, i8* getelementptr inbounds ([8 x i8]* @.str14793, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8]* @.str15794, i32 0, i32 0)
  call void @lua_getglobal(%struct.lua_State* %0, i8* %cond)
  %2 = load %struct.lua_State** %L.addr, align 8
  %call = call i8* @lua_tolstring(%struct.lua_State* %2, i32 -1, i64* null)
  store i8* %call, i8** %p, align 8
  %3 = load i8** %p, align 8
  %cmp = icmp eq i8* %3, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load i32* %firstline.addr, align 4
  %tobool1 = icmp ne i32 %4, 0
  %cond2 = select i1 %tobool1, i8* getelementptr inbounds ([3 x i8]* @.str16795, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8]* @.str17796, i32 0, i32 0)
  store i8* %cond2, i8** %p, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load i8** %p, align 8
  ret i8* %5
}

; Function Attrs: nounwind uwtable
define hidden %union.Closure.157* @luaU_undump(%struct.lua_State.154* %L, %struct.Zio.449* %Z, %struct.Mbuffer* %buff, i8* %name) #0 {
entry:
  %L.addr = alloca %struct.lua_State.154*, align 8
  %Z.addr = alloca %struct.Zio.449*, align 8
  %buff.addr = alloca %struct.Mbuffer*, align 8
  %name.addr = alloca i8*, align 8
  %S = alloca %struct.LoadState, align 8
  %cl = alloca %union.Closure.157*, align 8
  %io = alloca %struct.lua_TValue.137*, align 8
  %p32 = alloca %struct.Proto.160*, align 8
  %io41 = alloca %struct.lua_TValue.137*, align 8
  store %struct.lua_State.154* %L, %struct.lua_State.154** %L.addr, align 8
  store %struct.Zio.449* %Z, %struct.Zio.449** %Z.addr, align 8
  store %struct.Mbuffer* %buff, %struct.Mbuffer** %buff.addr, align 8
  store i8* %name, i8** %name.addr, align 8
  %0 = load i8** %name.addr, align 8
  %1 = load i8* %0, align 1
  %conv = sext i8 %1 to i32
  %cmp = icmp eq i32 %conv, 64
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load i8** %name.addr, align 8
  %3 = load i8* %2, align 1
  %conv2 = sext i8 %3 to i32
  %cmp3 = icmp eq i32 %conv2, 61
  br i1 %cmp3, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  %4 = load i8** %name.addr, align 8
  %add.ptr = getelementptr inbounds i8* %4, i64 1
  %name5 = getelementptr inbounds %struct.LoadState* %S, i32 0, i32 3
  store i8* %add.ptr, i8** %name5, align 8
  br label %if.end14

if.else:                                          ; preds = %lor.lhs.false
  %5 = load i8** %name.addr, align 8
  %6 = load i8* %5, align 1
  %conv6 = sext i8 %6 to i32
  %7 = load i8* getelementptr inbounds ([5 x i8]* @.str811, i32 0, i64 0), align 1
  %conv7 = sext i8 %7 to i32
  %cmp8 = icmp eq i32 %conv6, %conv7
  br i1 %cmp8, label %if.then10, label %if.else12

if.then10:                                        ; preds = %if.else
  %name11 = getelementptr inbounds %struct.LoadState* %S, i32 0, i32 3
  store i8* getelementptr inbounds ([14 x i8]* @.str1812, i32 0, i32 0), i8** %name11, align 8
  br label %if.end

if.else12:                                        ; preds = %if.else
  %8 = load i8** %name.addr, align 8
  %name13 = getelementptr inbounds %struct.LoadState* %S, i32 0, i32 3
  store i8* %8, i8** %name13, align 8
  br label %if.end

if.end:                                           ; preds = %if.else12, %if.then10
  br label %if.end14

if.end14:                                         ; preds = %if.end, %if.then
  %9 = load %struct.lua_State.154** %L.addr, align 8
  %L15 = getelementptr inbounds %struct.LoadState* %S, i32 0, i32 0
  store %struct.lua_State.154* %9, %struct.lua_State.154** %L15, align 8
  %10 = load %struct.Zio.449** %Z.addr, align 8
  %Z16 = getelementptr inbounds %struct.LoadState* %S, i32 0, i32 1
  store %struct.Zio.449* %10, %struct.Zio.449** %Z16, align 8
  %11 = load %struct.Mbuffer** %buff.addr, align 8
  %b = getelementptr inbounds %struct.LoadState* %S, i32 0, i32 2
  store %struct.Mbuffer* %11, %struct.Mbuffer** %b, align 8
  call void @LoadHeader(%struct.LoadState* %S)
  %12 = load %struct.lua_State.154** %L.addr, align 8
  %call = call %union.Closure.157* @luaF_newLclosure(%struct.lua_State.154* %12, i32 1)
  store %union.Closure.157* %call, %union.Closure.157** %cl, align 8
  %13 = load %struct.lua_State.154** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State.154* %13, i32 0, i32 4
  %14 = load %struct.lua_TValue.137** %top, align 8
  store %struct.lua_TValue.137* %14, %struct.lua_TValue.137** %io, align 8
  %15 = load %union.Closure.157** %cl, align 8
  %16 = bitcast %union.Closure.157* %15 to %union.GCObject.155*
  %17 = load %struct.lua_TValue.137** %io, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue.137* %17, i32 0, i32 0
  %gc = bitcast %union.Value.136* %value_ to %union.GCObject.155**
  store %union.GCObject.155* %16, %union.GCObject.155** %gc, align 8
  %18 = load %struct.lua_TValue.137** %io, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue.137* %18, i32 0, i32 1
  store i32 70, i32* %tt_, align 4
  %19 = load %struct.lua_State.154** %L.addr, align 8
  %top17 = getelementptr inbounds %struct.lua_State.154* %19, i32 0, i32 4
  %20 = load %struct.lua_TValue.137** %top17, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue.137* %20, i32 1
  store %struct.lua_TValue.137* %incdec.ptr, %struct.lua_TValue.137** %top17, align 8
  %21 = load %struct.lua_State.154** %L.addr, align 8
  %stack_last = getelementptr inbounds %struct.lua_State.154* %21, i32 0, i32 8
  %22 = load %struct.lua_TValue.137** %stack_last, align 8
  %23 = load %struct.lua_State.154** %L.addr, align 8
  %top18 = getelementptr inbounds %struct.lua_State.154* %23, i32 0, i32 4
  %24 = load %struct.lua_TValue.137** %top18, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.lua_TValue.137* %22 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.lua_TValue.137* %24 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 16
  %cmp19 = icmp sle i64 %sub.ptr.div, 0
  br i1 %cmp19, label %if.then21, label %if.else22

if.then21:                                        ; preds = %if.end14
  %25 = load %struct.lua_State.154** %L.addr, align 8
  call void bitcast (void (%struct.lua_State*, i32)* @luaD_growstack to void (%struct.lua_State.154*, i32)*)(%struct.lua_State.154* %25, i32 0)
  br label %if.end23

if.else22:                                        ; preds = %if.end14
  br label %if.end23

if.end23:                                         ; preds = %if.else22, %if.then21
  %26 = load %struct.lua_State.154** %L.addr, align 8
  %call24 = call %struct.Proto.160* @luaF_newproto(%struct.lua_State.154* %26)
  %27 = load %union.Closure.157** %cl, align 8
  %l = bitcast %union.Closure.157* %27 to %struct.LClosure.453*
  %p = getelementptr inbounds %struct.LClosure.453* %l, i32 0, i32 5
  store %struct.Proto.160* %call24, %struct.Proto.160** %p, align 8
  %28 = load %union.Closure.157** %cl, align 8
  %l25 = bitcast %union.Closure.157* %28 to %struct.LClosure.453*
  %p26 = getelementptr inbounds %struct.LClosure.453* %l25, i32 0, i32 5
  %29 = load %struct.Proto.160** %p26, align 8
  call void @LoadFunction(%struct.LoadState* %S, %struct.Proto.160* %29)
  %30 = load %union.Closure.157** %cl, align 8
  %l27 = bitcast %union.Closure.157* %30 to %struct.LClosure.453*
  %p28 = getelementptr inbounds %struct.LClosure.453* %l27, i32 0, i32 5
  %31 = load %struct.Proto.160** %p28, align 8
  %sizeupvalues = getelementptr inbounds %struct.Proto.160* %31, i32 0, i32 11
  %32 = load i32* %sizeupvalues, align 4
  %cmp29 = icmp ne i32 %32, 1
  br i1 %cmp29, label %if.then31, label %if.end47

if.then31:                                        ; preds = %if.end23
  %33 = load %union.Closure.157** %cl, align 8
  %l33 = bitcast %union.Closure.157* %33 to %struct.LClosure.453*
  %p34 = getelementptr inbounds %struct.LClosure.453* %l33, i32 0, i32 5
  %34 = load %struct.Proto.160** %p34, align 8
  store %struct.Proto.160* %34, %struct.Proto.160** %p32, align 8
  %35 = load %struct.lua_State.154** %L.addr, align 8
  %36 = load %union.Closure.157** %cl, align 8
  %l35 = bitcast %union.Closure.157* %36 to %struct.LClosure.453*
  %p36 = getelementptr inbounds %struct.LClosure.453* %l35, i32 0, i32 5
  %37 = load %struct.Proto.160** %p36, align 8
  %sizeupvalues37 = getelementptr inbounds %struct.Proto.160* %37, i32 0, i32 11
  %38 = load i32* %sizeupvalues37, align 4
  %call38 = call %union.Closure.157* @luaF_newLclosure(%struct.lua_State.154* %35, i32 %38)
  store %union.Closure.157* %call38, %union.Closure.157** %cl, align 8
  %39 = load %struct.Proto.160** %p32, align 8
  %40 = load %union.Closure.157** %cl, align 8
  %l39 = bitcast %union.Closure.157* %40 to %struct.LClosure.453*
  %p40 = getelementptr inbounds %struct.LClosure.453* %l39, i32 0, i32 5
  store %struct.Proto.160* %39, %struct.Proto.160** %p40, align 8
  %41 = load %struct.lua_State.154** %L.addr, align 8
  %top42 = getelementptr inbounds %struct.lua_State.154* %41, i32 0, i32 4
  %42 = load %struct.lua_TValue.137** %top42, align 8
  %add.ptr43 = getelementptr inbounds %struct.lua_TValue.137* %42, i64 -1
  store %struct.lua_TValue.137* %add.ptr43, %struct.lua_TValue.137** %io41, align 8
  %43 = load %union.Closure.157** %cl, align 8
  %44 = bitcast %union.Closure.157* %43 to %union.GCObject.155*
  %45 = load %struct.lua_TValue.137** %io41, align 8
  %value_44 = getelementptr inbounds %struct.lua_TValue.137* %45, i32 0, i32 0
  %gc45 = bitcast %union.Value.136* %value_44 to %union.GCObject.155**
  store %union.GCObject.155* %44, %union.GCObject.155** %gc45, align 8
  %46 = load %struct.lua_TValue.137** %io41, align 8
  %tt_46 = getelementptr inbounds %struct.lua_TValue.137* %46, i32 0, i32 1
  store i32 70, i32* %tt_46, align 4
  br label %if.end47

if.end47:                                         ; preds = %if.then31, %if.end23
  %47 = load %union.Closure.157** %cl, align 8
  ret %union.Closure.157* %47
}

; Function Attrs: nounwind uwtable
define hidden void @luaU_header(i8* %h) #0 {
entry:
  %h.addr = alloca i8*, align 8
  %x = alloca i32, align 4
  store i8* %h, i8** %h.addr, align 8
  store i32 1, i32* %x, align 4
  %0 = load i8** %h.addr, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* getelementptr inbounds ([5 x i8]* @.str811, i32 0, i32 0), i64 4, i32 1, i1 false)
  %1 = load i8** %h.addr, align 8
  %add.ptr = getelementptr inbounds i8* %1, i64 4
  store i8* %add.ptr, i8** %h.addr, align 8
  %2 = load i8* getelementptr inbounds ([2 x i8]* @.str2813, i32 0, i64 0), align 1
  %conv = sext i8 %2 to i32
  %sub = sub nsw i32 %conv, 48
  %mul = mul nsw i32 %sub, 16
  %3 = load i8* getelementptr inbounds ([2 x i8]* @.str3814, i32 0, i64 0), align 1
  %conv1 = sext i8 %3 to i32
  %sub2 = sub nsw i32 %conv1, 48
  %add = add nsw i32 %mul, %sub2
  %conv3 = trunc i32 %add to i8
  %4 = load i8** %h.addr, align 8
  %incdec.ptr = getelementptr inbounds i8* %4, i32 1
  store i8* %incdec.ptr, i8** %h.addr, align 8
  store i8 %conv3, i8* %4, align 1
  %5 = load i8** %h.addr, align 8
  %incdec.ptr4 = getelementptr inbounds i8* %5, i32 1
  store i8* %incdec.ptr4, i8** %h.addr, align 8
  store i8 0, i8* %5, align 1
  %6 = bitcast i32* %x to i8*
  %7 = load i8* %6, align 1
  %8 = load i8** %h.addr, align 8
  %incdec.ptr5 = getelementptr inbounds i8* %8, i32 1
  store i8* %incdec.ptr5, i8** %h.addr, align 8
  store i8 %7, i8* %8, align 1
  %9 = load i8** %h.addr, align 8
  %incdec.ptr6 = getelementptr inbounds i8* %9, i32 1
  store i8* %incdec.ptr6, i8** %h.addr, align 8
  store i8 4, i8* %9, align 1
  %10 = load i8** %h.addr, align 8
  %incdec.ptr7 = getelementptr inbounds i8* %10, i32 1
  store i8* %incdec.ptr7, i8** %h.addr, align 8
  store i8 8, i8* %10, align 1
  %11 = load i8** %h.addr, align 8
  %incdec.ptr8 = getelementptr inbounds i8* %11, i32 1
  store i8* %incdec.ptr8, i8** %h.addr, align 8
  store i8 4, i8* %11, align 1
  %12 = load i8** %h.addr, align 8
  %incdec.ptr9 = getelementptr inbounds i8* %12, i32 1
  store i8* %incdec.ptr9, i8** %h.addr, align 8
  store i8 8, i8* %12, align 1
  %13 = load i8** %h.addr, align 8
  %incdec.ptr10 = getelementptr inbounds i8* %13, i32 1
  store i8* %incdec.ptr10, i8** %h.addr, align 8
  store i8 0, i8* %13, align 1
  %14 = load i8** %h.addr, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %14, i8* getelementptr inbounds ([7 x i8]* @.str4815, i32 0, i32 0), i64 6, i32 1, i1 false)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @LoadHeader(%struct.LoadState* %S) #0 {
entry:
  %S.addr = alloca %struct.LoadState*, align 8
  %h = alloca [18 x i8], align 16
  %s = alloca [18 x i8], align 16
  store %struct.LoadState* %S, %struct.LoadState** %S.addr, align 8
  %arraydecay = getelementptr inbounds [18 x i8]* %h, i32 0, i32 0
  call void @luaU_header(i8* %arraydecay)
  %0 = bitcast [18 x i8]* %s to i8*
  %1 = bitcast [18 x i8]* %h to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* %1, i64 1, i32 16, i1 false)
  %2 = load %struct.LoadState** %S.addr, align 8
  %arraydecay1 = getelementptr inbounds [18 x i8]* %s, i32 0, i32 0
  %add.ptr = getelementptr inbounds i8* %arraydecay1, i64 1
  call void @LoadBlock(%struct.LoadState* %2, i8* %add.ptr, i64 17)
  %arraydecay2 = getelementptr inbounds [18 x i8]* %h, i32 0, i32 0
  %arraydecay3 = getelementptr inbounds [18 x i8]* %s, i32 0, i32 0
  %call = call i32 @memcmp(i8* %arraydecay2, i8* %arraydecay3, i64 18) #10
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  ret void

if.end:                                           ; preds = %entry
  %arraydecay4 = getelementptr inbounds [18 x i8]* %h, i32 0, i32 0
  %arraydecay5 = getelementptr inbounds [18 x i8]* %s, i32 0, i32 0
  %call6 = call i32 @memcmp(i8* %arraydecay4, i8* %arraydecay5, i64 4) #10
  %cmp7 = icmp ne i32 %call6, 0
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end
  %3 = load %struct.LoadState** %S.addr, align 8
  call void @error(%struct.LoadState* %3, i8* getelementptr inbounds ([6 x i8]* @.str8819, i32 0, i32 0)) #9
  unreachable

if.end9:                                          ; preds = %if.end
  %arraydecay10 = getelementptr inbounds [18 x i8]* %h, i32 0, i32 0
  %arraydecay11 = getelementptr inbounds [18 x i8]* %s, i32 0, i32 0
  %call12 = call i32 @memcmp(i8* %arraydecay10, i8* %arraydecay11, i64 6) #10
  %cmp13 = icmp ne i32 %call12, 0
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end9
  %4 = load %struct.LoadState** %S.addr, align 8
  call void @error(%struct.LoadState* %4, i8* getelementptr inbounds ([20 x i8]* @.str9820, i32 0, i32 0)) #9
  unreachable

if.end15:                                         ; preds = %if.end9
  %arraydecay16 = getelementptr inbounds [18 x i8]* %h, i32 0, i32 0
  %arraydecay17 = getelementptr inbounds [18 x i8]* %s, i32 0, i32 0
  %call18 = call i32 @memcmp(i8* %arraydecay16, i8* %arraydecay17, i64 12) #10
  %cmp19 = icmp ne i32 %call18, 0
  br i1 %cmp19, label %if.then20, label %if.else

if.then20:                                        ; preds = %if.end15
  %5 = load %struct.LoadState** %S.addr, align 8
  call void @error(%struct.LoadState* %5, i8* getelementptr inbounds ([13 x i8]* @.str10821, i32 0, i32 0)) #9
  unreachable

if.else:                                          ; preds = %if.end15
  %6 = load %struct.LoadState** %S.addr, align 8
  call void @error(%struct.LoadState* %6, i8* getelementptr inbounds ([10 x i8]* @.str7818, i32 0, i32 0)) #9
  unreachable
}

; Function Attrs: nounwind uwtable
define internal void @LoadFunction(%struct.LoadState* %S, %struct.Proto.160* %f) #0 {
entry:
  %S.addr = alloca %struct.LoadState*, align 8
  %f.addr = alloca %struct.Proto.160*, align 8
  store %struct.LoadState* %S, %struct.LoadState** %S.addr, align 8
  store %struct.Proto.160* %f, %struct.Proto.160** %f.addr, align 8
  %0 = load %struct.LoadState** %S.addr, align 8
  %call = call i32 @LoadInt(%struct.LoadState* %0)
  %1 = load %struct.Proto.160** %f.addr, align 8
  %linedefined = getelementptr inbounds %struct.Proto.160* %1, i32 0, i32 17
  store i32 %call, i32* %linedefined, align 4
  %2 = load %struct.LoadState** %S.addr, align 8
  %call1 = call i32 @LoadInt(%struct.LoadState* %2)
  %3 = load %struct.Proto.160** %f.addr, align 8
  %lastlinedefined = getelementptr inbounds %struct.Proto.160* %3, i32 0, i32 18
  store i32 %call1, i32* %lastlinedefined, align 4
  %4 = load %struct.LoadState** %S.addr, align 8
  %call2 = call i32 @LoadChar(%struct.LoadState* %4)
  %conv = trunc i32 %call2 to i8
  %5 = load %struct.Proto.160** %f.addr, align 8
  %numparams = getelementptr inbounds %struct.Proto.160* %5, i32 0, i32 20
  store i8 %conv, i8* %numparams, align 1
  %6 = load %struct.LoadState** %S.addr, align 8
  %call3 = call i32 @LoadChar(%struct.LoadState* %6)
  %conv4 = trunc i32 %call3 to i8
  %7 = load %struct.Proto.160** %f.addr, align 8
  %is_vararg = getelementptr inbounds %struct.Proto.160* %7, i32 0, i32 21
  store i8 %conv4, i8* %is_vararg, align 1
  %8 = load %struct.LoadState** %S.addr, align 8
  %call5 = call i32 @LoadChar(%struct.LoadState* %8)
  %conv6 = trunc i32 %call5 to i8
  %9 = load %struct.Proto.160** %f.addr, align 8
  %maxstacksize = getelementptr inbounds %struct.Proto.160* %9, i32 0, i32 22
  store i8 %conv6, i8* %maxstacksize, align 1
  %10 = load %struct.LoadState** %S.addr, align 8
  %11 = load %struct.Proto.160** %f.addr, align 8
  call void @LoadCode(%struct.LoadState* %10, %struct.Proto.160* %11)
  %12 = load %struct.LoadState** %S.addr, align 8
  %13 = load %struct.Proto.160** %f.addr, align 8
  call void @LoadConstants(%struct.LoadState* %12, %struct.Proto.160* %13)
  %14 = load %struct.LoadState** %S.addr, align 8
  %15 = load %struct.Proto.160** %f.addr, align 8
  call void @LoadUpvalues(%struct.LoadState* %14, %struct.Proto.160* %15)
  %16 = load %struct.LoadState** %S.addr, align 8
  %17 = load %struct.Proto.160** %f.addr, align 8
  call void @LoadDebug(%struct.LoadState* %16, %struct.Proto.160* %17)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @LoadBlock(%struct.LoadState* %S, i8* %b, i64 %size) #0 {
entry:
  %S.addr = alloca %struct.LoadState*, align 8
  %b.addr = alloca i8*, align 8
  %size.addr = alloca i64, align 8
  store %struct.LoadState* %S, %struct.LoadState** %S.addr, align 8
  store i8* %b, i8** %b.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  %0 = load %struct.LoadState** %S.addr, align 8
  %Z = getelementptr inbounds %struct.LoadState* %0, i32 0, i32 1
  %1 = load %struct.Zio.449** %Z, align 8
  %2 = load i8** %b.addr, align 8
  %3 = load i64* %size.addr, align 8
  %call = call i64 bitcast (i64 (%struct.Zio*, i8*, i64)* @luaZ_read to i64 (%struct.Zio.449*, i8*, i64)*)(%struct.Zio.449* %1, i8* %2, i64 %3)
  %cmp = icmp ne i64 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load %struct.LoadState** %S.addr, align 8
  call void @error(%struct.LoadState* %4, i8* getelementptr inbounds ([10 x i8]* @.str5816, i32 0, i32 0)) #9
  unreachable

if.end:                                           ; preds = %entry
  ret void
}

; Function Attrs: noreturn nounwind uwtable
define internal void @error(%struct.LoadState* %S, i8* %why) #6 {
entry:
  %S.addr = alloca %struct.LoadState*, align 8
  %why.addr = alloca i8*, align 8
  store %struct.LoadState* %S, %struct.LoadState** %S.addr, align 8
  store i8* %why, i8** %why.addr, align 8
  %0 = load %struct.LoadState** %S.addr, align 8
  %L = getelementptr inbounds %struct.LoadState* %0, i32 0, i32 0
  %1 = load %struct.lua_State.154** %L, align 8
  %2 = load %struct.LoadState** %S.addr, align 8
  %name = getelementptr inbounds %struct.LoadState* %2, i32 0, i32 3
  %3 = load i8** %name, align 8
  %4 = load i8** %why.addr, align 8
  %call = call i8* (%struct.lua_State.154*, i8*, ...)* bitcast (i8* (%struct.lua_State.279*, i8*, ...)* @luaO_pushfstring to i8* (%struct.lua_State.154*, i8*, ...)*)(%struct.lua_State.154* %1, i8* getelementptr inbounds ([25 x i8]* @.str6817, i32 0, i32 0), i8* %3, i8* %4)
  %5 = load %struct.LoadState** %S.addr, align 8
  %L1 = getelementptr inbounds %struct.LoadState* %5, i32 0, i32 0
  %6 = load %struct.lua_State.154** %L1, align 8
  call void bitcast (void (%struct.lua_State*, i32)* @luaD_throw to void (%struct.lua_State.154*, i32)*)(%struct.lua_State.154* %6, i32 3) #9
  unreachable

return:                                           ; No predecessors!
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @LoadInt(%struct.LoadState* %S) #0 {
entry:
  %S.addr = alloca %struct.LoadState*, align 8
  %x = alloca i32, align 4
  store %struct.LoadState* %S, %struct.LoadState** %S.addr, align 8
  %0 = load %struct.LoadState** %S.addr, align 8
  %1 = bitcast i32* %x to i8*
  call void @LoadBlock(%struct.LoadState* %0, i8* %1, i64 4)
  %2 = load i32* %x, align 4
  %cmp = icmp slt i32 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load %struct.LoadState** %S.addr, align 8
  call void @error(%struct.LoadState* %3, i8* getelementptr inbounds ([10 x i8]* @.str7818, i32 0, i32 0)) #9
  unreachable

if.end:                                           ; preds = %entry
  %4 = load i32* %x, align 4
  ret i32 %4
}

; Function Attrs: nounwind uwtable
define internal i32 @LoadChar(%struct.LoadState* %S) #0 {
entry:
  %S.addr = alloca %struct.LoadState*, align 8
  %x = alloca i8, align 1
  store %struct.LoadState* %S, %struct.LoadState** %S.addr, align 8
  %0 = load %struct.LoadState** %S.addr, align 8
  call void @LoadBlock(%struct.LoadState* %0, i8* %x, i64 1)
  %1 = load i8* %x, align 1
  %conv = sext i8 %1 to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define internal void @LoadCode(%struct.LoadState* %S, %struct.Proto.160* %f) #0 {
entry:
  %S.addr = alloca %struct.LoadState*, align 8
  %f.addr = alloca %struct.Proto.160*, align 8
  %n = alloca i32, align 4
  store %struct.LoadState* %S, %struct.LoadState** %S.addr, align 8
  store %struct.Proto.160* %f, %struct.Proto.160** %f.addr, align 8
  %0 = load %struct.LoadState** %S.addr, align 8
  %call = call i32 @LoadInt(%struct.LoadState* %0)
  store i32 %call, i32* %n, align 4
  %1 = load i32* %n, align 4
  %add = add nsw i32 %1, 1
  %conv = sext i32 %add to i64
  %cmp = icmp ugt i64 %conv, 4611686018427387903
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load %struct.LoadState** %S.addr, align 8
  %L = getelementptr inbounds %struct.LoadState* %2, i32 0, i32 0
  %3 = load %struct.lua_State.154** %L, align 8
  call void bitcast (void (%struct.lua_State*)* @luaM_toobig to void (%struct.lua_State.154*)*)(%struct.lua_State.154* %3) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %4
  %cond = phi i32 [ 0, %4 ], [ 0, %cond.false ]
  %5 = load %struct.LoadState** %S.addr, align 8
  %L2 = getelementptr inbounds %struct.LoadState* %5, i32 0, i32 0
  %6 = load %struct.lua_State.154** %L2, align 8
  %7 = load i32* %n, align 4
  %conv3 = sext i32 %7 to i64
  %mul = mul i64 %conv3, 4
  %call4 = call i8* bitcast (i8* (%struct.lua_State*, i8*, i64, i64)* @luaM_realloc_ to i8* (%struct.lua_State.154*, i8*, i64, i64)*)(%struct.lua_State.154* %6, i8* null, i64 0, i64 %mul)
  %8 = bitcast i8* %call4 to i32*
  %9 = load %struct.Proto.160** %f.addr, align 8
  %code = getelementptr inbounds %struct.Proto.160* %9, i32 0, i32 4
  store i32* %8, i32** %code, align 8
  %10 = load i32* %n, align 4
  %11 = load %struct.Proto.160** %f.addr, align 8
  %sizecode = getelementptr inbounds %struct.Proto.160* %11, i32 0, i32 13
  store i32 %10, i32* %sizecode, align 4
  %12 = load %struct.LoadState** %S.addr, align 8
  %13 = load %struct.Proto.160** %f.addr, align 8
  %code5 = getelementptr inbounds %struct.Proto.160* %13, i32 0, i32 4
  %14 = load i32** %code5, align 8
  %15 = bitcast i32* %14 to i8*
  %16 = load i32* %n, align 4
  %conv6 = sext i32 %16 to i64
  %mul7 = mul i64 %conv6, 4
  call void @LoadBlock(%struct.LoadState* %12, i8* %15, i64 %mul7)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @LoadConstants(%struct.LoadState* %S, %struct.Proto.160* %f) #0 {
entry:
  %S.addr = alloca %struct.LoadState*, align 8
  %f.addr = alloca %struct.Proto.160*, align 8
  %i = alloca i32, align 4
  %n = alloca i32, align 4
  %o = alloca %struct.lua_TValue.137*, align 8
  %t = alloca i32, align 4
  %io = alloca %struct.lua_TValue.137*, align 8
  %io21 = alloca %struct.lua_TValue.137*, align 8
  %io27 = alloca %struct.lua_TValue.137*, align 8
  %x_ = alloca %union.TString.143*, align 8
  store %struct.LoadState* %S, %struct.LoadState** %S.addr, align 8
  store %struct.Proto.160* %f, %struct.Proto.160** %f.addr, align 8
  %0 = load %struct.LoadState** %S.addr, align 8
  %call = call i32 @LoadInt(%struct.LoadState* %0)
  store i32 %call, i32* %n, align 4
  %1 = load i32* %n, align 4
  %add = add nsw i32 %1, 1
  %conv = sext i32 %add to i64
  %cmp = icmp ugt i64 %conv, 1152921504606846975
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load %struct.LoadState** %S.addr, align 8
  %L = getelementptr inbounds %struct.LoadState* %2, i32 0, i32 0
  %3 = load %struct.lua_State.154** %L, align 8
  call void bitcast (void (%struct.lua_State*)* @luaM_toobig to void (%struct.lua_State.154*)*)(%struct.lua_State.154* %3) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %4
  %cond = phi i32 [ 0, %4 ], [ 0, %cond.false ]
  %5 = load %struct.LoadState** %S.addr, align 8
  %L2 = getelementptr inbounds %struct.LoadState* %5, i32 0, i32 0
  %6 = load %struct.lua_State.154** %L2, align 8
  %7 = load i32* %n, align 4
  %conv3 = sext i32 %7 to i64
  %mul = mul i64 %conv3, 16
  %call4 = call i8* bitcast (i8* (%struct.lua_State*, i8*, i64, i64)* @luaM_realloc_ to i8* (%struct.lua_State.154*, i8*, i64, i64)*)(%struct.lua_State.154* %6, i8* null, i64 0, i64 %mul)
  %8 = bitcast i8* %call4 to %struct.lua_TValue.137*
  %9 = load %struct.Proto.160** %f.addr, align 8
  %k = getelementptr inbounds %struct.Proto.160* %9, i32 0, i32 3
  store %struct.lua_TValue.137* %8, %struct.lua_TValue.137** %k, align 8
  %10 = load i32* %n, align 4
  %11 = load %struct.Proto.160** %f.addr, align 8
  %sizek = getelementptr inbounds %struct.Proto.160* %11, i32 0, i32 12
  store i32 %10, i32* %sizek, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %12 = load i32* %i, align 4
  %13 = load i32* %n, align 4
  %cmp5 = icmp slt i32 %12, %13
  br i1 %cmp5, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %14 = load i32* %i, align 4
  %idxprom = sext i32 %14 to i64
  %15 = load %struct.Proto.160** %f.addr, align 8
  %k7 = getelementptr inbounds %struct.Proto.160* %15, i32 0, i32 3
  %16 = load %struct.lua_TValue.137** %k7, align 8
  %arrayidx = getelementptr inbounds %struct.lua_TValue.137* %16, i64 %idxprom
  %tt_ = getelementptr inbounds %struct.lua_TValue.137* %arrayidx, i32 0, i32 1
  store i32 0, i32* %tt_, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %17 = load i32* %i, align 4
  %inc = add nsw i32 %17, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %i, align 4
  br label %for.cond8

for.cond8:                                        ; preds = %for.inc32, %for.end
  %18 = load i32* %i, align 4
  %19 = load i32* %n, align 4
  %cmp9 = icmp slt i32 %18, %19
  br i1 %cmp9, label %for.body11, label %for.end34

for.body11:                                       ; preds = %for.cond8
  %20 = load i32* %i, align 4
  %idxprom12 = sext i32 %20 to i64
  %21 = load %struct.Proto.160** %f.addr, align 8
  %k13 = getelementptr inbounds %struct.Proto.160* %21, i32 0, i32 3
  %22 = load %struct.lua_TValue.137** %k13, align 8
  %arrayidx14 = getelementptr inbounds %struct.lua_TValue.137* %22, i64 %idxprom12
  store %struct.lua_TValue.137* %arrayidx14, %struct.lua_TValue.137** %o, align 8
  %23 = load %struct.LoadState** %S.addr, align 8
  %call15 = call i32 @LoadChar(%struct.LoadState* %23)
  store i32 %call15, i32* %t, align 4
  %24 = load i32* %t, align 4
  switch i32 %24, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb17
    i32 3, label %sw.bb20
    i32 4, label %sw.bb26
  ]

sw.bb:                                            ; preds = %for.body11
  %25 = load %struct.lua_TValue.137** %o, align 8
  %tt_16 = getelementptr inbounds %struct.lua_TValue.137* %25, i32 0, i32 1
  store i32 0, i32* %tt_16, align 4
  br label %sw.epilog

sw.bb17:                                          ; preds = %for.body11
  %26 = load %struct.lua_TValue.137** %o, align 8
  store %struct.lua_TValue.137* %26, %struct.lua_TValue.137** %io, align 8
  %27 = load %struct.LoadState** %S.addr, align 8
  %call18 = call i32 @LoadChar(%struct.LoadState* %27)
  %28 = load %struct.lua_TValue.137** %io, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue.137* %28, i32 0, i32 0
  %b = bitcast %union.Value.136* %value_ to i32*
  store i32 %call18, i32* %b, align 4
  %29 = load %struct.lua_TValue.137** %io, align 8
  %tt_19 = getelementptr inbounds %struct.lua_TValue.137* %29, i32 0, i32 1
  store i32 1, i32* %tt_19, align 4
  br label %sw.epilog

sw.bb20:                                          ; preds = %for.body11
  %30 = load %struct.lua_TValue.137** %o, align 8
  store %struct.lua_TValue.137* %30, %struct.lua_TValue.137** %io21, align 8
  %31 = load %struct.LoadState** %S.addr, align 8
  %call22 = call double @LoadNumber(%struct.LoadState* %31)
  %32 = load %struct.lua_TValue.137** %io21, align 8
  %value_23 = getelementptr inbounds %struct.lua_TValue.137* %32, i32 0, i32 0
  %n24 = bitcast %union.Value.136* %value_23 to double*
  store double %call22, double* %n24, align 8
  %33 = load %struct.lua_TValue.137** %io21, align 8
  %tt_25 = getelementptr inbounds %struct.lua_TValue.137* %33, i32 0, i32 1
  store i32 3, i32* %tt_25, align 4
  br label %sw.epilog

sw.bb26:                                          ; preds = %for.body11
  %34 = load %struct.lua_TValue.137** %o, align 8
  store %struct.lua_TValue.137* %34, %struct.lua_TValue.137** %io27, align 8
  %35 = load %struct.LoadState** %S.addr, align 8
  %call28 = call %union.TString.143* @LoadString(%struct.LoadState* %35)
  store %union.TString.143* %call28, %union.TString.143** %x_, align 8
  %36 = load %union.TString.143** %x_, align 8
  %37 = bitcast %union.TString.143* %36 to %union.GCObject.155*
  %38 = load %struct.lua_TValue.137** %io27, align 8
  %value_29 = getelementptr inbounds %struct.lua_TValue.137* %38, i32 0, i32 0
  %gc = bitcast %union.Value.136* %value_29 to %union.GCObject.155**
  store %union.GCObject.155* %37, %union.GCObject.155** %gc, align 8
  %39 = load %union.TString.143** %x_, align 8
  %tsv = bitcast %union.TString.143* %39 to %struct.anon.0.142*
  %tt = getelementptr inbounds %struct.anon.0.142* %tsv, i32 0, i32 1
  %40 = load i8* %tt, align 1
  %conv30 = zext i8 %40 to i32
  %or = or i32 %conv30, 64
  %41 = load %struct.lua_TValue.137** %io27, align 8
  %tt_31 = getelementptr inbounds %struct.lua_TValue.137* %41, i32 0, i32 1
  store i32 %or, i32* %tt_31, align 4
  br label %sw.epilog

sw.default:                                       ; preds = %for.body11
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb26, %sw.bb20, %sw.bb17, %sw.bb
  br label %for.inc32

for.inc32:                                        ; preds = %sw.epilog
  %42 = load i32* %i, align 4
  %inc33 = add nsw i32 %42, 1
  store i32 %inc33, i32* %i, align 4
  br label %for.cond8

for.end34:                                        ; preds = %for.cond8
  %43 = load %struct.LoadState** %S.addr, align 8
  %call35 = call i32 @LoadInt(%struct.LoadState* %43)
  store i32 %call35, i32* %n, align 4
  %44 = load i32* %n, align 4
  %add36 = add nsw i32 %44, 1
  %conv37 = sext i32 %add36 to i64
  %cmp38 = icmp ugt i64 %conv37, 2305843009213693951
  br i1 %cmp38, label %cond.true40, label %cond.false42

cond.true40:                                      ; preds = %for.end34
  %45 = load %struct.LoadState** %S.addr, align 8
  %L41 = getelementptr inbounds %struct.LoadState* %45, i32 0, i32 0
  %46 = load %struct.lua_State.154** %L41, align 8
  call void bitcast (void (%struct.lua_State*)* @luaM_toobig to void (%struct.lua_State.154*)*)(%struct.lua_State.154* %46) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end43

cond.false42:                                     ; preds = %for.end34
  br label %cond.end43

cond.end43:                                       ; preds = %cond.false42, %47
  %cond44 = phi i32 [ 0, %47 ], [ 0, %cond.false42 ]
  %48 = load %struct.LoadState** %S.addr, align 8
  %L45 = getelementptr inbounds %struct.LoadState* %48, i32 0, i32 0
  %49 = load %struct.lua_State.154** %L45, align 8
  %50 = load i32* %n, align 4
  %conv46 = sext i32 %50 to i64
  %mul47 = mul i64 %conv46, 8
  %call48 = call i8* bitcast (i8* (%struct.lua_State*, i8*, i64, i64)* @luaM_realloc_ to i8* (%struct.lua_State.154*, i8*, i64, i64)*)(%struct.lua_State.154* %49, i8* null, i64 0, i64 %mul47)
  %51 = bitcast i8* %call48 to %struct.Proto.160**
  %52 = load %struct.Proto.160** %f.addr, align 8
  %p = getelementptr inbounds %struct.Proto.160* %52, i32 0, i32 5
  store %struct.Proto.160** %51, %struct.Proto.160*** %p, align 8
  %53 = load i32* %n, align 4
  %54 = load %struct.Proto.160** %f.addr, align 8
  %sizep = getelementptr inbounds %struct.Proto.160* %54, i32 0, i32 15
  store i32 %53, i32* %sizep, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond49

for.cond49:                                       ; preds = %for.inc56, %cond.end43
  %55 = load i32* %i, align 4
  %56 = load i32* %n, align 4
  %cmp50 = icmp slt i32 %55, %56
  br i1 %cmp50, label %for.body52, label %for.end58

for.body52:                                       ; preds = %for.cond49
  %57 = load i32* %i, align 4
  %idxprom53 = sext i32 %57 to i64
  %58 = load %struct.Proto.160** %f.addr, align 8
  %p54 = getelementptr inbounds %struct.Proto.160* %58, i32 0, i32 5
  %59 = load %struct.Proto.160*** %p54, align 8
  %arrayidx55 = getelementptr inbounds %struct.Proto.160** %59, i64 %idxprom53
  store %struct.Proto.160* null, %struct.Proto.160** %arrayidx55, align 8
  br label %for.inc56

for.inc56:                                        ; preds = %for.body52
  %60 = load i32* %i, align 4
  %inc57 = add nsw i32 %60, 1
  store i32 %inc57, i32* %i, align 4
  br label %for.cond49

for.end58:                                        ; preds = %for.cond49
  store i32 0, i32* %i, align 4
  br label %for.cond59

for.cond59:                                       ; preds = %for.inc71, %for.end58
  %61 = load i32* %i, align 4
  %62 = load i32* %n, align 4
  %cmp60 = icmp slt i32 %61, %62
  br i1 %cmp60, label %for.body62, label %for.end73

for.body62:                                       ; preds = %for.cond59
  %63 = load %struct.LoadState** %S.addr, align 8
  %L63 = getelementptr inbounds %struct.LoadState* %63, i32 0, i32 0
  %64 = load %struct.lua_State.154** %L63, align 8
  %call64 = call %struct.Proto.160* @luaF_newproto(%struct.lua_State.154* %64)
  %65 = load i32* %i, align 4
  %idxprom65 = sext i32 %65 to i64
  %66 = load %struct.Proto.160** %f.addr, align 8
  %p66 = getelementptr inbounds %struct.Proto.160* %66, i32 0, i32 5
  %67 = load %struct.Proto.160*** %p66, align 8
  %arrayidx67 = getelementptr inbounds %struct.Proto.160** %67, i64 %idxprom65
  store %struct.Proto.160* %call64, %struct.Proto.160** %arrayidx67, align 8
  %68 = load %struct.LoadState** %S.addr, align 8
  %69 = load i32* %i, align 4
  %idxprom68 = sext i32 %69 to i64
  %70 = load %struct.Proto.160** %f.addr, align 8
  %p69 = getelementptr inbounds %struct.Proto.160* %70, i32 0, i32 5
  %71 = load %struct.Proto.160*** %p69, align 8
  %arrayidx70 = getelementptr inbounds %struct.Proto.160** %71, i64 %idxprom68
  %72 = load %struct.Proto.160** %arrayidx70, align 8
  call void @LoadFunction(%struct.LoadState* %68, %struct.Proto.160* %72)
  br label %for.inc71

for.inc71:                                        ; preds = %for.body62
  %73 = load i32* %i, align 4
  %inc72 = add nsw i32 %73, 1
  store i32 %inc72, i32* %i, align 4
  br label %for.cond59

for.end73:                                        ; preds = %for.cond59
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @LoadUpvalues(%struct.LoadState* %S, %struct.Proto.160* %f) #0 {
entry:
  %S.addr = alloca %struct.LoadState*, align 8
  %f.addr = alloca %struct.Proto.160*, align 8
  %i = alloca i32, align 4
  %n = alloca i32, align 4
  store %struct.LoadState* %S, %struct.LoadState** %S.addr, align 8
  store %struct.Proto.160* %f, %struct.Proto.160** %f.addr, align 8
  %0 = load %struct.LoadState** %S.addr, align 8
  %call = call i32 @LoadInt(%struct.LoadState* %0)
  store i32 %call, i32* %n, align 4
  %1 = load i32* %n, align 4
  %add = add nsw i32 %1, 1
  %conv = sext i32 %add to i64
  %cmp = icmp ugt i64 %conv, 1152921504606846975
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load %struct.LoadState** %S.addr, align 8
  %L = getelementptr inbounds %struct.LoadState* %2, i32 0, i32 0
  %3 = load %struct.lua_State.154** %L, align 8
  call void bitcast (void (%struct.lua_State*)* @luaM_toobig to void (%struct.lua_State.154*)*)(%struct.lua_State.154* %3) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %4
  %cond = phi i32 [ 0, %4 ], [ 0, %cond.false ]
  %5 = load %struct.LoadState** %S.addr, align 8
  %L2 = getelementptr inbounds %struct.LoadState* %5, i32 0, i32 0
  %6 = load %struct.lua_State.154** %L2, align 8
  %7 = load i32* %n, align 4
  %conv3 = sext i32 %7 to i64
  %mul = mul i64 %conv3, 16
  %call4 = call i8* bitcast (i8* (%struct.lua_State*, i8*, i64, i64)* @luaM_realloc_ to i8* (%struct.lua_State.154*, i8*, i64, i64)*)(%struct.lua_State.154* %6, i8* null, i64 0, i64 %mul)
  %8 = bitcast i8* %call4 to %struct.Upvaldesc.159*
  %9 = load %struct.Proto.160** %f.addr, align 8
  %upvalues = getelementptr inbounds %struct.Proto.160* %9, i32 0, i32 8
  store %struct.Upvaldesc.159* %8, %struct.Upvaldesc.159** %upvalues, align 8
  %10 = load i32* %n, align 4
  %11 = load %struct.Proto.160** %f.addr, align 8
  %sizeupvalues = getelementptr inbounds %struct.Proto.160* %11, i32 0, i32 11
  store i32 %10, i32* %sizeupvalues, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %12 = load i32* %i, align 4
  %13 = load i32* %n, align 4
  %cmp5 = icmp slt i32 %12, %13
  br i1 %cmp5, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %14 = load i32* %i, align 4
  %idxprom = sext i32 %14 to i64
  %15 = load %struct.Proto.160** %f.addr, align 8
  %upvalues7 = getelementptr inbounds %struct.Proto.160* %15, i32 0, i32 8
  %16 = load %struct.Upvaldesc.159** %upvalues7, align 8
  %arrayidx = getelementptr inbounds %struct.Upvaldesc.159* %16, i64 %idxprom
  %name = getelementptr inbounds %struct.Upvaldesc.159* %arrayidx, i32 0, i32 0
  store %union.TString.143* null, %union.TString.143** %name, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %17 = load i32* %i, align 4
  %inc = add nsw i32 %17, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %i, align 4
  br label %for.cond8

for.cond8:                                        ; preds = %for.inc22, %for.end
  %18 = load i32* %i, align 4
  %19 = load i32* %n, align 4
  %cmp9 = icmp slt i32 %18, %19
  br i1 %cmp9, label %for.body11, label %for.end24

for.body11:                                       ; preds = %for.cond8
  %20 = load %struct.LoadState** %S.addr, align 8
  %call12 = call i32 @LoadChar(%struct.LoadState* %20)
  %conv13 = trunc i32 %call12 to i8
  %21 = load i32* %i, align 4
  %idxprom14 = sext i32 %21 to i64
  %22 = load %struct.Proto.160** %f.addr, align 8
  %upvalues15 = getelementptr inbounds %struct.Proto.160* %22, i32 0, i32 8
  %23 = load %struct.Upvaldesc.159** %upvalues15, align 8
  %arrayidx16 = getelementptr inbounds %struct.Upvaldesc.159* %23, i64 %idxprom14
  %instack = getelementptr inbounds %struct.Upvaldesc.159* %arrayidx16, i32 0, i32 1
  store i8 %conv13, i8* %instack, align 1
  %24 = load %struct.LoadState** %S.addr, align 8
  %call17 = call i32 @LoadChar(%struct.LoadState* %24)
  %conv18 = trunc i32 %call17 to i8
  %25 = load i32* %i, align 4
  %idxprom19 = sext i32 %25 to i64
  %26 = load %struct.Proto.160** %f.addr, align 8
  %upvalues20 = getelementptr inbounds %struct.Proto.160* %26, i32 0, i32 8
  %27 = load %struct.Upvaldesc.159** %upvalues20, align 8
  %arrayidx21 = getelementptr inbounds %struct.Upvaldesc.159* %27, i64 %idxprom19
  %idx = getelementptr inbounds %struct.Upvaldesc.159* %arrayidx21, i32 0, i32 2
  store i8 %conv18, i8* %idx, align 1
  br label %for.inc22

for.inc22:                                        ; preds = %for.body11
  %28 = load i32* %i, align 4
  %inc23 = add nsw i32 %28, 1
  store i32 %inc23, i32* %i, align 4
  br label %for.cond8

for.end24:                                        ; preds = %for.cond8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @LoadDebug(%struct.LoadState* %S, %struct.Proto.160* %f) #0 {
entry:
  %S.addr = alloca %struct.LoadState*, align 8
  %f.addr = alloca %struct.Proto.160*, align 8
  %i = alloca i32, align 4
  %n = alloca i32, align 4
  store %struct.LoadState* %S, %struct.LoadState** %S.addr, align 8
  store %struct.Proto.160* %f, %struct.Proto.160** %f.addr, align 8
  %0 = load %struct.LoadState** %S.addr, align 8
  %call = call %union.TString.143* @LoadString(%struct.LoadState* %0)
  %1 = load %struct.Proto.160** %f.addr, align 8
  %source = getelementptr inbounds %struct.Proto.160* %1, i32 0, i32 10
  store %union.TString.143* %call, %union.TString.143** %source, align 8
  %2 = load %struct.LoadState** %S.addr, align 8
  %call1 = call i32 @LoadInt(%struct.LoadState* %2)
  store i32 %call1, i32* %n, align 4
  %3 = load i32* %n, align 4
  %add = add nsw i32 %3, 1
  %conv = sext i32 %add to i64
  %cmp = icmp ugt i64 %conv, 4611686018427387903
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %4 = load %struct.LoadState** %S.addr, align 8
  %L = getelementptr inbounds %struct.LoadState* %4, i32 0, i32 0
  %5 = load %struct.lua_State.154** %L, align 8
  call void bitcast (void (%struct.lua_State*)* @luaM_toobig to void (%struct.lua_State.154*)*)(%struct.lua_State.154* %5) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %6
  %cond = phi i32 [ 0, %6 ], [ 0, %cond.false ]
  %7 = load %struct.LoadState** %S.addr, align 8
  %L3 = getelementptr inbounds %struct.LoadState* %7, i32 0, i32 0
  %8 = load %struct.lua_State.154** %L3, align 8
  %9 = load i32* %n, align 4
  %conv4 = sext i32 %9 to i64
  %mul = mul i64 %conv4, 4
  %call5 = call i8* bitcast (i8* (%struct.lua_State*, i8*, i64, i64)* @luaM_realloc_ to i8* (%struct.lua_State.154*, i8*, i64, i64)*)(%struct.lua_State.154* %8, i8* null, i64 0, i64 %mul)
  %10 = bitcast i8* %call5 to i32*
  %11 = load %struct.Proto.160** %f.addr, align 8
  %lineinfo = getelementptr inbounds %struct.Proto.160* %11, i32 0, i32 6
  store i32* %10, i32** %lineinfo, align 8
  %12 = load i32* %n, align 4
  %13 = load %struct.Proto.160** %f.addr, align 8
  %sizelineinfo = getelementptr inbounds %struct.Proto.160* %13, i32 0, i32 14
  store i32 %12, i32* %sizelineinfo, align 4
  %14 = load %struct.LoadState** %S.addr, align 8
  %15 = load %struct.Proto.160** %f.addr, align 8
  %lineinfo6 = getelementptr inbounds %struct.Proto.160* %15, i32 0, i32 6
  %16 = load i32** %lineinfo6, align 8
  %17 = bitcast i32* %16 to i8*
  %18 = load i32* %n, align 4
  %conv7 = sext i32 %18 to i64
  %mul8 = mul i64 %conv7, 4
  call void @LoadBlock(%struct.LoadState* %14, i8* %17, i64 %mul8)
  %19 = load %struct.LoadState** %S.addr, align 8
  %call9 = call i32 @LoadInt(%struct.LoadState* %19)
  store i32 %call9, i32* %n, align 4
  %20 = load i32* %n, align 4
  %add10 = add nsw i32 %20, 1
  %conv11 = sext i32 %add10 to i64
  %cmp12 = icmp ugt i64 %conv11, 1152921504606846975
  br i1 %cmp12, label %cond.true14, label %cond.false16

cond.true14:                                      ; preds = %cond.end
  %21 = load %struct.LoadState** %S.addr, align 8
  %L15 = getelementptr inbounds %struct.LoadState* %21, i32 0, i32 0
  %22 = load %struct.lua_State.154** %L15, align 8
  call void bitcast (void (%struct.lua_State*)* @luaM_toobig to void (%struct.lua_State.154*)*)(%struct.lua_State.154* %22) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end17

cond.false16:                                     ; preds = %cond.end
  br label %cond.end17

cond.end17:                                       ; preds = %cond.false16, %23
  %cond18 = phi i32 [ 0, %23 ], [ 0, %cond.false16 ]
  %24 = load %struct.LoadState** %S.addr, align 8
  %L19 = getelementptr inbounds %struct.LoadState* %24, i32 0, i32 0
  %25 = load %struct.lua_State.154** %L19, align 8
  %26 = load i32* %n, align 4
  %conv20 = sext i32 %26 to i64
  %mul21 = mul i64 %conv20, 16
  %call22 = call i8* bitcast (i8* (%struct.lua_State*, i8*, i64, i64)* @luaM_realloc_ to i8* (%struct.lua_State.154*, i8*, i64, i64)*)(%struct.lua_State.154* %25, i8* null, i64 0, i64 %mul21)
  %27 = bitcast i8* %call22 to %struct.LocVar.158*
  %28 = load %struct.Proto.160** %f.addr, align 8
  %locvars = getelementptr inbounds %struct.Proto.160* %28, i32 0, i32 7
  store %struct.LocVar.158* %27, %struct.LocVar.158** %locvars, align 8
  %29 = load i32* %n, align 4
  %30 = load %struct.Proto.160** %f.addr, align 8
  %sizelocvars = getelementptr inbounds %struct.Proto.160* %30, i32 0, i32 16
  store i32 %29, i32* %sizelocvars, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end17
  %31 = load i32* %i, align 4
  %32 = load i32* %n, align 4
  %cmp23 = icmp slt i32 %31, %32
  br i1 %cmp23, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %33 = load i32* %i, align 4
  %idxprom = sext i32 %33 to i64
  %34 = load %struct.Proto.160** %f.addr, align 8
  %locvars25 = getelementptr inbounds %struct.Proto.160* %34, i32 0, i32 7
  %35 = load %struct.LocVar.158** %locvars25, align 8
  %arrayidx = getelementptr inbounds %struct.LocVar.158* %35, i64 %idxprom
  %varname = getelementptr inbounds %struct.LocVar.158* %arrayidx, i32 0, i32 0
  store %union.TString.143* null, %union.TString.143** %varname, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %36 = load i32* %i, align 4
  %inc = add nsw i32 %36, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %i, align 4
  br label %for.cond26

for.cond26:                                       ; preds = %for.inc43, %for.end
  %37 = load i32* %i, align 4
  %38 = load i32* %n, align 4
  %cmp27 = icmp slt i32 %37, %38
  br i1 %cmp27, label %for.body29, label %for.end45

for.body29:                                       ; preds = %for.cond26
  %39 = load %struct.LoadState** %S.addr, align 8
  %call30 = call %union.TString.143* @LoadString(%struct.LoadState* %39)
  %40 = load i32* %i, align 4
  %idxprom31 = sext i32 %40 to i64
  %41 = load %struct.Proto.160** %f.addr, align 8
  %locvars32 = getelementptr inbounds %struct.Proto.160* %41, i32 0, i32 7
  %42 = load %struct.LocVar.158** %locvars32, align 8
  %arrayidx33 = getelementptr inbounds %struct.LocVar.158* %42, i64 %idxprom31
  %varname34 = getelementptr inbounds %struct.LocVar.158* %arrayidx33, i32 0, i32 0
  store %union.TString.143* %call30, %union.TString.143** %varname34, align 8
  %43 = load %struct.LoadState** %S.addr, align 8
  %call35 = call i32 @LoadInt(%struct.LoadState* %43)
  %44 = load i32* %i, align 4
  %idxprom36 = sext i32 %44 to i64
  %45 = load %struct.Proto.160** %f.addr, align 8
  %locvars37 = getelementptr inbounds %struct.Proto.160* %45, i32 0, i32 7
  %46 = load %struct.LocVar.158** %locvars37, align 8
  %arrayidx38 = getelementptr inbounds %struct.LocVar.158* %46, i64 %idxprom36
  %startpc = getelementptr inbounds %struct.LocVar.158* %arrayidx38, i32 0, i32 1
  store i32 %call35, i32* %startpc, align 4
  %47 = load %struct.LoadState** %S.addr, align 8
  %call39 = call i32 @LoadInt(%struct.LoadState* %47)
  %48 = load i32* %i, align 4
  %idxprom40 = sext i32 %48 to i64
  %49 = load %struct.Proto.160** %f.addr, align 8
  %locvars41 = getelementptr inbounds %struct.Proto.160* %49, i32 0, i32 7
  %50 = load %struct.LocVar.158** %locvars41, align 8
  %arrayidx42 = getelementptr inbounds %struct.LocVar.158* %50, i64 %idxprom40
  %endpc = getelementptr inbounds %struct.LocVar.158* %arrayidx42, i32 0, i32 2
  store i32 %call39, i32* %endpc, align 4
  br label %for.inc43

for.inc43:                                        ; preds = %for.body29
  %51 = load i32* %i, align 4
  %inc44 = add nsw i32 %51, 1
  store i32 %inc44, i32* %i, align 4
  br label %for.cond26

for.end45:                                        ; preds = %for.cond26
  %52 = load %struct.LoadState** %S.addr, align 8
  %call46 = call i32 @LoadInt(%struct.LoadState* %52)
  store i32 %call46, i32* %n, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond47

for.cond47:                                       ; preds = %for.inc54, %for.end45
  %53 = load i32* %i, align 4
  %54 = load i32* %n, align 4
  %cmp48 = icmp slt i32 %53, %54
  br i1 %cmp48, label %for.body50, label %for.end56

for.body50:                                       ; preds = %for.cond47
  %55 = load %struct.LoadState** %S.addr, align 8
  %call51 = call %union.TString.143* @LoadString(%struct.LoadState* %55)
  %56 = load i32* %i, align 4
  %idxprom52 = sext i32 %56 to i64
  %57 = load %struct.Proto.160** %f.addr, align 8
  %upvalues = getelementptr inbounds %struct.Proto.160* %57, i32 0, i32 8
  %58 = load %struct.Upvaldesc.159** %upvalues, align 8
  %arrayidx53 = getelementptr inbounds %struct.Upvaldesc.159* %58, i64 %idxprom52
  %name = getelementptr inbounds %struct.Upvaldesc.159* %arrayidx53, i32 0, i32 0
  store %union.TString.143* %call51, %union.TString.143** %name, align 8
  br label %for.inc54

for.inc54:                                        ; preds = %for.body50
  %59 = load i32* %i, align 4
  %inc55 = add nsw i32 %59, 1
  store i32 %inc55, i32* %i, align 4
  br label %for.cond47

for.end56:                                        ; preds = %for.cond47
  ret void
}

; Function Attrs: nounwind uwtable
define internal double @LoadNumber(%struct.LoadState* %S) #0 {
entry:
  %S.addr = alloca %struct.LoadState*, align 8
  %x = alloca double, align 8
  store %struct.LoadState* %S, %struct.LoadState** %S.addr, align 8
  %0 = load %struct.LoadState** %S.addr, align 8
  %1 = bitcast double* %x to i8*
  call void @LoadBlock(%struct.LoadState* %0, i8* %1, i64 8)
  %2 = load double* %x, align 8
  ret double %2
}

; Function Attrs: nounwind uwtable
define internal %union.TString.143* @LoadString(%struct.LoadState* %S) #0 {
entry:
  %retval = alloca %union.TString.143*, align 8
  %S.addr = alloca %struct.LoadState*, align 8
  %size = alloca i64, align 8
  %s = alloca i8*, align 8
  store %struct.LoadState* %S, %struct.LoadState** %S.addr, align 8
  %0 = load %struct.LoadState** %S.addr, align 8
  %1 = bitcast i64* %size to i8*
  call void @LoadBlock(%struct.LoadState* %0, i8* %1, i64 8)
  %2 = load i64* %size, align 8
  %cmp = icmp eq i64 %2, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store %union.TString.143* null, %union.TString.143** %retval
  br label %return

if.else:                                          ; preds = %entry
  %3 = load %struct.LoadState** %S.addr, align 8
  %L = getelementptr inbounds %struct.LoadState* %3, i32 0, i32 0
  %4 = load %struct.lua_State.154** %L, align 8
  %5 = load %struct.LoadState** %S.addr, align 8
  %b = getelementptr inbounds %struct.LoadState* %5, i32 0, i32 2
  %6 = load %struct.Mbuffer** %b, align 8
  %7 = load i64* %size, align 8
  %call = call i8* bitcast (i8* (%struct.lua_State*, %struct.Mbuffer*, i64)* @luaZ_openspace to i8* (%struct.lua_State.154*, %struct.Mbuffer*, i64)*)(%struct.lua_State.154* %4, %struct.Mbuffer* %6, i64 %7)
  store i8* %call, i8** %s, align 8
  %8 = load %struct.LoadState** %S.addr, align 8
  %9 = load i8** %s, align 8
  %10 = load i64* %size, align 8
  %mul = mul i64 %10, 1
  call void @LoadBlock(%struct.LoadState* %8, i8* %9, i64 %mul)
  %11 = load %struct.LoadState** %S.addr, align 8
  %L1 = getelementptr inbounds %struct.LoadState* %11, i32 0, i32 0
  %12 = load %struct.lua_State.154** %L1, align 8
  %13 = load i8** %s, align 8
  %14 = load i64* %size, align 8
  %sub = sub i64 %14, 1
  %call2 = call %union.TString.143* bitcast (%union.TString.367* (%struct.lua_State.364*, i8*, i64)* @luaS_newlstr to %union.TString.143* (%struct.lua_State.154*, i8*, i64)*)(%struct.lua_State.154* %12, i8* %13, i64 %sub)
  store %union.TString.143* %call2, %union.TString.143** %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %15 = load %union.TString.143** %retval
  ret %union.TString.143* %15
}

; Function Attrs: nounwind uwtable
define hidden %struct.lua_TValue.349* @luaV_tonumber(%struct.lua_TValue.349* %obj, %struct.lua_TValue.349* %n) #0 {
entry:
  %retval = alloca %struct.lua_TValue.349*, align 8
  %obj.addr = alloca %struct.lua_TValue.349*, align 8
  %n.addr = alloca %struct.lua_TValue.349*, align 8
  %num = alloca double, align 8
  %io = alloca %struct.lua_TValue.349*, align 8
  store %struct.lua_TValue.349* %obj, %struct.lua_TValue.349** %obj.addr, align 8
  store %struct.lua_TValue.349* %n, %struct.lua_TValue.349** %n.addr, align 8
  %0 = load %struct.lua_TValue.349** %obj.addr, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue.349* %0, i32 0, i32 1
  %1 = load i32* %tt_, align 4
  %cmp = icmp eq i32 %1, 3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.lua_TValue.349** %obj.addr, align 8
  store %struct.lua_TValue.349* %2, %struct.lua_TValue.349** %retval
  br label %return

if.end:                                           ; preds = %entry
  %3 = load %struct.lua_TValue.349** %obj.addr, align 8
  %tt_1 = getelementptr inbounds %struct.lua_TValue.349* %3, i32 0, i32 1
  %4 = load i32* %tt_1, align 4
  %and = and i32 %4, 15
  %cmp2 = icmp eq i32 %and, 4
  br i1 %cmp2, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.end
  %5 = load %struct.lua_TValue.349** %obj.addr, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue.349* %5, i32 0, i32 0
  %gc = bitcast %union.Value.348* %value_ to %union.GCObject.365**
  %6 = load %union.GCObject.365** %gc, align 8
  %ts = bitcast %union.GCObject.365* %6 to %union.TString.367*
  %add.ptr = getelementptr inbounds %union.TString.367* %ts, i64 1
  %7 = bitcast %union.TString.367* %add.ptr to i8*
  %8 = load %struct.lua_TValue.349** %obj.addr, align 8
  %value_3 = getelementptr inbounds %struct.lua_TValue.349* %8, i32 0, i32 0
  %gc4 = bitcast %union.Value.348* %value_3 to %union.GCObject.365**
  %9 = load %union.GCObject.365** %gc4, align 8
  %ts5 = bitcast %union.GCObject.365* %9 to %union.TString.367*
  %tsv = bitcast %union.TString.367* %ts5 to %struct.anon.366*
  %len = getelementptr inbounds %struct.anon.366* %tsv, i32 0, i32 5
  %10 = load i64* %len, align 8
  %call = call i32 @luaO_str2d(i8* %7, i64 %10, double* %num)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then6, label %if.else

if.then6:                                         ; preds = %land.lhs.true
  %11 = load %struct.lua_TValue.349** %n.addr, align 8
  store %struct.lua_TValue.349* %11, %struct.lua_TValue.349** %io, align 8
  %12 = load double* %num, align 8
  %13 = load %struct.lua_TValue.349** %io, align 8
  %value_7 = getelementptr inbounds %struct.lua_TValue.349* %13, i32 0, i32 0
  %n8 = bitcast %union.Value.348* %value_7 to double*
  store double %12, double* %n8, align 8
  %14 = load %struct.lua_TValue.349** %io, align 8
  %tt_9 = getelementptr inbounds %struct.lua_TValue.349* %14, i32 0, i32 1
  store i32 3, i32* %tt_9, align 4
  %15 = load %struct.lua_TValue.349** %n.addr, align 8
  store %struct.lua_TValue.349* %15, %struct.lua_TValue.349** %retval
  br label %return

if.else:                                          ; preds = %land.lhs.true, %if.end
  store %struct.lua_TValue.349* null, %struct.lua_TValue.349** %retval
  br label %return

return:                                           ; preds = %if.else, %if.then6, %if.then
  %16 = load %struct.lua_TValue.349** %retval
  ret %struct.lua_TValue.349* %16
}

; Function Attrs: nounwind uwtable
define hidden i32 @luaV_tostring(%struct.lua_State.364* %L, %struct.lua_TValue.349* %obj) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State.364*, align 8
  %obj.addr = alloca %struct.lua_TValue.349*, align 8
  %s = alloca [32 x i8], align 16
  %n = alloca double, align 8
  %l = alloca i32, align 4
  %io = alloca %struct.lua_TValue.349*, align 8
  %x_ = alloca %union.TString.367*, align 8
  store %struct.lua_State.364* %L, %struct.lua_State.364** %L.addr, align 8
  store %struct.lua_TValue.349* %obj, %struct.lua_TValue.349** %obj.addr, align 8
  %0 = load %struct.lua_TValue.349** %obj.addr, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue.349* %0, i32 0, i32 1
  %1 = load i32* %tt_, align 4
  %cmp = icmp eq i32 %1, 3
  br i1 %cmp, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval
  br label %return

if.else:                                          ; preds = %entry
  %2 = load %struct.lua_TValue.349** %obj.addr, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue.349* %2, i32 0, i32 0
  %n1 = bitcast %union.Value.348* %value_ to double*
  %3 = load double* %n1, align 8
  store double %3, double* %n, align 8
  %arraydecay = getelementptr inbounds [32 x i8]* %s, i32 0, i32 0
  %4 = load double* %n, align 8
  %call = call i32 (i8*, i8*, ...)* @sprintf(i8* %arraydecay, i8* getelementptr inbounds ([6 x i8]* @.str826, i32 0, i32 0), double %4) #1
  store i32 %call, i32* %l, align 4
  %5 = load %struct.lua_TValue.349** %obj.addr, align 8
  store %struct.lua_TValue.349* %5, %struct.lua_TValue.349** %io, align 8
  %6 = load %struct.lua_State.364** %L.addr, align 8
  %arraydecay2 = getelementptr inbounds [32 x i8]* %s, i32 0, i32 0
  %7 = load i32* %l, align 4
  %conv = sext i32 %7 to i64
  %call3 = call %union.TString.367* @luaS_newlstr(%struct.lua_State.364* %6, i8* %arraydecay2, i64 %conv)
  store %union.TString.367* %call3, %union.TString.367** %x_, align 8
  %8 = load %union.TString.367** %x_, align 8
  %9 = bitcast %union.TString.367* %8 to %union.GCObject.365*
  %10 = load %struct.lua_TValue.349** %io, align 8
  %value_4 = getelementptr inbounds %struct.lua_TValue.349* %10, i32 0, i32 0
  %gc = bitcast %union.Value.348* %value_4 to %union.GCObject.365**
  store %union.GCObject.365* %9, %union.GCObject.365** %gc, align 8
  %11 = load %union.TString.367** %x_, align 8
  %tsv = bitcast %union.TString.367* %11 to %struct.anon.366*
  %tt = getelementptr inbounds %struct.anon.366* %tsv, i32 0, i32 1
  %12 = load i8* %tt, align 1
  %conv5 = zext i8 %12 to i32
  %or = or i32 %conv5, 64
  %13 = load %struct.lua_TValue.349** %io, align 8
  %tt_6 = getelementptr inbounds %struct.lua_TValue.349* %13, i32 0, i32 1
  store i32 %or, i32* %tt_6, align 4
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %14 = load i32* %retval
  ret i32 %14
}

; Function Attrs: nounwind uwtable
define hidden void @luaV_gettable(%struct.lua_State.364* %L, %struct.lua_TValue.349* %t, %struct.lua_TValue.349* %key, %struct.lua_TValue.349* %val) #0 {
entry:
  %L.addr = alloca %struct.lua_State.364*, align 8
  %t.addr = alloca %struct.lua_TValue.349*, align 8
  %key.addr = alloca %struct.lua_TValue.349*, align 8
  %val.addr = alloca %struct.lua_TValue.349*, align 8
  %loop = alloca i32, align 4
  %tm = alloca %struct.lua_TValue.349*, align 8
  %h = alloca %struct.Table.357*, align 8
  %res = alloca %struct.lua_TValue.349*, align 8
  %io2 = alloca %struct.lua_TValue.349*, align 8
  %io1 = alloca %struct.lua_TValue.349*, align 8
  store %struct.lua_State.364* %L, %struct.lua_State.364** %L.addr, align 8
  store %struct.lua_TValue.349* %t, %struct.lua_TValue.349** %t.addr, align 8
  store %struct.lua_TValue.349* %key, %struct.lua_TValue.349** %key.addr, align 8
  store %struct.lua_TValue.349* %val, %struct.lua_TValue.349** %val.addr, align 8
  store i32 0, i32* %loop, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32* %loop, align 4
  %cmp = icmp slt i32 %0, 100
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load %struct.lua_TValue.349** %t.addr, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue.349* %1, i32 0, i32 1
  %2 = load i32* %tt_, align 4
  %cmp1 = icmp eq i32 %2, 69
  br i1 %cmp1, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %3 = load %struct.lua_TValue.349** %t.addr, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue.349* %3, i32 0, i32 0
  %gc = bitcast %union.Value.348* %value_ to %union.GCObject.365**
  %4 = load %union.GCObject.365** %gc, align 8
  %h2 = bitcast %union.GCObject.365* %4 to %struct.Table.357*
  store %struct.Table.357* %h2, %struct.Table.357** %h, align 8
  %5 = load %struct.Table.357** %h, align 8
  %6 = load %struct.lua_TValue.349** %key.addr, align 8
  %call = call %struct.lua_TValue.349* bitcast (%struct.lua_TValue* (%struct.Table*, %struct.lua_TValue*)* @luaH_get to %struct.lua_TValue.349* (%struct.Table.357*, %struct.lua_TValue.349*)*)(%struct.Table.357* %5, %struct.lua_TValue.349* %6)
  store %struct.lua_TValue.349* %call, %struct.lua_TValue.349** %res, align 8
  %7 = load %struct.lua_TValue.349** %res, align 8
  %tt_3 = getelementptr inbounds %struct.lua_TValue.349* %7, i32 0, i32 1
  %8 = load i32* %tt_3, align 4
  %cmp4 = icmp eq i32 %8, 0
  br i1 %cmp4, label %lor.lhs.false, label %if.then15

lor.lhs.false:                                    ; preds = %if.then
  %9 = load %struct.Table.357** %h, align 8
  %metatable = getelementptr inbounds %struct.Table.357* %9, i32 0, i32 5
  %10 = load %struct.Table.357** %metatable, align 8
  %cmp5 = icmp eq %struct.Table.357* %10, null
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %lor.lhs.false
  br label %cond.end11

cond.false:                                       ; preds = %lor.lhs.false
  %11 = load %struct.Table.357** %h, align 8
  %metatable6 = getelementptr inbounds %struct.Table.357* %11, i32 0, i32 5
  %12 = load %struct.Table.357** %metatable6, align 8
  %flags = getelementptr inbounds %struct.Table.357* %12, i32 0, i32 3
  %13 = load i8* %flags, align 1
  %conv = zext i8 %13 to i32
  %and = and i32 %conv, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true7, label %cond.false8

cond.true7:                                       ; preds = %cond.false
  br label %cond.end

cond.false8:                                      ; preds = %cond.false
  %14 = load %struct.Table.357** %h, align 8
  %metatable9 = getelementptr inbounds %struct.Table.357* %14, i32 0, i32 5
  %15 = load %struct.Table.357** %metatable9, align 8
  %16 = load %struct.lua_State.364** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State.364* %16, i32 0, i32 5
  %17 = load %struct.global_State.358** %l_G, align 8
  %tmname = getelementptr inbounds %struct.global_State.358* %17, i32 0, i32 33
  %arrayidx = getelementptr inbounds [17 x %union.TString.367*]* %tmname, i32 0, i64 0
  %18 = load %union.TString.367** %arrayidx, align 8
  %call10 = call %struct.lua_TValue.349* bitcast (%struct.lua_TValue* (%struct.Table*, i32, %union.TString*)* @luaT_gettm to %struct.lua_TValue.349* (%struct.Table.357*, i32, %union.TString.367*)*)(%struct.Table.357* %15, i32 0, %union.TString.367* %18)
  br label %cond.end

cond.end:                                         ; preds = %cond.false8, %cond.true7
  %cond = phi %struct.lua_TValue.349* [ null, %cond.true7 ], [ %call10, %cond.false8 ]
  br label %cond.end11

cond.end11:                                       ; preds = %cond.end, %cond.true
  %cond12 = phi %struct.lua_TValue.349* [ null, %cond.true ], [ %cond, %cond.end ]
  store %struct.lua_TValue.349* %cond12, %struct.lua_TValue.349** %tm, align 8
  %cmp13 = icmp eq %struct.lua_TValue.349* %cond12, null
  br i1 %cmp13, label %if.then15, label %if.end

if.then15:                                        ; preds = %cond.end11, %if.then
  %19 = load %struct.lua_TValue.349** %res, align 8
  store %struct.lua_TValue.349* %19, %struct.lua_TValue.349** %io2, align 8
  %20 = load %struct.lua_TValue.349** %val.addr, align 8
  store %struct.lua_TValue.349* %20, %struct.lua_TValue.349** %io1, align 8
  %21 = load %struct.lua_TValue.349** %io1, align 8
  %value_16 = getelementptr inbounds %struct.lua_TValue.349* %21, i32 0, i32 0
  %22 = load %struct.lua_TValue.349** %io2, align 8
  %value_17 = getelementptr inbounds %struct.lua_TValue.349* %22, i32 0, i32 0
  %23 = bitcast %union.Value.348* %value_16 to i8*
  %24 = bitcast %union.Value.348* %value_17 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %23, i8* %24, i64 8, i32 8, i1 false)
  %25 = load %struct.lua_TValue.349** %io2, align 8
  %tt_18 = getelementptr inbounds %struct.lua_TValue.349* %25, i32 0, i32 1
  %26 = load i32* %tt_18, align 4
  %27 = load %struct.lua_TValue.349** %io1, align 8
  %tt_19 = getelementptr inbounds %struct.lua_TValue.349* %27, i32 0, i32 1
  store i32 %26, i32* %tt_19, align 4
  br label %return

if.end:                                           ; preds = %cond.end11
  br label %if.end26

if.else:                                          ; preds = %for.body
  %28 = load %struct.lua_State.364** %L.addr, align 8
  %29 = load %struct.lua_TValue.349** %t.addr, align 8
  %call20 = call %struct.lua_TValue.349* bitcast (%struct.lua_TValue* (%struct.lua_State*, %struct.lua_TValue*, i32)* @luaT_gettmbyobj to %struct.lua_TValue.349* (%struct.lua_State.364*, %struct.lua_TValue.349*, i32)*)(%struct.lua_State.364* %28, %struct.lua_TValue.349* %29, i32 0)
  store %struct.lua_TValue.349* %call20, %struct.lua_TValue.349** %tm, align 8
  %tt_21 = getelementptr inbounds %struct.lua_TValue.349* %call20, i32 0, i32 1
  %30 = load i32* %tt_21, align 4
  %cmp22 = icmp eq i32 %30, 0
  br i1 %cmp22, label %if.then24, label %if.end25

if.then24:                                        ; preds = %if.else
  %31 = load %struct.lua_State.364** %L.addr, align 8
  %32 = load %struct.lua_TValue.349** %t.addr, align 8
  call void bitcast (void (%struct.lua_State*, %struct.lua_TValue*, i8*)* @luaG_typeerror to void (%struct.lua_State.364*, %struct.lua_TValue.349*, i8*)*)(%struct.lua_State.364* %31, %struct.lua_TValue.349* %32, i8* getelementptr inbounds ([6 x i8]* @.str1827, i32 0, i32 0)) #9
  unreachable

if.end25:                                         ; preds = %if.else
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %if.end
  %33 = load %struct.lua_TValue.349** %tm, align 8
  %tt_27 = getelementptr inbounds %struct.lua_TValue.349* %33, i32 0, i32 1
  %34 = load i32* %tt_27, align 4
  %and28 = and i32 %34, 15
  %cmp29 = icmp eq i32 %and28, 6
  br i1 %cmp29, label %if.then31, label %if.end32

if.then31:                                        ; preds = %if.end26
  %35 = load %struct.lua_State.364** %L.addr, align 8
  %36 = load %struct.lua_TValue.349** %tm, align 8
  %37 = load %struct.lua_TValue.349** %t.addr, align 8
  %38 = load %struct.lua_TValue.349** %key.addr, align 8
  %39 = load %struct.lua_TValue.349** %val.addr, align 8
  call void @callTM(%struct.lua_State.364* %35, %struct.lua_TValue.349* %36, %struct.lua_TValue.349* %37, %struct.lua_TValue.349* %38, %struct.lua_TValue.349* %39, i32 1)
  br label %return

if.end32:                                         ; preds = %if.end26
  %40 = load %struct.lua_TValue.349** %tm, align 8
  store %struct.lua_TValue.349* %40, %struct.lua_TValue.349** %t.addr, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end32
  %41 = load i32* %loop, align 4
  %inc = add nsw i32 %41, 1
  store i32 %inc, i32* %loop, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %42 = load %struct.lua_State.364** %L.addr, align 8
  call void (%struct.lua_State.364*, i8*, ...)* bitcast (void (%struct.lua_State*, i8*, ...)* @luaG_runerror to void (%struct.lua_State.364*, i8*, ...)*)(%struct.lua_State.364* %42, i8* getelementptr inbounds ([17 x i8]* @.str2828, i32 0, i32 0)) #9
  unreachable

return:                                           ; preds = %if.then31, %if.then15
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @luaV_settable(%struct.lua_State.364* %L, %struct.lua_TValue.349* %t, %struct.lua_TValue.349* %key, %struct.lua_TValue.349* %val) #0 {
entry:
  %L.addr = alloca %struct.lua_State.364*, align 8
  %t.addr = alloca %struct.lua_TValue.349*, align 8
  %key.addr = alloca %struct.lua_TValue.349*, align 8
  %val.addr = alloca %struct.lua_TValue.349*, align 8
  %loop = alloca i32, align 4
  %tm = alloca %struct.lua_TValue.349*, align 8
  %h = alloca %struct.Table.357*, align 8
  %oldval = alloca %struct.lua_TValue.349*, align 8
  %io2 = alloca %struct.lua_TValue.349*, align 8
  %io1 = alloca %struct.lua_TValue.349*, align 8
  store %struct.lua_State.364* %L, %struct.lua_State.364** %L.addr, align 8
  store %struct.lua_TValue.349* %t, %struct.lua_TValue.349** %t.addr, align 8
  store %struct.lua_TValue.349* %key, %struct.lua_TValue.349** %key.addr, align 8
  store %struct.lua_TValue.349* %val, %struct.lua_TValue.349** %val.addr, align 8
  store i32 0, i32* %loop, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32* %loop, align 4
  %cmp = icmp slt i32 %0, 100
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load %struct.lua_TValue.349** %t.addr, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue.349* %1, i32 0, i32 1
  %2 = load i32* %tt_, align 4
  %cmp1 = icmp eq i32 %2, 69
  br i1 %cmp1, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %3 = load %struct.lua_TValue.349** %t.addr, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue.349* %3, i32 0, i32 0
  %gc = bitcast %union.Value.348* %value_ to %union.GCObject.365**
  %4 = load %union.GCObject.365** %gc, align 8
  %h2 = bitcast %union.GCObject.365* %4 to %struct.Table.357*
  store %struct.Table.357* %h2, %struct.Table.357** %h, align 8
  %5 = load %struct.Table.357** %h, align 8
  %6 = load %struct.lua_TValue.349** %key.addr, align 8
  %call = call %struct.lua_TValue.349* bitcast (%struct.lua_TValue* (%struct.Table*, %struct.lua_TValue*)* @luaH_get to %struct.lua_TValue.349* (%struct.Table.357*, %struct.lua_TValue.349*)*)(%struct.Table.357* %5, %struct.lua_TValue.349* %6)
  store %struct.lua_TValue.349* %call, %struct.lua_TValue.349** %oldval, align 8
  %7 = load %struct.lua_TValue.349** %oldval, align 8
  %tt_3 = getelementptr inbounds %struct.lua_TValue.349* %7, i32 0, i32 1
  %8 = load i32* %tt_3, align 4
  %cmp4 = icmp eq i32 %8, 0
  br i1 %cmp4, label %lor.lhs.false, label %if.then19

lor.lhs.false:                                    ; preds = %if.then
  %9 = load %struct.Table.357** %h, align 8
  %metatable = getelementptr inbounds %struct.Table.357* %9, i32 0, i32 5
  %10 = load %struct.Table.357** %metatable, align 8
  %cmp5 = icmp eq %struct.Table.357* %10, null
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %lor.lhs.false
  br label %cond.end11

cond.false:                                       ; preds = %lor.lhs.false
  %11 = load %struct.Table.357** %h, align 8
  %metatable6 = getelementptr inbounds %struct.Table.357* %11, i32 0, i32 5
  %12 = load %struct.Table.357** %metatable6, align 8
  %flags = getelementptr inbounds %struct.Table.357* %12, i32 0, i32 3
  %13 = load i8* %flags, align 1
  %conv = zext i8 %13 to i32
  %and = and i32 %conv, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true7, label %cond.false8

cond.true7:                                       ; preds = %cond.false
  br label %cond.end

cond.false8:                                      ; preds = %cond.false
  %14 = load %struct.Table.357** %h, align 8
  %metatable9 = getelementptr inbounds %struct.Table.357* %14, i32 0, i32 5
  %15 = load %struct.Table.357** %metatable9, align 8
  %16 = load %struct.lua_State.364** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State.364* %16, i32 0, i32 5
  %17 = load %struct.global_State.358** %l_G, align 8
  %tmname = getelementptr inbounds %struct.global_State.358* %17, i32 0, i32 33
  %arrayidx = getelementptr inbounds [17 x %union.TString.367*]* %tmname, i32 0, i64 1
  %18 = load %union.TString.367** %arrayidx, align 8
  %call10 = call %struct.lua_TValue.349* bitcast (%struct.lua_TValue* (%struct.Table*, i32, %union.TString*)* @luaT_gettm to %struct.lua_TValue.349* (%struct.Table.357*, i32, %union.TString.367*)*)(%struct.Table.357* %15, i32 1, %union.TString.367* %18)
  br label %cond.end

cond.end:                                         ; preds = %cond.false8, %cond.true7
  %cond = phi %struct.lua_TValue.349* [ null, %cond.true7 ], [ %call10, %cond.false8 ]
  br label %cond.end11

cond.end11:                                       ; preds = %cond.end, %cond.true
  %cond12 = phi %struct.lua_TValue.349* [ null, %cond.true ], [ %cond, %cond.end ]
  store %struct.lua_TValue.349* %cond12, %struct.lua_TValue.349** %tm, align 8
  %cmp13 = icmp eq %struct.lua_TValue.349* %cond12, null
  br i1 %cmp13, label %land.lhs.true, label %if.end41

land.lhs.true:                                    ; preds = %cond.end11
  %19 = load %struct.lua_TValue.349** %oldval, align 8
  %cmp15 = icmp ne %struct.lua_TValue.349* %19, bitcast ({ %union.Value.281, i32, [4 x i8] }* @luaO_nilobject_ to %struct.lua_TValue.349*)
  br i1 %cmp15, label %if.then19, label %lor.lhs.false17

lor.lhs.false17:                                  ; preds = %land.lhs.true
  %20 = load %struct.lua_State.364** %L.addr, align 8
  %21 = load %struct.Table.357** %h, align 8
  %22 = load %struct.lua_TValue.349** %key.addr, align 8
  %call18 = call %struct.lua_TValue.349* bitcast (%struct.lua_TValue* (%struct.lua_State*, %struct.Table*, %struct.lua_TValue*)* @luaH_newkey to %struct.lua_TValue.349* (%struct.lua_State.364*, %struct.Table.357*, %struct.lua_TValue.349*)*)(%struct.lua_State.364* %20, %struct.Table.357* %21, %struct.lua_TValue.349* %22)
  store %struct.lua_TValue.349* %call18, %struct.lua_TValue.349** %oldval, align 8
  br i1 true, label %if.then19, label %if.end41

if.then19:                                        ; preds = %lor.lhs.false17, %land.lhs.true, %if.then
  %23 = load %struct.lua_TValue.349** %val.addr, align 8
  store %struct.lua_TValue.349* %23, %struct.lua_TValue.349** %io2, align 8
  %24 = load %struct.lua_TValue.349** %oldval, align 8
  store %struct.lua_TValue.349* %24, %struct.lua_TValue.349** %io1, align 8
  %25 = load %struct.lua_TValue.349** %io1, align 8
  %value_20 = getelementptr inbounds %struct.lua_TValue.349* %25, i32 0, i32 0
  %26 = load %struct.lua_TValue.349** %io2, align 8
  %value_21 = getelementptr inbounds %struct.lua_TValue.349* %26, i32 0, i32 0
  %27 = bitcast %union.Value.348* %value_20 to i8*
  %28 = bitcast %union.Value.348* %value_21 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %27, i8* %28, i64 8, i32 8, i1 false)
  %29 = load %struct.lua_TValue.349** %io2, align 8
  %tt_22 = getelementptr inbounds %struct.lua_TValue.349* %29, i32 0, i32 1
  %30 = load i32* %tt_22, align 4
  %31 = load %struct.lua_TValue.349** %io1, align 8
  %tt_23 = getelementptr inbounds %struct.lua_TValue.349* %31, i32 0, i32 1
  store i32 %30, i32* %tt_23, align 4
  %32 = load %struct.Table.357** %h, align 8
  %flags24 = getelementptr inbounds %struct.Table.357* %32, i32 0, i32 3
  store i8 0, i8* %flags24, align 1
  %33 = load %struct.lua_TValue.349** %val.addr, align 8
  %tt_25 = getelementptr inbounds %struct.lua_TValue.349* %33, i32 0, i32 1
  %34 = load i32* %tt_25, align 4
  %and26 = and i32 %34, 64
  %tobool27 = icmp ne i32 %and26, 0
  br i1 %tobool27, label %land.lhs.true28, label %if.end

land.lhs.true28:                                  ; preds = %if.then19
  %35 = load %struct.lua_TValue.349** %val.addr, align 8
  %value_29 = getelementptr inbounds %struct.lua_TValue.349* %35, i32 0, i32 0
  %gc30 = bitcast %union.Value.348* %value_29 to %union.GCObject.365**
  %36 = load %union.GCObject.365** %gc30, align 8
  %gch = bitcast %union.GCObject.365* %36 to %struct.GCheader.479*
  %marked = getelementptr inbounds %struct.GCheader.479* %gch, i32 0, i32 2
  %37 = load i8* %marked, align 1
  %conv31 = zext i8 %37 to i32
  %and32 = and i32 %conv31, 3
  %tobool33 = icmp ne i32 %and32, 0
  br i1 %tobool33, label %land.lhs.true34, label %if.end

land.lhs.true34:                                  ; preds = %land.lhs.true28
  %38 = load %struct.Table.357** %h, align 8
  %39 = bitcast %struct.Table.357* %38 to %union.GCObject.365*
  %gch35 = bitcast %union.GCObject.365* %39 to %struct.GCheader.479*
  %marked36 = getelementptr inbounds %struct.GCheader.479* %gch35, i32 0, i32 2
  %40 = load i8* %marked36, align 1
  %conv37 = zext i8 %40 to i32
  %and38 = and i32 %conv37, 4
  %tobool39 = icmp ne i32 %and38, 0
  br i1 %tobool39, label %if.then40, label %if.end

if.then40:                                        ; preds = %land.lhs.true34
  %41 = load %struct.lua_State.364** %L.addr, align 8
  %42 = load %struct.Table.357** %h, align 8
  %43 = bitcast %struct.Table.357* %42 to %union.GCObject.365*
  call void bitcast (void (%struct.lua_State*, %union.GCObject*)* @luaC_barrierback_ to void (%struct.lua_State.364*, %union.GCObject.365*)*)(%struct.lua_State.364* %41, %union.GCObject.365* %43)
  br label %if.end

if.end:                                           ; preds = %if.then40, %land.lhs.true34, %land.lhs.true28, %if.then19
  br label %return

if.end41:                                         ; preds = %lor.lhs.false17, %cond.end11
  br label %if.end48

if.else:                                          ; preds = %for.body
  %44 = load %struct.lua_State.364** %L.addr, align 8
  %45 = load %struct.lua_TValue.349** %t.addr, align 8
  %call42 = call %struct.lua_TValue.349* bitcast (%struct.lua_TValue* (%struct.lua_State*, %struct.lua_TValue*, i32)* @luaT_gettmbyobj to %struct.lua_TValue.349* (%struct.lua_State.364*, %struct.lua_TValue.349*, i32)*)(%struct.lua_State.364* %44, %struct.lua_TValue.349* %45, i32 1)
  store %struct.lua_TValue.349* %call42, %struct.lua_TValue.349** %tm, align 8
  %tt_43 = getelementptr inbounds %struct.lua_TValue.349* %call42, i32 0, i32 1
  %46 = load i32* %tt_43, align 4
  %cmp44 = icmp eq i32 %46, 0
  br i1 %cmp44, label %if.then46, label %if.end47

if.then46:                                        ; preds = %if.else
  %47 = load %struct.lua_State.364** %L.addr, align 8
  %48 = load %struct.lua_TValue.349** %t.addr, align 8
  call void bitcast (void (%struct.lua_State*, %struct.lua_TValue*, i8*)* @luaG_typeerror to void (%struct.lua_State.364*, %struct.lua_TValue.349*, i8*)*)(%struct.lua_State.364* %47, %struct.lua_TValue.349* %48, i8* getelementptr inbounds ([6 x i8]* @.str1827, i32 0, i32 0)) #9
  unreachable

if.end47:                                         ; preds = %if.else
  br label %if.end48

if.end48:                                         ; preds = %if.end47, %if.end41
  %49 = load %struct.lua_TValue.349** %tm, align 8
  %tt_49 = getelementptr inbounds %struct.lua_TValue.349* %49, i32 0, i32 1
  %50 = load i32* %tt_49, align 4
  %and50 = and i32 %50, 15
  %cmp51 = icmp eq i32 %and50, 6
  br i1 %cmp51, label %if.then53, label %if.end54

if.then53:                                        ; preds = %if.end48
  %51 = load %struct.lua_State.364** %L.addr, align 8
  %52 = load %struct.lua_TValue.349** %tm, align 8
  %53 = load %struct.lua_TValue.349** %t.addr, align 8
  %54 = load %struct.lua_TValue.349** %key.addr, align 8
  %55 = load %struct.lua_TValue.349** %val.addr, align 8
  call void @callTM(%struct.lua_State.364* %51, %struct.lua_TValue.349* %52, %struct.lua_TValue.349* %53, %struct.lua_TValue.349* %54, %struct.lua_TValue.349* %55, i32 0)
  br label %return

if.end54:                                         ; preds = %if.end48
  %56 = load %struct.lua_TValue.349** %tm, align 8
  store %struct.lua_TValue.349* %56, %struct.lua_TValue.349** %t.addr, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end54
  %57 = load i32* %loop, align 4
  %inc = add nsw i32 %57, 1
  store i32 %inc, i32* %loop, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %58 = load %struct.lua_State.364** %L.addr, align 8
  call void (%struct.lua_State.364*, i8*, ...)* bitcast (void (%struct.lua_State*, i8*, ...)* @luaG_runerror to void (%struct.lua_State.364*, i8*, ...)*)(%struct.lua_State.364* %58, i8* getelementptr inbounds ([17 x i8]* @.str3829, i32 0, i32 0)) #9
  unreachable

return:                                           ; preds = %if.then53, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define hidden i32 @luaV_lessthan(%struct.lua_State.364* %L, %struct.lua_TValue.349* %l, %struct.lua_TValue.349* %r) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State.364*, align 8
  %l.addr = alloca %struct.lua_TValue.349*, align 8
  %r.addr = alloca %struct.lua_TValue.349*, align 8
  %res = alloca i32, align 4
  store %struct.lua_State.364* %L, %struct.lua_State.364** %L.addr, align 8
  store %struct.lua_TValue.349* %l, %struct.lua_TValue.349** %l.addr, align 8
  store %struct.lua_TValue.349* %r, %struct.lua_TValue.349** %r.addr, align 8
  %0 = load %struct.lua_TValue.349** %l.addr, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue.349* %0, i32 0, i32 1
  %1 = load i32* %tt_, align 4
  %cmp = icmp eq i32 %1, 3
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %2 = load %struct.lua_TValue.349** %r.addr, align 8
  %tt_1 = getelementptr inbounds %struct.lua_TValue.349* %2, i32 0, i32 1
  %3 = load i32* %tt_1, align 4
  %cmp2 = icmp eq i32 %3, 3
  br i1 %cmp2, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %4 = load %struct.lua_TValue.349** %l.addr, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue.349* %4, i32 0, i32 0
  %n = bitcast %union.Value.348* %value_ to double*
  %5 = load double* %n, align 8
  %6 = load %struct.lua_TValue.349** %r.addr, align 8
  %value_3 = getelementptr inbounds %struct.lua_TValue.349* %6, i32 0, i32 0
  %n4 = bitcast %union.Value.348* %value_3 to double*
  %7 = load double* %n4, align 8
  %cmp5 = fcmp olt double %5, %7
  %conv = zext i1 %cmp5 to i32
  store i32 %conv, i32* %retval
  br label %return

if.else:                                          ; preds = %land.lhs.true, %entry
  %8 = load %struct.lua_TValue.349** %l.addr, align 8
  %tt_6 = getelementptr inbounds %struct.lua_TValue.349* %8, i32 0, i32 1
  %9 = load i32* %tt_6, align 4
  %and = and i32 %9, 15
  %cmp7 = icmp eq i32 %and, 4
  br i1 %cmp7, label %land.lhs.true9, label %if.else21

land.lhs.true9:                                   ; preds = %if.else
  %10 = load %struct.lua_TValue.349** %r.addr, align 8
  %tt_10 = getelementptr inbounds %struct.lua_TValue.349* %10, i32 0, i32 1
  %11 = load i32* %tt_10, align 4
  %and11 = and i32 %11, 15
  %cmp12 = icmp eq i32 %and11, 4
  br i1 %cmp12, label %if.then14, label %if.else21

if.then14:                                        ; preds = %land.lhs.true9
  %12 = load %struct.lua_TValue.349** %l.addr, align 8
  %value_15 = getelementptr inbounds %struct.lua_TValue.349* %12, i32 0, i32 0
  %gc = bitcast %union.Value.348* %value_15 to %union.GCObject.365**
  %13 = load %union.GCObject.365** %gc, align 8
  %ts = bitcast %union.GCObject.365* %13 to %union.TString.367*
  %14 = load %struct.lua_TValue.349** %r.addr, align 8
  %value_16 = getelementptr inbounds %struct.lua_TValue.349* %14, i32 0, i32 0
  %gc17 = bitcast %union.Value.348* %value_16 to %union.GCObject.365**
  %15 = load %union.GCObject.365** %gc17, align 8
  %ts18 = bitcast %union.GCObject.365* %15 to %union.TString.367*
  %call = call i32 @l_strcmp(%union.TString.367* %ts, %union.TString.367* %ts18)
  %cmp19 = icmp slt i32 %call, 0
  %conv20 = zext i1 %cmp19 to i32
  store i32 %conv20, i32* %retval
  br label %return

if.else21:                                        ; preds = %land.lhs.true9, %if.else
  %16 = load %struct.lua_State.364** %L.addr, align 8
  %17 = load %struct.lua_TValue.349** %l.addr, align 8
  %18 = load %struct.lua_TValue.349** %r.addr, align 8
  %call22 = call i32 @call_orderTM(%struct.lua_State.364* %16, %struct.lua_TValue.349* %17, %struct.lua_TValue.349* %18, i32 13)
  store i32 %call22, i32* %res, align 4
  %cmp23 = icmp slt i32 %call22, 0
  br i1 %cmp23, label %if.then25, label %if.end

if.then25:                                        ; preds = %if.else21
  %19 = load %struct.lua_State.364** %L.addr, align 8
  %20 = load %struct.lua_TValue.349** %l.addr, align 8
  %21 = load %struct.lua_TValue.349** %r.addr, align 8
  call void bitcast (void (%struct.lua_State*, %struct.lua_TValue*, %struct.lua_TValue*)* @luaG_ordererror to void (%struct.lua_State.364*, %struct.lua_TValue.349*, %struct.lua_TValue.349*)*)(%struct.lua_State.364* %19, %struct.lua_TValue.349* %20, %struct.lua_TValue.349* %21) #9
  unreachable

if.end:                                           ; preds = %if.else21
  br label %if.end26

if.end26:                                         ; preds = %if.end
  br label %if.end27

if.end27:                                         ; preds = %if.end26
  %22 = load i32* %res, align 4
  store i32 %22, i32* %retval
  br label %return

return:                                           ; preds = %if.end27, %if.then14, %if.then
  %23 = load i32* %retval
  ret i32 %23
}

; Function Attrs: nounwind uwtable
define hidden i32 @luaV_lessequal(%struct.lua_State.364* %L, %struct.lua_TValue.349* %l, %struct.lua_TValue.349* %r) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State.364*, align 8
  %l.addr = alloca %struct.lua_TValue.349*, align 8
  %r.addr = alloca %struct.lua_TValue.349*, align 8
  %res = alloca i32, align 4
  store %struct.lua_State.364* %L, %struct.lua_State.364** %L.addr, align 8
  store %struct.lua_TValue.349* %l, %struct.lua_TValue.349** %l.addr, align 8
  store %struct.lua_TValue.349* %r, %struct.lua_TValue.349** %r.addr, align 8
  %0 = load %struct.lua_TValue.349** %l.addr, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue.349* %0, i32 0, i32 1
  %1 = load i32* %tt_, align 4
  %cmp = icmp eq i32 %1, 3
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %2 = load %struct.lua_TValue.349** %r.addr, align 8
  %tt_1 = getelementptr inbounds %struct.lua_TValue.349* %2, i32 0, i32 1
  %3 = load i32* %tt_1, align 4
  %cmp2 = icmp eq i32 %3, 3
  br i1 %cmp2, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %4 = load %struct.lua_TValue.349** %l.addr, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue.349* %4, i32 0, i32 0
  %n = bitcast %union.Value.348* %value_ to double*
  %5 = load double* %n, align 8
  %6 = load %struct.lua_TValue.349** %r.addr, align 8
  %value_3 = getelementptr inbounds %struct.lua_TValue.349* %6, i32 0, i32 0
  %n4 = bitcast %union.Value.348* %value_3 to double*
  %7 = load double* %n4, align 8
  %cmp5 = fcmp ole double %5, %7
  %conv = zext i1 %cmp5 to i32
  store i32 %conv, i32* %retval
  br label %return

if.else:                                          ; preds = %land.lhs.true, %entry
  %8 = load %struct.lua_TValue.349** %l.addr, align 8
  %tt_6 = getelementptr inbounds %struct.lua_TValue.349* %8, i32 0, i32 1
  %9 = load i32* %tt_6, align 4
  %and = and i32 %9, 15
  %cmp7 = icmp eq i32 %and, 4
  br i1 %cmp7, label %land.lhs.true9, label %if.else21

land.lhs.true9:                                   ; preds = %if.else
  %10 = load %struct.lua_TValue.349** %r.addr, align 8
  %tt_10 = getelementptr inbounds %struct.lua_TValue.349* %10, i32 0, i32 1
  %11 = load i32* %tt_10, align 4
  %and11 = and i32 %11, 15
  %cmp12 = icmp eq i32 %and11, 4
  br i1 %cmp12, label %if.then14, label %if.else21

if.then14:                                        ; preds = %land.lhs.true9
  %12 = load %struct.lua_TValue.349** %l.addr, align 8
  %value_15 = getelementptr inbounds %struct.lua_TValue.349* %12, i32 0, i32 0
  %gc = bitcast %union.Value.348* %value_15 to %union.GCObject.365**
  %13 = load %union.GCObject.365** %gc, align 8
  %ts = bitcast %union.GCObject.365* %13 to %union.TString.367*
  %14 = load %struct.lua_TValue.349** %r.addr, align 8
  %value_16 = getelementptr inbounds %struct.lua_TValue.349* %14, i32 0, i32 0
  %gc17 = bitcast %union.Value.348* %value_16 to %union.GCObject.365**
  %15 = load %union.GCObject.365** %gc17, align 8
  %ts18 = bitcast %union.GCObject.365* %15 to %union.TString.367*
  %call = call i32 @l_strcmp(%union.TString.367* %ts, %union.TString.367* %ts18)
  %cmp19 = icmp sle i32 %call, 0
  %conv20 = zext i1 %cmp19 to i32
  store i32 %conv20, i32* %retval
  br label %return

if.else21:                                        ; preds = %land.lhs.true9, %if.else
  %16 = load %struct.lua_State.364** %L.addr, align 8
  %17 = load %struct.lua_TValue.349** %l.addr, align 8
  %18 = load %struct.lua_TValue.349** %r.addr, align 8
  %call22 = call i32 @call_orderTM(%struct.lua_State.364* %16, %struct.lua_TValue.349* %17, %struct.lua_TValue.349* %18, i32 14)
  store i32 %call22, i32* %res, align 4
  %cmp23 = icmp sge i32 %call22, 0
  br i1 %cmp23, label %if.then25, label %if.else26

if.then25:                                        ; preds = %if.else21
  %19 = load i32* %res, align 4
  store i32 %19, i32* %retval
  br label %return

if.else26:                                        ; preds = %if.else21
  %20 = load %struct.lua_State.364** %L.addr, align 8
  %21 = load %struct.lua_TValue.349** %r.addr, align 8
  %22 = load %struct.lua_TValue.349** %l.addr, align 8
  %call27 = call i32 @call_orderTM(%struct.lua_State.364* %20, %struct.lua_TValue.349* %21, %struct.lua_TValue.349* %22, i32 13)
  store i32 %call27, i32* %res, align 4
  %cmp28 = icmp slt i32 %call27, 0
  br i1 %cmp28, label %if.then30, label %if.end

if.then30:                                        ; preds = %if.else26
  %23 = load %struct.lua_State.364** %L.addr, align 8
  %24 = load %struct.lua_TValue.349** %l.addr, align 8
  %25 = load %struct.lua_TValue.349** %r.addr, align 8
  call void bitcast (void (%struct.lua_State*, %struct.lua_TValue*, %struct.lua_TValue*)* @luaG_ordererror to void (%struct.lua_State.364*, %struct.lua_TValue.349*, %struct.lua_TValue.349*)*)(%struct.lua_State.364* %23, %struct.lua_TValue.349* %24, %struct.lua_TValue.349* %25) #9
  unreachable

if.end:                                           ; preds = %if.else26
  br label %if.end31

if.end31:                                         ; preds = %if.end
  br label %if.end32

if.end32:                                         ; preds = %if.end31
  br label %if.end33

if.end33:                                         ; preds = %if.end32
  %26 = load i32* %res, align 4
  %tobool = icmp ne i32 %26, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  store i32 %lnot.ext, i32* %retval
  br label %return

return:                                           ; preds = %if.end33, %if.then25, %if.then14, %if.then
  %27 = load i32* %retval
  ret i32 %27
}

; Function Attrs: nounwind uwtable
define hidden i32 @luaV_equalobj_(%struct.lua_State.364* %L, %struct.lua_TValue.349* %t1, %struct.lua_TValue.349* %t2) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State.364*, align 8
  %t1.addr = alloca %struct.lua_TValue.349*, align 8
  %t2.addr = alloca %struct.lua_TValue.349*, align 8
  %tm = alloca %struct.lua_TValue.349*, align 8
  store %struct.lua_State.364* %L, %struct.lua_State.364** %L.addr, align 8
  store %struct.lua_TValue.349* %t1, %struct.lua_TValue.349** %t1.addr, align 8
  store %struct.lua_TValue.349* %t2, %struct.lua_TValue.349** %t2.addr, align 8
  %0 = load %struct.lua_TValue.349** %t1.addr, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue.349* %0, i32 0, i32 1
  %1 = load i32* %tt_, align 4
  %and = and i32 %1, 63
  switch i32 %and, label %sw.default [
    i32 0, label %sw.bb
    i32 3, label %sw.bb1
    i32 1, label %sw.bb4
    i32 2, label %sw.bb10
    i32 22, label %sw.bb16
    i32 4, label %sw.bb22
    i32 20, label %sw.bb29
    i32 7, label %sw.bb36
    i32 5, label %sw.bb59
  ]

sw.bb:                                            ; preds = %entry
  store i32 1, i32* %retval
  br label %return

sw.bb1:                                           ; preds = %entry
  %2 = load %struct.lua_TValue.349** %t1.addr, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue.349* %2, i32 0, i32 0
  %n = bitcast %union.Value.348* %value_ to double*
  %3 = load double* %n, align 8
  %4 = load %struct.lua_TValue.349** %t2.addr, align 8
  %value_2 = getelementptr inbounds %struct.lua_TValue.349* %4, i32 0, i32 0
  %n3 = bitcast %union.Value.348* %value_2 to double*
  %5 = load double* %n3, align 8
  %cmp = fcmp oeq double %3, %5
  %conv = zext i1 %cmp to i32
  store i32 %conv, i32* %retval
  br label %return

sw.bb4:                                           ; preds = %entry
  %6 = load %struct.lua_TValue.349** %t1.addr, align 8
  %value_5 = getelementptr inbounds %struct.lua_TValue.349* %6, i32 0, i32 0
  %b = bitcast %union.Value.348* %value_5 to i32*
  %7 = load i32* %b, align 4
  %8 = load %struct.lua_TValue.349** %t2.addr, align 8
  %value_6 = getelementptr inbounds %struct.lua_TValue.349* %8, i32 0, i32 0
  %b7 = bitcast %union.Value.348* %value_6 to i32*
  %9 = load i32* %b7, align 4
  %cmp8 = icmp eq i32 %7, %9
  %conv9 = zext i1 %cmp8 to i32
  store i32 %conv9, i32* %retval
  br label %return

sw.bb10:                                          ; preds = %entry
  %10 = load %struct.lua_TValue.349** %t1.addr, align 8
  %value_11 = getelementptr inbounds %struct.lua_TValue.349* %10, i32 0, i32 0
  %p = bitcast %union.Value.348* %value_11 to i8**
  %11 = load i8** %p, align 8
  %12 = load %struct.lua_TValue.349** %t2.addr, align 8
  %value_12 = getelementptr inbounds %struct.lua_TValue.349* %12, i32 0, i32 0
  %p13 = bitcast %union.Value.348* %value_12 to i8**
  %13 = load i8** %p13, align 8
  %cmp14 = icmp eq i8* %11, %13
  %conv15 = zext i1 %cmp14 to i32
  store i32 %conv15, i32* %retval
  br label %return

sw.bb16:                                          ; preds = %entry
  %14 = load %struct.lua_TValue.349** %t1.addr, align 8
  %value_17 = getelementptr inbounds %struct.lua_TValue.349* %14, i32 0, i32 0
  %f = bitcast %union.Value.348* %value_17 to i32 (%struct.lua_State.364*)**
  %15 = load i32 (%struct.lua_State.364*)** %f, align 8
  %16 = load %struct.lua_TValue.349** %t2.addr, align 8
  %value_18 = getelementptr inbounds %struct.lua_TValue.349* %16, i32 0, i32 0
  %f19 = bitcast %union.Value.348* %value_18 to i32 (%struct.lua_State.364*)**
  %17 = load i32 (%struct.lua_State.364*)** %f19, align 8
  %cmp20 = icmp eq i32 (%struct.lua_State.364*)* %15, %17
  %conv21 = zext i1 %cmp20 to i32
  store i32 %conv21, i32* %retval
  br label %return

sw.bb22:                                          ; preds = %entry
  %18 = load %struct.lua_TValue.349** %t1.addr, align 8
  %value_23 = getelementptr inbounds %struct.lua_TValue.349* %18, i32 0, i32 0
  %gc = bitcast %union.Value.348* %value_23 to %union.GCObject.365**
  %19 = load %union.GCObject.365** %gc, align 8
  %ts = bitcast %union.GCObject.365* %19 to %union.TString.367*
  %20 = load %struct.lua_TValue.349** %t2.addr, align 8
  %value_24 = getelementptr inbounds %struct.lua_TValue.349* %20, i32 0, i32 0
  %gc25 = bitcast %union.Value.348* %value_24 to %union.GCObject.365**
  %21 = load %union.GCObject.365** %gc25, align 8
  %ts26 = bitcast %union.GCObject.365* %21 to %union.TString.367*
  %cmp27 = icmp eq %union.TString.367* %ts, %ts26
  %conv28 = zext i1 %cmp27 to i32
  store i32 %conv28, i32* %retval
  br label %return

sw.bb29:                                          ; preds = %entry
  %22 = load %struct.lua_TValue.349** %t1.addr, align 8
  %value_30 = getelementptr inbounds %struct.lua_TValue.349* %22, i32 0, i32 0
  %gc31 = bitcast %union.Value.348* %value_30 to %union.GCObject.365**
  %23 = load %union.GCObject.365** %gc31, align 8
  %ts32 = bitcast %union.GCObject.365* %23 to %union.TString.367*
  %24 = load %struct.lua_TValue.349** %t2.addr, align 8
  %value_33 = getelementptr inbounds %struct.lua_TValue.349* %24, i32 0, i32 0
  %gc34 = bitcast %union.Value.348* %value_33 to %union.GCObject.365**
  %25 = load %union.GCObject.365** %gc34, align 8
  %ts35 = bitcast %union.GCObject.365* %25 to %union.TString.367*
  %call = call i32 @luaS_eqlngstr(%union.TString.367* %ts32, %union.TString.367* %ts35)
  store i32 %call, i32* %retval
  br label %return

sw.bb36:                                          ; preds = %entry
  %26 = load %struct.lua_TValue.349** %t1.addr, align 8
  %value_37 = getelementptr inbounds %struct.lua_TValue.349* %26, i32 0, i32 0
  %gc38 = bitcast %union.Value.348* %value_37 to %union.GCObject.365**
  %27 = load %union.GCObject.365** %gc38, align 8
  %u = bitcast %union.GCObject.365* %27 to %union.Udata.481*
  %uv = bitcast %union.Udata.481* %u to %struct.anon.2.480*
  %28 = load %struct.lua_TValue.349** %t2.addr, align 8
  %value_39 = getelementptr inbounds %struct.lua_TValue.349* %28, i32 0, i32 0
  %gc40 = bitcast %union.Value.348* %value_39 to %union.GCObject.365**
  %29 = load %union.GCObject.365** %gc40, align 8
  %u41 = bitcast %union.GCObject.365* %29 to %union.Udata.481*
  %uv42 = bitcast %union.Udata.481* %u41 to %struct.anon.2.480*
  %cmp43 = icmp eq %struct.anon.2.480* %uv, %uv42
  br i1 %cmp43, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb36
  store i32 1, i32* %retval
  br label %return

if.else:                                          ; preds = %sw.bb36
  %30 = load %struct.lua_State.364** %L.addr, align 8
  %cmp45 = icmp eq %struct.lua_State.364* %30, null
  br i1 %cmp45, label %if.then47, label %if.end

if.then47:                                        ; preds = %if.else
  store i32 0, i32* %retval
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end48

if.end48:                                         ; preds = %if.end
  %31 = load %struct.lua_State.364** %L.addr, align 8
  %32 = load %struct.lua_TValue.349** %t1.addr, align 8
  %value_49 = getelementptr inbounds %struct.lua_TValue.349* %32, i32 0, i32 0
  %gc50 = bitcast %union.Value.348* %value_49 to %union.GCObject.365**
  %33 = load %union.GCObject.365** %gc50, align 8
  %u51 = bitcast %union.GCObject.365* %33 to %union.Udata.481*
  %uv52 = bitcast %union.Udata.481* %u51 to %struct.anon.2.480*
  %metatable = getelementptr inbounds %struct.anon.2.480* %uv52, i32 0, i32 3
  %34 = load %struct.Table.357** %metatable, align 8
  %35 = load %struct.lua_TValue.349** %t2.addr, align 8
  %value_53 = getelementptr inbounds %struct.lua_TValue.349* %35, i32 0, i32 0
  %gc54 = bitcast %union.Value.348* %value_53 to %union.GCObject.365**
  %36 = load %union.GCObject.365** %gc54, align 8
  %u55 = bitcast %union.GCObject.365* %36 to %union.Udata.481*
  %uv56 = bitcast %union.Udata.481* %u55 to %struct.anon.2.480*
  %metatable57 = getelementptr inbounds %struct.anon.2.480* %uv56, i32 0, i32 3
  %37 = load %struct.Table.357** %metatable57, align 8
  %call58 = call %struct.lua_TValue.349* @get_equalTM(%struct.lua_State.364* %31, %struct.Table.357* %34, %struct.Table.357* %37, i32 5)
  store %struct.lua_TValue.349* %call58, %struct.lua_TValue.349** %tm, align 8
  br label %sw.epilog

sw.bb59:                                          ; preds = %entry
  %38 = load %struct.lua_TValue.349** %t1.addr, align 8
  %value_60 = getelementptr inbounds %struct.lua_TValue.349* %38, i32 0, i32 0
  %gc61 = bitcast %union.Value.348* %value_60 to %union.GCObject.365**
  %39 = load %union.GCObject.365** %gc61, align 8
  %h = bitcast %union.GCObject.365* %39 to %struct.Table.357*
  %40 = load %struct.lua_TValue.349** %t2.addr, align 8
  %value_62 = getelementptr inbounds %struct.lua_TValue.349* %40, i32 0, i32 0
  %gc63 = bitcast %union.Value.348* %value_62 to %union.GCObject.365**
  %41 = load %union.GCObject.365** %gc63, align 8
  %h64 = bitcast %union.GCObject.365* %41 to %struct.Table.357*
  %cmp65 = icmp eq %struct.Table.357* %h, %h64
  br i1 %cmp65, label %if.then67, label %if.else68

if.then67:                                        ; preds = %sw.bb59
  store i32 1, i32* %retval
  br label %return

if.else68:                                        ; preds = %sw.bb59
  %42 = load %struct.lua_State.364** %L.addr, align 8
  %cmp69 = icmp eq %struct.lua_State.364* %42, null
  br i1 %cmp69, label %if.then71, label %if.end72

if.then71:                                        ; preds = %if.else68
  store i32 0, i32* %retval
  br label %return

if.end72:                                         ; preds = %if.else68
  br label %if.end73

if.end73:                                         ; preds = %if.end72
  %43 = load %struct.lua_State.364** %L.addr, align 8
  %44 = load %struct.lua_TValue.349** %t1.addr, align 8
  %value_74 = getelementptr inbounds %struct.lua_TValue.349* %44, i32 0, i32 0
  %gc75 = bitcast %union.Value.348* %value_74 to %union.GCObject.365**
  %45 = load %union.GCObject.365** %gc75, align 8
  %h76 = bitcast %union.GCObject.365* %45 to %struct.Table.357*
  %metatable77 = getelementptr inbounds %struct.Table.357* %h76, i32 0, i32 5
  %46 = load %struct.Table.357** %metatable77, align 8
  %47 = load %struct.lua_TValue.349** %t2.addr, align 8
  %value_78 = getelementptr inbounds %struct.lua_TValue.349* %47, i32 0, i32 0
  %gc79 = bitcast %union.Value.348* %value_78 to %union.GCObject.365**
  %48 = load %union.GCObject.365** %gc79, align 8
  %h80 = bitcast %union.GCObject.365* %48 to %struct.Table.357*
  %metatable81 = getelementptr inbounds %struct.Table.357* %h80, i32 0, i32 5
  %49 = load %struct.Table.357** %metatable81, align 8
  %call82 = call %struct.lua_TValue.349* @get_equalTM(%struct.lua_State.364* %43, %struct.Table.357* %46, %struct.Table.357* %49, i32 5)
  store %struct.lua_TValue.349* %call82, %struct.lua_TValue.349** %tm, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %50 = load %struct.lua_TValue.349** %t1.addr, align 8
  %value_83 = getelementptr inbounds %struct.lua_TValue.349* %50, i32 0, i32 0
  %gc84 = bitcast %union.Value.348* %value_83 to %union.GCObject.365**
  %51 = load %union.GCObject.365** %gc84, align 8
  %52 = load %struct.lua_TValue.349** %t2.addr, align 8
  %value_85 = getelementptr inbounds %struct.lua_TValue.349* %52, i32 0, i32 0
  %gc86 = bitcast %union.Value.348* %value_85 to %union.GCObject.365**
  %53 = load %union.GCObject.365** %gc86, align 8
  %cmp87 = icmp eq %union.GCObject.365* %51, %53
  %conv88 = zext i1 %cmp87 to i32
  store i32 %conv88, i32* %retval
  br label %return

sw.epilog:                                        ; preds = %if.end73, %if.end48
  %54 = load %struct.lua_TValue.349** %tm, align 8
  %cmp89 = icmp eq %struct.lua_TValue.349* %54, null
  br i1 %cmp89, label %if.then91, label %if.end92

if.then91:                                        ; preds = %sw.epilog
  store i32 0, i32* %retval
  br label %return

if.end92:                                         ; preds = %sw.epilog
  %55 = load %struct.lua_State.364** %L.addr, align 8
  %56 = load %struct.lua_TValue.349** %tm, align 8
  %57 = load %struct.lua_TValue.349** %t1.addr, align 8
  %58 = load %struct.lua_TValue.349** %t2.addr, align 8
  %59 = load %struct.lua_State.364** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State.364* %59, i32 0, i32 4
  %60 = load %struct.lua_TValue.349** %top, align 8
  call void @callTM(%struct.lua_State.364* %55, %struct.lua_TValue.349* %56, %struct.lua_TValue.349* %57, %struct.lua_TValue.349* %58, %struct.lua_TValue.349* %60, i32 1)
  %61 = load %struct.lua_State.364** %L.addr, align 8
  %top93 = getelementptr inbounds %struct.lua_State.364* %61, i32 0, i32 4
  %62 = load %struct.lua_TValue.349** %top93, align 8
  %tt_94 = getelementptr inbounds %struct.lua_TValue.349* %62, i32 0, i32 1
  %63 = load i32* %tt_94, align 4
  %cmp95 = icmp eq i32 %63, 0
  br i1 %cmp95, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.end92
  %64 = load %struct.lua_State.364** %L.addr, align 8
  %top97 = getelementptr inbounds %struct.lua_State.364* %64, i32 0, i32 4
  %65 = load %struct.lua_TValue.349** %top97, align 8
  %tt_98 = getelementptr inbounds %struct.lua_TValue.349* %65, i32 0, i32 1
  %66 = load i32* %tt_98, align 4
  %cmp99 = icmp eq i32 %66, 1
  br i1 %cmp99, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %lor.rhs
  %67 = load %struct.lua_State.364** %L.addr, align 8
  %top101 = getelementptr inbounds %struct.lua_State.364* %67, i32 0, i32 4
  %68 = load %struct.lua_TValue.349** %top101, align 8
  %value_102 = getelementptr inbounds %struct.lua_TValue.349* %68, i32 0, i32 0
  %b103 = bitcast %union.Value.348* %value_102 to i32*
  %69 = load i32* %b103, align 4
  %cmp104 = icmp eq i32 %69, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %lor.rhs
  %70 = phi i1 [ false, %lor.rhs ], [ %cmp104, %land.rhs ]
  br label %lor.end

lor.end:                                          ; preds = %land.end, %if.end92
  %71 = phi i1 [ true, %if.end92 ], [ %70, %land.end ]
  %lnot = xor i1 %71, true
  %lnot.ext = zext i1 %lnot to i32
  store i32 %lnot.ext, i32* %retval
  br label %return

return:                                           ; preds = %lor.end, %if.then91, %sw.default, %if.then71, %if.then67, %if.then47, %if.then, %sw.bb29, %sw.bb22, %sw.bb16, %sw.bb10, %sw.bb4, %sw.bb1, %sw.bb
  %72 = load i32* %retval
  ret i32 %72
}

; Function Attrs: nounwind uwtable
define hidden void @luaV_concat(%struct.lua_State.364* %L, i32 %total) #0 {
entry:
  %L.addr = alloca %struct.lua_State.364*, align 8
  %total.addr = alloca i32, align 4
  %top = alloca %struct.lua_TValue.349*, align 8
  %n = alloca i32, align 4
  %io2 = alloca %struct.lua_TValue.349*, align 8
  %io1 = alloca %struct.lua_TValue.349*, align 8
  %tl = alloca i64, align 8
  %buffer = alloca i8*, align 8
  %i = alloca i32, align 4
  %l = alloca i64, align 8
  %l85 = alloca i64, align 8
  %io = alloca %struct.lua_TValue.349*, align 8
  %x_ = alloca %union.TString.367*, align 8
  store %struct.lua_State.364* %L, %struct.lua_State.364** %L.addr, align 8
  store i32 %total, i32* %total.addr, align 4
  br label %do.body

do.body:                                          ; preds = %do.cond122, %entry
  %0 = load %struct.lua_State.364** %L.addr, align 8
  %top1 = getelementptr inbounds %struct.lua_State.364* %0, i32 0, i32 4
  %1 = load %struct.lua_TValue.349** %top1, align 8
  store %struct.lua_TValue.349* %1, %struct.lua_TValue.349** %top, align 8
  store i32 2, i32* %n, align 4
  %2 = load %struct.lua_TValue.349** %top, align 8
  %add.ptr = getelementptr inbounds %struct.lua_TValue.349* %2, i64 -2
  %tt_ = getelementptr inbounds %struct.lua_TValue.349* %add.ptr, i32 0, i32 1
  %3 = load i32* %tt_, align 4
  %and = and i32 %3, 15
  %cmp = icmp eq i32 %and, 4
  br i1 %cmp, label %lor.lhs.false5, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.body
  %4 = load %struct.lua_TValue.349** %top, align 8
  %add.ptr2 = getelementptr inbounds %struct.lua_TValue.349* %4, i64 -2
  %tt_3 = getelementptr inbounds %struct.lua_TValue.349* %add.ptr2, i32 0, i32 1
  %5 = load i32* %tt_3, align 4
  %cmp4 = icmp eq i32 %5, 3
  br i1 %cmp4, label %lor.lhs.false5, label %if.then

lor.lhs.false5:                                   ; preds = %lor.lhs.false, %do.body
  %6 = load %struct.lua_TValue.349** %top, align 8
  %add.ptr6 = getelementptr inbounds %struct.lua_TValue.349* %6, i64 -1
  %tt_7 = getelementptr inbounds %struct.lua_TValue.349* %add.ptr6, i32 0, i32 1
  %7 = load i32* %tt_7, align 4
  %and8 = and i32 %7, 15
  %cmp9 = icmp eq i32 %and8, 4
  br i1 %cmp9, label %if.else, label %lor.lhs.false10

lor.lhs.false10:                                  ; preds = %lor.lhs.false5
  %8 = load %struct.lua_State.364** %L.addr, align 8
  %9 = load %struct.lua_TValue.349** %top, align 8
  %add.ptr11 = getelementptr inbounds %struct.lua_TValue.349* %9, i64 -1
  %call = call i32 @luaV_tostring(%struct.lua_State.364* %8, %struct.lua_TValue.349* %add.ptr11)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %lor.lhs.false10, %lor.lhs.false
  %10 = load %struct.lua_State.364** %L.addr, align 8
  %11 = load %struct.lua_TValue.349** %top, align 8
  %add.ptr12 = getelementptr inbounds %struct.lua_TValue.349* %11, i64 -2
  %12 = load %struct.lua_TValue.349** %top, align 8
  %add.ptr13 = getelementptr inbounds %struct.lua_TValue.349* %12, i64 -1
  %13 = load %struct.lua_TValue.349** %top, align 8
  %add.ptr14 = getelementptr inbounds %struct.lua_TValue.349* %13, i64 -2
  %call15 = call i32 @call_binTM(%struct.lua_State.364* %10, %struct.lua_TValue.349* %add.ptr12, %struct.lua_TValue.349* %add.ptr13, %struct.lua_TValue.349* %add.ptr14, i32 15)
  %tobool16 = icmp ne i32 %call15, 0
  br i1 %tobool16, label %if.end, label %if.then17

if.then17:                                        ; preds = %if.then
  %14 = load %struct.lua_State.364** %L.addr, align 8
  %15 = load %struct.lua_TValue.349** %top, align 8
  %add.ptr18 = getelementptr inbounds %struct.lua_TValue.349* %15, i64 -2
  %16 = load %struct.lua_TValue.349** %top, align 8
  %add.ptr19 = getelementptr inbounds %struct.lua_TValue.349* %16, i64 -1
  call void bitcast (void (%struct.lua_State*, %struct.lua_TValue*, %struct.lua_TValue*)* @luaG_concaterror to void (%struct.lua_State.364*, %struct.lua_TValue.349*, %struct.lua_TValue.349*)*)(%struct.lua_State.364* %14, %struct.lua_TValue.349* %add.ptr18, %struct.lua_TValue.349* %add.ptr19) #9
  unreachable

if.end:                                           ; preds = %if.then
  br label %if.end114

if.else:                                          ; preds = %lor.lhs.false10, %lor.lhs.false5
  %17 = load %struct.lua_TValue.349** %top, align 8
  %add.ptr20 = getelementptr inbounds %struct.lua_TValue.349* %17, i64 -1
  %value_ = getelementptr inbounds %struct.lua_TValue.349* %add.ptr20, i32 0, i32 0
  %gc = bitcast %union.Value.348* %value_ to %union.GCObject.365**
  %18 = load %union.GCObject.365** %gc, align 8
  %ts = bitcast %union.GCObject.365* %18 to %union.TString.367*
  %tsv = bitcast %union.TString.367* %ts to %struct.anon.366*
  %len = getelementptr inbounds %struct.anon.366* %tsv, i32 0, i32 5
  %19 = load i64* %len, align 8
  %cmp21 = icmp eq i64 %19, 0
  br i1 %cmp21, label %if.then22, label %if.else30

if.then22:                                        ; preds = %if.else
  %20 = load %struct.lua_TValue.349** %top, align 8
  %add.ptr23 = getelementptr inbounds %struct.lua_TValue.349* %20, i64 -2
  %tt_24 = getelementptr inbounds %struct.lua_TValue.349* %add.ptr23, i32 0, i32 1
  %21 = load i32* %tt_24, align 4
  %and25 = and i32 %21, 15
  %cmp26 = icmp eq i32 %and25, 4
  br i1 %cmp26, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.then22
  %22 = load %struct.lua_State.364** %L.addr, align 8
  %23 = load %struct.lua_TValue.349** %top, align 8
  %add.ptr27 = getelementptr inbounds %struct.lua_TValue.349* %23, i64 -2
  %call28 = call i32 @luaV_tostring(%struct.lua_State.364* %22, %struct.lua_TValue.349* %add.ptr27)
  %tobool29 = icmp ne i32 %call28, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.then22
  %24 = phi i1 [ true, %if.then22 ], [ %tobool29, %lor.rhs ]
  %lor.ext = zext i1 %24 to i32
  br label %if.end113

if.else30:                                        ; preds = %if.else
  %25 = load %struct.lua_TValue.349** %top, align 8
  %add.ptr31 = getelementptr inbounds %struct.lua_TValue.349* %25, i64 -2
  %tt_32 = getelementptr inbounds %struct.lua_TValue.349* %add.ptr31, i32 0, i32 1
  %26 = load i32* %tt_32, align 4
  %and33 = and i32 %26, 15
  %cmp34 = icmp eq i32 %and33, 4
  br i1 %cmp34, label %land.lhs.true, label %if.else49

land.lhs.true:                                    ; preds = %if.else30
  %27 = load %struct.lua_TValue.349** %top, align 8
  %add.ptr35 = getelementptr inbounds %struct.lua_TValue.349* %27, i64 -2
  %value_36 = getelementptr inbounds %struct.lua_TValue.349* %add.ptr35, i32 0, i32 0
  %gc37 = bitcast %union.Value.348* %value_36 to %union.GCObject.365**
  %28 = load %union.GCObject.365** %gc37, align 8
  %ts38 = bitcast %union.GCObject.365* %28 to %union.TString.367*
  %tsv39 = bitcast %union.TString.367* %ts38 to %struct.anon.366*
  %len40 = getelementptr inbounds %struct.anon.366* %tsv39, i32 0, i32 5
  %29 = load i64* %len40, align 8
  %cmp41 = icmp eq i64 %29, 0
  br i1 %cmp41, label %if.then42, label %if.else49

if.then42:                                        ; preds = %land.lhs.true
  %30 = load %struct.lua_TValue.349** %top, align 8
  %add.ptr43 = getelementptr inbounds %struct.lua_TValue.349* %30, i64 -1
  store %struct.lua_TValue.349* %add.ptr43, %struct.lua_TValue.349** %io2, align 8
  %31 = load %struct.lua_TValue.349** %top, align 8
  %add.ptr44 = getelementptr inbounds %struct.lua_TValue.349* %31, i64 -2
  store %struct.lua_TValue.349* %add.ptr44, %struct.lua_TValue.349** %io1, align 8
  %32 = load %struct.lua_TValue.349** %io1, align 8
  %value_45 = getelementptr inbounds %struct.lua_TValue.349* %32, i32 0, i32 0
  %33 = load %struct.lua_TValue.349** %io2, align 8
  %value_46 = getelementptr inbounds %struct.lua_TValue.349* %33, i32 0, i32 0
  %34 = bitcast %union.Value.348* %value_45 to i8*
  %35 = bitcast %union.Value.348* %value_46 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %34, i8* %35, i64 8, i32 8, i1 false)
  %36 = load %struct.lua_TValue.349** %io2, align 8
  %tt_47 = getelementptr inbounds %struct.lua_TValue.349* %36, i32 0, i32 1
  %37 = load i32* %tt_47, align 4
  %38 = load %struct.lua_TValue.349** %io1, align 8
  %tt_48 = getelementptr inbounds %struct.lua_TValue.349* %38, i32 0, i32 1
  store i32 %37, i32* %tt_48, align 4
  br label %if.end112

if.else49:                                        ; preds = %land.lhs.true, %if.else30
  %39 = load %struct.lua_TValue.349** %top, align 8
  %add.ptr50 = getelementptr inbounds %struct.lua_TValue.349* %39, i64 -1
  %value_51 = getelementptr inbounds %struct.lua_TValue.349* %add.ptr50, i32 0, i32 0
  %gc52 = bitcast %union.Value.348* %value_51 to %union.GCObject.365**
  %40 = load %union.GCObject.365** %gc52, align 8
  %ts53 = bitcast %union.GCObject.365* %40 to %union.TString.367*
  %tsv54 = bitcast %union.TString.367* %ts53 to %struct.anon.366*
  %len55 = getelementptr inbounds %struct.anon.366* %tsv54, i32 0, i32 5
  %41 = load i64* %len55, align 8
  store i64 %41, i64* %tl, align 8
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.else49
  %42 = load i32* %i, align 4
  %43 = load i32* %total.addr, align 4
  %cmp56 = icmp slt i32 %42, %43
  br i1 %cmp56, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %44 = load %struct.lua_TValue.349** %top, align 8
  %45 = load i32* %i, align 4
  %idx.ext = sext i32 %45 to i64
  %idx.neg = sub i64 0, %idx.ext
  %add.ptr57 = getelementptr inbounds %struct.lua_TValue.349* %44, i64 %idx.neg
  %add.ptr58 = getelementptr inbounds %struct.lua_TValue.349* %add.ptr57, i64 -1
  %tt_59 = getelementptr inbounds %struct.lua_TValue.349* %add.ptr58, i32 0, i32 1
  %46 = load i32* %tt_59, align 4
  %and60 = and i32 %46, 15
  %cmp61 = icmp eq i32 %and60, 4
  br i1 %cmp61, label %lor.end69, label %lor.rhs62

lor.rhs62:                                        ; preds = %land.rhs
  %47 = load %struct.lua_State.364** %L.addr, align 8
  %48 = load %struct.lua_TValue.349** %top, align 8
  %49 = load i32* %i, align 4
  %idx.ext63 = sext i32 %49 to i64
  %idx.neg64 = sub i64 0, %idx.ext63
  %add.ptr65 = getelementptr inbounds %struct.lua_TValue.349* %48, i64 %idx.neg64
  %add.ptr66 = getelementptr inbounds %struct.lua_TValue.349* %add.ptr65, i64 -1
  %call67 = call i32 @luaV_tostring(%struct.lua_State.364* %47, %struct.lua_TValue.349* %add.ptr66)
  %tobool68 = icmp ne i32 %call67, 0
  br label %lor.end69

lor.end69:                                        ; preds = %lor.rhs62, %land.rhs
  %50 = phi i1 [ true, %land.rhs ], [ %tobool68, %lor.rhs62 ]
  br label %land.end

land.end:                                         ; preds = %lor.end69, %for.cond
  %51 = phi i1 [ false, %for.cond ], [ %50, %lor.end69 ]
  br i1 %51, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %52 = load %struct.lua_TValue.349** %top, align 8
  %53 = load i32* %i, align 4
  %idx.ext71 = sext i32 %53 to i64
  %idx.neg72 = sub i64 0, %idx.ext71
  %add.ptr73 = getelementptr inbounds %struct.lua_TValue.349* %52, i64 %idx.neg72
  %add.ptr74 = getelementptr inbounds %struct.lua_TValue.349* %add.ptr73, i64 -1
  %value_75 = getelementptr inbounds %struct.lua_TValue.349* %add.ptr74, i32 0, i32 0
  %gc76 = bitcast %union.Value.348* %value_75 to %union.GCObject.365**
  %54 = load %union.GCObject.365** %gc76, align 8
  %ts77 = bitcast %union.GCObject.365* %54 to %union.TString.367*
  %tsv78 = bitcast %union.TString.367* %ts77 to %struct.anon.366*
  %len79 = getelementptr inbounds %struct.anon.366* %tsv78, i32 0, i32 5
  %55 = load i64* %len79, align 8
  store i64 %55, i64* %l, align 8
  %56 = load i64* %l, align 8
  %57 = load i64* %tl, align 8
  %sub = sub i64 -3, %57
  %cmp80 = icmp uge i64 %56, %sub
  br i1 %cmp80, label %if.then81, label %if.end82

if.then81:                                        ; preds = %for.body
  %58 = load %struct.lua_State.364** %L.addr, align 8
  call void (%struct.lua_State.364*, i8*, ...)* bitcast (void (%struct.lua_State*, i8*, ...)* @luaG_runerror to void (%struct.lua_State.364*, i8*, ...)*)(%struct.lua_State.364* %58, i8* getelementptr inbounds ([23 x i8]* @.str4830, i32 0, i32 0)) #9
  unreachable

if.end82:                                         ; preds = %for.body
  %59 = load i64* %l, align 8
  %60 = load i64* %tl, align 8
  %add = add i64 %60, %59
  store i64 %add, i64* %tl, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end82
  %61 = load i32* %i, align 4
  %inc = add nsw i32 %61, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %land.end
  %62 = load %struct.lua_State.364** %L.addr, align 8
  %63 = load %struct.lua_State.364** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State.364* %63, i32 0, i32 5
  %64 = load %struct.global_State.358** %l_G, align 8
  %buff = getelementptr inbounds %struct.global_State.358* %64, i32 0, i32 25
  %65 = load i64* %tl, align 8
  %call83 = call i8* bitcast (i8* (%struct.lua_State*, %struct.Mbuffer*, i64)* @luaZ_openspace to i8* (%struct.lua_State.364*, %struct.Mbuffer*, i64)*)(%struct.lua_State.364* %62, %struct.Mbuffer* %buff, i64 %65)
  store i8* %call83, i8** %buffer, align 8
  store i64 0, i64* %tl, align 8
  %66 = load i32* %i, align 4
  store i32 %66, i32* %n, align 4
  br label %do.body84

do.body84:                                        ; preds = %do.cond, %for.end
  %67 = load %struct.lua_TValue.349** %top, align 8
  %68 = load i32* %i, align 4
  %idx.ext86 = sext i32 %68 to i64
  %idx.neg87 = sub i64 0, %idx.ext86
  %add.ptr88 = getelementptr inbounds %struct.lua_TValue.349* %67, i64 %idx.neg87
  %value_89 = getelementptr inbounds %struct.lua_TValue.349* %add.ptr88, i32 0, i32 0
  %gc90 = bitcast %union.Value.348* %value_89 to %union.GCObject.365**
  %69 = load %union.GCObject.365** %gc90, align 8
  %ts91 = bitcast %union.GCObject.365* %69 to %union.TString.367*
  %tsv92 = bitcast %union.TString.367* %ts91 to %struct.anon.366*
  %len93 = getelementptr inbounds %struct.anon.366* %tsv92, i32 0, i32 5
  %70 = load i64* %len93, align 8
  store i64 %70, i64* %l85, align 8
  %71 = load i8** %buffer, align 8
  %72 = load i64* %tl, align 8
  %add.ptr94 = getelementptr inbounds i8* %71, i64 %72
  %73 = load %struct.lua_TValue.349** %top, align 8
  %74 = load i32* %i, align 4
  %idx.ext95 = sext i32 %74 to i64
  %idx.neg96 = sub i64 0, %idx.ext95
  %add.ptr97 = getelementptr inbounds %struct.lua_TValue.349* %73, i64 %idx.neg96
  %value_98 = getelementptr inbounds %struct.lua_TValue.349* %add.ptr97, i32 0, i32 0
  %gc99 = bitcast %union.Value.348* %value_98 to %union.GCObject.365**
  %75 = load %union.GCObject.365** %gc99, align 8
  %ts100 = bitcast %union.GCObject.365* %75 to %union.TString.367*
  %add.ptr101 = getelementptr inbounds %union.TString.367* %ts100, i64 1
  %76 = bitcast %union.TString.367* %add.ptr101 to i8*
  %77 = load i64* %l85, align 8
  %mul = mul i64 %77, 1
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %add.ptr94, i8* %76, i64 %mul, i32 1, i1 false)
  %78 = load i64* %l85, align 8
  %79 = load i64* %tl, align 8
  %add102 = add i64 %79, %78
  store i64 %add102, i64* %tl, align 8
  br label %do.cond

do.cond:                                          ; preds = %do.body84
  %80 = load i32* %i, align 4
  %dec = add nsw i32 %80, -1
  store i32 %dec, i32* %i, align 4
  %cmp103 = icmp sgt i32 %dec, 0
  br i1 %cmp103, label %do.body84, label %do.end

do.end:                                           ; preds = %do.cond
  %81 = load %struct.lua_TValue.349** %top, align 8
  %82 = load i32* %n, align 4
  %idx.ext104 = sext i32 %82 to i64
  %idx.neg105 = sub i64 0, %idx.ext104
  %add.ptr106 = getelementptr inbounds %struct.lua_TValue.349* %81, i64 %idx.neg105
  store %struct.lua_TValue.349* %add.ptr106, %struct.lua_TValue.349** %io, align 8
  %83 = load %struct.lua_State.364** %L.addr, align 8
  %84 = load i8** %buffer, align 8
  %85 = load i64* %tl, align 8
  %call107 = call %union.TString.367* @luaS_newlstr(%struct.lua_State.364* %83, i8* %84, i64 %85)
  store %union.TString.367* %call107, %union.TString.367** %x_, align 8
  %86 = load %union.TString.367** %x_, align 8
  %87 = bitcast %union.TString.367* %86 to %union.GCObject.365*
  %88 = load %struct.lua_TValue.349** %io, align 8
  %value_108 = getelementptr inbounds %struct.lua_TValue.349* %88, i32 0, i32 0
  %gc109 = bitcast %union.Value.348* %value_108 to %union.GCObject.365**
  store %union.GCObject.365* %87, %union.GCObject.365** %gc109, align 8
  %89 = load %union.TString.367** %x_, align 8
  %tsv110 = bitcast %union.TString.367* %89 to %struct.anon.366*
  %tt = getelementptr inbounds %struct.anon.366* %tsv110, i32 0, i32 1
  %90 = load i8* %tt, align 1
  %conv = zext i8 %90 to i32
  %or = or i32 %conv, 64
  %91 = load %struct.lua_TValue.349** %io, align 8
  %tt_111 = getelementptr inbounds %struct.lua_TValue.349* %91, i32 0, i32 1
  store i32 %or, i32* %tt_111, align 4
  br label %if.end112

if.end112:                                        ; preds = %do.end, %if.then42
  br label %if.end113

if.end113:                                        ; preds = %if.end112, %lor.end
  br label %if.end114

if.end114:                                        ; preds = %if.end113, %if.end
  %92 = load i32* %n, align 4
  %sub115 = sub nsw i32 %92, 1
  %93 = load i32* %total.addr, align 4
  %sub116 = sub nsw i32 %93, %sub115
  store i32 %sub116, i32* %total.addr, align 4
  %94 = load i32* %n, align 4
  %sub117 = sub nsw i32 %94, 1
  %95 = load %struct.lua_State.364** %L.addr, align 8
  %top118 = getelementptr inbounds %struct.lua_State.364* %95, i32 0, i32 4
  %96 = load %struct.lua_TValue.349** %top118, align 8
  %idx.ext119 = sext i32 %sub117 to i64
  %idx.neg120 = sub i64 0, %idx.ext119
  %add.ptr121 = getelementptr inbounds %struct.lua_TValue.349* %96, i64 %idx.neg120
  store %struct.lua_TValue.349* %add.ptr121, %struct.lua_TValue.349** %top118, align 8
  br label %do.cond122

do.cond122:                                       ; preds = %if.end114
  %97 = load i32* %total.addr, align 4
  %cmp123 = icmp sgt i32 %97, 1
  br i1 %cmp123, label %do.body, label %do.end125

do.end125:                                        ; preds = %do.cond122
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @luaV_objlen(%struct.lua_State.364* %L, %struct.lua_TValue.349* %ra, %struct.lua_TValue.349* %rb) #0 {
entry:
  %L.addr = alloca %struct.lua_State.364*, align 8
  %ra.addr = alloca %struct.lua_TValue.349*, align 8
  %rb.addr = alloca %struct.lua_TValue.349*, align 8
  %tm = alloca %struct.lua_TValue.349*, align 8
  %h = alloca %struct.Table.357*, align 8
  %io = alloca %struct.lua_TValue.349*, align 8
  %io15 = alloca %struct.lua_TValue.349*, align 8
  store %struct.lua_State.364* %L, %struct.lua_State.364** %L.addr, align 8
  store %struct.lua_TValue.349* %ra, %struct.lua_TValue.349** %ra.addr, align 8
  store %struct.lua_TValue.349* %rb, %struct.lua_TValue.349** %rb.addr, align 8
  %0 = load %struct.lua_TValue.349** %rb.addr, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue.349* %0, i32 0, i32 1
  %1 = load i32* %tt_, align 4
  %and = and i32 %1, 15
  switch i32 %and, label %sw.default [
    i32 5, label %sw.bb
    i32 4, label %sw.bb14
  ]

sw.bb:                                            ; preds = %entry
  %2 = load %struct.lua_TValue.349** %rb.addr, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue.349* %2, i32 0, i32 0
  %gc = bitcast %union.Value.348* %value_ to %union.GCObject.365**
  %3 = load %union.GCObject.365** %gc, align 8
  %h1 = bitcast %union.GCObject.365* %3 to %struct.Table.357*
  store %struct.Table.357* %h1, %struct.Table.357** %h, align 8
  %4 = load %struct.Table.357** %h, align 8
  %metatable = getelementptr inbounds %struct.Table.357* %4, i32 0, i32 5
  %5 = load %struct.Table.357** %metatable, align 8
  %cmp = icmp eq %struct.Table.357* %5, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %sw.bb
  br label %cond.end7

cond.false:                                       ; preds = %sw.bb
  %6 = load %struct.Table.357** %h, align 8
  %metatable2 = getelementptr inbounds %struct.Table.357* %6, i32 0, i32 5
  %7 = load %struct.Table.357** %metatable2, align 8
  %flags = getelementptr inbounds %struct.Table.357* %7, i32 0, i32 3
  %8 = load i8* %flags, align 1
  %conv = zext i8 %8 to i32
  %and3 = and i32 %conv, 16
  %tobool = icmp ne i32 %and3, 0
  br i1 %tobool, label %cond.true4, label %cond.false5

cond.true4:                                       ; preds = %cond.false
  br label %cond.end

cond.false5:                                      ; preds = %cond.false
  %9 = load %struct.Table.357** %h, align 8
  %metatable6 = getelementptr inbounds %struct.Table.357* %9, i32 0, i32 5
  %10 = load %struct.Table.357** %metatable6, align 8
  %11 = load %struct.lua_State.364** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State.364* %11, i32 0, i32 5
  %12 = load %struct.global_State.358** %l_G, align 8
  %tmname = getelementptr inbounds %struct.global_State.358* %12, i32 0, i32 33
  %arrayidx = getelementptr inbounds [17 x %union.TString.367*]* %tmname, i32 0, i64 4
  %13 = load %union.TString.367** %arrayidx, align 8
  %call = call %struct.lua_TValue.349* bitcast (%struct.lua_TValue* (%struct.Table*, i32, %union.TString*)* @luaT_gettm to %struct.lua_TValue.349* (%struct.Table.357*, i32, %union.TString.367*)*)(%struct.Table.357* %10, i32 4, %union.TString.367* %13)
  br label %cond.end

cond.end:                                         ; preds = %cond.false5, %cond.true4
  %cond = phi %struct.lua_TValue.349* [ null, %cond.true4 ], [ %call, %cond.false5 ]
  br label %cond.end7

cond.end7:                                        ; preds = %cond.end, %cond.true
  %cond8 = phi %struct.lua_TValue.349* [ null, %cond.true ], [ %cond, %cond.end ]
  store %struct.lua_TValue.349* %cond8, %struct.lua_TValue.349** %tm, align 8
  %14 = load %struct.lua_TValue.349** %tm, align 8
  %tobool9 = icmp ne %struct.lua_TValue.349* %14, null
  br i1 %tobool9, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end7
  br label %sw.epilog

if.end:                                           ; preds = %cond.end7
  %15 = load %struct.lua_TValue.349** %ra.addr, align 8
  store %struct.lua_TValue.349* %15, %struct.lua_TValue.349** %io, align 8
  %16 = load %struct.Table.357** %h, align 8
  %call10 = call i32 bitcast (i32 (%struct.Table*)* @luaH_getn to i32 (%struct.Table.357*)*)(%struct.Table.357* %16)
  %conv11 = sitofp i32 %call10 to double
  %17 = load %struct.lua_TValue.349** %io, align 8
  %value_12 = getelementptr inbounds %struct.lua_TValue.349* %17, i32 0, i32 0
  %n = bitcast %union.Value.348* %value_12 to double*
  store double %conv11, double* %n, align 8
  %18 = load %struct.lua_TValue.349** %io, align 8
  %tt_13 = getelementptr inbounds %struct.lua_TValue.349* %18, i32 0, i32 1
  store i32 3, i32* %tt_13, align 4
  br label %return

sw.bb14:                                          ; preds = %entry
  %19 = load %struct.lua_TValue.349** %ra.addr, align 8
  store %struct.lua_TValue.349* %19, %struct.lua_TValue.349** %io15, align 8
  %20 = load %struct.lua_TValue.349** %rb.addr, align 8
  %value_16 = getelementptr inbounds %struct.lua_TValue.349* %20, i32 0, i32 0
  %gc17 = bitcast %union.Value.348* %value_16 to %union.GCObject.365**
  %21 = load %union.GCObject.365** %gc17, align 8
  %ts = bitcast %union.GCObject.365* %21 to %union.TString.367*
  %tsv = bitcast %union.TString.367* %ts to %struct.anon.366*
  %len = getelementptr inbounds %struct.anon.366* %tsv, i32 0, i32 5
  %22 = load i64* %len, align 8
  %conv18 = uitofp i64 %22 to double
  %23 = load %struct.lua_TValue.349** %io15, align 8
  %value_19 = getelementptr inbounds %struct.lua_TValue.349* %23, i32 0, i32 0
  %n20 = bitcast %union.Value.348* %value_19 to double*
  store double %conv18, double* %n20, align 8
  %24 = load %struct.lua_TValue.349** %io15, align 8
  %tt_21 = getelementptr inbounds %struct.lua_TValue.349* %24, i32 0, i32 1
  store i32 3, i32* %tt_21, align 4
  br label %return

sw.default:                                       ; preds = %entry
  %25 = load %struct.lua_State.364** %L.addr, align 8
  %26 = load %struct.lua_TValue.349** %rb.addr, align 8
  %call22 = call %struct.lua_TValue.349* bitcast (%struct.lua_TValue* (%struct.lua_State*, %struct.lua_TValue*, i32)* @luaT_gettmbyobj to %struct.lua_TValue.349* (%struct.lua_State.364*, %struct.lua_TValue.349*, i32)*)(%struct.lua_State.364* %25, %struct.lua_TValue.349* %26, i32 4)
  store %struct.lua_TValue.349* %call22, %struct.lua_TValue.349** %tm, align 8
  %27 = load %struct.lua_TValue.349** %tm, align 8
  %tt_23 = getelementptr inbounds %struct.lua_TValue.349* %27, i32 0, i32 1
  %28 = load i32* %tt_23, align 4
  %cmp24 = icmp eq i32 %28, 0
  br i1 %cmp24, label %if.then26, label %if.end27

if.then26:                                        ; preds = %sw.default
  %29 = load %struct.lua_State.364** %L.addr, align 8
  %30 = load %struct.lua_TValue.349** %rb.addr, align 8
  call void bitcast (void (%struct.lua_State*, %struct.lua_TValue*, i8*)* @luaG_typeerror to void (%struct.lua_State.364*, %struct.lua_TValue.349*, i8*)*)(%struct.lua_State.364* %29, %struct.lua_TValue.349* %30, i8* getelementptr inbounds ([14 x i8]* @.str5831, i32 0, i32 0)) #9
  unreachable

if.end27:                                         ; preds = %sw.default
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end27, %if.then
  %31 = load %struct.lua_State.364** %L.addr, align 8
  %32 = load %struct.lua_TValue.349** %tm, align 8
  %33 = load %struct.lua_TValue.349** %rb.addr, align 8
  %34 = load %struct.lua_TValue.349** %rb.addr, align 8
  %35 = load %struct.lua_TValue.349** %ra.addr, align 8
  call void @callTM(%struct.lua_State.364* %31, %struct.lua_TValue.349* %32, %struct.lua_TValue.349* %33, %struct.lua_TValue.349* %34, %struct.lua_TValue.349* %35, i32 1)
  br label %return

return:                                           ; preds = %sw.epilog, %sw.bb14, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @luaV_arith(%struct.lua_State.364* %L, %struct.lua_TValue.349* %ra, %struct.lua_TValue.349* %rb, %struct.lua_TValue.349* %rc, i32 %op) #0 {
entry:
  %L.addr = alloca %struct.lua_State.364*, align 8
  %ra.addr = alloca %struct.lua_TValue.349*, align 8
  %rb.addr = alloca %struct.lua_TValue.349*, align 8
  %rc.addr = alloca %struct.lua_TValue.349*, align 8
  %op.addr = alloca i32, align 4
  %tempb = alloca %struct.lua_TValue.349, align 8
  %tempc = alloca %struct.lua_TValue.349, align 8
  %b = alloca %struct.lua_TValue.349*, align 8
  %c = alloca %struct.lua_TValue.349*, align 8
  %res = alloca double, align 8
  %io = alloca %struct.lua_TValue.349*, align 8
  store %struct.lua_State.364* %L, %struct.lua_State.364** %L.addr, align 8
  store %struct.lua_TValue.349* %ra, %struct.lua_TValue.349** %ra.addr, align 8
  store %struct.lua_TValue.349* %rb, %struct.lua_TValue.349** %rb.addr, align 8
  store %struct.lua_TValue.349* %rc, %struct.lua_TValue.349** %rc.addr, align 8
  store i32 %op, i32* %op.addr, align 4
  %0 = load %struct.lua_TValue.349** %rb.addr, align 8
  %call = call %struct.lua_TValue.349* @luaV_tonumber(%struct.lua_TValue.349* %0, %struct.lua_TValue.349* %tempb)
  store %struct.lua_TValue.349* %call, %struct.lua_TValue.349** %b, align 8
  %cmp = icmp ne %struct.lua_TValue.349* %call, null
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %1 = load %struct.lua_TValue.349** %rc.addr, align 8
  %call1 = call %struct.lua_TValue.349* @luaV_tonumber(%struct.lua_TValue.349* %1, %struct.lua_TValue.349* %tempc)
  store %struct.lua_TValue.349* %call1, %struct.lua_TValue.349** %c, align 8
  %cmp2 = icmp ne %struct.lua_TValue.349* %call1, null
  br i1 %cmp2, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %2 = load i32* %op.addr, align 4
  %sub = sub i32 %2, 6
  %add = add i32 %sub, 0
  %3 = load %struct.lua_TValue.349** %b, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue.349* %3, i32 0, i32 0
  %n = bitcast %union.Value.348* %value_ to double*
  %4 = load double* %n, align 8
  %5 = load %struct.lua_TValue.349** %c, align 8
  %value_3 = getelementptr inbounds %struct.lua_TValue.349* %5, i32 0, i32 0
  %n4 = bitcast %union.Value.348* %value_3 to double*
  %6 = load double* %n4, align 8
  %call5 = call double @luaO_arith(i32 %add, double %4, double %6)
  store double %call5, double* %res, align 8
  %7 = load %struct.lua_TValue.349** %ra.addr, align 8
  store %struct.lua_TValue.349* %7, %struct.lua_TValue.349** %io, align 8
  %8 = load double* %res, align 8
  %9 = load %struct.lua_TValue.349** %io, align 8
  %value_6 = getelementptr inbounds %struct.lua_TValue.349* %9, i32 0, i32 0
  %n7 = bitcast %union.Value.348* %value_6 to double*
  store double %8, double* %n7, align 8
  %10 = load %struct.lua_TValue.349** %io, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue.349* %10, i32 0, i32 1
  store i32 3, i32* %tt_, align 4
  br label %if.end10

if.else:                                          ; preds = %land.lhs.true, %entry
  %11 = load %struct.lua_State.364** %L.addr, align 8
  %12 = load %struct.lua_TValue.349** %rb.addr, align 8
  %13 = load %struct.lua_TValue.349** %rc.addr, align 8
  %14 = load %struct.lua_TValue.349** %ra.addr, align 8
  %15 = load i32* %op.addr, align 4
  %call8 = call i32 @call_binTM(%struct.lua_State.364* %11, %struct.lua_TValue.349* %12, %struct.lua_TValue.349* %13, %struct.lua_TValue.349* %14, i32 %15)
  %tobool = icmp ne i32 %call8, 0
  br i1 %tobool, label %if.end, label %if.then9

if.then9:                                         ; preds = %if.else
  %16 = load %struct.lua_State.364** %L.addr, align 8
  %17 = load %struct.lua_TValue.349** %rb.addr, align 8
  %18 = load %struct.lua_TValue.349** %rc.addr, align 8
  call void bitcast (void (%struct.lua_State*, %struct.lua_TValue*, %struct.lua_TValue*)* @luaG_aritherror to void (%struct.lua_State.364*, %struct.lua_TValue.349*, %struct.lua_TValue.349*)*)(%struct.lua_State.364* %16, %struct.lua_TValue.349* %17, %struct.lua_TValue.349* %18) #9
  unreachable

if.end:                                           ; preds = %if.else
  br label %if.end10

if.end10:                                         ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @luaV_finishOp(%struct.lua_State.364* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State.364*, align 8
  %ci = alloca %struct.CallInfo.361*, align 8
  %base = alloca %struct.lua_TValue.349*, align 8
  %inst = alloca i32, align 4
  %op = alloca i32, align 4
  %io2 = alloca %struct.lua_TValue.349*, align 8
  %io1 = alloca %struct.lua_TValue.349*, align 8
  %res = alloca i32, align 4
  %top43 = alloca %struct.lua_TValue.349*, align 8
  %b46 = alloca i32, align 4
  %total = alloca i32, align 4
  %io252 = alloca %struct.lua_TValue.349*, align 8
  %io153 = alloca %struct.lua_TValue.349*, align 8
  %io265 = alloca %struct.lua_TValue.349*, align 8
  %io168 = alloca %struct.lua_TValue.349*, align 8
  store %struct.lua_State.364* %L, %struct.lua_State.364** %L.addr, align 8
  %0 = load %struct.lua_State.364** %L.addr, align 8
  %ci1 = getelementptr inbounds %struct.lua_State.364* %0, i32 0, i32 6
  %1 = load %struct.CallInfo.361** %ci1, align 8
  store %struct.CallInfo.361* %1, %struct.CallInfo.361** %ci, align 8
  %2 = load %struct.CallInfo.361** %ci, align 8
  %u = getelementptr inbounds %struct.CallInfo.361* %2, i32 0, i32 7
  %l = bitcast %union.anon.360* %u to %struct.anon.482*
  %base2 = getelementptr inbounds %struct.anon.482* %l, i32 0, i32 0
  %3 = load %struct.lua_TValue.349** %base2, align 8
  store %struct.lua_TValue.349* %3, %struct.lua_TValue.349** %base, align 8
  %4 = load %struct.CallInfo.361** %ci, align 8
  %u3 = getelementptr inbounds %struct.CallInfo.361* %4, i32 0, i32 7
  %l4 = bitcast %union.anon.360* %u3 to %struct.anon.482*
  %savedpc = getelementptr inbounds %struct.anon.482* %l4, i32 0, i32 1
  %5 = load i32** %savedpc, align 8
  %add.ptr = getelementptr inbounds i32* %5, i64 -1
  %6 = load i32* %add.ptr, align 4
  store i32 %6, i32* %inst, align 4
  %7 = load i32* %inst, align 4
  %shr = lshr i32 %7, 0
  %and = and i32 %shr, 63
  store i32 %and, i32* %op, align 4
  %8 = load i32* %op, align 4
  switch i32 %8, label %sw.default [
    i32 13, label %sw.bb
    i32 14, label %sw.bb
    i32 15, label %sw.bb
    i32 16, label %sw.bb
    i32 17, label %sw.bb
    i32 18, label %sw.bb
    i32 19, label %sw.bb
    i32 21, label %sw.bb
    i32 6, label %sw.bb
    i32 7, label %sw.bb
    i32 12, label %sw.bb
    i32 26, label %sw.bb10
    i32 25, label %sw.bb10
    i32 24, label %sw.bb10
    i32 22, label %sw.bb42
    i32 34, label %sw.bb82
    i32 29, label %sw.bb85
    i32 30, label %sw.bb94
    i32 8, label %sw.bb94
    i32 10, label %sw.bb94
  ]

sw.bb:                                            ; preds = %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry
  %9 = load %struct.lua_State.364** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State.364* %9, i32 0, i32 4
  %10 = load %struct.lua_TValue.349** %top, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue.349* %10, i32 -1
  store %struct.lua_TValue.349* %incdec.ptr, %struct.lua_TValue.349** %top, align 8
  store %struct.lua_TValue.349* %incdec.ptr, %struct.lua_TValue.349** %io2, align 8
  %11 = load %struct.lua_TValue.349** %base, align 8
  %12 = load i32* %inst, align 4
  %shr5 = lshr i32 %12, 6
  %and6 = and i32 %shr5, 255
  %idx.ext = sext i32 %and6 to i64
  %add.ptr7 = getelementptr inbounds %struct.lua_TValue.349* %11, i64 %idx.ext
  store %struct.lua_TValue.349* %add.ptr7, %struct.lua_TValue.349** %io1, align 8
  %13 = load %struct.lua_TValue.349** %io1, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue.349* %13, i32 0, i32 0
  %14 = load %struct.lua_TValue.349** %io2, align 8
  %value_8 = getelementptr inbounds %struct.lua_TValue.349* %14, i32 0, i32 0
  %15 = bitcast %union.Value.348* %value_ to i8*
  %16 = bitcast %union.Value.348* %value_8 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %15, i8* %16, i64 8, i32 8, i1 false)
  %17 = load %struct.lua_TValue.349** %io2, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue.349* %17, i32 0, i32 1
  %18 = load i32* %tt_, align 4
  %19 = load %struct.lua_TValue.349** %io1, align 8
  %tt_9 = getelementptr inbounds %struct.lua_TValue.349* %19, i32 0, i32 1
  store i32 %18, i32* %tt_9, align 4
  br label %sw.epilog

sw.bb10:                                          ; preds = %entry, %entry, %entry
  %20 = load %struct.lua_State.364** %L.addr, align 8
  %top11 = getelementptr inbounds %struct.lua_State.364* %20, i32 0, i32 4
  %21 = load %struct.lua_TValue.349** %top11, align 8
  %add.ptr12 = getelementptr inbounds %struct.lua_TValue.349* %21, i64 -1
  %tt_13 = getelementptr inbounds %struct.lua_TValue.349* %add.ptr12, i32 0, i32 1
  %22 = load i32* %tt_13, align 4
  %cmp = icmp eq i32 %22, 0
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %sw.bb10
  %23 = load %struct.lua_State.364** %L.addr, align 8
  %top14 = getelementptr inbounds %struct.lua_State.364* %23, i32 0, i32 4
  %24 = load %struct.lua_TValue.349** %top14, align 8
  %add.ptr15 = getelementptr inbounds %struct.lua_TValue.349* %24, i64 -1
  %tt_16 = getelementptr inbounds %struct.lua_TValue.349* %add.ptr15, i32 0, i32 1
  %25 = load i32* %tt_16, align 4
  %cmp17 = icmp eq i32 %25, 1
  br i1 %cmp17, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %lor.rhs
  %26 = load %struct.lua_State.364** %L.addr, align 8
  %top18 = getelementptr inbounds %struct.lua_State.364* %26, i32 0, i32 4
  %27 = load %struct.lua_TValue.349** %top18, align 8
  %add.ptr19 = getelementptr inbounds %struct.lua_TValue.349* %27, i64 -1
  %value_20 = getelementptr inbounds %struct.lua_TValue.349* %add.ptr19, i32 0, i32 0
  %b = bitcast %union.Value.348* %value_20 to i32*
  %28 = load i32* %b, align 4
  %cmp21 = icmp eq i32 %28, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %lor.rhs
  %29 = phi i1 [ false, %lor.rhs ], [ %cmp21, %land.rhs ]
  br label %lor.end

lor.end:                                          ; preds = %land.end, %sw.bb10
  %30 = phi i1 [ true, %sw.bb10 ], [ %29, %land.end ]
  %lnot = xor i1 %30, true
  %lnot.ext = zext i1 %lnot to i32
  store i32 %lnot.ext, i32* %res, align 4
  %31 = load %struct.lua_State.364** %L.addr, align 8
  %top22 = getelementptr inbounds %struct.lua_State.364* %31, i32 0, i32 4
  %32 = load %struct.lua_TValue.349** %top22, align 8
  %incdec.ptr23 = getelementptr inbounds %struct.lua_TValue.349* %32, i32 -1
  store %struct.lua_TValue.349* %incdec.ptr23, %struct.lua_TValue.349** %top22, align 8
  %33 = load i32* %op, align 4
  %cmp24 = icmp eq i32 %33, 26
  br i1 %cmp24, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.end
  %34 = load %struct.lua_State.364** %L.addr, align 8
  %35 = load %struct.lua_TValue.349** %base, align 8
  %36 = load i32* %inst, align 4
  %shr25 = lshr i32 %36, 23
  %and26 = and i32 %shr25, 511
  %idx.ext27 = sext i32 %and26 to i64
  %add.ptr28 = getelementptr inbounds %struct.lua_TValue.349* %35, i64 %idx.ext27
  %call = call %struct.lua_TValue.349* bitcast (%struct.lua_TValue* (%struct.lua_State*, %struct.lua_TValue*, i32)* @luaT_gettmbyobj to %struct.lua_TValue.349* (%struct.lua_State.364*, %struct.lua_TValue.349*, i32)*)(%struct.lua_State.364* %34, %struct.lua_TValue.349* %add.ptr28, i32 14)
  %tt_29 = getelementptr inbounds %struct.lua_TValue.349* %call, i32 0, i32 1
  %37 = load i32* %tt_29, align 4
  %cmp30 = icmp eq i32 %37, 0
  br i1 %cmp30, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %38 = load i32* %res, align 4
  %tobool = icmp ne i32 %38, 0
  %lnot31 = xor i1 %tobool, true
  %lnot.ext32 = zext i1 %lnot31 to i32
  store i32 %lnot.ext32, i32* %res, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %lor.end
  %39 = load i32* %res, align 4
  %40 = load i32* %inst, align 4
  %shr33 = lshr i32 %40, 6
  %and34 = and i32 %shr33, 255
  %cmp35 = icmp ne i32 %39, %and34
  br i1 %cmp35, label %if.then36, label %if.end41

if.then36:                                        ; preds = %if.end
  %41 = load %struct.CallInfo.361** %ci, align 8
  %u37 = getelementptr inbounds %struct.CallInfo.361* %41, i32 0, i32 7
  %l38 = bitcast %union.anon.360* %u37 to %struct.anon.482*
  %savedpc39 = getelementptr inbounds %struct.anon.482* %l38, i32 0, i32 1
  %42 = load i32** %savedpc39, align 8
  %incdec.ptr40 = getelementptr inbounds i32* %42, i32 1
  store i32* %incdec.ptr40, i32** %savedpc39, align 8
  br label %if.end41

if.end41:                                         ; preds = %if.then36, %if.end
  br label %sw.epilog

sw.bb42:                                          ; preds = %entry
  %43 = load %struct.lua_State.364** %L.addr, align 8
  %top44 = getelementptr inbounds %struct.lua_State.364* %43, i32 0, i32 4
  %44 = load %struct.lua_TValue.349** %top44, align 8
  %add.ptr45 = getelementptr inbounds %struct.lua_TValue.349* %44, i64 -1
  store %struct.lua_TValue.349* %add.ptr45, %struct.lua_TValue.349** %top43, align 8
  %45 = load i32* %inst, align 4
  %shr47 = lshr i32 %45, 23
  %and48 = and i32 %shr47, 511
  store i32 %and48, i32* %b46, align 4
  %46 = load %struct.lua_TValue.349** %top43, align 8
  %add.ptr49 = getelementptr inbounds %struct.lua_TValue.349* %46, i64 -1
  %47 = load %struct.lua_TValue.349** %base, align 8
  %48 = load i32* %b46, align 4
  %idx.ext50 = sext i32 %48 to i64
  %add.ptr51 = getelementptr inbounds %struct.lua_TValue.349* %47, i64 %idx.ext50
  %sub.ptr.lhs.cast = ptrtoint %struct.lua_TValue.349* %add.ptr49 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.lua_TValue.349* %add.ptr51 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 16
  %conv = trunc i64 %sub.ptr.div to i32
  store i32 %conv, i32* %total, align 4
  %49 = load %struct.lua_TValue.349** %top43, align 8
  store %struct.lua_TValue.349* %49, %struct.lua_TValue.349** %io252, align 8
  %50 = load %struct.lua_TValue.349** %top43, align 8
  %add.ptr54 = getelementptr inbounds %struct.lua_TValue.349* %50, i64 -2
  store %struct.lua_TValue.349* %add.ptr54, %struct.lua_TValue.349** %io153, align 8
  %51 = load %struct.lua_TValue.349** %io153, align 8
  %value_55 = getelementptr inbounds %struct.lua_TValue.349* %51, i32 0, i32 0
  %52 = load %struct.lua_TValue.349** %io252, align 8
  %value_56 = getelementptr inbounds %struct.lua_TValue.349* %52, i32 0, i32 0
  %53 = bitcast %union.Value.348* %value_55 to i8*
  %54 = bitcast %union.Value.348* %value_56 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %53, i8* %54, i64 8, i32 8, i1 false)
  %55 = load %struct.lua_TValue.349** %io252, align 8
  %tt_57 = getelementptr inbounds %struct.lua_TValue.349* %55, i32 0, i32 1
  %56 = load i32* %tt_57, align 4
  %57 = load %struct.lua_TValue.349** %io153, align 8
  %tt_58 = getelementptr inbounds %struct.lua_TValue.349* %57, i32 0, i32 1
  store i32 %56, i32* %tt_58, align 4
  %58 = load i32* %total, align 4
  %cmp59 = icmp sgt i32 %58, 1
  br i1 %cmp59, label %if.then61, label %if.end64

if.then61:                                        ; preds = %sw.bb42
  %59 = load %struct.lua_TValue.349** %top43, align 8
  %add.ptr62 = getelementptr inbounds %struct.lua_TValue.349* %59, i64 -1
  %60 = load %struct.lua_State.364** %L.addr, align 8
  %top63 = getelementptr inbounds %struct.lua_State.364* %60, i32 0, i32 4
  store %struct.lua_TValue.349* %add.ptr62, %struct.lua_TValue.349** %top63, align 8
  %61 = load %struct.lua_State.364** %L.addr, align 8
  %62 = load i32* %total, align 4
  call void @luaV_concat(%struct.lua_State.364* %61, i32 %62)
  br label %if.end64

if.end64:                                         ; preds = %if.then61, %sw.bb42
  %63 = load %struct.lua_State.364** %L.addr, align 8
  %top66 = getelementptr inbounds %struct.lua_State.364* %63, i32 0, i32 4
  %64 = load %struct.lua_TValue.349** %top66, align 8
  %add.ptr67 = getelementptr inbounds %struct.lua_TValue.349* %64, i64 -1
  store %struct.lua_TValue.349* %add.ptr67, %struct.lua_TValue.349** %io265, align 8
  %65 = load %struct.CallInfo.361** %ci, align 8
  %u69 = getelementptr inbounds %struct.CallInfo.361* %65, i32 0, i32 7
  %l70 = bitcast %union.anon.360* %u69 to %struct.anon.482*
  %base71 = getelementptr inbounds %struct.anon.482* %l70, i32 0, i32 0
  %66 = load %struct.lua_TValue.349** %base71, align 8
  %67 = load i32* %inst, align 4
  %shr72 = lshr i32 %67, 6
  %and73 = and i32 %shr72, 255
  %idx.ext74 = sext i32 %and73 to i64
  %add.ptr75 = getelementptr inbounds %struct.lua_TValue.349* %66, i64 %idx.ext74
  store %struct.lua_TValue.349* %add.ptr75, %struct.lua_TValue.349** %io168, align 8
  %68 = load %struct.lua_TValue.349** %io168, align 8
  %value_76 = getelementptr inbounds %struct.lua_TValue.349* %68, i32 0, i32 0
  %69 = load %struct.lua_TValue.349** %io265, align 8
  %value_77 = getelementptr inbounds %struct.lua_TValue.349* %69, i32 0, i32 0
  %70 = bitcast %union.Value.348* %value_76 to i8*
  %71 = bitcast %union.Value.348* %value_77 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %70, i8* %71, i64 8, i32 8, i1 false)
  %72 = load %struct.lua_TValue.349** %io265, align 8
  %tt_78 = getelementptr inbounds %struct.lua_TValue.349* %72, i32 0, i32 1
  %73 = load i32* %tt_78, align 4
  %74 = load %struct.lua_TValue.349** %io168, align 8
  %tt_79 = getelementptr inbounds %struct.lua_TValue.349* %74, i32 0, i32 1
  store i32 %73, i32* %tt_79, align 4
  %75 = load %struct.CallInfo.361** %ci, align 8
  %top80 = getelementptr inbounds %struct.CallInfo.361* %75, i32 0, i32 1
  %76 = load %struct.lua_TValue.349** %top80, align 8
  %77 = load %struct.lua_State.364** %L.addr, align 8
  %top81 = getelementptr inbounds %struct.lua_State.364* %77, i32 0, i32 4
  store %struct.lua_TValue.349* %76, %struct.lua_TValue.349** %top81, align 8
  br label %sw.epilog

sw.bb82:                                          ; preds = %entry
  %78 = load %struct.CallInfo.361** %ci, align 8
  %top83 = getelementptr inbounds %struct.CallInfo.361* %78, i32 0, i32 1
  %79 = load %struct.lua_TValue.349** %top83, align 8
  %80 = load %struct.lua_State.364** %L.addr, align 8
  %top84 = getelementptr inbounds %struct.lua_State.364* %80, i32 0, i32 4
  store %struct.lua_TValue.349* %79, %struct.lua_TValue.349** %top84, align 8
  br label %sw.epilog

sw.bb85:                                          ; preds = %entry
  %81 = load i32* %inst, align 4
  %shr86 = lshr i32 %81, 14
  %and87 = and i32 %shr86, 511
  %sub = sub nsw i32 %and87, 1
  %cmp88 = icmp sge i32 %sub, 0
  br i1 %cmp88, label %if.then90, label %if.end93

if.then90:                                        ; preds = %sw.bb85
  %82 = load %struct.CallInfo.361** %ci, align 8
  %top91 = getelementptr inbounds %struct.CallInfo.361* %82, i32 0, i32 1
  %83 = load %struct.lua_TValue.349** %top91, align 8
  %84 = load %struct.lua_State.364** %L.addr, align 8
  %top92 = getelementptr inbounds %struct.lua_State.364* %84, i32 0, i32 4
  store %struct.lua_TValue.349* %83, %struct.lua_TValue.349** %top92, align 8
  br label %if.end93

if.end93:                                         ; preds = %if.then90, %sw.bb85
  br label %sw.epilog

sw.bb94:                                          ; preds = %entry, %entry, %entry
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb94, %if.end93, %sw.bb82, %if.end64, %if.end41, %sw.bb
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @luaV_execute(%struct.lua_State.364* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State.364*, align 8
  %ci = alloca %struct.CallInfo.361*, align 8
  %cl = alloca %struct.LClosure.483*, align 8
  %k = alloca %struct.lua_TValue.349*, align 8
  %base = alloca %struct.lua_TValue.349*, align 8
  %i = alloca i32, align 4
  %ra = alloca %struct.lua_TValue.349*, align 8
  %io2 = alloca %struct.lua_TValue.349*, align 8
  %io1 = alloca %struct.lua_TValue.349*, align 8
  %rb = alloca %struct.lua_TValue.349*, align 8
  %io231 = alloca %struct.lua_TValue.349*, align 8
  %io132 = alloca %struct.lua_TValue.349*, align 8
  %rb38 = alloca %struct.lua_TValue.349*, align 8
  %io247 = alloca %struct.lua_TValue.349*, align 8
  %io148 = alloca %struct.lua_TValue.349*, align 8
  %io = alloca %struct.lua_TValue.349*, align 8
  %b68 = alloca i32, align 4
  %b76 = alloca i32, align 4
  %io279 = alloca %struct.lua_TValue.349*, align 8
  %io180 = alloca %struct.lua_TValue.349*, align 8
  %b86 = alloca i32, align 4
  %a = alloca i32, align 4
  %uv = alloca %struct.UpVal.352*, align 8
  %io2184 = alloca %struct.lua_TValue.349*, align 8
  %io1185 = alloca %struct.lua_TValue.349*, align 8
  %b249 = alloca i32, align 4
  %c = alloca i32, align 4
  %t = alloca %struct.Table.357*, align 8
  %io254 = alloca %struct.lua_TValue.349*, align 8
  %rb278 = alloca %struct.lua_TValue.349*, align 8
  %io2283 = alloca %struct.lua_TValue.349*, align 8
  %io1284 = alloca %struct.lua_TValue.349*, align 8
  %rb311 = alloca %struct.lua_TValue.349*, align 8
  %rc = alloca %struct.lua_TValue.349*, align 8
  %nb = alloca double, align 8
  %nc = alloca double, align 8
  %io357 = alloca %struct.lua_TValue.349*, align 8
  %rb366 = alloca %struct.lua_TValue.349*, align 8
  %rc384 = alloca %struct.lua_TValue.349*, align 8
  %nb410 = alloca double, align 8
  %nc413 = alloca double, align 8
  %io416 = alloca %struct.lua_TValue.349*, align 8
  %rb426 = alloca %struct.lua_TValue.349*, align 8
  %rc444 = alloca %struct.lua_TValue.349*, align 8
  %nb470 = alloca double, align 8
  %nc473 = alloca double, align 8
  %io476 = alloca %struct.lua_TValue.349*, align 8
  %rb486 = alloca %struct.lua_TValue.349*, align 8
  %rc504 = alloca %struct.lua_TValue.349*, align 8
  %nb530 = alloca double, align 8
  %nc533 = alloca double, align 8
  %io536 = alloca %struct.lua_TValue.349*, align 8
  %rb546 = alloca %struct.lua_TValue.349*, align 8
  %rc564 = alloca %struct.lua_TValue.349*, align 8
  %nb590 = alloca double, align 8
  %nc593 = alloca double, align 8
  %io596 = alloca %struct.lua_TValue.349*, align 8
  %rb610 = alloca %struct.lua_TValue.349*, align 8
  %rc628 = alloca %struct.lua_TValue.349*, align 8
  %nb654 = alloca double, align 8
  %nc657 = alloca double, align 8
  %io660 = alloca %struct.lua_TValue.349*, align 8
  %rb671 = alloca %struct.lua_TValue.349*, align 8
  %nb680 = alloca double, align 8
  %io683 = alloca %struct.lua_TValue.349*, align 8
  %rb694 = alloca %struct.lua_TValue.349*, align 8
  %res = alloca i32, align 4
  %io709 = alloca %struct.lua_TValue.349*, align 8
  %b722 = alloca i32, align 4
  %c725 = alloca i32, align 4
  %rb728 = alloca %struct.lua_TValue.349*, align 8
  %io2744 = alloca %struct.lua_TValue.349*, align 8
  %io1745 = alloca %struct.lua_TValue.349*, align 8
  %a772 = alloca i32, align 4
  %rb795 = alloca %struct.lua_TValue.349*, align 8
  %rc813 = alloca %struct.lua_TValue.349*, align 8
  %a852 = alloca i32, align 4
  %a927 = alloca i32, align 4
  %a1002 = alloca i32, align 4
  %a1067 = alloca i32, align 4
  %rb1091 = alloca %struct.lua_TValue.349*, align 8
  %io21131 = alloca %struct.lua_TValue.349*, align 8
  %io11132 = alloca %struct.lua_TValue.349*, align 8
  %a1140 = alloca i32, align 4
  %b1164 = alloca i32, align 4
  %nresults = alloca i32, align 4
  %b1195 = alloca i32, align 4
  %nci = alloca %struct.CallInfo.361*, align 8
  %oci = alloca %struct.CallInfo.361*, align 8
  %nfunc = alloca %struct.lua_TValue.349*, align 8
  %ofunc = alloca %struct.lua_TValue.349*, align 8
  %lim = alloca %struct.lua_TValue.349*, align 8
  %aux = alloca i32, align 4
  %io21239 = alloca %struct.lua_TValue.349*, align 8
  %io11242 = alloca %struct.lua_TValue.349*, align 8
  %b1277 = alloca i32, align 4
  %step = alloca double, align 8
  %idx = alloca double, align 8
  %limit = alloca double, align 8
  %io1334 = alloca %struct.lua_TValue.349*, align 8
  %io1338 = alloca %struct.lua_TValue.349*, align 8
  %init = alloca %struct.lua_TValue.349*, align 8
  %plimit = alloca %struct.lua_TValue.349*, align 8
  %pstep = alloca %struct.lua_TValue.349*, align 8
  %io1378 = alloca %struct.lua_TValue.349*, align 8
  %cb = alloca %struct.lua_TValue.349*, align 8
  %io21397 = alloca %struct.lua_TValue.349*, align 8
  %io11399 = alloca %struct.lua_TValue.349*, align 8
  %io21405 = alloca %struct.lua_TValue.349*, align 8
  %io11407 = alloca %struct.lua_TValue.349*, align 8
  %io21413 = alloca %struct.lua_TValue.349*, align 8
  %io11414 = alloca %struct.lua_TValue.349*, align 8
  %io21442 = alloca %struct.lua_TValue.349*, align 8
  %io11444 = alloca %struct.lua_TValue.349*, align 8
  %n1459 = alloca i32, align 4
  %c1462 = alloca i32, align 4
  %last = alloca i32, align 4
  %h = alloca %struct.Table.357*, align 8
  %val = alloca %struct.lua_TValue.349*, align 8
  %p1528 = alloca %struct.Proto.478*, align 8
  %ncl = alloca %union.Closure.475*, align 8
  %io1543 = alloca %struct.lua_TValue.349*, align 8
  %b1562 = alloca i32, align 4
  %j = alloca i32, align 4
  %n1566 = alloca i32, align 4
  %io21610 = alloca %struct.lua_TValue.349*, align 8
  %io11615 = alloca %struct.lua_TValue.349*, align 8
  store %struct.lua_State.364* %L, %struct.lua_State.364** %L.addr, align 8
  %0 = load %struct.lua_State.364** %L.addr, align 8
  %ci1 = getelementptr inbounds %struct.lua_State.364* %0, i32 0, i32 6
  %1 = load %struct.CallInfo.361** %ci1, align 8
  store %struct.CallInfo.361* %1, %struct.CallInfo.361** %ci, align 8
  br label %newframe

newframe:                                         ; preds = %if.end1306, %for.end, %if.else1189, %entry
  %2 = load %struct.CallInfo.361** %ci, align 8
  %func = getelementptr inbounds %struct.CallInfo.361* %2, i32 0, i32 0
  %3 = load %struct.lua_TValue.349** %func, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue.349* %3, i32 0, i32 0
  %gc = bitcast %union.Value.348* %value_ to %union.GCObject.365**
  %4 = load %union.GCObject.365** %gc, align 8
  %cl2 = bitcast %union.GCObject.365* %4 to %union.Closure.475*
  %l = bitcast %union.Closure.475* %cl2 to %struct.LClosure.483*
  store %struct.LClosure.483* %l, %struct.LClosure.483** %cl, align 8
  %5 = load %struct.LClosure.483** %cl, align 8
  %p = getelementptr inbounds %struct.LClosure.483* %5, i32 0, i32 5
  %6 = load %struct.Proto.478** %p, align 8
  %k3 = getelementptr inbounds %struct.Proto.478* %6, i32 0, i32 3
  %7 = load %struct.lua_TValue.349** %k3, align 8
  store %struct.lua_TValue.349* %7, %struct.lua_TValue.349** %k, align 8
  %8 = load %struct.CallInfo.361** %ci, align 8
  %u = getelementptr inbounds %struct.CallInfo.361* %8, i32 0, i32 7
  %l4 = bitcast %union.anon.360* %u to %struct.anon.482*
  %base5 = getelementptr inbounds %struct.anon.482* %l4, i32 0, i32 0
  %9 = load %struct.lua_TValue.349** %base5, align 8
  store %struct.lua_TValue.349* %9, %struct.lua_TValue.349** %base, align 8
  br label %for.cond

for.cond:                                         ; preds = %sw.epilog, %newframe
  %10 = load %struct.CallInfo.361** %ci, align 8
  %u6 = getelementptr inbounds %struct.CallInfo.361* %10, i32 0, i32 7
  %l7 = bitcast %union.anon.360* %u6 to %struct.anon.482*
  %savedpc = getelementptr inbounds %struct.anon.482* %l7, i32 0, i32 1
  %11 = load i32** %savedpc, align 8
  %incdec.ptr = getelementptr inbounds i32* %11, i32 1
  store i32* %incdec.ptr, i32** %savedpc, align 8
  %12 = load i32* %11, align 4
  store i32 %12, i32* %i, align 4
  %13 = load %struct.lua_State.364** %L.addr, align 8
  %hookmask = getelementptr inbounds %struct.lua_State.364* %13, i32 0, i32 13
  %14 = load i8* %hookmask, align 1
  %conv = zext i8 %14 to i32
  %and = and i32 %conv, 12
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.cond
  %15 = load %struct.lua_State.364** %L.addr, align 8
  %hookcount = getelementptr inbounds %struct.lua_State.364* %15, i32 0, i32 16
  %16 = load i32* %hookcount, align 4
  %dec = add nsw i32 %16, -1
  store i32 %dec, i32* %hookcount, align 4
  %cmp = icmp eq i32 %dec, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %17 = load %struct.lua_State.364** %L.addr, align 8
  %hookmask9 = getelementptr inbounds %struct.lua_State.364* %17, i32 0, i32 13
  %18 = load i8* %hookmask9, align 1
  %conv10 = zext i8 %18 to i32
  %and11 = and i32 %conv10, 4
  %tobool12 = icmp ne i32 %and11, 0
  br i1 %tobool12, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %19 = load %struct.lua_State.364** %L.addr, align 8
  call void @traceexec(%struct.lua_State.364* %19)
  %20 = load %struct.CallInfo.361** %ci, align 8
  %u13 = getelementptr inbounds %struct.CallInfo.361* %20, i32 0, i32 7
  %l14 = bitcast %union.anon.360* %u13 to %struct.anon.482*
  %base15 = getelementptr inbounds %struct.anon.482* %l14, i32 0, i32 0
  %21 = load %struct.lua_TValue.349** %base15, align 8
  store %struct.lua_TValue.349* %21, %struct.lua_TValue.349** %base, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false, %for.cond
  %22 = load %struct.lua_TValue.349** %base, align 8
  %23 = load i32* %i, align 4
  %shr = lshr i32 %23, 6
  %and16 = and i32 %shr, 255
  %idx.ext = sext i32 %and16 to i64
  %add.ptr = getelementptr inbounds %struct.lua_TValue.349* %22, i64 %idx.ext
  store %struct.lua_TValue.349* %add.ptr, %struct.lua_TValue.349** %ra, align 8
  %24 = load i32* %i, align 4
  %shr17 = lshr i32 %24, 0
  %and18 = and i32 %shr17, 63
  switch i32 %and18, label %sw.epilog [
    i32 0, label %sw.bb
    i32 1, label %sw.bb26
    i32 2, label %sw.bb37
    i32 3, label %sw.bb53
    i32 4, label %sw.bb67
    i32 5, label %sw.bb75
    i32 6, label %sw.bb85
    i32 7, label %sw.bb109
    i32 8, label %sw.bb134
    i32 9, label %sw.bb178
    i32 10, label %sw.bb210
    i32 11, label %sw.bb248
    i32 12, label %sw.bb277
    i32 13, label %sw.bb310
    i32 14, label %sw.bb365
    i32 15, label %sw.bb425
    i32 16, label %sw.bb485
    i32 17, label %sw.bb545
    i32 18, label %sw.bb609
    i32 19, label %sw.bb670
    i32 20, label %sw.bb693
    i32 21, label %sw.bb713
    i32 22, label %sw.bb721
    i32 23, label %sw.bb771
    i32 24, label %sw.bb794
    i32 25, label %sw.bb878
    i32 26, label %sw.bb953
    i32 27, label %sw.bb1028
    i32 28, label %sw.bb1090
    i32 29, label %sw.bb1163
    i32 30, label %sw.bb1194
    i32 31, label %sw.bb1276
    i32 32, label %sw.bb1307
    i32 33, label %sw.bb1344
    i32 34, label %sw.bb1395
    i32 35, label %sw.bb1436
    i32 36, label %sw.bb1458
    i32 37, label %sw.bb1527
    i32 38, label %sw.bb1561
    i32 39, label %sw.bb1630
  ]

sw.bb:                                            ; preds = %if.end
  %25 = load %struct.lua_TValue.349** %base, align 8
  %26 = load i32* %i, align 4
  %shr19 = lshr i32 %26, 23
  %and20 = and i32 %shr19, 511
  %idx.ext21 = sext i32 %and20 to i64
  %add.ptr22 = getelementptr inbounds %struct.lua_TValue.349* %25, i64 %idx.ext21
  store %struct.lua_TValue.349* %add.ptr22, %struct.lua_TValue.349** %io2, align 8
  %27 = load %struct.lua_TValue.349** %ra, align 8
  store %struct.lua_TValue.349* %27, %struct.lua_TValue.349** %io1, align 8
  %28 = load %struct.lua_TValue.349** %io1, align 8
  %value_23 = getelementptr inbounds %struct.lua_TValue.349* %28, i32 0, i32 0
  %29 = load %struct.lua_TValue.349** %io2, align 8
  %value_24 = getelementptr inbounds %struct.lua_TValue.349* %29, i32 0, i32 0
  %30 = bitcast %union.Value.348* %value_23 to i8*
  %31 = bitcast %union.Value.348* %value_24 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %30, i8* %31, i64 8, i32 8, i1 false)
  %32 = load %struct.lua_TValue.349** %io2, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue.349* %32, i32 0, i32 1
  %33 = load i32* %tt_, align 4
  %34 = load %struct.lua_TValue.349** %io1, align 8
  %tt_25 = getelementptr inbounds %struct.lua_TValue.349* %34, i32 0, i32 1
  store i32 %33, i32* %tt_25, align 4
  br label %sw.epilog

sw.bb26:                                          ; preds = %if.end
  %35 = load %struct.lua_TValue.349** %k, align 8
  %36 = load i32* %i, align 4
  %shr27 = lshr i32 %36, 14
  %and28 = and i32 %shr27, 262143
  %idx.ext29 = sext i32 %and28 to i64
  %add.ptr30 = getelementptr inbounds %struct.lua_TValue.349* %35, i64 %idx.ext29
  store %struct.lua_TValue.349* %add.ptr30, %struct.lua_TValue.349** %rb, align 8
  %37 = load %struct.lua_TValue.349** %rb, align 8
  store %struct.lua_TValue.349* %37, %struct.lua_TValue.349** %io231, align 8
  %38 = load %struct.lua_TValue.349** %ra, align 8
  store %struct.lua_TValue.349* %38, %struct.lua_TValue.349** %io132, align 8
  %39 = load %struct.lua_TValue.349** %io132, align 8
  %value_33 = getelementptr inbounds %struct.lua_TValue.349* %39, i32 0, i32 0
  %40 = load %struct.lua_TValue.349** %io231, align 8
  %value_34 = getelementptr inbounds %struct.lua_TValue.349* %40, i32 0, i32 0
  %41 = bitcast %union.Value.348* %value_33 to i8*
  %42 = bitcast %union.Value.348* %value_34 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %41, i8* %42, i64 8, i32 8, i1 false)
  %43 = load %struct.lua_TValue.349** %io231, align 8
  %tt_35 = getelementptr inbounds %struct.lua_TValue.349* %43, i32 0, i32 1
  %44 = load i32* %tt_35, align 4
  %45 = load %struct.lua_TValue.349** %io132, align 8
  %tt_36 = getelementptr inbounds %struct.lua_TValue.349* %45, i32 0, i32 1
  store i32 %44, i32* %tt_36, align 4
  br label %sw.epilog

sw.bb37:                                          ; preds = %if.end
  %46 = load %struct.lua_TValue.349** %k, align 8
  %47 = load %struct.CallInfo.361** %ci, align 8
  %u39 = getelementptr inbounds %struct.CallInfo.361* %47, i32 0, i32 7
  %l40 = bitcast %union.anon.360* %u39 to %struct.anon.482*
  %savedpc41 = getelementptr inbounds %struct.anon.482* %l40, i32 0, i32 1
  %48 = load i32** %savedpc41, align 8
  %incdec.ptr42 = getelementptr inbounds i32* %48, i32 1
  store i32* %incdec.ptr42, i32** %savedpc41, align 8
  %49 = load i32* %48, align 4
  %shr43 = lshr i32 %49, 6
  %and44 = and i32 %shr43, 67108863
  %idx.ext45 = sext i32 %and44 to i64
  %add.ptr46 = getelementptr inbounds %struct.lua_TValue.349* %46, i64 %idx.ext45
  store %struct.lua_TValue.349* %add.ptr46, %struct.lua_TValue.349** %rb38, align 8
  %50 = load %struct.lua_TValue.349** %rb38, align 8
  store %struct.lua_TValue.349* %50, %struct.lua_TValue.349** %io247, align 8
  %51 = load %struct.lua_TValue.349** %ra, align 8
  store %struct.lua_TValue.349* %51, %struct.lua_TValue.349** %io148, align 8
  %52 = load %struct.lua_TValue.349** %io148, align 8
  %value_49 = getelementptr inbounds %struct.lua_TValue.349* %52, i32 0, i32 0
  %53 = load %struct.lua_TValue.349** %io247, align 8
  %value_50 = getelementptr inbounds %struct.lua_TValue.349* %53, i32 0, i32 0
  %54 = bitcast %union.Value.348* %value_49 to i8*
  %55 = bitcast %union.Value.348* %value_50 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %54, i8* %55, i64 8, i32 8, i1 false)
  %56 = load %struct.lua_TValue.349** %io247, align 8
  %tt_51 = getelementptr inbounds %struct.lua_TValue.349* %56, i32 0, i32 1
  %57 = load i32* %tt_51, align 4
  %58 = load %struct.lua_TValue.349** %io148, align 8
  %tt_52 = getelementptr inbounds %struct.lua_TValue.349* %58, i32 0, i32 1
  store i32 %57, i32* %tt_52, align 4
  br label %sw.epilog

sw.bb53:                                          ; preds = %if.end
  %59 = load %struct.lua_TValue.349** %ra, align 8
  store %struct.lua_TValue.349* %59, %struct.lua_TValue.349** %io, align 8
  %60 = load i32* %i, align 4
  %shr54 = lshr i32 %60, 23
  %and55 = and i32 %shr54, 511
  %61 = load %struct.lua_TValue.349** %io, align 8
  %value_56 = getelementptr inbounds %struct.lua_TValue.349* %61, i32 0, i32 0
  %b = bitcast %union.Value.348* %value_56 to i32*
  store i32 %and55, i32* %b, align 4
  %62 = load %struct.lua_TValue.349** %io, align 8
  %tt_57 = getelementptr inbounds %struct.lua_TValue.349* %62, i32 0, i32 1
  store i32 1, i32* %tt_57, align 4
  %63 = load i32* %i, align 4
  %shr58 = lshr i32 %63, 14
  %and59 = and i32 %shr58, 511
  %tobool60 = icmp ne i32 %and59, 0
  br i1 %tobool60, label %if.then61, label %if.end66

if.then61:                                        ; preds = %sw.bb53
  %64 = load %struct.CallInfo.361** %ci, align 8
  %u62 = getelementptr inbounds %struct.CallInfo.361* %64, i32 0, i32 7
  %l63 = bitcast %union.anon.360* %u62 to %struct.anon.482*
  %savedpc64 = getelementptr inbounds %struct.anon.482* %l63, i32 0, i32 1
  %65 = load i32** %savedpc64, align 8
  %incdec.ptr65 = getelementptr inbounds i32* %65, i32 1
  store i32* %incdec.ptr65, i32** %savedpc64, align 8
  br label %if.end66

if.end66:                                         ; preds = %if.then61, %sw.bb53
  br label %sw.epilog

sw.bb67:                                          ; preds = %if.end
  %66 = load i32* %i, align 4
  %shr69 = lshr i32 %66, 23
  %and70 = and i32 %shr69, 511
  store i32 %and70, i32* %b68, align 4
  br label %do.body

do.body:                                          ; preds = %do.cond, %sw.bb67
  %67 = load %struct.lua_TValue.349** %ra, align 8
  %incdec.ptr71 = getelementptr inbounds %struct.lua_TValue.349* %67, i32 1
  store %struct.lua_TValue.349* %incdec.ptr71, %struct.lua_TValue.349** %ra, align 8
  %tt_72 = getelementptr inbounds %struct.lua_TValue.349* %67, i32 0, i32 1
  store i32 0, i32* %tt_72, align 4
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %68 = load i32* %b68, align 4
  %dec73 = add nsw i32 %68, -1
  store i32 %dec73, i32* %b68, align 4
  %tobool74 = icmp ne i32 %68, 0
  br i1 %tobool74, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  br label %sw.epilog

sw.bb75:                                          ; preds = %if.end
  %69 = load i32* %i, align 4
  %shr77 = lshr i32 %69, 23
  %and78 = and i32 %shr77, 511
  store i32 %and78, i32* %b76, align 4
  %70 = load i32* %b76, align 4
  %idxprom = sext i32 %70 to i64
  %71 = load %struct.LClosure.483** %cl, align 8
  %upvals = getelementptr inbounds %struct.LClosure.483* %71, i32 0, i32 6
  %arrayidx = getelementptr inbounds [1 x %struct.UpVal.352*]* %upvals, i32 0, i64 %idxprom
  %72 = load %struct.UpVal.352** %arrayidx, align 8
  %v = getelementptr inbounds %struct.UpVal.352* %72, i32 0, i32 3
  %73 = load %struct.lua_TValue.349** %v, align 8
  store %struct.lua_TValue.349* %73, %struct.lua_TValue.349** %io279, align 8
  %74 = load %struct.lua_TValue.349** %ra, align 8
  store %struct.lua_TValue.349* %74, %struct.lua_TValue.349** %io180, align 8
  %75 = load %struct.lua_TValue.349** %io180, align 8
  %value_81 = getelementptr inbounds %struct.lua_TValue.349* %75, i32 0, i32 0
  %76 = load %struct.lua_TValue.349** %io279, align 8
  %value_82 = getelementptr inbounds %struct.lua_TValue.349* %76, i32 0, i32 0
  %77 = bitcast %union.Value.348* %value_81 to i8*
  %78 = bitcast %union.Value.348* %value_82 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %77, i8* %78, i64 8, i32 8, i1 false)
  %79 = load %struct.lua_TValue.349** %io279, align 8
  %tt_83 = getelementptr inbounds %struct.lua_TValue.349* %79, i32 0, i32 1
  %80 = load i32* %tt_83, align 4
  %81 = load %struct.lua_TValue.349** %io180, align 8
  %tt_84 = getelementptr inbounds %struct.lua_TValue.349* %81, i32 0, i32 1
  store i32 %80, i32* %tt_84, align 4
  br label %sw.epilog

sw.bb85:                                          ; preds = %if.end
  %82 = load i32* %i, align 4
  %shr87 = lshr i32 %82, 23
  %and88 = and i32 %shr87, 511
  store i32 %and88, i32* %b86, align 4
  %83 = load %struct.lua_State.364** %L.addr, align 8
  %84 = load i32* %b86, align 4
  %idxprom89 = sext i32 %84 to i64
  %85 = load %struct.LClosure.483** %cl, align 8
  %upvals90 = getelementptr inbounds %struct.LClosure.483* %85, i32 0, i32 6
  %arrayidx91 = getelementptr inbounds [1 x %struct.UpVal.352*]* %upvals90, i32 0, i64 %idxprom89
  %86 = load %struct.UpVal.352** %arrayidx91, align 8
  %v92 = getelementptr inbounds %struct.UpVal.352* %86, i32 0, i32 3
  %87 = load %struct.lua_TValue.349** %v92, align 8
  %88 = load i32* %i, align 4
  %shr93 = lshr i32 %88, 14
  %and94 = and i32 %shr93, 511
  %and95 = and i32 %and94, 256
  %tobool96 = icmp ne i32 %and95, 0
  br i1 %tobool96, label %cond.true, label %cond.false

cond.true:                                        ; preds = %sw.bb85
  %89 = load %struct.lua_TValue.349** %k, align 8
  %90 = load i32* %i, align 4
  %shr97 = lshr i32 %90, 14
  %and98 = and i32 %shr97, 511
  %and99 = and i32 %and98, -257
  %idx.ext100 = sext i32 %and99 to i64
  %add.ptr101 = getelementptr inbounds %struct.lua_TValue.349* %89, i64 %idx.ext100
  br label %cond.end

cond.false:                                       ; preds = %sw.bb85
  %91 = load %struct.lua_TValue.349** %base, align 8
  %92 = load i32* %i, align 4
  %shr102 = lshr i32 %92, 14
  %and103 = and i32 %shr102, 511
  %idx.ext104 = sext i32 %and103 to i64
  %add.ptr105 = getelementptr inbounds %struct.lua_TValue.349* %91, i64 %idx.ext104
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.lua_TValue.349* [ %add.ptr101, %cond.true ], [ %add.ptr105, %cond.false ]
  %93 = load %struct.lua_TValue.349** %ra, align 8
  call void @luaV_gettable(%struct.lua_State.364* %83, %struct.lua_TValue.349* %87, %struct.lua_TValue.349* %cond, %struct.lua_TValue.349* %93)
  %94 = load %struct.CallInfo.361** %ci, align 8
  %u106 = getelementptr inbounds %struct.CallInfo.361* %94, i32 0, i32 7
  %l107 = bitcast %union.anon.360* %u106 to %struct.anon.482*
  %base108 = getelementptr inbounds %struct.anon.482* %l107, i32 0, i32 0
  %95 = load %struct.lua_TValue.349** %base108, align 8
  store %struct.lua_TValue.349* %95, %struct.lua_TValue.349** %base, align 8
  br label %sw.epilog

sw.bb109:                                         ; preds = %if.end
  %96 = load %struct.lua_State.364** %L.addr, align 8
  %97 = load %struct.lua_TValue.349** %base, align 8
  %98 = load i32* %i, align 4
  %shr110 = lshr i32 %98, 23
  %and111 = and i32 %shr110, 511
  %idx.ext112 = sext i32 %and111 to i64
  %add.ptr113 = getelementptr inbounds %struct.lua_TValue.349* %97, i64 %idx.ext112
  %99 = load i32* %i, align 4
  %shr114 = lshr i32 %99, 14
  %and115 = and i32 %shr114, 511
  %and116 = and i32 %and115, 256
  %tobool117 = icmp ne i32 %and116, 0
  br i1 %tobool117, label %cond.true118, label %cond.false124

cond.true118:                                     ; preds = %sw.bb109
  %100 = load %struct.lua_TValue.349** %k, align 8
  %101 = load i32* %i, align 4
  %shr119 = lshr i32 %101, 14
  %and120 = and i32 %shr119, 511
  %and121 = and i32 %and120, -257
  %idx.ext122 = sext i32 %and121 to i64
  %add.ptr123 = getelementptr inbounds %struct.lua_TValue.349* %100, i64 %idx.ext122
  br label %cond.end129

cond.false124:                                    ; preds = %sw.bb109
  %102 = load %struct.lua_TValue.349** %base, align 8
  %103 = load i32* %i, align 4
  %shr125 = lshr i32 %103, 14
  %and126 = and i32 %shr125, 511
  %idx.ext127 = sext i32 %and126 to i64
  %add.ptr128 = getelementptr inbounds %struct.lua_TValue.349* %102, i64 %idx.ext127
  br label %cond.end129

cond.end129:                                      ; preds = %cond.false124, %cond.true118
  %cond130 = phi %struct.lua_TValue.349* [ %add.ptr123, %cond.true118 ], [ %add.ptr128, %cond.false124 ]
  %104 = load %struct.lua_TValue.349** %ra, align 8
  call void @luaV_gettable(%struct.lua_State.364* %96, %struct.lua_TValue.349* %add.ptr113, %struct.lua_TValue.349* %cond130, %struct.lua_TValue.349* %104)
  %105 = load %struct.CallInfo.361** %ci, align 8
  %u131 = getelementptr inbounds %struct.CallInfo.361* %105, i32 0, i32 7
  %l132 = bitcast %union.anon.360* %u131 to %struct.anon.482*
  %base133 = getelementptr inbounds %struct.anon.482* %l132, i32 0, i32 0
  %106 = load %struct.lua_TValue.349** %base133, align 8
  store %struct.lua_TValue.349* %106, %struct.lua_TValue.349** %base, align 8
  br label %sw.epilog

sw.bb134:                                         ; preds = %if.end
  %107 = load i32* %i, align 4
  %shr135 = lshr i32 %107, 6
  %and136 = and i32 %shr135, 255
  store i32 %and136, i32* %a, align 4
  %108 = load %struct.lua_State.364** %L.addr, align 8
  %109 = load i32* %a, align 4
  %idxprom137 = sext i32 %109 to i64
  %110 = load %struct.LClosure.483** %cl, align 8
  %upvals138 = getelementptr inbounds %struct.LClosure.483* %110, i32 0, i32 6
  %arrayidx139 = getelementptr inbounds [1 x %struct.UpVal.352*]* %upvals138, i32 0, i64 %idxprom137
  %111 = load %struct.UpVal.352** %arrayidx139, align 8
  %v140 = getelementptr inbounds %struct.UpVal.352* %111, i32 0, i32 3
  %112 = load %struct.lua_TValue.349** %v140, align 8
  %113 = load i32* %i, align 4
  %shr141 = lshr i32 %113, 23
  %and142 = and i32 %shr141, 511
  %and143 = and i32 %and142, 256
  %tobool144 = icmp ne i32 %and143, 0
  br i1 %tobool144, label %cond.true145, label %cond.false151

cond.true145:                                     ; preds = %sw.bb134
  %114 = load %struct.lua_TValue.349** %k, align 8
  %115 = load i32* %i, align 4
  %shr146 = lshr i32 %115, 23
  %and147 = and i32 %shr146, 511
  %and148 = and i32 %and147, -257
  %idx.ext149 = sext i32 %and148 to i64
  %add.ptr150 = getelementptr inbounds %struct.lua_TValue.349* %114, i64 %idx.ext149
  br label %cond.end156

cond.false151:                                    ; preds = %sw.bb134
  %116 = load %struct.lua_TValue.349** %base, align 8
  %117 = load i32* %i, align 4
  %shr152 = lshr i32 %117, 23
  %and153 = and i32 %shr152, 511
  %idx.ext154 = sext i32 %and153 to i64
  %add.ptr155 = getelementptr inbounds %struct.lua_TValue.349* %116, i64 %idx.ext154
  br label %cond.end156

cond.end156:                                      ; preds = %cond.false151, %cond.true145
  %cond157 = phi %struct.lua_TValue.349* [ %add.ptr150, %cond.true145 ], [ %add.ptr155, %cond.false151 ]
  %118 = load i32* %i, align 4
  %shr158 = lshr i32 %118, 14
  %and159 = and i32 %shr158, 511
  %and160 = and i32 %and159, 256
  %tobool161 = icmp ne i32 %and160, 0
  br i1 %tobool161, label %cond.true162, label %cond.false168

cond.true162:                                     ; preds = %cond.end156
  %119 = load %struct.lua_TValue.349** %k, align 8
  %120 = load i32* %i, align 4
  %shr163 = lshr i32 %120, 14
  %and164 = and i32 %shr163, 511
  %and165 = and i32 %and164, -257
  %idx.ext166 = sext i32 %and165 to i64
  %add.ptr167 = getelementptr inbounds %struct.lua_TValue.349* %119, i64 %idx.ext166
  br label %cond.end173

cond.false168:                                    ; preds = %cond.end156
  %121 = load %struct.lua_TValue.349** %base, align 8
  %122 = load i32* %i, align 4
  %shr169 = lshr i32 %122, 14
  %and170 = and i32 %shr169, 511
  %idx.ext171 = sext i32 %and170 to i64
  %add.ptr172 = getelementptr inbounds %struct.lua_TValue.349* %121, i64 %idx.ext171
  br label %cond.end173

cond.end173:                                      ; preds = %cond.false168, %cond.true162
  %cond174 = phi %struct.lua_TValue.349* [ %add.ptr167, %cond.true162 ], [ %add.ptr172, %cond.false168 ]
  call void @luaV_settable(%struct.lua_State.364* %108, %struct.lua_TValue.349* %112, %struct.lua_TValue.349* %cond157, %struct.lua_TValue.349* %cond174)
  %123 = load %struct.CallInfo.361** %ci, align 8
  %u175 = getelementptr inbounds %struct.CallInfo.361* %123, i32 0, i32 7
  %l176 = bitcast %union.anon.360* %u175 to %struct.anon.482*
  %base177 = getelementptr inbounds %struct.anon.482* %l176, i32 0, i32 0
  %124 = load %struct.lua_TValue.349** %base177, align 8
  store %struct.lua_TValue.349* %124, %struct.lua_TValue.349** %base, align 8
  br label %sw.epilog

sw.bb178:                                         ; preds = %if.end
  %125 = load i32* %i, align 4
  %shr179 = lshr i32 %125, 23
  %and180 = and i32 %shr179, 511
  %idxprom181 = sext i32 %and180 to i64
  %126 = load %struct.LClosure.483** %cl, align 8
  %upvals182 = getelementptr inbounds %struct.LClosure.483* %126, i32 0, i32 6
  %arrayidx183 = getelementptr inbounds [1 x %struct.UpVal.352*]* %upvals182, i32 0, i64 %idxprom181
  %127 = load %struct.UpVal.352** %arrayidx183, align 8
  store %struct.UpVal.352* %127, %struct.UpVal.352** %uv, align 8
  %128 = load %struct.lua_TValue.349** %ra, align 8
  store %struct.lua_TValue.349* %128, %struct.lua_TValue.349** %io2184, align 8
  %129 = load %struct.UpVal.352** %uv, align 8
  %v186 = getelementptr inbounds %struct.UpVal.352* %129, i32 0, i32 3
  %130 = load %struct.lua_TValue.349** %v186, align 8
  store %struct.lua_TValue.349* %130, %struct.lua_TValue.349** %io1185, align 8
  %131 = load %struct.lua_TValue.349** %io1185, align 8
  %value_187 = getelementptr inbounds %struct.lua_TValue.349* %131, i32 0, i32 0
  %132 = load %struct.lua_TValue.349** %io2184, align 8
  %value_188 = getelementptr inbounds %struct.lua_TValue.349* %132, i32 0, i32 0
  %133 = bitcast %union.Value.348* %value_187 to i8*
  %134 = bitcast %union.Value.348* %value_188 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %133, i8* %134, i64 8, i32 8, i1 false)
  %135 = load %struct.lua_TValue.349** %io2184, align 8
  %tt_189 = getelementptr inbounds %struct.lua_TValue.349* %135, i32 0, i32 1
  %136 = load i32* %tt_189, align 4
  %137 = load %struct.lua_TValue.349** %io1185, align 8
  %tt_190 = getelementptr inbounds %struct.lua_TValue.349* %137, i32 0, i32 1
  store i32 %136, i32* %tt_190, align 4
  %138 = load %struct.lua_TValue.349** %ra, align 8
  %tt_191 = getelementptr inbounds %struct.lua_TValue.349* %138, i32 0, i32 1
  %139 = load i32* %tt_191, align 4
  %and192 = and i32 %139, 64
  %tobool193 = icmp ne i32 %and192, 0
  br i1 %tobool193, label %land.lhs.true194, label %if.end209

land.lhs.true194:                                 ; preds = %sw.bb178
  %140 = load %struct.lua_TValue.349** %ra, align 8
  %value_195 = getelementptr inbounds %struct.lua_TValue.349* %140, i32 0, i32 0
  %gc196 = bitcast %union.Value.348* %value_195 to %union.GCObject.365**
  %141 = load %union.GCObject.365** %gc196, align 8
  %gch = bitcast %union.GCObject.365* %141 to %struct.GCheader.479*
  %marked = getelementptr inbounds %struct.GCheader.479* %gch, i32 0, i32 2
  %142 = load i8* %marked, align 1
  %conv197 = zext i8 %142 to i32
  %and198 = and i32 %conv197, 3
  %tobool199 = icmp ne i32 %and198, 0
  br i1 %tobool199, label %land.lhs.true200, label %if.end209

land.lhs.true200:                                 ; preds = %land.lhs.true194
  %143 = load %struct.UpVal.352** %uv, align 8
  %144 = bitcast %struct.UpVal.352* %143 to %union.GCObject.365*
  %gch201 = bitcast %union.GCObject.365* %144 to %struct.GCheader.479*
  %marked202 = getelementptr inbounds %struct.GCheader.479* %gch201, i32 0, i32 2
  %145 = load i8* %marked202, align 1
  %conv203 = zext i8 %145 to i32
  %and204 = and i32 %conv203, 4
  %tobool205 = icmp ne i32 %and204, 0
  br i1 %tobool205, label %if.then206, label %if.end209

if.then206:                                       ; preds = %land.lhs.true200
  %146 = load %struct.lua_State.364** %L.addr, align 8
  %147 = load %struct.UpVal.352** %uv, align 8
  %148 = bitcast %struct.UpVal.352* %147 to %union.GCObject.365*
  %149 = load %struct.lua_TValue.349** %ra, align 8
  %value_207 = getelementptr inbounds %struct.lua_TValue.349* %149, i32 0, i32 0
  %gc208 = bitcast %union.Value.348* %value_207 to %union.GCObject.365**
  %150 = load %union.GCObject.365** %gc208, align 8
  call void bitcast (void (%struct.lua_State*, %union.GCObject*, %union.GCObject*)* @luaC_barrier_ to void (%struct.lua_State.364*, %union.GCObject.365*, %union.GCObject.365*)*)(%struct.lua_State.364* %146, %union.GCObject.365* %148, %union.GCObject.365* %150)
  br label %if.end209

if.end209:                                        ; preds = %if.then206, %land.lhs.true200, %land.lhs.true194, %sw.bb178
  br label %sw.epilog

sw.bb210:                                         ; preds = %if.end
  %151 = load %struct.lua_State.364** %L.addr, align 8
  %152 = load %struct.lua_TValue.349** %ra, align 8
  %153 = load i32* %i, align 4
  %shr211 = lshr i32 %153, 23
  %and212 = and i32 %shr211, 511
  %and213 = and i32 %and212, 256
  %tobool214 = icmp ne i32 %and213, 0
  br i1 %tobool214, label %cond.true215, label %cond.false221

cond.true215:                                     ; preds = %sw.bb210
  %154 = load %struct.lua_TValue.349** %k, align 8
  %155 = load i32* %i, align 4
  %shr216 = lshr i32 %155, 23
  %and217 = and i32 %shr216, 511
  %and218 = and i32 %and217, -257
  %idx.ext219 = sext i32 %and218 to i64
  %add.ptr220 = getelementptr inbounds %struct.lua_TValue.349* %154, i64 %idx.ext219
  br label %cond.end226

cond.false221:                                    ; preds = %sw.bb210
  %156 = load %struct.lua_TValue.349** %base, align 8
  %157 = load i32* %i, align 4
  %shr222 = lshr i32 %157, 23
  %and223 = and i32 %shr222, 511
  %idx.ext224 = sext i32 %and223 to i64
  %add.ptr225 = getelementptr inbounds %struct.lua_TValue.349* %156, i64 %idx.ext224
  br label %cond.end226

cond.end226:                                      ; preds = %cond.false221, %cond.true215
  %cond227 = phi %struct.lua_TValue.349* [ %add.ptr220, %cond.true215 ], [ %add.ptr225, %cond.false221 ]
  %158 = load i32* %i, align 4
  %shr228 = lshr i32 %158, 14
  %and229 = and i32 %shr228, 511
  %and230 = and i32 %and229, 256
  %tobool231 = icmp ne i32 %and230, 0
  br i1 %tobool231, label %cond.true232, label %cond.false238

cond.true232:                                     ; preds = %cond.end226
  %159 = load %struct.lua_TValue.349** %k, align 8
  %160 = load i32* %i, align 4
  %shr233 = lshr i32 %160, 14
  %and234 = and i32 %shr233, 511
  %and235 = and i32 %and234, -257
  %idx.ext236 = sext i32 %and235 to i64
  %add.ptr237 = getelementptr inbounds %struct.lua_TValue.349* %159, i64 %idx.ext236
  br label %cond.end243

cond.false238:                                    ; preds = %cond.end226
  %161 = load %struct.lua_TValue.349** %base, align 8
  %162 = load i32* %i, align 4
  %shr239 = lshr i32 %162, 14
  %and240 = and i32 %shr239, 511
  %idx.ext241 = sext i32 %and240 to i64
  %add.ptr242 = getelementptr inbounds %struct.lua_TValue.349* %161, i64 %idx.ext241
  br label %cond.end243

cond.end243:                                      ; preds = %cond.false238, %cond.true232
  %cond244 = phi %struct.lua_TValue.349* [ %add.ptr237, %cond.true232 ], [ %add.ptr242, %cond.false238 ]
  call void @luaV_settable(%struct.lua_State.364* %151, %struct.lua_TValue.349* %152, %struct.lua_TValue.349* %cond227, %struct.lua_TValue.349* %cond244)
  %163 = load %struct.CallInfo.361** %ci, align 8
  %u245 = getelementptr inbounds %struct.CallInfo.361* %163, i32 0, i32 7
  %l246 = bitcast %union.anon.360* %u245 to %struct.anon.482*
  %base247 = getelementptr inbounds %struct.anon.482* %l246, i32 0, i32 0
  %164 = load %struct.lua_TValue.349** %base247, align 8
  store %struct.lua_TValue.349* %164, %struct.lua_TValue.349** %base, align 8
  br label %sw.epilog

sw.bb248:                                         ; preds = %if.end
  %165 = load i32* %i, align 4
  %shr250 = lshr i32 %165, 23
  %and251 = and i32 %shr250, 511
  store i32 %and251, i32* %b249, align 4
  %166 = load i32* %i, align 4
  %shr252 = lshr i32 %166, 14
  %and253 = and i32 %shr252, 511
  store i32 %and253, i32* %c, align 4
  %167 = load %struct.lua_State.364** %L.addr, align 8
  %call = call %struct.Table.357* bitcast (%struct.Table* (%struct.lua_State*)* @luaH_new to %struct.Table.357* (%struct.lua_State.364*)*)(%struct.lua_State.364* %167)
  store %struct.Table.357* %call, %struct.Table.357** %t, align 8
  %168 = load %struct.lua_TValue.349** %ra, align 8
  store %struct.lua_TValue.349* %168, %struct.lua_TValue.349** %io254, align 8
  %169 = load %struct.Table.357** %t, align 8
  %170 = bitcast %struct.Table.357* %169 to %union.GCObject.365*
  %171 = load %struct.lua_TValue.349** %io254, align 8
  %value_255 = getelementptr inbounds %struct.lua_TValue.349* %171, i32 0, i32 0
  %gc256 = bitcast %union.Value.348* %value_255 to %union.GCObject.365**
  store %union.GCObject.365* %170, %union.GCObject.365** %gc256, align 8
  %172 = load %struct.lua_TValue.349** %io254, align 8
  %tt_257 = getelementptr inbounds %struct.lua_TValue.349* %172, i32 0, i32 1
  store i32 69, i32* %tt_257, align 4
  %173 = load i32* %b249, align 4
  %cmp258 = icmp ne i32 %173, 0
  br i1 %cmp258, label %if.then263, label %lor.lhs.false260

lor.lhs.false260:                                 ; preds = %sw.bb248
  %174 = load i32* %c, align 4
  %cmp261 = icmp ne i32 %174, 0
  br i1 %cmp261, label %if.then263, label %if.end266

if.then263:                                       ; preds = %lor.lhs.false260, %sw.bb248
  %175 = load %struct.lua_State.364** %L.addr, align 8
  %176 = load %struct.Table.357** %t, align 8
  %177 = load i32* %b249, align 4
  %call264 = call i32 @luaO_fb2int(i32 %177)
  %178 = load i32* %c, align 4
  %call265 = call i32 @luaO_fb2int(i32 %178)
  call void bitcast (void (%struct.lua_State*, %struct.Table*, i32, i32)* @luaH_resize to void (%struct.lua_State.364*, %struct.Table.357*, i32, i32)*)(%struct.lua_State.364* %175, %struct.Table.357* %176, i32 %call264, i32 %call265)
  br label %if.end266

if.end266:                                        ; preds = %if.then263, %lor.lhs.false260
  %179 = load %struct.lua_State.364** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State.364* %179, i32 0, i32 5
  %180 = load %struct.global_State.358** %l_G, align 8
  %GCdebt = getelementptr inbounds %struct.global_State.358* %180, i32 0, i32 3
  %181 = load i64* %GCdebt, align 8
  %cmp267 = icmp sgt i64 %181, 0
  br i1 %cmp267, label %if.then269, label %if.end273

if.then269:                                       ; preds = %if.end266
  %182 = load %struct.lua_TValue.349** %ra, align 8
  %add.ptr270 = getelementptr inbounds %struct.lua_TValue.349* %182, i64 1
  %183 = load %struct.lua_State.364** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State.364* %183, i32 0, i32 4
  store %struct.lua_TValue.349* %add.ptr270, %struct.lua_TValue.349** %top, align 8
  %184 = load %struct.lua_State.364** %L.addr, align 8
  call void bitcast (void (%struct.lua_State*)* @luaC_step to void (%struct.lua_State.364*)*)(%struct.lua_State.364* %184)
  %185 = load %struct.CallInfo.361** %ci, align 8
  %top271 = getelementptr inbounds %struct.CallInfo.361* %185, i32 0, i32 1
  %186 = load %struct.lua_TValue.349** %top271, align 8
  %187 = load %struct.lua_State.364** %L.addr, align 8
  %top272 = getelementptr inbounds %struct.lua_State.364* %187, i32 0, i32 4
  store %struct.lua_TValue.349* %186, %struct.lua_TValue.349** %top272, align 8
  br label %if.end273

if.end273:                                        ; preds = %if.then269, %if.end266
  %188 = load %struct.CallInfo.361** %ci, align 8
  %u274 = getelementptr inbounds %struct.CallInfo.361* %188, i32 0, i32 7
  %l275 = bitcast %union.anon.360* %u274 to %struct.anon.482*
  %base276 = getelementptr inbounds %struct.anon.482* %l275, i32 0, i32 0
  %189 = load %struct.lua_TValue.349** %base276, align 8
  store %struct.lua_TValue.349* %189, %struct.lua_TValue.349** %base, align 8
  br label %sw.epilog

sw.bb277:                                         ; preds = %if.end
  %190 = load %struct.lua_TValue.349** %base, align 8
  %191 = load i32* %i, align 4
  %shr279 = lshr i32 %191, 23
  %and280 = and i32 %shr279, 511
  %idx.ext281 = sext i32 %and280 to i64
  %add.ptr282 = getelementptr inbounds %struct.lua_TValue.349* %190, i64 %idx.ext281
  store %struct.lua_TValue.349* %add.ptr282, %struct.lua_TValue.349** %rb278, align 8
  %192 = load %struct.lua_TValue.349** %rb278, align 8
  store %struct.lua_TValue.349* %192, %struct.lua_TValue.349** %io2283, align 8
  %193 = load %struct.lua_TValue.349** %ra, align 8
  %add.ptr285 = getelementptr inbounds %struct.lua_TValue.349* %193, i64 1
  store %struct.lua_TValue.349* %add.ptr285, %struct.lua_TValue.349** %io1284, align 8
  %194 = load %struct.lua_TValue.349** %io1284, align 8
  %value_286 = getelementptr inbounds %struct.lua_TValue.349* %194, i32 0, i32 0
  %195 = load %struct.lua_TValue.349** %io2283, align 8
  %value_287 = getelementptr inbounds %struct.lua_TValue.349* %195, i32 0, i32 0
  %196 = bitcast %union.Value.348* %value_286 to i8*
  %197 = bitcast %union.Value.348* %value_287 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %196, i8* %197, i64 8, i32 8, i1 false)
  %198 = load %struct.lua_TValue.349** %io2283, align 8
  %tt_288 = getelementptr inbounds %struct.lua_TValue.349* %198, i32 0, i32 1
  %199 = load i32* %tt_288, align 4
  %200 = load %struct.lua_TValue.349** %io1284, align 8
  %tt_289 = getelementptr inbounds %struct.lua_TValue.349* %200, i32 0, i32 1
  store i32 %199, i32* %tt_289, align 4
  %201 = load %struct.lua_State.364** %L.addr, align 8
  %202 = load %struct.lua_TValue.349** %rb278, align 8
  %203 = load i32* %i, align 4
  %shr290 = lshr i32 %203, 14
  %and291 = and i32 %shr290, 511
  %and292 = and i32 %and291, 256
  %tobool293 = icmp ne i32 %and292, 0
  br i1 %tobool293, label %cond.true294, label %cond.false300

cond.true294:                                     ; preds = %sw.bb277
  %204 = load %struct.lua_TValue.349** %k, align 8
  %205 = load i32* %i, align 4
  %shr295 = lshr i32 %205, 14
  %and296 = and i32 %shr295, 511
  %and297 = and i32 %and296, -257
  %idx.ext298 = sext i32 %and297 to i64
  %add.ptr299 = getelementptr inbounds %struct.lua_TValue.349* %204, i64 %idx.ext298
  br label %cond.end305

cond.false300:                                    ; preds = %sw.bb277
  %206 = load %struct.lua_TValue.349** %base, align 8
  %207 = load i32* %i, align 4
  %shr301 = lshr i32 %207, 14
  %and302 = and i32 %shr301, 511
  %idx.ext303 = sext i32 %and302 to i64
  %add.ptr304 = getelementptr inbounds %struct.lua_TValue.349* %206, i64 %idx.ext303
  br label %cond.end305

cond.end305:                                      ; preds = %cond.false300, %cond.true294
  %cond306 = phi %struct.lua_TValue.349* [ %add.ptr299, %cond.true294 ], [ %add.ptr304, %cond.false300 ]
  %208 = load %struct.lua_TValue.349** %ra, align 8
  call void @luaV_gettable(%struct.lua_State.364* %201, %struct.lua_TValue.349* %202, %struct.lua_TValue.349* %cond306, %struct.lua_TValue.349* %208)
  %209 = load %struct.CallInfo.361** %ci, align 8
  %u307 = getelementptr inbounds %struct.CallInfo.361* %209, i32 0, i32 7
  %l308 = bitcast %union.anon.360* %u307 to %struct.anon.482*
  %base309 = getelementptr inbounds %struct.anon.482* %l308, i32 0, i32 0
  %210 = load %struct.lua_TValue.349** %base309, align 8
  store %struct.lua_TValue.349* %210, %struct.lua_TValue.349** %base, align 8
  br label %sw.epilog

sw.bb310:                                         ; preds = %if.end
  %211 = load i32* %i, align 4
  %shr312 = lshr i32 %211, 23
  %and313 = and i32 %shr312, 511
  %and314 = and i32 %and313, 256
  %tobool315 = icmp ne i32 %and314, 0
  br i1 %tobool315, label %cond.true316, label %cond.false322

cond.true316:                                     ; preds = %sw.bb310
  %212 = load %struct.lua_TValue.349** %k, align 8
  %213 = load i32* %i, align 4
  %shr317 = lshr i32 %213, 23
  %and318 = and i32 %shr317, 511
  %and319 = and i32 %and318, -257
  %idx.ext320 = sext i32 %and319 to i64
  %add.ptr321 = getelementptr inbounds %struct.lua_TValue.349* %212, i64 %idx.ext320
  br label %cond.end327

cond.false322:                                    ; preds = %sw.bb310
  %214 = load %struct.lua_TValue.349** %base, align 8
  %215 = load i32* %i, align 4
  %shr323 = lshr i32 %215, 23
  %and324 = and i32 %shr323, 511
  %idx.ext325 = sext i32 %and324 to i64
  %add.ptr326 = getelementptr inbounds %struct.lua_TValue.349* %214, i64 %idx.ext325
  br label %cond.end327

cond.end327:                                      ; preds = %cond.false322, %cond.true316
  %cond328 = phi %struct.lua_TValue.349* [ %add.ptr321, %cond.true316 ], [ %add.ptr326, %cond.false322 ]
  store %struct.lua_TValue.349* %cond328, %struct.lua_TValue.349** %rb311, align 8
  %216 = load i32* %i, align 4
  %shr329 = lshr i32 %216, 14
  %and330 = and i32 %shr329, 511
  %and331 = and i32 %and330, 256
  %tobool332 = icmp ne i32 %and331, 0
  br i1 %tobool332, label %cond.true333, label %cond.false339

cond.true333:                                     ; preds = %cond.end327
  %217 = load %struct.lua_TValue.349** %k, align 8
  %218 = load i32* %i, align 4
  %shr334 = lshr i32 %218, 14
  %and335 = and i32 %shr334, 511
  %and336 = and i32 %and335, -257
  %idx.ext337 = sext i32 %and336 to i64
  %add.ptr338 = getelementptr inbounds %struct.lua_TValue.349* %217, i64 %idx.ext337
  br label %cond.end344

cond.false339:                                    ; preds = %cond.end327
  %219 = load %struct.lua_TValue.349** %base, align 8
  %220 = load i32* %i, align 4
  %shr340 = lshr i32 %220, 14
  %and341 = and i32 %shr340, 511
  %idx.ext342 = sext i32 %and341 to i64
  %add.ptr343 = getelementptr inbounds %struct.lua_TValue.349* %219, i64 %idx.ext342
  br label %cond.end344

cond.end344:                                      ; preds = %cond.false339, %cond.true333
  %cond345 = phi %struct.lua_TValue.349* [ %add.ptr338, %cond.true333 ], [ %add.ptr343, %cond.false339 ]
  store %struct.lua_TValue.349* %cond345, %struct.lua_TValue.349** %rc, align 8
  %221 = load %struct.lua_TValue.349** %rb311, align 8
  %tt_346 = getelementptr inbounds %struct.lua_TValue.349* %221, i32 0, i32 1
  %222 = load i32* %tt_346, align 4
  %cmp347 = icmp eq i32 %222, 3
  br i1 %cmp347, label %land.lhs.true349, label %if.else

land.lhs.true349:                                 ; preds = %cond.end344
  %223 = load %struct.lua_TValue.349** %rc, align 8
  %tt_350 = getelementptr inbounds %struct.lua_TValue.349* %223, i32 0, i32 1
  %224 = load i32* %tt_350, align 4
  %cmp351 = icmp eq i32 %224, 3
  br i1 %cmp351, label %if.then353, label %if.else

if.then353:                                       ; preds = %land.lhs.true349
  %225 = load %struct.lua_TValue.349** %rb311, align 8
  %value_354 = getelementptr inbounds %struct.lua_TValue.349* %225, i32 0, i32 0
  %n = bitcast %union.Value.348* %value_354 to double*
  %226 = load double* %n, align 8
  store double %226, double* %nb, align 8
  %227 = load %struct.lua_TValue.349** %rc, align 8
  %value_355 = getelementptr inbounds %struct.lua_TValue.349* %227, i32 0, i32 0
  %n356 = bitcast %union.Value.348* %value_355 to double*
  %228 = load double* %n356, align 8
  store double %228, double* %nc, align 8
  %229 = load %struct.lua_TValue.349** %ra, align 8
  store %struct.lua_TValue.349* %229, %struct.lua_TValue.349** %io357, align 8
  %230 = load double* %nb, align 8
  %231 = load double* %nc, align 8
  %add = fadd double %230, %231
  %232 = load %struct.lua_TValue.349** %io357, align 8
  %value_358 = getelementptr inbounds %struct.lua_TValue.349* %232, i32 0, i32 0
  %n359 = bitcast %union.Value.348* %value_358 to double*
  store double %add, double* %n359, align 8
  %233 = load %struct.lua_TValue.349** %io357, align 8
  %tt_360 = getelementptr inbounds %struct.lua_TValue.349* %233, i32 0, i32 1
  store i32 3, i32* %tt_360, align 4
  br label %if.end364

if.else:                                          ; preds = %land.lhs.true349, %cond.end344
  %234 = load %struct.lua_State.364** %L.addr, align 8
  %235 = load %struct.lua_TValue.349** %ra, align 8
  %236 = load %struct.lua_TValue.349** %rb311, align 8
  %237 = load %struct.lua_TValue.349** %rc, align 8
  call void @luaV_arith(%struct.lua_State.364* %234, %struct.lua_TValue.349* %235, %struct.lua_TValue.349* %236, %struct.lua_TValue.349* %237, i32 6)
  %238 = load %struct.CallInfo.361** %ci, align 8
  %u361 = getelementptr inbounds %struct.CallInfo.361* %238, i32 0, i32 7
  %l362 = bitcast %union.anon.360* %u361 to %struct.anon.482*
  %base363 = getelementptr inbounds %struct.anon.482* %l362, i32 0, i32 0
  %239 = load %struct.lua_TValue.349** %base363, align 8
  store %struct.lua_TValue.349* %239, %struct.lua_TValue.349** %base, align 8
  br label %if.end364

if.end364:                                        ; preds = %if.else, %if.then353
  br label %sw.epilog

sw.bb365:                                         ; preds = %if.end
  %240 = load i32* %i, align 4
  %shr367 = lshr i32 %240, 23
  %and368 = and i32 %shr367, 511
  %and369 = and i32 %and368, 256
  %tobool370 = icmp ne i32 %and369, 0
  br i1 %tobool370, label %cond.true371, label %cond.false377

cond.true371:                                     ; preds = %sw.bb365
  %241 = load %struct.lua_TValue.349** %k, align 8
  %242 = load i32* %i, align 4
  %shr372 = lshr i32 %242, 23
  %and373 = and i32 %shr372, 511
  %and374 = and i32 %and373, -257
  %idx.ext375 = sext i32 %and374 to i64
  %add.ptr376 = getelementptr inbounds %struct.lua_TValue.349* %241, i64 %idx.ext375
  br label %cond.end382

cond.false377:                                    ; preds = %sw.bb365
  %243 = load %struct.lua_TValue.349** %base, align 8
  %244 = load i32* %i, align 4
  %shr378 = lshr i32 %244, 23
  %and379 = and i32 %shr378, 511
  %idx.ext380 = sext i32 %and379 to i64
  %add.ptr381 = getelementptr inbounds %struct.lua_TValue.349* %243, i64 %idx.ext380
  br label %cond.end382

cond.end382:                                      ; preds = %cond.false377, %cond.true371
  %cond383 = phi %struct.lua_TValue.349* [ %add.ptr376, %cond.true371 ], [ %add.ptr381, %cond.false377 ]
  store %struct.lua_TValue.349* %cond383, %struct.lua_TValue.349** %rb366, align 8
  %245 = load i32* %i, align 4
  %shr385 = lshr i32 %245, 14
  %and386 = and i32 %shr385, 511
  %and387 = and i32 %and386, 256
  %tobool388 = icmp ne i32 %and387, 0
  br i1 %tobool388, label %cond.true389, label %cond.false395

cond.true389:                                     ; preds = %cond.end382
  %246 = load %struct.lua_TValue.349** %k, align 8
  %247 = load i32* %i, align 4
  %shr390 = lshr i32 %247, 14
  %and391 = and i32 %shr390, 511
  %and392 = and i32 %and391, -257
  %idx.ext393 = sext i32 %and392 to i64
  %add.ptr394 = getelementptr inbounds %struct.lua_TValue.349* %246, i64 %idx.ext393
  br label %cond.end400

cond.false395:                                    ; preds = %cond.end382
  %248 = load %struct.lua_TValue.349** %base, align 8
  %249 = load i32* %i, align 4
  %shr396 = lshr i32 %249, 14
  %and397 = and i32 %shr396, 511
  %idx.ext398 = sext i32 %and397 to i64
  %add.ptr399 = getelementptr inbounds %struct.lua_TValue.349* %248, i64 %idx.ext398
  br label %cond.end400

cond.end400:                                      ; preds = %cond.false395, %cond.true389
  %cond401 = phi %struct.lua_TValue.349* [ %add.ptr394, %cond.true389 ], [ %add.ptr399, %cond.false395 ]
  store %struct.lua_TValue.349* %cond401, %struct.lua_TValue.349** %rc384, align 8
  %250 = load %struct.lua_TValue.349** %rb366, align 8
  %tt_402 = getelementptr inbounds %struct.lua_TValue.349* %250, i32 0, i32 1
  %251 = load i32* %tt_402, align 4
  %cmp403 = icmp eq i32 %251, 3
  br i1 %cmp403, label %land.lhs.true405, label %if.else420

land.lhs.true405:                                 ; preds = %cond.end400
  %252 = load %struct.lua_TValue.349** %rc384, align 8
  %tt_406 = getelementptr inbounds %struct.lua_TValue.349* %252, i32 0, i32 1
  %253 = load i32* %tt_406, align 4
  %cmp407 = icmp eq i32 %253, 3
  br i1 %cmp407, label %if.then409, label %if.else420

if.then409:                                       ; preds = %land.lhs.true405
  %254 = load %struct.lua_TValue.349** %rb366, align 8
  %value_411 = getelementptr inbounds %struct.lua_TValue.349* %254, i32 0, i32 0
  %n412 = bitcast %union.Value.348* %value_411 to double*
  %255 = load double* %n412, align 8
  store double %255, double* %nb410, align 8
  %256 = load %struct.lua_TValue.349** %rc384, align 8
  %value_414 = getelementptr inbounds %struct.lua_TValue.349* %256, i32 0, i32 0
  %n415 = bitcast %union.Value.348* %value_414 to double*
  %257 = load double* %n415, align 8
  store double %257, double* %nc413, align 8
  %258 = load %struct.lua_TValue.349** %ra, align 8
  store %struct.lua_TValue.349* %258, %struct.lua_TValue.349** %io416, align 8
  %259 = load double* %nb410, align 8
  %260 = load double* %nc413, align 8
  %sub = fsub double %259, %260
  %261 = load %struct.lua_TValue.349** %io416, align 8
  %value_417 = getelementptr inbounds %struct.lua_TValue.349* %261, i32 0, i32 0
  %n418 = bitcast %union.Value.348* %value_417 to double*
  store double %sub, double* %n418, align 8
  %262 = load %struct.lua_TValue.349** %io416, align 8
  %tt_419 = getelementptr inbounds %struct.lua_TValue.349* %262, i32 0, i32 1
  store i32 3, i32* %tt_419, align 4
  br label %if.end424

if.else420:                                       ; preds = %land.lhs.true405, %cond.end400
  %263 = load %struct.lua_State.364** %L.addr, align 8
  %264 = load %struct.lua_TValue.349** %ra, align 8
  %265 = load %struct.lua_TValue.349** %rb366, align 8
  %266 = load %struct.lua_TValue.349** %rc384, align 8
  call void @luaV_arith(%struct.lua_State.364* %263, %struct.lua_TValue.349* %264, %struct.lua_TValue.349* %265, %struct.lua_TValue.349* %266, i32 7)
  %267 = load %struct.CallInfo.361** %ci, align 8
  %u421 = getelementptr inbounds %struct.CallInfo.361* %267, i32 0, i32 7
  %l422 = bitcast %union.anon.360* %u421 to %struct.anon.482*
  %base423 = getelementptr inbounds %struct.anon.482* %l422, i32 0, i32 0
  %268 = load %struct.lua_TValue.349** %base423, align 8
  store %struct.lua_TValue.349* %268, %struct.lua_TValue.349** %base, align 8
  br label %if.end424

if.end424:                                        ; preds = %if.else420, %if.then409
  br label %sw.epilog

sw.bb425:                                         ; preds = %if.end
  %269 = load i32* %i, align 4
  %shr427 = lshr i32 %269, 23
  %and428 = and i32 %shr427, 511
  %and429 = and i32 %and428, 256
  %tobool430 = icmp ne i32 %and429, 0
  br i1 %tobool430, label %cond.true431, label %cond.false437

cond.true431:                                     ; preds = %sw.bb425
  %270 = load %struct.lua_TValue.349** %k, align 8
  %271 = load i32* %i, align 4
  %shr432 = lshr i32 %271, 23
  %and433 = and i32 %shr432, 511
  %and434 = and i32 %and433, -257
  %idx.ext435 = sext i32 %and434 to i64
  %add.ptr436 = getelementptr inbounds %struct.lua_TValue.349* %270, i64 %idx.ext435
  br label %cond.end442

cond.false437:                                    ; preds = %sw.bb425
  %272 = load %struct.lua_TValue.349** %base, align 8
  %273 = load i32* %i, align 4
  %shr438 = lshr i32 %273, 23
  %and439 = and i32 %shr438, 511
  %idx.ext440 = sext i32 %and439 to i64
  %add.ptr441 = getelementptr inbounds %struct.lua_TValue.349* %272, i64 %idx.ext440
  br label %cond.end442

cond.end442:                                      ; preds = %cond.false437, %cond.true431
  %cond443 = phi %struct.lua_TValue.349* [ %add.ptr436, %cond.true431 ], [ %add.ptr441, %cond.false437 ]
  store %struct.lua_TValue.349* %cond443, %struct.lua_TValue.349** %rb426, align 8
  %274 = load i32* %i, align 4
  %shr445 = lshr i32 %274, 14
  %and446 = and i32 %shr445, 511
  %and447 = and i32 %and446, 256
  %tobool448 = icmp ne i32 %and447, 0
  br i1 %tobool448, label %cond.true449, label %cond.false455

cond.true449:                                     ; preds = %cond.end442
  %275 = load %struct.lua_TValue.349** %k, align 8
  %276 = load i32* %i, align 4
  %shr450 = lshr i32 %276, 14
  %and451 = and i32 %shr450, 511
  %and452 = and i32 %and451, -257
  %idx.ext453 = sext i32 %and452 to i64
  %add.ptr454 = getelementptr inbounds %struct.lua_TValue.349* %275, i64 %idx.ext453
  br label %cond.end460

cond.false455:                                    ; preds = %cond.end442
  %277 = load %struct.lua_TValue.349** %base, align 8
  %278 = load i32* %i, align 4
  %shr456 = lshr i32 %278, 14
  %and457 = and i32 %shr456, 511
  %idx.ext458 = sext i32 %and457 to i64
  %add.ptr459 = getelementptr inbounds %struct.lua_TValue.349* %277, i64 %idx.ext458
  br label %cond.end460

cond.end460:                                      ; preds = %cond.false455, %cond.true449
  %cond461 = phi %struct.lua_TValue.349* [ %add.ptr454, %cond.true449 ], [ %add.ptr459, %cond.false455 ]
  store %struct.lua_TValue.349* %cond461, %struct.lua_TValue.349** %rc444, align 8
  %279 = load %struct.lua_TValue.349** %rb426, align 8
  %tt_462 = getelementptr inbounds %struct.lua_TValue.349* %279, i32 0, i32 1
  %280 = load i32* %tt_462, align 4
  %cmp463 = icmp eq i32 %280, 3
  br i1 %cmp463, label %land.lhs.true465, label %if.else480

land.lhs.true465:                                 ; preds = %cond.end460
  %281 = load %struct.lua_TValue.349** %rc444, align 8
  %tt_466 = getelementptr inbounds %struct.lua_TValue.349* %281, i32 0, i32 1
  %282 = load i32* %tt_466, align 4
  %cmp467 = icmp eq i32 %282, 3
  br i1 %cmp467, label %if.then469, label %if.else480

if.then469:                                       ; preds = %land.lhs.true465
  %283 = load %struct.lua_TValue.349** %rb426, align 8
  %value_471 = getelementptr inbounds %struct.lua_TValue.349* %283, i32 0, i32 0
  %n472 = bitcast %union.Value.348* %value_471 to double*
  %284 = load double* %n472, align 8
  store double %284, double* %nb470, align 8
  %285 = load %struct.lua_TValue.349** %rc444, align 8
  %value_474 = getelementptr inbounds %struct.lua_TValue.349* %285, i32 0, i32 0
  %n475 = bitcast %union.Value.348* %value_474 to double*
  %286 = load double* %n475, align 8
  store double %286, double* %nc473, align 8
  %287 = load %struct.lua_TValue.349** %ra, align 8
  store %struct.lua_TValue.349* %287, %struct.lua_TValue.349** %io476, align 8
  %288 = load double* %nb470, align 8
  %289 = load double* %nc473, align 8
  %mul = fmul double %288, %289
  %290 = load %struct.lua_TValue.349** %io476, align 8
  %value_477 = getelementptr inbounds %struct.lua_TValue.349* %290, i32 0, i32 0
  %n478 = bitcast %union.Value.348* %value_477 to double*
  store double %mul, double* %n478, align 8
  %291 = load %struct.lua_TValue.349** %io476, align 8
  %tt_479 = getelementptr inbounds %struct.lua_TValue.349* %291, i32 0, i32 1
  store i32 3, i32* %tt_479, align 4
  br label %if.end484

if.else480:                                       ; preds = %land.lhs.true465, %cond.end460
  %292 = load %struct.lua_State.364** %L.addr, align 8
  %293 = load %struct.lua_TValue.349** %ra, align 8
  %294 = load %struct.lua_TValue.349** %rb426, align 8
  %295 = load %struct.lua_TValue.349** %rc444, align 8
  call void @luaV_arith(%struct.lua_State.364* %292, %struct.lua_TValue.349* %293, %struct.lua_TValue.349* %294, %struct.lua_TValue.349* %295, i32 8)
  %296 = load %struct.CallInfo.361** %ci, align 8
  %u481 = getelementptr inbounds %struct.CallInfo.361* %296, i32 0, i32 7
  %l482 = bitcast %union.anon.360* %u481 to %struct.anon.482*
  %base483 = getelementptr inbounds %struct.anon.482* %l482, i32 0, i32 0
  %297 = load %struct.lua_TValue.349** %base483, align 8
  store %struct.lua_TValue.349* %297, %struct.lua_TValue.349** %base, align 8
  br label %if.end484

if.end484:                                        ; preds = %if.else480, %if.then469
  br label %sw.epilog

sw.bb485:                                         ; preds = %if.end
  %298 = load i32* %i, align 4
  %shr487 = lshr i32 %298, 23
  %and488 = and i32 %shr487, 511
  %and489 = and i32 %and488, 256
  %tobool490 = icmp ne i32 %and489, 0
  br i1 %tobool490, label %cond.true491, label %cond.false497

cond.true491:                                     ; preds = %sw.bb485
  %299 = load %struct.lua_TValue.349** %k, align 8
  %300 = load i32* %i, align 4
  %shr492 = lshr i32 %300, 23
  %and493 = and i32 %shr492, 511
  %and494 = and i32 %and493, -257
  %idx.ext495 = sext i32 %and494 to i64
  %add.ptr496 = getelementptr inbounds %struct.lua_TValue.349* %299, i64 %idx.ext495
  br label %cond.end502

cond.false497:                                    ; preds = %sw.bb485
  %301 = load %struct.lua_TValue.349** %base, align 8
  %302 = load i32* %i, align 4
  %shr498 = lshr i32 %302, 23
  %and499 = and i32 %shr498, 511
  %idx.ext500 = sext i32 %and499 to i64
  %add.ptr501 = getelementptr inbounds %struct.lua_TValue.349* %301, i64 %idx.ext500
  br label %cond.end502

cond.end502:                                      ; preds = %cond.false497, %cond.true491
  %cond503 = phi %struct.lua_TValue.349* [ %add.ptr496, %cond.true491 ], [ %add.ptr501, %cond.false497 ]
  store %struct.lua_TValue.349* %cond503, %struct.lua_TValue.349** %rb486, align 8
  %303 = load i32* %i, align 4
  %shr505 = lshr i32 %303, 14
  %and506 = and i32 %shr505, 511
  %and507 = and i32 %and506, 256
  %tobool508 = icmp ne i32 %and507, 0
  br i1 %tobool508, label %cond.true509, label %cond.false515

cond.true509:                                     ; preds = %cond.end502
  %304 = load %struct.lua_TValue.349** %k, align 8
  %305 = load i32* %i, align 4
  %shr510 = lshr i32 %305, 14
  %and511 = and i32 %shr510, 511
  %and512 = and i32 %and511, -257
  %idx.ext513 = sext i32 %and512 to i64
  %add.ptr514 = getelementptr inbounds %struct.lua_TValue.349* %304, i64 %idx.ext513
  br label %cond.end520

cond.false515:                                    ; preds = %cond.end502
  %306 = load %struct.lua_TValue.349** %base, align 8
  %307 = load i32* %i, align 4
  %shr516 = lshr i32 %307, 14
  %and517 = and i32 %shr516, 511
  %idx.ext518 = sext i32 %and517 to i64
  %add.ptr519 = getelementptr inbounds %struct.lua_TValue.349* %306, i64 %idx.ext518
  br label %cond.end520

cond.end520:                                      ; preds = %cond.false515, %cond.true509
  %cond521 = phi %struct.lua_TValue.349* [ %add.ptr514, %cond.true509 ], [ %add.ptr519, %cond.false515 ]
  store %struct.lua_TValue.349* %cond521, %struct.lua_TValue.349** %rc504, align 8
  %308 = load %struct.lua_TValue.349** %rb486, align 8
  %tt_522 = getelementptr inbounds %struct.lua_TValue.349* %308, i32 0, i32 1
  %309 = load i32* %tt_522, align 4
  %cmp523 = icmp eq i32 %309, 3
  br i1 %cmp523, label %land.lhs.true525, label %if.else540

land.lhs.true525:                                 ; preds = %cond.end520
  %310 = load %struct.lua_TValue.349** %rc504, align 8
  %tt_526 = getelementptr inbounds %struct.lua_TValue.349* %310, i32 0, i32 1
  %311 = load i32* %tt_526, align 4
  %cmp527 = icmp eq i32 %311, 3
  br i1 %cmp527, label %if.then529, label %if.else540

if.then529:                                       ; preds = %land.lhs.true525
  %312 = load %struct.lua_TValue.349** %rb486, align 8
  %value_531 = getelementptr inbounds %struct.lua_TValue.349* %312, i32 0, i32 0
  %n532 = bitcast %union.Value.348* %value_531 to double*
  %313 = load double* %n532, align 8
  store double %313, double* %nb530, align 8
  %314 = load %struct.lua_TValue.349** %rc504, align 8
  %value_534 = getelementptr inbounds %struct.lua_TValue.349* %314, i32 0, i32 0
  %n535 = bitcast %union.Value.348* %value_534 to double*
  %315 = load double* %n535, align 8
  store double %315, double* %nc533, align 8
  %316 = load %struct.lua_TValue.349** %ra, align 8
  store %struct.lua_TValue.349* %316, %struct.lua_TValue.349** %io536, align 8
  %317 = load double* %nb530, align 8
  %318 = load double* %nc533, align 8
  %div = fdiv double %317, %318
  %319 = load %struct.lua_TValue.349** %io536, align 8
  %value_537 = getelementptr inbounds %struct.lua_TValue.349* %319, i32 0, i32 0
  %n538 = bitcast %union.Value.348* %value_537 to double*
  store double %div, double* %n538, align 8
  %320 = load %struct.lua_TValue.349** %io536, align 8
  %tt_539 = getelementptr inbounds %struct.lua_TValue.349* %320, i32 0, i32 1
  store i32 3, i32* %tt_539, align 4
  br label %if.end544

if.else540:                                       ; preds = %land.lhs.true525, %cond.end520
  %321 = load %struct.lua_State.364** %L.addr, align 8
  %322 = load %struct.lua_TValue.349** %ra, align 8
  %323 = load %struct.lua_TValue.349** %rb486, align 8
  %324 = load %struct.lua_TValue.349** %rc504, align 8
  call void @luaV_arith(%struct.lua_State.364* %321, %struct.lua_TValue.349* %322, %struct.lua_TValue.349* %323, %struct.lua_TValue.349* %324, i32 9)
  %325 = load %struct.CallInfo.361** %ci, align 8
  %u541 = getelementptr inbounds %struct.CallInfo.361* %325, i32 0, i32 7
  %l542 = bitcast %union.anon.360* %u541 to %struct.anon.482*
  %base543 = getelementptr inbounds %struct.anon.482* %l542, i32 0, i32 0
  %326 = load %struct.lua_TValue.349** %base543, align 8
  store %struct.lua_TValue.349* %326, %struct.lua_TValue.349** %base, align 8
  br label %if.end544

if.end544:                                        ; preds = %if.else540, %if.then529
  br label %sw.epilog

sw.bb545:                                         ; preds = %if.end
  %327 = load i32* %i, align 4
  %shr547 = lshr i32 %327, 23
  %and548 = and i32 %shr547, 511
  %and549 = and i32 %and548, 256
  %tobool550 = icmp ne i32 %and549, 0
  br i1 %tobool550, label %cond.true551, label %cond.false557

cond.true551:                                     ; preds = %sw.bb545
  %328 = load %struct.lua_TValue.349** %k, align 8
  %329 = load i32* %i, align 4
  %shr552 = lshr i32 %329, 23
  %and553 = and i32 %shr552, 511
  %and554 = and i32 %and553, -257
  %idx.ext555 = sext i32 %and554 to i64
  %add.ptr556 = getelementptr inbounds %struct.lua_TValue.349* %328, i64 %idx.ext555
  br label %cond.end562

cond.false557:                                    ; preds = %sw.bb545
  %330 = load %struct.lua_TValue.349** %base, align 8
  %331 = load i32* %i, align 4
  %shr558 = lshr i32 %331, 23
  %and559 = and i32 %shr558, 511
  %idx.ext560 = sext i32 %and559 to i64
  %add.ptr561 = getelementptr inbounds %struct.lua_TValue.349* %330, i64 %idx.ext560
  br label %cond.end562

cond.end562:                                      ; preds = %cond.false557, %cond.true551
  %cond563 = phi %struct.lua_TValue.349* [ %add.ptr556, %cond.true551 ], [ %add.ptr561, %cond.false557 ]
  store %struct.lua_TValue.349* %cond563, %struct.lua_TValue.349** %rb546, align 8
  %332 = load i32* %i, align 4
  %shr565 = lshr i32 %332, 14
  %and566 = and i32 %shr565, 511
  %and567 = and i32 %and566, 256
  %tobool568 = icmp ne i32 %and567, 0
  br i1 %tobool568, label %cond.true569, label %cond.false575

cond.true569:                                     ; preds = %cond.end562
  %333 = load %struct.lua_TValue.349** %k, align 8
  %334 = load i32* %i, align 4
  %shr570 = lshr i32 %334, 14
  %and571 = and i32 %shr570, 511
  %and572 = and i32 %and571, -257
  %idx.ext573 = sext i32 %and572 to i64
  %add.ptr574 = getelementptr inbounds %struct.lua_TValue.349* %333, i64 %idx.ext573
  br label %cond.end580

cond.false575:                                    ; preds = %cond.end562
  %335 = load %struct.lua_TValue.349** %base, align 8
  %336 = load i32* %i, align 4
  %shr576 = lshr i32 %336, 14
  %and577 = and i32 %shr576, 511
  %idx.ext578 = sext i32 %and577 to i64
  %add.ptr579 = getelementptr inbounds %struct.lua_TValue.349* %335, i64 %idx.ext578
  br label %cond.end580

cond.end580:                                      ; preds = %cond.false575, %cond.true569
  %cond581 = phi %struct.lua_TValue.349* [ %add.ptr574, %cond.true569 ], [ %add.ptr579, %cond.false575 ]
  store %struct.lua_TValue.349* %cond581, %struct.lua_TValue.349** %rc564, align 8
  %337 = load %struct.lua_TValue.349** %rb546, align 8
  %tt_582 = getelementptr inbounds %struct.lua_TValue.349* %337, i32 0, i32 1
  %338 = load i32* %tt_582, align 4
  %cmp583 = icmp eq i32 %338, 3
  br i1 %cmp583, label %land.lhs.true585, label %if.else604

land.lhs.true585:                                 ; preds = %cond.end580
  %339 = load %struct.lua_TValue.349** %rc564, align 8
  %tt_586 = getelementptr inbounds %struct.lua_TValue.349* %339, i32 0, i32 1
  %340 = load i32* %tt_586, align 4
  %cmp587 = icmp eq i32 %340, 3
  br i1 %cmp587, label %if.then589, label %if.else604

if.then589:                                       ; preds = %land.lhs.true585
  %341 = load %struct.lua_TValue.349** %rb546, align 8
  %value_591 = getelementptr inbounds %struct.lua_TValue.349* %341, i32 0, i32 0
  %n592 = bitcast %union.Value.348* %value_591 to double*
  %342 = load double* %n592, align 8
  store double %342, double* %nb590, align 8
  %343 = load %struct.lua_TValue.349** %rc564, align 8
  %value_594 = getelementptr inbounds %struct.lua_TValue.349* %343, i32 0, i32 0
  %n595 = bitcast %union.Value.348* %value_594 to double*
  %344 = load double* %n595, align 8
  store double %344, double* %nc593, align 8
  %345 = load %struct.lua_TValue.349** %ra, align 8
  store %struct.lua_TValue.349* %345, %struct.lua_TValue.349** %io596, align 8
  %346 = load double* %nb590, align 8
  %347 = load double* %nb590, align 8
  %348 = load double* %nc593, align 8
  %div597 = fdiv double %347, %348
  %call598 = call double @floor(double %div597) #11
  %349 = load double* %nc593, align 8
  %mul599 = fmul double %call598, %349
  %sub600 = fsub double %346, %mul599
  %350 = load %struct.lua_TValue.349** %io596, align 8
  %value_601 = getelementptr inbounds %struct.lua_TValue.349* %350, i32 0, i32 0
  %n602 = bitcast %union.Value.348* %value_601 to double*
  store double %sub600, double* %n602, align 8
  %351 = load %struct.lua_TValue.349** %io596, align 8
  %tt_603 = getelementptr inbounds %struct.lua_TValue.349* %351, i32 0, i32 1
  store i32 3, i32* %tt_603, align 4
  br label %if.end608

if.else604:                                       ; preds = %land.lhs.true585, %cond.end580
  %352 = load %struct.lua_State.364** %L.addr, align 8
  %353 = load %struct.lua_TValue.349** %ra, align 8
  %354 = load %struct.lua_TValue.349** %rb546, align 8
  %355 = load %struct.lua_TValue.349** %rc564, align 8
  call void @luaV_arith(%struct.lua_State.364* %352, %struct.lua_TValue.349* %353, %struct.lua_TValue.349* %354, %struct.lua_TValue.349* %355, i32 10)
  %356 = load %struct.CallInfo.361** %ci, align 8
  %u605 = getelementptr inbounds %struct.CallInfo.361* %356, i32 0, i32 7
  %l606 = bitcast %union.anon.360* %u605 to %struct.anon.482*
  %base607 = getelementptr inbounds %struct.anon.482* %l606, i32 0, i32 0
  %357 = load %struct.lua_TValue.349** %base607, align 8
  store %struct.lua_TValue.349* %357, %struct.lua_TValue.349** %base, align 8
  br label %if.end608

if.end608:                                        ; preds = %if.else604, %if.then589
  br label %sw.epilog

sw.bb609:                                         ; preds = %if.end
  %358 = load i32* %i, align 4
  %shr611 = lshr i32 %358, 23
  %and612 = and i32 %shr611, 511
  %and613 = and i32 %and612, 256
  %tobool614 = icmp ne i32 %and613, 0
  br i1 %tobool614, label %cond.true615, label %cond.false621

cond.true615:                                     ; preds = %sw.bb609
  %359 = load %struct.lua_TValue.349** %k, align 8
  %360 = load i32* %i, align 4
  %shr616 = lshr i32 %360, 23
  %and617 = and i32 %shr616, 511
  %and618 = and i32 %and617, -257
  %idx.ext619 = sext i32 %and618 to i64
  %add.ptr620 = getelementptr inbounds %struct.lua_TValue.349* %359, i64 %idx.ext619
  br label %cond.end626

cond.false621:                                    ; preds = %sw.bb609
  %361 = load %struct.lua_TValue.349** %base, align 8
  %362 = load i32* %i, align 4
  %shr622 = lshr i32 %362, 23
  %and623 = and i32 %shr622, 511
  %idx.ext624 = sext i32 %and623 to i64
  %add.ptr625 = getelementptr inbounds %struct.lua_TValue.349* %361, i64 %idx.ext624
  br label %cond.end626

cond.end626:                                      ; preds = %cond.false621, %cond.true615
  %cond627 = phi %struct.lua_TValue.349* [ %add.ptr620, %cond.true615 ], [ %add.ptr625, %cond.false621 ]
  store %struct.lua_TValue.349* %cond627, %struct.lua_TValue.349** %rb610, align 8
  %363 = load i32* %i, align 4
  %shr629 = lshr i32 %363, 14
  %and630 = and i32 %shr629, 511
  %and631 = and i32 %and630, 256
  %tobool632 = icmp ne i32 %and631, 0
  br i1 %tobool632, label %cond.true633, label %cond.false639

cond.true633:                                     ; preds = %cond.end626
  %364 = load %struct.lua_TValue.349** %k, align 8
  %365 = load i32* %i, align 4
  %shr634 = lshr i32 %365, 14
  %and635 = and i32 %shr634, 511
  %and636 = and i32 %and635, -257
  %idx.ext637 = sext i32 %and636 to i64
  %add.ptr638 = getelementptr inbounds %struct.lua_TValue.349* %364, i64 %idx.ext637
  br label %cond.end644

cond.false639:                                    ; preds = %cond.end626
  %366 = load %struct.lua_TValue.349** %base, align 8
  %367 = load i32* %i, align 4
  %shr640 = lshr i32 %367, 14
  %and641 = and i32 %shr640, 511
  %idx.ext642 = sext i32 %and641 to i64
  %add.ptr643 = getelementptr inbounds %struct.lua_TValue.349* %366, i64 %idx.ext642
  br label %cond.end644

cond.end644:                                      ; preds = %cond.false639, %cond.true633
  %cond645 = phi %struct.lua_TValue.349* [ %add.ptr638, %cond.true633 ], [ %add.ptr643, %cond.false639 ]
  store %struct.lua_TValue.349* %cond645, %struct.lua_TValue.349** %rc628, align 8
  %368 = load %struct.lua_TValue.349** %rb610, align 8
  %tt_646 = getelementptr inbounds %struct.lua_TValue.349* %368, i32 0, i32 1
  %369 = load i32* %tt_646, align 4
  %cmp647 = icmp eq i32 %369, 3
  br i1 %cmp647, label %land.lhs.true649, label %if.else665

land.lhs.true649:                                 ; preds = %cond.end644
  %370 = load %struct.lua_TValue.349** %rc628, align 8
  %tt_650 = getelementptr inbounds %struct.lua_TValue.349* %370, i32 0, i32 1
  %371 = load i32* %tt_650, align 4
  %cmp651 = icmp eq i32 %371, 3
  br i1 %cmp651, label %if.then653, label %if.else665

if.then653:                                       ; preds = %land.lhs.true649
  %372 = load %struct.lua_TValue.349** %rb610, align 8
  %value_655 = getelementptr inbounds %struct.lua_TValue.349* %372, i32 0, i32 0
  %n656 = bitcast %union.Value.348* %value_655 to double*
  %373 = load double* %n656, align 8
  store double %373, double* %nb654, align 8
  %374 = load %struct.lua_TValue.349** %rc628, align 8
  %value_658 = getelementptr inbounds %struct.lua_TValue.349* %374, i32 0, i32 0
  %n659 = bitcast %union.Value.348* %value_658 to double*
  %375 = load double* %n659, align 8
  store double %375, double* %nc657, align 8
  %376 = load %struct.lua_TValue.349** %ra, align 8
  store %struct.lua_TValue.349* %376, %struct.lua_TValue.349** %io660, align 8
  %377 = load double* %nb654, align 8
  %378 = load double* %nc657, align 8
  %call661 = call double @pow(double %377, double %378) #1
  %379 = load %struct.lua_TValue.349** %io660, align 8
  %value_662 = getelementptr inbounds %struct.lua_TValue.349* %379, i32 0, i32 0
  %n663 = bitcast %union.Value.348* %value_662 to double*
  store double %call661, double* %n663, align 8
  %380 = load %struct.lua_TValue.349** %io660, align 8
  %tt_664 = getelementptr inbounds %struct.lua_TValue.349* %380, i32 0, i32 1
  store i32 3, i32* %tt_664, align 4
  br label %if.end669

if.else665:                                       ; preds = %land.lhs.true649, %cond.end644
  %381 = load %struct.lua_State.364** %L.addr, align 8
  %382 = load %struct.lua_TValue.349** %ra, align 8
  %383 = load %struct.lua_TValue.349** %rb610, align 8
  %384 = load %struct.lua_TValue.349** %rc628, align 8
  call void @luaV_arith(%struct.lua_State.364* %381, %struct.lua_TValue.349* %382, %struct.lua_TValue.349* %383, %struct.lua_TValue.349* %384, i32 11)
  %385 = load %struct.CallInfo.361** %ci, align 8
  %u666 = getelementptr inbounds %struct.CallInfo.361* %385, i32 0, i32 7
  %l667 = bitcast %union.anon.360* %u666 to %struct.anon.482*
  %base668 = getelementptr inbounds %struct.anon.482* %l667, i32 0, i32 0
  %386 = load %struct.lua_TValue.349** %base668, align 8
  store %struct.lua_TValue.349* %386, %struct.lua_TValue.349** %base, align 8
  br label %if.end669

if.end669:                                        ; preds = %if.else665, %if.then653
  br label %sw.epilog

sw.bb670:                                         ; preds = %if.end
  %387 = load %struct.lua_TValue.349** %base, align 8
  %388 = load i32* %i, align 4
  %shr672 = lshr i32 %388, 23
  %and673 = and i32 %shr672, 511
  %idx.ext674 = sext i32 %and673 to i64
  %add.ptr675 = getelementptr inbounds %struct.lua_TValue.349* %387, i64 %idx.ext674
  store %struct.lua_TValue.349* %add.ptr675, %struct.lua_TValue.349** %rb671, align 8
  %389 = load %struct.lua_TValue.349** %rb671, align 8
  %tt_676 = getelementptr inbounds %struct.lua_TValue.349* %389, i32 0, i32 1
  %390 = load i32* %tt_676, align 4
  %cmp677 = icmp eq i32 %390, 3
  br i1 %cmp677, label %if.then679, label %if.else688

if.then679:                                       ; preds = %sw.bb670
  %391 = load %struct.lua_TValue.349** %rb671, align 8
  %value_681 = getelementptr inbounds %struct.lua_TValue.349* %391, i32 0, i32 0
  %n682 = bitcast %union.Value.348* %value_681 to double*
  %392 = load double* %n682, align 8
  store double %392, double* %nb680, align 8
  %393 = load %struct.lua_TValue.349** %ra, align 8
  store %struct.lua_TValue.349* %393, %struct.lua_TValue.349** %io683, align 8
  %394 = load double* %nb680, align 8
  %sub684 = fsub double -0.000000e+00, %394
  %395 = load %struct.lua_TValue.349** %io683, align 8
  %value_685 = getelementptr inbounds %struct.lua_TValue.349* %395, i32 0, i32 0
  %n686 = bitcast %union.Value.348* %value_685 to double*
  store double %sub684, double* %n686, align 8
  %396 = load %struct.lua_TValue.349** %io683, align 8
  %tt_687 = getelementptr inbounds %struct.lua_TValue.349* %396, i32 0, i32 1
  store i32 3, i32* %tt_687, align 4
  br label %if.end692

if.else688:                                       ; preds = %sw.bb670
  %397 = load %struct.lua_State.364** %L.addr, align 8
  %398 = load %struct.lua_TValue.349** %ra, align 8
  %399 = load %struct.lua_TValue.349** %rb671, align 8
  %400 = load %struct.lua_TValue.349** %rb671, align 8
  call void @luaV_arith(%struct.lua_State.364* %397, %struct.lua_TValue.349* %398, %struct.lua_TValue.349* %399, %struct.lua_TValue.349* %400, i32 12)
  %401 = load %struct.CallInfo.361** %ci, align 8
  %u689 = getelementptr inbounds %struct.CallInfo.361* %401, i32 0, i32 7
  %l690 = bitcast %union.anon.360* %u689 to %struct.anon.482*
  %base691 = getelementptr inbounds %struct.anon.482* %l690, i32 0, i32 0
  %402 = load %struct.lua_TValue.349** %base691, align 8
  store %struct.lua_TValue.349* %402, %struct.lua_TValue.349** %base, align 8
  br label %if.end692

if.end692:                                        ; preds = %if.else688, %if.then679
  br label %sw.epilog

sw.bb693:                                         ; preds = %if.end
  %403 = load %struct.lua_TValue.349** %base, align 8
  %404 = load i32* %i, align 4
  %shr695 = lshr i32 %404, 23
  %and696 = and i32 %shr695, 511
  %idx.ext697 = sext i32 %and696 to i64
  %add.ptr698 = getelementptr inbounds %struct.lua_TValue.349* %403, i64 %idx.ext697
  store %struct.lua_TValue.349* %add.ptr698, %struct.lua_TValue.349** %rb694, align 8
  %405 = load %struct.lua_TValue.349** %rb694, align 8
  %tt_699 = getelementptr inbounds %struct.lua_TValue.349* %405, i32 0, i32 1
  %406 = load i32* %tt_699, align 4
  %cmp700 = icmp eq i32 %406, 0
  br i1 %cmp700, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %sw.bb693
  %407 = load %struct.lua_TValue.349** %rb694, align 8
  %tt_702 = getelementptr inbounds %struct.lua_TValue.349* %407, i32 0, i32 1
  %408 = load i32* %tt_702, align 4
  %cmp703 = icmp eq i32 %408, 1
  br i1 %cmp703, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %lor.rhs
  %409 = load %struct.lua_TValue.349** %rb694, align 8
  %value_705 = getelementptr inbounds %struct.lua_TValue.349* %409, i32 0, i32 0
  %b706 = bitcast %union.Value.348* %value_705 to i32*
  %410 = load i32* %b706, align 4
  %cmp707 = icmp eq i32 %410, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %lor.rhs
  %411 = phi i1 [ false, %lor.rhs ], [ %cmp707, %land.rhs ]
  br label %lor.end

lor.end:                                          ; preds = %land.end, %sw.bb693
  %412 = phi i1 [ true, %sw.bb693 ], [ %411, %land.end ]
  %lor.ext = zext i1 %412 to i32
  store i32 %lor.ext, i32* %res, align 4
  %413 = load %struct.lua_TValue.349** %ra, align 8
  store %struct.lua_TValue.349* %413, %struct.lua_TValue.349** %io709, align 8
  %414 = load i32* %res, align 4
  %415 = load %struct.lua_TValue.349** %io709, align 8
  %value_710 = getelementptr inbounds %struct.lua_TValue.349* %415, i32 0, i32 0
  %b711 = bitcast %union.Value.348* %value_710 to i32*
  store i32 %414, i32* %b711, align 4
  %416 = load %struct.lua_TValue.349** %io709, align 8
  %tt_712 = getelementptr inbounds %struct.lua_TValue.349* %416, i32 0, i32 1
  store i32 1, i32* %tt_712, align 4
  br label %sw.epilog

sw.bb713:                                         ; preds = %if.end
  %417 = load %struct.lua_State.364** %L.addr, align 8
  %418 = load %struct.lua_TValue.349** %ra, align 8
  %419 = load %struct.lua_TValue.349** %base, align 8
  %420 = load i32* %i, align 4
  %shr714 = lshr i32 %420, 23
  %and715 = and i32 %shr714, 511
  %idx.ext716 = sext i32 %and715 to i64
  %add.ptr717 = getelementptr inbounds %struct.lua_TValue.349* %419, i64 %idx.ext716
  call void @luaV_objlen(%struct.lua_State.364* %417, %struct.lua_TValue.349* %418, %struct.lua_TValue.349* %add.ptr717)
  %421 = load %struct.CallInfo.361** %ci, align 8
  %u718 = getelementptr inbounds %struct.CallInfo.361* %421, i32 0, i32 7
  %l719 = bitcast %union.anon.360* %u718 to %struct.anon.482*
  %base720 = getelementptr inbounds %struct.anon.482* %l719, i32 0, i32 0
  %422 = load %struct.lua_TValue.349** %base720, align 8
  store %struct.lua_TValue.349* %422, %struct.lua_TValue.349** %base, align 8
  br label %sw.epilog

sw.bb721:                                         ; preds = %if.end
  %423 = load i32* %i, align 4
  %shr723 = lshr i32 %423, 23
  %and724 = and i32 %shr723, 511
  store i32 %and724, i32* %b722, align 4
  %424 = load i32* %i, align 4
  %shr726 = lshr i32 %424, 14
  %and727 = and i32 %shr726, 511
  store i32 %and727, i32* %c725, align 4
  %425 = load %struct.lua_TValue.349** %base, align 8
  %426 = load i32* %c725, align 4
  %idx.ext729 = sext i32 %426 to i64
  %add.ptr730 = getelementptr inbounds %struct.lua_TValue.349* %425, i64 %idx.ext729
  %add.ptr731 = getelementptr inbounds %struct.lua_TValue.349* %add.ptr730, i64 1
  %427 = load %struct.lua_State.364** %L.addr, align 8
  %top732 = getelementptr inbounds %struct.lua_State.364* %427, i32 0, i32 4
  store %struct.lua_TValue.349* %add.ptr731, %struct.lua_TValue.349** %top732, align 8
  %428 = load %struct.lua_State.364** %L.addr, align 8
  %429 = load i32* %c725, align 4
  %430 = load i32* %b722, align 4
  %sub733 = sub nsw i32 %429, %430
  %add734 = add nsw i32 %sub733, 1
  call void @luaV_concat(%struct.lua_State.364* %428, i32 %add734)
  %431 = load %struct.CallInfo.361** %ci, align 8
  %u735 = getelementptr inbounds %struct.CallInfo.361* %431, i32 0, i32 7
  %l736 = bitcast %union.anon.360* %u735 to %struct.anon.482*
  %base737 = getelementptr inbounds %struct.anon.482* %l736, i32 0, i32 0
  %432 = load %struct.lua_TValue.349** %base737, align 8
  store %struct.lua_TValue.349* %432, %struct.lua_TValue.349** %base, align 8
  %433 = load %struct.lua_TValue.349** %base, align 8
  %434 = load i32* %i, align 4
  %shr738 = lshr i32 %434, 6
  %and739 = and i32 %shr738, 255
  %idx.ext740 = sext i32 %and739 to i64
  %add.ptr741 = getelementptr inbounds %struct.lua_TValue.349* %433, i64 %idx.ext740
  store %struct.lua_TValue.349* %add.ptr741, %struct.lua_TValue.349** %ra, align 8
  %435 = load i32* %b722, align 4
  %436 = load %struct.lua_TValue.349** %base, align 8
  %idx.ext742 = sext i32 %435 to i64
  %add.ptr743 = getelementptr inbounds %struct.lua_TValue.349* %436, i64 %idx.ext742
  store %struct.lua_TValue.349* %add.ptr743, %struct.lua_TValue.349** %rb728, align 8
  %437 = load %struct.lua_TValue.349** %rb728, align 8
  store %struct.lua_TValue.349* %437, %struct.lua_TValue.349** %io2744, align 8
  %438 = load %struct.lua_TValue.349** %ra, align 8
  store %struct.lua_TValue.349* %438, %struct.lua_TValue.349** %io1745, align 8
  %439 = load %struct.lua_TValue.349** %io1745, align 8
  %value_746 = getelementptr inbounds %struct.lua_TValue.349* %439, i32 0, i32 0
  %440 = load %struct.lua_TValue.349** %io2744, align 8
  %value_747 = getelementptr inbounds %struct.lua_TValue.349* %440, i32 0, i32 0
  %441 = bitcast %union.Value.348* %value_746 to i8*
  %442 = bitcast %union.Value.348* %value_747 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %441, i8* %442, i64 8, i32 8, i1 false)
  %443 = load %struct.lua_TValue.349** %io2744, align 8
  %tt_748 = getelementptr inbounds %struct.lua_TValue.349* %443, i32 0, i32 1
  %444 = load i32* %tt_748, align 4
  %445 = load %struct.lua_TValue.349** %io1745, align 8
  %tt_749 = getelementptr inbounds %struct.lua_TValue.349* %445, i32 0, i32 1
  store i32 %444, i32* %tt_749, align 4
  %446 = load %struct.lua_State.364** %L.addr, align 8
  %l_G750 = getelementptr inbounds %struct.lua_State.364* %446, i32 0, i32 5
  %447 = load %struct.global_State.358** %l_G750, align 8
  %GCdebt751 = getelementptr inbounds %struct.global_State.358* %447, i32 0, i32 3
  %448 = load i64* %GCdebt751, align 8
  %cmp752 = icmp sgt i64 %448, 0
  br i1 %cmp752, label %if.then754, label %if.end765

if.then754:                                       ; preds = %sw.bb721
  %449 = load %struct.lua_TValue.349** %ra, align 8
  %450 = load %struct.lua_TValue.349** %rb728, align 8
  %cmp755 = icmp uge %struct.lua_TValue.349* %449, %450
  br i1 %cmp755, label %cond.true757, label %cond.false759

cond.true757:                                     ; preds = %if.then754
  %451 = load %struct.lua_TValue.349** %ra, align 8
  %add.ptr758 = getelementptr inbounds %struct.lua_TValue.349* %451, i64 1
  br label %cond.end760

cond.false759:                                    ; preds = %if.then754
  %452 = load %struct.lua_TValue.349** %rb728, align 8
  br label %cond.end760

cond.end760:                                      ; preds = %cond.false759, %cond.true757
  %cond761 = phi %struct.lua_TValue.349* [ %add.ptr758, %cond.true757 ], [ %452, %cond.false759 ]
  %453 = load %struct.lua_State.364** %L.addr, align 8
  %top762 = getelementptr inbounds %struct.lua_State.364* %453, i32 0, i32 4
  store %struct.lua_TValue.349* %cond761, %struct.lua_TValue.349** %top762, align 8
  %454 = load %struct.lua_State.364** %L.addr, align 8
  call void bitcast (void (%struct.lua_State*)* @luaC_step to void (%struct.lua_State.364*)*)(%struct.lua_State.364* %454)
  %455 = load %struct.CallInfo.361** %ci, align 8
  %top763 = getelementptr inbounds %struct.CallInfo.361* %455, i32 0, i32 1
  %456 = load %struct.lua_TValue.349** %top763, align 8
  %457 = load %struct.lua_State.364** %L.addr, align 8
  %top764 = getelementptr inbounds %struct.lua_State.364* %457, i32 0, i32 4
  store %struct.lua_TValue.349* %456, %struct.lua_TValue.349** %top764, align 8
  br label %if.end765

if.end765:                                        ; preds = %cond.end760, %sw.bb721
  %458 = load %struct.CallInfo.361** %ci, align 8
  %u766 = getelementptr inbounds %struct.CallInfo.361* %458, i32 0, i32 7
  %l767 = bitcast %union.anon.360* %u766 to %struct.anon.482*
  %base768 = getelementptr inbounds %struct.anon.482* %l767, i32 0, i32 0
  %459 = load %struct.lua_TValue.349** %base768, align 8
  store %struct.lua_TValue.349* %459, %struct.lua_TValue.349** %base, align 8
  %460 = load %struct.CallInfo.361** %ci, align 8
  %top769 = getelementptr inbounds %struct.CallInfo.361* %460, i32 0, i32 1
  %461 = load %struct.lua_TValue.349** %top769, align 8
  %462 = load %struct.lua_State.364** %L.addr, align 8
  %top770 = getelementptr inbounds %struct.lua_State.364* %462, i32 0, i32 4
  store %struct.lua_TValue.349* %461, %struct.lua_TValue.349** %top770, align 8
  br label %sw.epilog

sw.bb771:                                         ; preds = %if.end
  %463 = load i32* %i, align 4
  %shr773 = lshr i32 %463, 6
  %and774 = and i32 %shr773, 255
  store i32 %and774, i32* %a772, align 4
  %464 = load i32* %a772, align 4
  %cmp775 = icmp sgt i32 %464, 0
  br i1 %cmp775, label %if.then777, label %if.end784

if.then777:                                       ; preds = %sw.bb771
  %465 = load %struct.lua_State.364** %L.addr, align 8
  %466 = load %struct.CallInfo.361** %ci, align 8
  %u778 = getelementptr inbounds %struct.CallInfo.361* %466, i32 0, i32 7
  %l779 = bitcast %union.anon.360* %u778 to %struct.anon.482*
  %base780 = getelementptr inbounds %struct.anon.482* %l779, i32 0, i32 0
  %467 = load %struct.lua_TValue.349** %base780, align 8
  %468 = load i32* %a772, align 4
  %idx.ext781 = sext i32 %468 to i64
  %add.ptr782 = getelementptr inbounds %struct.lua_TValue.349* %467, i64 %idx.ext781
  %add.ptr783 = getelementptr inbounds %struct.lua_TValue.349* %add.ptr782, i64 -1
  call void bitcast (void (%struct.lua_State.154*, %struct.lua_TValue.137*)* @luaF_close to void (%struct.lua_State.364*, %struct.lua_TValue.349*)*)(%struct.lua_State.364* %465, %struct.lua_TValue.349* %add.ptr783)
  br label %if.end784

if.end784:                                        ; preds = %if.then777, %sw.bb771
  %469 = load i32* %i, align 4
  %shr785 = lshr i32 %469, 14
  %and786 = and i32 %shr785, 262143
  %sub787 = sub nsw i32 %and786, 131071
  %add788 = add nsw i32 %sub787, 0
  %470 = load %struct.CallInfo.361** %ci, align 8
  %u789 = getelementptr inbounds %struct.CallInfo.361* %470, i32 0, i32 7
  %l790 = bitcast %union.anon.360* %u789 to %struct.anon.482*
  %savedpc791 = getelementptr inbounds %struct.anon.482* %l790, i32 0, i32 1
  %471 = load i32** %savedpc791, align 8
  %idx.ext792 = sext i32 %add788 to i64
  %add.ptr793 = getelementptr inbounds i32* %471, i64 %idx.ext792
  store i32* %add.ptr793, i32** %savedpc791, align 8
  br label %sw.epilog

sw.bb794:                                         ; preds = %if.end
  %472 = load i32* %i, align 4
  %shr796 = lshr i32 %472, 23
  %and797 = and i32 %shr796, 511
  %and798 = and i32 %and797, 256
  %tobool799 = icmp ne i32 %and798, 0
  br i1 %tobool799, label %cond.true800, label %cond.false806

cond.true800:                                     ; preds = %sw.bb794
  %473 = load %struct.lua_TValue.349** %k, align 8
  %474 = load i32* %i, align 4
  %shr801 = lshr i32 %474, 23
  %and802 = and i32 %shr801, 511
  %and803 = and i32 %and802, -257
  %idx.ext804 = sext i32 %and803 to i64
  %add.ptr805 = getelementptr inbounds %struct.lua_TValue.349* %473, i64 %idx.ext804
  br label %cond.end811

cond.false806:                                    ; preds = %sw.bb794
  %475 = load %struct.lua_TValue.349** %base, align 8
  %476 = load i32* %i, align 4
  %shr807 = lshr i32 %476, 23
  %and808 = and i32 %shr807, 511
  %idx.ext809 = sext i32 %and808 to i64
  %add.ptr810 = getelementptr inbounds %struct.lua_TValue.349* %475, i64 %idx.ext809
  br label %cond.end811

cond.end811:                                      ; preds = %cond.false806, %cond.true800
  %cond812 = phi %struct.lua_TValue.349* [ %add.ptr805, %cond.true800 ], [ %add.ptr810, %cond.false806 ]
  store %struct.lua_TValue.349* %cond812, %struct.lua_TValue.349** %rb795, align 8
  %477 = load i32* %i, align 4
  %shr814 = lshr i32 %477, 14
  %and815 = and i32 %shr814, 511
  %and816 = and i32 %and815, 256
  %tobool817 = icmp ne i32 %and816, 0
  br i1 %tobool817, label %cond.true818, label %cond.false824

cond.true818:                                     ; preds = %cond.end811
  %478 = load %struct.lua_TValue.349** %k, align 8
  %479 = load i32* %i, align 4
  %shr819 = lshr i32 %479, 14
  %and820 = and i32 %shr819, 511
  %and821 = and i32 %and820, -257
  %idx.ext822 = sext i32 %and821 to i64
  %add.ptr823 = getelementptr inbounds %struct.lua_TValue.349* %478, i64 %idx.ext822
  br label %cond.end829

cond.false824:                                    ; preds = %cond.end811
  %480 = load %struct.lua_TValue.349** %base, align 8
  %481 = load i32* %i, align 4
  %shr825 = lshr i32 %481, 14
  %and826 = and i32 %shr825, 511
  %idx.ext827 = sext i32 %and826 to i64
  %add.ptr828 = getelementptr inbounds %struct.lua_TValue.349* %480, i64 %idx.ext827
  br label %cond.end829

cond.end829:                                      ; preds = %cond.false824, %cond.true818
  %cond830 = phi %struct.lua_TValue.349* [ %add.ptr823, %cond.true818 ], [ %add.ptr828, %cond.false824 ]
  store %struct.lua_TValue.349* %cond830, %struct.lua_TValue.349** %rc813, align 8
  %482 = load %struct.lua_TValue.349** %rb795, align 8
  %tt_831 = getelementptr inbounds %struct.lua_TValue.349* %482, i32 0, i32 1
  %483 = load i32* %tt_831, align 4
  %484 = load %struct.lua_TValue.349** %rc813, align 8
  %tt_832 = getelementptr inbounds %struct.lua_TValue.349* %484, i32 0, i32 1
  %485 = load i32* %tt_832, align 4
  %cmp833 = icmp eq i32 %483, %485
  br i1 %cmp833, label %land.rhs835, label %land.end838

land.rhs835:                                      ; preds = %cond.end829
  %486 = load %struct.lua_State.364** %L.addr, align 8
  %487 = load %struct.lua_TValue.349** %rb795, align 8
  %488 = load %struct.lua_TValue.349** %rc813, align 8
  %call836 = call i32 @luaV_equalobj_(%struct.lua_State.364* %486, %struct.lua_TValue.349* %487, %struct.lua_TValue.349* %488)
  %tobool837 = icmp ne i32 %call836, 0
  br label %land.end838

land.end838:                                      ; preds = %land.rhs835, %cond.end829
  %489 = phi i1 [ false, %cond.end829 ], [ %tobool837, %land.rhs835 ]
  %land.ext = zext i1 %489 to i32
  %490 = load i32* %i, align 4
  %shr839 = lshr i32 %490, 6
  %and840 = and i32 %shr839, 255
  %cmp841 = icmp ne i32 %land.ext, %and840
  br i1 %cmp841, label %if.then843, label %if.else848

if.then843:                                       ; preds = %land.end838
  %491 = load %struct.CallInfo.361** %ci, align 8
  %u844 = getelementptr inbounds %struct.CallInfo.361* %491, i32 0, i32 7
  %l845 = bitcast %union.anon.360* %u844 to %struct.anon.482*
  %savedpc846 = getelementptr inbounds %struct.anon.482* %l845, i32 0, i32 1
  %492 = load i32** %savedpc846, align 8
  %incdec.ptr847 = getelementptr inbounds i32* %492, i32 1
  store i32* %incdec.ptr847, i32** %savedpc846, align 8
  br label %if.end874

if.else848:                                       ; preds = %land.end838
  %493 = load %struct.CallInfo.361** %ci, align 8
  %u849 = getelementptr inbounds %struct.CallInfo.361* %493, i32 0, i32 7
  %l850 = bitcast %union.anon.360* %u849 to %struct.anon.482*
  %savedpc851 = getelementptr inbounds %struct.anon.482* %l850, i32 0, i32 1
  %494 = load i32** %savedpc851, align 8
  %495 = load i32* %494, align 4
  store i32 %495, i32* %i, align 4
  %496 = load i32* %i, align 4
  %shr853 = lshr i32 %496, 6
  %and854 = and i32 %shr853, 255
  store i32 %and854, i32* %a852, align 4
  %497 = load i32* %a852, align 4
  %cmp855 = icmp sgt i32 %497, 0
  br i1 %cmp855, label %if.then857, label %if.end864

if.then857:                                       ; preds = %if.else848
  %498 = load %struct.lua_State.364** %L.addr, align 8
  %499 = load %struct.CallInfo.361** %ci, align 8
  %u858 = getelementptr inbounds %struct.CallInfo.361* %499, i32 0, i32 7
  %l859 = bitcast %union.anon.360* %u858 to %struct.anon.482*
  %base860 = getelementptr inbounds %struct.anon.482* %l859, i32 0, i32 0
  %500 = load %struct.lua_TValue.349** %base860, align 8
  %501 = load i32* %a852, align 4
  %idx.ext861 = sext i32 %501 to i64
  %add.ptr862 = getelementptr inbounds %struct.lua_TValue.349* %500, i64 %idx.ext861
  %add.ptr863 = getelementptr inbounds %struct.lua_TValue.349* %add.ptr862, i64 -1
  call void bitcast (void (%struct.lua_State.154*, %struct.lua_TValue.137*)* @luaF_close to void (%struct.lua_State.364*, %struct.lua_TValue.349*)*)(%struct.lua_State.364* %498, %struct.lua_TValue.349* %add.ptr863)
  br label %if.end864

if.end864:                                        ; preds = %if.then857, %if.else848
  %502 = load i32* %i, align 4
  %shr865 = lshr i32 %502, 14
  %and866 = and i32 %shr865, 262143
  %sub867 = sub nsw i32 %and866, 131071
  %add868 = add nsw i32 %sub867, 1
  %503 = load %struct.CallInfo.361** %ci, align 8
  %u869 = getelementptr inbounds %struct.CallInfo.361* %503, i32 0, i32 7
  %l870 = bitcast %union.anon.360* %u869 to %struct.anon.482*
  %savedpc871 = getelementptr inbounds %struct.anon.482* %l870, i32 0, i32 1
  %504 = load i32** %savedpc871, align 8
  %idx.ext872 = sext i32 %add868 to i64
  %add.ptr873 = getelementptr inbounds i32* %504, i64 %idx.ext872
  store i32* %add.ptr873, i32** %savedpc871, align 8
  br label %if.end874

if.end874:                                        ; preds = %if.end864, %if.then843
  %505 = load %struct.CallInfo.361** %ci, align 8
  %u875 = getelementptr inbounds %struct.CallInfo.361* %505, i32 0, i32 7
  %l876 = bitcast %union.anon.360* %u875 to %struct.anon.482*
  %base877 = getelementptr inbounds %struct.anon.482* %l876, i32 0, i32 0
  %506 = load %struct.lua_TValue.349** %base877, align 8
  store %struct.lua_TValue.349* %506, %struct.lua_TValue.349** %base, align 8
  br label %sw.epilog

sw.bb878:                                         ; preds = %if.end
  %507 = load %struct.lua_State.364** %L.addr, align 8
  %508 = load i32* %i, align 4
  %shr879 = lshr i32 %508, 23
  %and880 = and i32 %shr879, 511
  %and881 = and i32 %and880, 256
  %tobool882 = icmp ne i32 %and881, 0
  br i1 %tobool882, label %cond.true883, label %cond.false889

cond.true883:                                     ; preds = %sw.bb878
  %509 = load %struct.lua_TValue.349** %k, align 8
  %510 = load i32* %i, align 4
  %shr884 = lshr i32 %510, 23
  %and885 = and i32 %shr884, 511
  %and886 = and i32 %and885, -257
  %idx.ext887 = sext i32 %and886 to i64
  %add.ptr888 = getelementptr inbounds %struct.lua_TValue.349* %509, i64 %idx.ext887
  br label %cond.end894

cond.false889:                                    ; preds = %sw.bb878
  %511 = load %struct.lua_TValue.349** %base, align 8
  %512 = load i32* %i, align 4
  %shr890 = lshr i32 %512, 23
  %and891 = and i32 %shr890, 511
  %idx.ext892 = sext i32 %and891 to i64
  %add.ptr893 = getelementptr inbounds %struct.lua_TValue.349* %511, i64 %idx.ext892
  br label %cond.end894

cond.end894:                                      ; preds = %cond.false889, %cond.true883
  %cond895 = phi %struct.lua_TValue.349* [ %add.ptr888, %cond.true883 ], [ %add.ptr893, %cond.false889 ]
  %513 = load i32* %i, align 4
  %shr896 = lshr i32 %513, 14
  %and897 = and i32 %shr896, 511
  %and898 = and i32 %and897, 256
  %tobool899 = icmp ne i32 %and898, 0
  br i1 %tobool899, label %cond.true900, label %cond.false906

cond.true900:                                     ; preds = %cond.end894
  %514 = load %struct.lua_TValue.349** %k, align 8
  %515 = load i32* %i, align 4
  %shr901 = lshr i32 %515, 14
  %and902 = and i32 %shr901, 511
  %and903 = and i32 %and902, -257
  %idx.ext904 = sext i32 %and903 to i64
  %add.ptr905 = getelementptr inbounds %struct.lua_TValue.349* %514, i64 %idx.ext904
  br label %cond.end911

cond.false906:                                    ; preds = %cond.end894
  %516 = load %struct.lua_TValue.349** %base, align 8
  %517 = load i32* %i, align 4
  %shr907 = lshr i32 %517, 14
  %and908 = and i32 %shr907, 511
  %idx.ext909 = sext i32 %and908 to i64
  %add.ptr910 = getelementptr inbounds %struct.lua_TValue.349* %516, i64 %idx.ext909
  br label %cond.end911

cond.end911:                                      ; preds = %cond.false906, %cond.true900
  %cond912 = phi %struct.lua_TValue.349* [ %add.ptr905, %cond.true900 ], [ %add.ptr910, %cond.false906 ]
  %call913 = call i32 @luaV_lessthan(%struct.lua_State.364* %507, %struct.lua_TValue.349* %cond895, %struct.lua_TValue.349* %cond912)
  %518 = load i32* %i, align 4
  %shr914 = lshr i32 %518, 6
  %and915 = and i32 %shr914, 255
  %cmp916 = icmp ne i32 %call913, %and915
  br i1 %cmp916, label %if.then918, label %if.else923

if.then918:                                       ; preds = %cond.end911
  %519 = load %struct.CallInfo.361** %ci, align 8
  %u919 = getelementptr inbounds %struct.CallInfo.361* %519, i32 0, i32 7
  %l920 = bitcast %union.anon.360* %u919 to %struct.anon.482*
  %savedpc921 = getelementptr inbounds %struct.anon.482* %l920, i32 0, i32 1
  %520 = load i32** %savedpc921, align 8
  %incdec.ptr922 = getelementptr inbounds i32* %520, i32 1
  store i32* %incdec.ptr922, i32** %savedpc921, align 8
  br label %if.end949

if.else923:                                       ; preds = %cond.end911
  %521 = load %struct.CallInfo.361** %ci, align 8
  %u924 = getelementptr inbounds %struct.CallInfo.361* %521, i32 0, i32 7
  %l925 = bitcast %union.anon.360* %u924 to %struct.anon.482*
  %savedpc926 = getelementptr inbounds %struct.anon.482* %l925, i32 0, i32 1
  %522 = load i32** %savedpc926, align 8
  %523 = load i32* %522, align 4
  store i32 %523, i32* %i, align 4
  %524 = load i32* %i, align 4
  %shr928 = lshr i32 %524, 6
  %and929 = and i32 %shr928, 255
  store i32 %and929, i32* %a927, align 4
  %525 = load i32* %a927, align 4
  %cmp930 = icmp sgt i32 %525, 0
  br i1 %cmp930, label %if.then932, label %if.end939

if.then932:                                       ; preds = %if.else923
  %526 = load %struct.lua_State.364** %L.addr, align 8
  %527 = load %struct.CallInfo.361** %ci, align 8
  %u933 = getelementptr inbounds %struct.CallInfo.361* %527, i32 0, i32 7
  %l934 = bitcast %union.anon.360* %u933 to %struct.anon.482*
  %base935 = getelementptr inbounds %struct.anon.482* %l934, i32 0, i32 0
  %528 = load %struct.lua_TValue.349** %base935, align 8
  %529 = load i32* %a927, align 4
  %idx.ext936 = sext i32 %529 to i64
  %add.ptr937 = getelementptr inbounds %struct.lua_TValue.349* %528, i64 %idx.ext936
  %add.ptr938 = getelementptr inbounds %struct.lua_TValue.349* %add.ptr937, i64 -1
  call void bitcast (void (%struct.lua_State.154*, %struct.lua_TValue.137*)* @luaF_close to void (%struct.lua_State.364*, %struct.lua_TValue.349*)*)(%struct.lua_State.364* %526, %struct.lua_TValue.349* %add.ptr938)
  br label %if.end939

if.end939:                                        ; preds = %if.then932, %if.else923
  %530 = load i32* %i, align 4
  %shr940 = lshr i32 %530, 14
  %and941 = and i32 %shr940, 262143
  %sub942 = sub nsw i32 %and941, 131071
  %add943 = add nsw i32 %sub942, 1
  %531 = load %struct.CallInfo.361** %ci, align 8
  %u944 = getelementptr inbounds %struct.CallInfo.361* %531, i32 0, i32 7
  %l945 = bitcast %union.anon.360* %u944 to %struct.anon.482*
  %savedpc946 = getelementptr inbounds %struct.anon.482* %l945, i32 0, i32 1
  %532 = load i32** %savedpc946, align 8
  %idx.ext947 = sext i32 %add943 to i64
  %add.ptr948 = getelementptr inbounds i32* %532, i64 %idx.ext947
  store i32* %add.ptr948, i32** %savedpc946, align 8
  br label %if.end949

if.end949:                                        ; preds = %if.end939, %if.then918
  %533 = load %struct.CallInfo.361** %ci, align 8
  %u950 = getelementptr inbounds %struct.CallInfo.361* %533, i32 0, i32 7
  %l951 = bitcast %union.anon.360* %u950 to %struct.anon.482*
  %base952 = getelementptr inbounds %struct.anon.482* %l951, i32 0, i32 0
  %534 = load %struct.lua_TValue.349** %base952, align 8
  store %struct.lua_TValue.349* %534, %struct.lua_TValue.349** %base, align 8
  br label %sw.epilog

sw.bb953:                                         ; preds = %if.end
  %535 = load %struct.lua_State.364** %L.addr, align 8
  %536 = load i32* %i, align 4
  %shr954 = lshr i32 %536, 23
  %and955 = and i32 %shr954, 511
  %and956 = and i32 %and955, 256
  %tobool957 = icmp ne i32 %and956, 0
  br i1 %tobool957, label %cond.true958, label %cond.false964

cond.true958:                                     ; preds = %sw.bb953
  %537 = load %struct.lua_TValue.349** %k, align 8
  %538 = load i32* %i, align 4
  %shr959 = lshr i32 %538, 23
  %and960 = and i32 %shr959, 511
  %and961 = and i32 %and960, -257
  %idx.ext962 = sext i32 %and961 to i64
  %add.ptr963 = getelementptr inbounds %struct.lua_TValue.349* %537, i64 %idx.ext962
  br label %cond.end969

cond.false964:                                    ; preds = %sw.bb953
  %539 = load %struct.lua_TValue.349** %base, align 8
  %540 = load i32* %i, align 4
  %shr965 = lshr i32 %540, 23
  %and966 = and i32 %shr965, 511
  %idx.ext967 = sext i32 %and966 to i64
  %add.ptr968 = getelementptr inbounds %struct.lua_TValue.349* %539, i64 %idx.ext967
  br label %cond.end969

cond.end969:                                      ; preds = %cond.false964, %cond.true958
  %cond970 = phi %struct.lua_TValue.349* [ %add.ptr963, %cond.true958 ], [ %add.ptr968, %cond.false964 ]
  %541 = load i32* %i, align 4
  %shr971 = lshr i32 %541, 14
  %and972 = and i32 %shr971, 511
  %and973 = and i32 %and972, 256
  %tobool974 = icmp ne i32 %and973, 0
  br i1 %tobool974, label %cond.true975, label %cond.false981

cond.true975:                                     ; preds = %cond.end969
  %542 = load %struct.lua_TValue.349** %k, align 8
  %543 = load i32* %i, align 4
  %shr976 = lshr i32 %543, 14
  %and977 = and i32 %shr976, 511
  %and978 = and i32 %and977, -257
  %idx.ext979 = sext i32 %and978 to i64
  %add.ptr980 = getelementptr inbounds %struct.lua_TValue.349* %542, i64 %idx.ext979
  br label %cond.end986

cond.false981:                                    ; preds = %cond.end969
  %544 = load %struct.lua_TValue.349** %base, align 8
  %545 = load i32* %i, align 4
  %shr982 = lshr i32 %545, 14
  %and983 = and i32 %shr982, 511
  %idx.ext984 = sext i32 %and983 to i64
  %add.ptr985 = getelementptr inbounds %struct.lua_TValue.349* %544, i64 %idx.ext984
  br label %cond.end986

cond.end986:                                      ; preds = %cond.false981, %cond.true975
  %cond987 = phi %struct.lua_TValue.349* [ %add.ptr980, %cond.true975 ], [ %add.ptr985, %cond.false981 ]
  %call988 = call i32 @luaV_lessequal(%struct.lua_State.364* %535, %struct.lua_TValue.349* %cond970, %struct.lua_TValue.349* %cond987)
  %546 = load i32* %i, align 4
  %shr989 = lshr i32 %546, 6
  %and990 = and i32 %shr989, 255
  %cmp991 = icmp ne i32 %call988, %and990
  br i1 %cmp991, label %if.then993, label %if.else998

if.then993:                                       ; preds = %cond.end986
  %547 = load %struct.CallInfo.361** %ci, align 8
  %u994 = getelementptr inbounds %struct.CallInfo.361* %547, i32 0, i32 7
  %l995 = bitcast %union.anon.360* %u994 to %struct.anon.482*
  %savedpc996 = getelementptr inbounds %struct.anon.482* %l995, i32 0, i32 1
  %548 = load i32** %savedpc996, align 8
  %incdec.ptr997 = getelementptr inbounds i32* %548, i32 1
  store i32* %incdec.ptr997, i32** %savedpc996, align 8
  br label %if.end1024

if.else998:                                       ; preds = %cond.end986
  %549 = load %struct.CallInfo.361** %ci, align 8
  %u999 = getelementptr inbounds %struct.CallInfo.361* %549, i32 0, i32 7
  %l1000 = bitcast %union.anon.360* %u999 to %struct.anon.482*
  %savedpc1001 = getelementptr inbounds %struct.anon.482* %l1000, i32 0, i32 1
  %550 = load i32** %savedpc1001, align 8
  %551 = load i32* %550, align 4
  store i32 %551, i32* %i, align 4
  %552 = load i32* %i, align 4
  %shr1003 = lshr i32 %552, 6
  %and1004 = and i32 %shr1003, 255
  store i32 %and1004, i32* %a1002, align 4
  %553 = load i32* %a1002, align 4
  %cmp1005 = icmp sgt i32 %553, 0
  br i1 %cmp1005, label %if.then1007, label %if.end1014

if.then1007:                                      ; preds = %if.else998
  %554 = load %struct.lua_State.364** %L.addr, align 8
  %555 = load %struct.CallInfo.361** %ci, align 8
  %u1008 = getelementptr inbounds %struct.CallInfo.361* %555, i32 0, i32 7
  %l1009 = bitcast %union.anon.360* %u1008 to %struct.anon.482*
  %base1010 = getelementptr inbounds %struct.anon.482* %l1009, i32 0, i32 0
  %556 = load %struct.lua_TValue.349** %base1010, align 8
  %557 = load i32* %a1002, align 4
  %idx.ext1011 = sext i32 %557 to i64
  %add.ptr1012 = getelementptr inbounds %struct.lua_TValue.349* %556, i64 %idx.ext1011
  %add.ptr1013 = getelementptr inbounds %struct.lua_TValue.349* %add.ptr1012, i64 -1
  call void bitcast (void (%struct.lua_State.154*, %struct.lua_TValue.137*)* @luaF_close to void (%struct.lua_State.364*, %struct.lua_TValue.349*)*)(%struct.lua_State.364* %554, %struct.lua_TValue.349* %add.ptr1013)
  br label %if.end1014

if.end1014:                                       ; preds = %if.then1007, %if.else998
  %558 = load i32* %i, align 4
  %shr1015 = lshr i32 %558, 14
  %and1016 = and i32 %shr1015, 262143
  %sub1017 = sub nsw i32 %and1016, 131071
  %add1018 = add nsw i32 %sub1017, 1
  %559 = load %struct.CallInfo.361** %ci, align 8
  %u1019 = getelementptr inbounds %struct.CallInfo.361* %559, i32 0, i32 7
  %l1020 = bitcast %union.anon.360* %u1019 to %struct.anon.482*
  %savedpc1021 = getelementptr inbounds %struct.anon.482* %l1020, i32 0, i32 1
  %560 = load i32** %savedpc1021, align 8
  %idx.ext1022 = sext i32 %add1018 to i64
  %add.ptr1023 = getelementptr inbounds i32* %560, i64 %idx.ext1022
  store i32* %add.ptr1023, i32** %savedpc1021, align 8
  br label %if.end1024

if.end1024:                                       ; preds = %if.end1014, %if.then993
  %561 = load %struct.CallInfo.361** %ci, align 8
  %u1025 = getelementptr inbounds %struct.CallInfo.361* %561, i32 0, i32 7
  %l1026 = bitcast %union.anon.360* %u1025 to %struct.anon.482*
  %base1027 = getelementptr inbounds %struct.anon.482* %l1026, i32 0, i32 0
  %562 = load %struct.lua_TValue.349** %base1027, align 8
  store %struct.lua_TValue.349* %562, %struct.lua_TValue.349** %base, align 8
  br label %sw.epilog

sw.bb1028:                                        ; preds = %if.end
  %563 = load i32* %i, align 4
  %shr1029 = lshr i32 %563, 14
  %and1030 = and i32 %shr1029, 511
  %tobool1031 = icmp ne i32 %and1030, 0
  br i1 %tobool1031, label %cond.true1032, label %cond.false1045

cond.true1032:                                    ; preds = %sw.bb1028
  %564 = load %struct.lua_TValue.349** %ra, align 8
  %tt_1033 = getelementptr inbounds %struct.lua_TValue.349* %564, i32 0, i32 1
  %565 = load i32* %tt_1033, align 4
  %cmp1034 = icmp eq i32 %565, 0
  br i1 %cmp1034, label %if.then1058, label %lor.lhs.false1036

lor.lhs.false1036:                                ; preds = %cond.true1032
  %566 = load %struct.lua_TValue.349** %ra, align 8
  %tt_1037 = getelementptr inbounds %struct.lua_TValue.349* %566, i32 0, i32 1
  %567 = load i32* %tt_1037, align 4
  %cmp1038 = icmp eq i32 %567, 1
  br i1 %cmp1038, label %land.lhs.true1040, label %if.else1063

land.lhs.true1040:                                ; preds = %lor.lhs.false1036
  %568 = load %struct.lua_TValue.349** %ra, align 8
  %value_1041 = getelementptr inbounds %struct.lua_TValue.349* %568, i32 0, i32 0
  %b1042 = bitcast %union.Value.348* %value_1041 to i32*
  %569 = load i32* %b1042, align 4
  %cmp1043 = icmp eq i32 %569, 0
  br i1 %cmp1043, label %if.then1058, label %if.else1063

cond.false1045:                                   ; preds = %sw.bb1028
  %570 = load %struct.lua_TValue.349** %ra, align 8
  %tt_1046 = getelementptr inbounds %struct.lua_TValue.349* %570, i32 0, i32 1
  %571 = load i32* %tt_1046, align 4
  %cmp1047 = icmp eq i32 %571, 0
  br i1 %cmp1047, label %if.else1063, label %lor.lhs.false1049

lor.lhs.false1049:                                ; preds = %cond.false1045
  %572 = load %struct.lua_TValue.349** %ra, align 8
  %tt_1050 = getelementptr inbounds %struct.lua_TValue.349* %572, i32 0, i32 1
  %573 = load i32* %tt_1050, align 4
  %cmp1051 = icmp eq i32 %573, 1
  br i1 %cmp1051, label %land.lhs.true1053, label %if.then1058

land.lhs.true1053:                                ; preds = %lor.lhs.false1049
  %574 = load %struct.lua_TValue.349** %ra, align 8
  %value_1054 = getelementptr inbounds %struct.lua_TValue.349* %574, i32 0, i32 0
  %b1055 = bitcast %union.Value.348* %value_1054 to i32*
  %575 = load i32* %b1055, align 4
  %cmp1056 = icmp eq i32 %575, 0
  br i1 %cmp1056, label %if.else1063, label %if.then1058

if.then1058:                                      ; preds = %land.lhs.true1053, %lor.lhs.false1049, %land.lhs.true1040, %cond.true1032
  %576 = load %struct.CallInfo.361** %ci, align 8
  %u1059 = getelementptr inbounds %struct.CallInfo.361* %576, i32 0, i32 7
  %l1060 = bitcast %union.anon.360* %u1059 to %struct.anon.482*
  %savedpc1061 = getelementptr inbounds %struct.anon.482* %l1060, i32 0, i32 1
  %577 = load i32** %savedpc1061, align 8
  %incdec.ptr1062 = getelementptr inbounds i32* %577, i32 1
  store i32* %incdec.ptr1062, i32** %savedpc1061, align 8
  br label %if.end1089

if.else1063:                                      ; preds = %land.lhs.true1053, %cond.false1045, %land.lhs.true1040, %lor.lhs.false1036
  %578 = load %struct.CallInfo.361** %ci, align 8
  %u1064 = getelementptr inbounds %struct.CallInfo.361* %578, i32 0, i32 7
  %l1065 = bitcast %union.anon.360* %u1064 to %struct.anon.482*
  %savedpc1066 = getelementptr inbounds %struct.anon.482* %l1065, i32 0, i32 1
  %579 = load i32** %savedpc1066, align 8
  %580 = load i32* %579, align 4
  store i32 %580, i32* %i, align 4
  %581 = load i32* %i, align 4
  %shr1068 = lshr i32 %581, 6
  %and1069 = and i32 %shr1068, 255
  store i32 %and1069, i32* %a1067, align 4
  %582 = load i32* %a1067, align 4
  %cmp1070 = icmp sgt i32 %582, 0
  br i1 %cmp1070, label %if.then1072, label %if.end1079

if.then1072:                                      ; preds = %if.else1063
  %583 = load %struct.lua_State.364** %L.addr, align 8
  %584 = load %struct.CallInfo.361** %ci, align 8
  %u1073 = getelementptr inbounds %struct.CallInfo.361* %584, i32 0, i32 7
  %l1074 = bitcast %union.anon.360* %u1073 to %struct.anon.482*
  %base1075 = getelementptr inbounds %struct.anon.482* %l1074, i32 0, i32 0
  %585 = load %struct.lua_TValue.349** %base1075, align 8
  %586 = load i32* %a1067, align 4
  %idx.ext1076 = sext i32 %586 to i64
  %add.ptr1077 = getelementptr inbounds %struct.lua_TValue.349* %585, i64 %idx.ext1076
  %add.ptr1078 = getelementptr inbounds %struct.lua_TValue.349* %add.ptr1077, i64 -1
  call void bitcast (void (%struct.lua_State.154*, %struct.lua_TValue.137*)* @luaF_close to void (%struct.lua_State.364*, %struct.lua_TValue.349*)*)(%struct.lua_State.364* %583, %struct.lua_TValue.349* %add.ptr1078)
  br label %if.end1079

if.end1079:                                       ; preds = %if.then1072, %if.else1063
  %587 = load i32* %i, align 4
  %shr1080 = lshr i32 %587, 14
  %and1081 = and i32 %shr1080, 262143
  %sub1082 = sub nsw i32 %and1081, 131071
  %add1083 = add nsw i32 %sub1082, 1
  %588 = load %struct.CallInfo.361** %ci, align 8
  %u1084 = getelementptr inbounds %struct.CallInfo.361* %588, i32 0, i32 7
  %l1085 = bitcast %union.anon.360* %u1084 to %struct.anon.482*
  %savedpc1086 = getelementptr inbounds %struct.anon.482* %l1085, i32 0, i32 1
  %589 = load i32** %savedpc1086, align 8
  %idx.ext1087 = sext i32 %add1083 to i64
  %add.ptr1088 = getelementptr inbounds i32* %589, i64 %idx.ext1087
  store i32* %add.ptr1088, i32** %savedpc1086, align 8
  br label %if.end1089

if.end1089:                                       ; preds = %if.end1079, %if.then1058
  br label %sw.epilog

sw.bb1090:                                        ; preds = %if.end
  %590 = load %struct.lua_TValue.349** %base, align 8
  %591 = load i32* %i, align 4
  %shr1092 = lshr i32 %591, 23
  %and1093 = and i32 %shr1092, 511
  %idx.ext1094 = sext i32 %and1093 to i64
  %add.ptr1095 = getelementptr inbounds %struct.lua_TValue.349* %590, i64 %idx.ext1094
  store %struct.lua_TValue.349* %add.ptr1095, %struct.lua_TValue.349** %rb1091, align 8
  %592 = load i32* %i, align 4
  %shr1096 = lshr i32 %592, 14
  %and1097 = and i32 %shr1096, 511
  %tobool1098 = icmp ne i32 %and1097, 0
  br i1 %tobool1098, label %cond.true1099, label %cond.false1112

cond.true1099:                                    ; preds = %sw.bb1090
  %593 = load %struct.lua_TValue.349** %rb1091, align 8
  %tt_1100 = getelementptr inbounds %struct.lua_TValue.349* %593, i32 0, i32 1
  %594 = load i32* %tt_1100, align 4
  %cmp1101 = icmp eq i32 %594, 0
  br i1 %cmp1101, label %if.then1125, label %lor.lhs.false1103

lor.lhs.false1103:                                ; preds = %cond.true1099
  %595 = load %struct.lua_TValue.349** %rb1091, align 8
  %tt_1104 = getelementptr inbounds %struct.lua_TValue.349* %595, i32 0, i32 1
  %596 = load i32* %tt_1104, align 4
  %cmp1105 = icmp eq i32 %596, 1
  br i1 %cmp1105, label %land.lhs.true1107, label %if.else1130

land.lhs.true1107:                                ; preds = %lor.lhs.false1103
  %597 = load %struct.lua_TValue.349** %rb1091, align 8
  %value_1108 = getelementptr inbounds %struct.lua_TValue.349* %597, i32 0, i32 0
  %b1109 = bitcast %union.Value.348* %value_1108 to i32*
  %598 = load i32* %b1109, align 4
  %cmp1110 = icmp eq i32 %598, 0
  br i1 %cmp1110, label %if.then1125, label %if.else1130

cond.false1112:                                   ; preds = %sw.bb1090
  %599 = load %struct.lua_TValue.349** %rb1091, align 8
  %tt_1113 = getelementptr inbounds %struct.lua_TValue.349* %599, i32 0, i32 1
  %600 = load i32* %tt_1113, align 4
  %cmp1114 = icmp eq i32 %600, 0
  br i1 %cmp1114, label %if.else1130, label %lor.lhs.false1116

lor.lhs.false1116:                                ; preds = %cond.false1112
  %601 = load %struct.lua_TValue.349** %rb1091, align 8
  %tt_1117 = getelementptr inbounds %struct.lua_TValue.349* %601, i32 0, i32 1
  %602 = load i32* %tt_1117, align 4
  %cmp1118 = icmp eq i32 %602, 1
  br i1 %cmp1118, label %land.lhs.true1120, label %if.then1125

land.lhs.true1120:                                ; preds = %lor.lhs.false1116
  %603 = load %struct.lua_TValue.349** %rb1091, align 8
  %value_1121 = getelementptr inbounds %struct.lua_TValue.349* %603, i32 0, i32 0
  %b1122 = bitcast %union.Value.348* %value_1121 to i32*
  %604 = load i32* %b1122, align 4
  %cmp1123 = icmp eq i32 %604, 0
  br i1 %cmp1123, label %if.else1130, label %if.then1125

if.then1125:                                      ; preds = %land.lhs.true1120, %lor.lhs.false1116, %land.lhs.true1107, %cond.true1099
  %605 = load %struct.CallInfo.361** %ci, align 8
  %u1126 = getelementptr inbounds %struct.CallInfo.361* %605, i32 0, i32 7
  %l1127 = bitcast %union.anon.360* %u1126 to %struct.anon.482*
  %savedpc1128 = getelementptr inbounds %struct.anon.482* %l1127, i32 0, i32 1
  %606 = load i32** %savedpc1128, align 8
  %incdec.ptr1129 = getelementptr inbounds i32* %606, i32 1
  store i32* %incdec.ptr1129, i32** %savedpc1128, align 8
  br label %if.end1162

if.else1130:                                      ; preds = %land.lhs.true1120, %cond.false1112, %land.lhs.true1107, %lor.lhs.false1103
  %607 = load %struct.lua_TValue.349** %rb1091, align 8
  store %struct.lua_TValue.349* %607, %struct.lua_TValue.349** %io21131, align 8
  %608 = load %struct.lua_TValue.349** %ra, align 8
  store %struct.lua_TValue.349* %608, %struct.lua_TValue.349** %io11132, align 8
  %609 = load %struct.lua_TValue.349** %io11132, align 8
  %value_1133 = getelementptr inbounds %struct.lua_TValue.349* %609, i32 0, i32 0
  %610 = load %struct.lua_TValue.349** %io21131, align 8
  %value_1134 = getelementptr inbounds %struct.lua_TValue.349* %610, i32 0, i32 0
  %611 = bitcast %union.Value.348* %value_1133 to i8*
  %612 = bitcast %union.Value.348* %value_1134 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %611, i8* %612, i64 8, i32 8, i1 false)
  %613 = load %struct.lua_TValue.349** %io21131, align 8
  %tt_1135 = getelementptr inbounds %struct.lua_TValue.349* %613, i32 0, i32 1
  %614 = load i32* %tt_1135, align 4
  %615 = load %struct.lua_TValue.349** %io11132, align 8
  %tt_1136 = getelementptr inbounds %struct.lua_TValue.349* %615, i32 0, i32 1
  store i32 %614, i32* %tt_1136, align 4
  %616 = load %struct.CallInfo.361** %ci, align 8
  %u1137 = getelementptr inbounds %struct.CallInfo.361* %616, i32 0, i32 7
  %l1138 = bitcast %union.anon.360* %u1137 to %struct.anon.482*
  %savedpc1139 = getelementptr inbounds %struct.anon.482* %l1138, i32 0, i32 1
  %617 = load i32** %savedpc1139, align 8
  %618 = load i32* %617, align 4
  store i32 %618, i32* %i, align 4
  %619 = load i32* %i, align 4
  %shr1141 = lshr i32 %619, 6
  %and1142 = and i32 %shr1141, 255
  store i32 %and1142, i32* %a1140, align 4
  %620 = load i32* %a1140, align 4
  %cmp1143 = icmp sgt i32 %620, 0
  br i1 %cmp1143, label %if.then1145, label %if.end1152

if.then1145:                                      ; preds = %if.else1130
  %621 = load %struct.lua_State.364** %L.addr, align 8
  %622 = load %struct.CallInfo.361** %ci, align 8
  %u1146 = getelementptr inbounds %struct.CallInfo.361* %622, i32 0, i32 7
  %l1147 = bitcast %union.anon.360* %u1146 to %struct.anon.482*
  %base1148 = getelementptr inbounds %struct.anon.482* %l1147, i32 0, i32 0
  %623 = load %struct.lua_TValue.349** %base1148, align 8
  %624 = load i32* %a1140, align 4
  %idx.ext1149 = sext i32 %624 to i64
  %add.ptr1150 = getelementptr inbounds %struct.lua_TValue.349* %623, i64 %idx.ext1149
  %add.ptr1151 = getelementptr inbounds %struct.lua_TValue.349* %add.ptr1150, i64 -1
  call void bitcast (void (%struct.lua_State.154*, %struct.lua_TValue.137*)* @luaF_close to void (%struct.lua_State.364*, %struct.lua_TValue.349*)*)(%struct.lua_State.364* %621, %struct.lua_TValue.349* %add.ptr1151)
  br label %if.end1152

if.end1152:                                       ; preds = %if.then1145, %if.else1130
  %625 = load i32* %i, align 4
  %shr1153 = lshr i32 %625, 14
  %and1154 = and i32 %shr1153, 262143
  %sub1155 = sub nsw i32 %and1154, 131071
  %add1156 = add nsw i32 %sub1155, 1
  %626 = load %struct.CallInfo.361** %ci, align 8
  %u1157 = getelementptr inbounds %struct.CallInfo.361* %626, i32 0, i32 7
  %l1158 = bitcast %union.anon.360* %u1157 to %struct.anon.482*
  %savedpc1159 = getelementptr inbounds %struct.anon.482* %l1158, i32 0, i32 1
  %627 = load i32** %savedpc1159, align 8
  %idx.ext1160 = sext i32 %add1156 to i64
  %add.ptr1161 = getelementptr inbounds i32* %627, i64 %idx.ext1160
  store i32* %add.ptr1161, i32** %savedpc1159, align 8
  br label %if.end1162

if.end1162:                                       ; preds = %if.end1152, %if.then1125
  br label %sw.epilog

sw.bb1163:                                        ; preds = %if.end
  %628 = load i32* %i, align 4
  %shr1165 = lshr i32 %628, 23
  %and1166 = and i32 %shr1165, 511
  store i32 %and1166, i32* %b1164, align 4
  %629 = load i32* %i, align 4
  %shr1167 = lshr i32 %629, 14
  %and1168 = and i32 %shr1167, 511
  %sub1169 = sub nsw i32 %and1168, 1
  store i32 %sub1169, i32* %nresults, align 4
  %630 = load i32* %b1164, align 4
  %cmp1170 = icmp ne i32 %630, 0
  br i1 %cmp1170, label %if.then1172, label %if.end1176

if.then1172:                                      ; preds = %sw.bb1163
  %631 = load %struct.lua_TValue.349** %ra, align 8
  %632 = load i32* %b1164, align 4
  %idx.ext1173 = sext i32 %632 to i64
  %add.ptr1174 = getelementptr inbounds %struct.lua_TValue.349* %631, i64 %idx.ext1173
  %633 = load %struct.lua_State.364** %L.addr, align 8
  %top1175 = getelementptr inbounds %struct.lua_State.364* %633, i32 0, i32 4
  store %struct.lua_TValue.349* %add.ptr1174, %struct.lua_TValue.349** %top1175, align 8
  br label %if.end1176

if.end1176:                                       ; preds = %if.then1172, %sw.bb1163
  %634 = load %struct.lua_State.364** %L.addr, align 8
  %635 = load %struct.lua_TValue.349** %ra, align 8
  %636 = load i32* %nresults, align 4
  %call1177 = call i32 bitcast (i32 (%struct.lua_State*, %struct.lua_TValue*, i32)* @luaD_precall to i32 (%struct.lua_State.364*, %struct.lua_TValue.349*, i32)*)(%struct.lua_State.364* %634, %struct.lua_TValue.349* %635, i32 %636)
  %tobool1178 = icmp ne i32 %call1177, 0
  br i1 %tobool1178, label %if.then1179, label %if.else1189

if.then1179:                                      ; preds = %if.end1176
  %637 = load i32* %nresults, align 4
  %cmp1180 = icmp sge i32 %637, 0
  br i1 %cmp1180, label %if.then1182, label %if.end1185

if.then1182:                                      ; preds = %if.then1179
  %638 = load %struct.CallInfo.361** %ci, align 8
  %top1183 = getelementptr inbounds %struct.CallInfo.361* %638, i32 0, i32 1
  %639 = load %struct.lua_TValue.349** %top1183, align 8
  %640 = load %struct.lua_State.364** %L.addr, align 8
  %top1184 = getelementptr inbounds %struct.lua_State.364* %640, i32 0, i32 4
  store %struct.lua_TValue.349* %639, %struct.lua_TValue.349** %top1184, align 8
  br label %if.end1185

if.end1185:                                       ; preds = %if.then1182, %if.then1179
  %641 = load %struct.CallInfo.361** %ci, align 8
  %u1186 = getelementptr inbounds %struct.CallInfo.361* %641, i32 0, i32 7
  %l1187 = bitcast %union.anon.360* %u1186 to %struct.anon.482*
  %base1188 = getelementptr inbounds %struct.anon.482* %l1187, i32 0, i32 0
  %642 = load %struct.lua_TValue.349** %base1188, align 8
  store %struct.lua_TValue.349* %642, %struct.lua_TValue.349** %base, align 8
  br label %if.end1193

if.else1189:                                      ; preds = %if.end1176
  %643 = load %struct.lua_State.364** %L.addr, align 8
  %ci1190 = getelementptr inbounds %struct.lua_State.364* %643, i32 0, i32 6
  %644 = load %struct.CallInfo.361** %ci1190, align 8
  store %struct.CallInfo.361* %644, %struct.CallInfo.361** %ci, align 8
  %645 = load %struct.CallInfo.361** %ci, align 8
  %callstatus = getelementptr inbounds %struct.CallInfo.361* %645, i32 0, i32 5
  %646 = load i8* %callstatus, align 1
  %conv1191 = zext i8 %646 to i32
  %or = or i32 %conv1191, 4
  %conv1192 = trunc i32 %or to i8
  store i8 %conv1192, i8* %callstatus, align 1
  br label %newframe

if.end1193:                                       ; preds = %if.end1185
  br label %sw.epilog

sw.bb1194:                                        ; preds = %if.end
  %647 = load i32* %i, align 4
  %shr1196 = lshr i32 %647, 23
  %and1197 = and i32 %shr1196, 511
  store i32 %and1197, i32* %b1195, align 4
  %648 = load i32* %b1195, align 4
  %cmp1198 = icmp ne i32 %648, 0
  br i1 %cmp1198, label %if.then1200, label %if.end1204

if.then1200:                                      ; preds = %sw.bb1194
  %649 = load %struct.lua_TValue.349** %ra, align 8
  %650 = load i32* %b1195, align 4
  %idx.ext1201 = sext i32 %650 to i64
  %add.ptr1202 = getelementptr inbounds %struct.lua_TValue.349* %649, i64 %idx.ext1201
  %651 = load %struct.lua_State.364** %L.addr, align 8
  %top1203 = getelementptr inbounds %struct.lua_State.364* %651, i32 0, i32 4
  store %struct.lua_TValue.349* %add.ptr1202, %struct.lua_TValue.349** %top1203, align 8
  br label %if.end1204

if.end1204:                                       ; preds = %if.then1200, %sw.bb1194
  %652 = load %struct.lua_State.364** %L.addr, align 8
  %653 = load %struct.lua_TValue.349** %ra, align 8
  %call1205 = call i32 bitcast (i32 (%struct.lua_State*, %struct.lua_TValue*, i32)* @luaD_precall to i32 (%struct.lua_State.364*, %struct.lua_TValue.349*, i32)*)(%struct.lua_State.364* %652, %struct.lua_TValue.349* %653, i32 -1)
  %tobool1206 = icmp ne i32 %call1205, 0
  br i1 %tobool1206, label %if.then1207, label %if.else1211

if.then1207:                                      ; preds = %if.end1204
  %654 = load %struct.CallInfo.361** %ci, align 8
  %u1208 = getelementptr inbounds %struct.CallInfo.361* %654, i32 0, i32 7
  %l1209 = bitcast %union.anon.360* %u1208 to %struct.anon.482*
  %base1210 = getelementptr inbounds %struct.anon.482* %l1209, i32 0, i32 0
  %655 = load %struct.lua_TValue.349** %base1210, align 8
  store %struct.lua_TValue.349* %655, %struct.lua_TValue.349** %base, align 8
  br label %if.end1275

if.else1211:                                      ; preds = %if.end1204
  %656 = load %struct.lua_State.364** %L.addr, align 8
  %ci1212 = getelementptr inbounds %struct.lua_State.364* %656, i32 0, i32 6
  %657 = load %struct.CallInfo.361** %ci1212, align 8
  store %struct.CallInfo.361* %657, %struct.CallInfo.361** %nci, align 8
  %658 = load %struct.CallInfo.361** %nci, align 8
  %previous = getelementptr inbounds %struct.CallInfo.361* %658, i32 0, i32 2
  %659 = load %struct.CallInfo.361** %previous, align 8
  store %struct.CallInfo.361* %659, %struct.CallInfo.361** %oci, align 8
  %660 = load %struct.CallInfo.361** %nci, align 8
  %func1213 = getelementptr inbounds %struct.CallInfo.361* %660, i32 0, i32 0
  %661 = load %struct.lua_TValue.349** %func1213, align 8
  store %struct.lua_TValue.349* %661, %struct.lua_TValue.349** %nfunc, align 8
  %662 = load %struct.CallInfo.361** %oci, align 8
  %func1214 = getelementptr inbounds %struct.CallInfo.361* %662, i32 0, i32 0
  %663 = load %struct.lua_TValue.349** %func1214, align 8
  store %struct.lua_TValue.349* %663, %struct.lua_TValue.349** %ofunc, align 8
  %664 = load %struct.CallInfo.361** %nci, align 8
  %u1215 = getelementptr inbounds %struct.CallInfo.361* %664, i32 0, i32 7
  %l1216 = bitcast %union.anon.360* %u1215 to %struct.anon.482*
  %base1217 = getelementptr inbounds %struct.anon.482* %l1216, i32 0, i32 0
  %665 = load %struct.lua_TValue.349** %base1217, align 8
  %666 = load %struct.lua_TValue.349** %nfunc, align 8
  %value_1218 = getelementptr inbounds %struct.lua_TValue.349* %666, i32 0, i32 0
  %gc1219 = bitcast %union.Value.348* %value_1218 to %union.GCObject.365**
  %667 = load %union.GCObject.365** %gc1219, align 8
  %cl1220 = bitcast %union.GCObject.365* %667 to %union.Closure.475*
  %l1221 = bitcast %union.Closure.475* %cl1220 to %struct.LClosure.483*
  %p1222 = getelementptr inbounds %struct.LClosure.483* %l1221, i32 0, i32 5
  %668 = load %struct.Proto.478** %p1222, align 8
  %numparams = getelementptr inbounds %struct.Proto.478* %668, i32 0, i32 20
  %669 = load i8* %numparams, align 1
  %conv1223 = zext i8 %669 to i32
  %idx.ext1224 = sext i32 %conv1223 to i64
  %add.ptr1225 = getelementptr inbounds %struct.lua_TValue.349* %665, i64 %idx.ext1224
  store %struct.lua_TValue.349* %add.ptr1225, %struct.lua_TValue.349** %lim, align 8
  %670 = load %struct.LClosure.483** %cl, align 8
  %p1226 = getelementptr inbounds %struct.LClosure.483* %670, i32 0, i32 5
  %671 = load %struct.Proto.478** %p1226, align 8
  %sizep = getelementptr inbounds %struct.Proto.478* %671, i32 0, i32 15
  %672 = load i32* %sizep, align 4
  %cmp1227 = icmp sgt i32 %672, 0
  br i1 %cmp1227, label %if.then1229, label %if.end1233

if.then1229:                                      ; preds = %if.else1211
  %673 = load %struct.lua_State.364** %L.addr, align 8
  %674 = load %struct.CallInfo.361** %oci, align 8
  %u1230 = getelementptr inbounds %struct.CallInfo.361* %674, i32 0, i32 7
  %l1231 = bitcast %union.anon.360* %u1230 to %struct.anon.482*
  %base1232 = getelementptr inbounds %struct.anon.482* %l1231, i32 0, i32 0
  %675 = load %struct.lua_TValue.349** %base1232, align 8
  call void bitcast (void (%struct.lua_State.154*, %struct.lua_TValue.137*)* @luaF_close to void (%struct.lua_State.364*, %struct.lua_TValue.349*)*)(%struct.lua_State.364* %673, %struct.lua_TValue.349* %675)
  br label %if.end1233

if.end1233:                                       ; preds = %if.then1229, %if.else1211
  store i32 0, i32* %aux, align 4
  br label %for.cond1234

for.cond1234:                                     ; preds = %for.inc, %if.end1233
  %676 = load %struct.lua_TValue.349** %nfunc, align 8
  %677 = load i32* %aux, align 4
  %idx.ext1235 = sext i32 %677 to i64
  %add.ptr1236 = getelementptr inbounds %struct.lua_TValue.349* %676, i64 %idx.ext1235
  %678 = load %struct.lua_TValue.349** %lim, align 8
  %cmp1237 = icmp ult %struct.lua_TValue.349* %add.ptr1236, %678
  br i1 %cmp1237, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond1234
  %679 = load %struct.lua_TValue.349** %nfunc, align 8
  %680 = load i32* %aux, align 4
  %idx.ext1240 = sext i32 %680 to i64
  %add.ptr1241 = getelementptr inbounds %struct.lua_TValue.349* %679, i64 %idx.ext1240
  store %struct.lua_TValue.349* %add.ptr1241, %struct.lua_TValue.349** %io21239, align 8
  %681 = load %struct.lua_TValue.349** %ofunc, align 8
  %682 = load i32* %aux, align 4
  %idx.ext1243 = sext i32 %682 to i64
  %add.ptr1244 = getelementptr inbounds %struct.lua_TValue.349* %681, i64 %idx.ext1243
  store %struct.lua_TValue.349* %add.ptr1244, %struct.lua_TValue.349** %io11242, align 8
  %683 = load %struct.lua_TValue.349** %io11242, align 8
  %value_1245 = getelementptr inbounds %struct.lua_TValue.349* %683, i32 0, i32 0
  %684 = load %struct.lua_TValue.349** %io21239, align 8
  %value_1246 = getelementptr inbounds %struct.lua_TValue.349* %684, i32 0, i32 0
  %685 = bitcast %union.Value.348* %value_1245 to i8*
  %686 = bitcast %union.Value.348* %value_1246 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %685, i8* %686, i64 8, i32 8, i1 false)
  %687 = load %struct.lua_TValue.349** %io21239, align 8
  %tt_1247 = getelementptr inbounds %struct.lua_TValue.349* %687, i32 0, i32 1
  %688 = load i32* %tt_1247, align 4
  %689 = load %struct.lua_TValue.349** %io11242, align 8
  %tt_1248 = getelementptr inbounds %struct.lua_TValue.349* %689, i32 0, i32 1
  store i32 %688, i32* %tt_1248, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %690 = load i32* %aux, align 4
  %inc = add nsw i32 %690, 1
  store i32 %inc, i32* %aux, align 4
  br label %for.cond1234

for.end:                                          ; preds = %for.cond1234
  %691 = load %struct.lua_TValue.349** %ofunc, align 8
  %692 = load %struct.CallInfo.361** %nci, align 8
  %u1249 = getelementptr inbounds %struct.CallInfo.361* %692, i32 0, i32 7
  %l1250 = bitcast %union.anon.360* %u1249 to %struct.anon.482*
  %base1251 = getelementptr inbounds %struct.anon.482* %l1250, i32 0, i32 0
  %693 = load %struct.lua_TValue.349** %base1251, align 8
  %694 = load %struct.lua_TValue.349** %nfunc, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.lua_TValue.349* %693 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.lua_TValue.349* %694 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 16
  %add.ptr1252 = getelementptr inbounds %struct.lua_TValue.349* %691, i64 %sub.ptr.div
  %695 = load %struct.CallInfo.361** %oci, align 8
  %u1253 = getelementptr inbounds %struct.CallInfo.361* %695, i32 0, i32 7
  %l1254 = bitcast %union.anon.360* %u1253 to %struct.anon.482*
  %base1255 = getelementptr inbounds %struct.anon.482* %l1254, i32 0, i32 0
  store %struct.lua_TValue.349* %add.ptr1252, %struct.lua_TValue.349** %base1255, align 8
  %696 = load %struct.lua_TValue.349** %ofunc, align 8
  %697 = load %struct.lua_State.364** %L.addr, align 8
  %top1256 = getelementptr inbounds %struct.lua_State.364* %697, i32 0, i32 4
  %698 = load %struct.lua_TValue.349** %top1256, align 8
  %699 = load %struct.lua_TValue.349** %nfunc, align 8
  %sub.ptr.lhs.cast1257 = ptrtoint %struct.lua_TValue.349* %698 to i64
  %sub.ptr.rhs.cast1258 = ptrtoint %struct.lua_TValue.349* %699 to i64
  %sub.ptr.sub1259 = sub i64 %sub.ptr.lhs.cast1257, %sub.ptr.rhs.cast1258
  %sub.ptr.div1260 = sdiv exact i64 %sub.ptr.sub1259, 16
  %add.ptr1261 = getelementptr inbounds %struct.lua_TValue.349* %696, i64 %sub.ptr.div1260
  %700 = load %struct.lua_State.364** %L.addr, align 8
  %top1262 = getelementptr inbounds %struct.lua_State.364* %700, i32 0, i32 4
  store %struct.lua_TValue.349* %add.ptr1261, %struct.lua_TValue.349** %top1262, align 8
  %701 = load %struct.CallInfo.361** %oci, align 8
  %top1263 = getelementptr inbounds %struct.CallInfo.361* %701, i32 0, i32 1
  store %struct.lua_TValue.349* %add.ptr1261, %struct.lua_TValue.349** %top1263, align 8
  %702 = load %struct.CallInfo.361** %nci, align 8
  %u1264 = getelementptr inbounds %struct.CallInfo.361* %702, i32 0, i32 7
  %l1265 = bitcast %union.anon.360* %u1264 to %struct.anon.482*
  %savedpc1266 = getelementptr inbounds %struct.anon.482* %l1265, i32 0, i32 1
  %703 = load i32** %savedpc1266, align 8
  %704 = load %struct.CallInfo.361** %oci, align 8
  %u1267 = getelementptr inbounds %struct.CallInfo.361* %704, i32 0, i32 7
  %l1268 = bitcast %union.anon.360* %u1267 to %struct.anon.482*
  %savedpc1269 = getelementptr inbounds %struct.anon.482* %l1268, i32 0, i32 1
  store i32* %703, i32** %savedpc1269, align 8
  %705 = load %struct.CallInfo.361** %oci, align 8
  %callstatus1270 = getelementptr inbounds %struct.CallInfo.361* %705, i32 0, i32 5
  %706 = load i8* %callstatus1270, align 1
  %conv1271 = zext i8 %706 to i32
  %or1272 = or i32 %conv1271, 64
  %conv1273 = trunc i32 %or1272 to i8
  store i8 %conv1273, i8* %callstatus1270, align 1
  %707 = load %struct.CallInfo.361** %oci, align 8
  %708 = load %struct.lua_State.364** %L.addr, align 8
  %ci1274 = getelementptr inbounds %struct.lua_State.364* %708, i32 0, i32 6
  store %struct.CallInfo.361* %707, %struct.CallInfo.361** %ci1274, align 8
  store %struct.CallInfo.361* %707, %struct.CallInfo.361** %ci, align 8
  br label %newframe

if.end1275:                                       ; preds = %if.then1207
  br label %sw.epilog

sw.bb1276:                                        ; preds = %if.end
  %709 = load i32* %i, align 4
  %shr1278 = lshr i32 %709, 23
  %and1279 = and i32 %shr1278, 511
  store i32 %and1279, i32* %b1277, align 4
  %710 = load i32* %b1277, align 4
  %cmp1280 = icmp ne i32 %710, 0
  br i1 %cmp1280, label %if.then1282, label %if.end1287

if.then1282:                                      ; preds = %sw.bb1276
  %711 = load %struct.lua_TValue.349** %ra, align 8
  %712 = load i32* %b1277, align 4
  %idx.ext1283 = sext i32 %712 to i64
  %add.ptr1284 = getelementptr inbounds %struct.lua_TValue.349* %711, i64 %idx.ext1283
  %add.ptr1285 = getelementptr inbounds %struct.lua_TValue.349* %add.ptr1284, i64 -1
  %713 = load %struct.lua_State.364** %L.addr, align 8
  %top1286 = getelementptr inbounds %struct.lua_State.364* %713, i32 0, i32 4
  store %struct.lua_TValue.349* %add.ptr1285, %struct.lua_TValue.349** %top1286, align 8
  br label %if.end1287

if.end1287:                                       ; preds = %if.then1282, %sw.bb1276
  %714 = load %struct.LClosure.483** %cl, align 8
  %p1288 = getelementptr inbounds %struct.LClosure.483* %714, i32 0, i32 5
  %715 = load %struct.Proto.478** %p1288, align 8
  %sizep1289 = getelementptr inbounds %struct.Proto.478* %715, i32 0, i32 15
  %716 = load i32* %sizep1289, align 4
  %cmp1290 = icmp sgt i32 %716, 0
  br i1 %cmp1290, label %if.then1292, label %if.end1293

if.then1292:                                      ; preds = %if.end1287
  %717 = load %struct.lua_State.364** %L.addr, align 8
  %718 = load %struct.lua_TValue.349** %base, align 8
  call void bitcast (void (%struct.lua_State.154*, %struct.lua_TValue.137*)* @luaF_close to void (%struct.lua_State.364*, %struct.lua_TValue.349*)*)(%struct.lua_State.364* %717, %struct.lua_TValue.349* %718)
  br label %if.end1293

if.end1293:                                       ; preds = %if.then1292, %if.end1287
  %719 = load %struct.lua_State.364** %L.addr, align 8
  %720 = load %struct.lua_TValue.349** %ra, align 8
  %call1294 = call i32 bitcast (i32 (%struct.lua_State*, %struct.lua_TValue*)* @luaD_poscall to i32 (%struct.lua_State.364*, %struct.lua_TValue.349*)*)(%struct.lua_State.364* %719, %struct.lua_TValue.349* %720)
  store i32 %call1294, i32* %b1277, align 4
  %721 = load %struct.CallInfo.361** %ci, align 8
  %callstatus1295 = getelementptr inbounds %struct.CallInfo.361* %721, i32 0, i32 5
  %722 = load i8* %callstatus1295, align 1
  %conv1296 = zext i8 %722 to i32
  %and1297 = and i32 %conv1296, 4
  %tobool1298 = icmp ne i32 %and1297, 0
  br i1 %tobool1298, label %if.else1300, label %if.then1299

if.then1299:                                      ; preds = %if.end1293
  ret void

if.else1300:                                      ; preds = %if.end1293
  %723 = load %struct.lua_State.364** %L.addr, align 8
  %ci1301 = getelementptr inbounds %struct.lua_State.364* %723, i32 0, i32 6
  %724 = load %struct.CallInfo.361** %ci1301, align 8
  store %struct.CallInfo.361* %724, %struct.CallInfo.361** %ci, align 8
  %725 = load i32* %b1277, align 4
  %tobool1302 = icmp ne i32 %725, 0
  br i1 %tobool1302, label %if.then1303, label %if.end1306

if.then1303:                                      ; preds = %if.else1300
  %726 = load %struct.CallInfo.361** %ci, align 8
  %top1304 = getelementptr inbounds %struct.CallInfo.361* %726, i32 0, i32 1
  %727 = load %struct.lua_TValue.349** %top1304, align 8
  %728 = load %struct.lua_State.364** %L.addr, align 8
  %top1305 = getelementptr inbounds %struct.lua_State.364* %728, i32 0, i32 4
  store %struct.lua_TValue.349* %727, %struct.lua_TValue.349** %top1305, align 8
  br label %if.end1306

if.end1306:                                       ; preds = %if.then1303, %if.else1300
  br label %newframe

sw.bb1307:                                        ; preds = %if.end
  %729 = load %struct.lua_TValue.349** %ra, align 8
  %add.ptr1308 = getelementptr inbounds %struct.lua_TValue.349* %729, i64 2
  %value_1309 = getelementptr inbounds %struct.lua_TValue.349* %add.ptr1308, i32 0, i32 0
  %n1310 = bitcast %union.Value.348* %value_1309 to double*
  %730 = load double* %n1310, align 8
  store double %730, double* %step, align 8
  %731 = load %struct.lua_TValue.349** %ra, align 8
  %value_1311 = getelementptr inbounds %struct.lua_TValue.349* %731, i32 0, i32 0
  %n1312 = bitcast %union.Value.348* %value_1311 to double*
  %732 = load double* %n1312, align 8
  %733 = load double* %step, align 8
  %add1313 = fadd double %732, %733
  store double %add1313, double* %idx, align 8
  %734 = load %struct.lua_TValue.349** %ra, align 8
  %add.ptr1314 = getelementptr inbounds %struct.lua_TValue.349* %734, i64 1
  %value_1315 = getelementptr inbounds %struct.lua_TValue.349* %add.ptr1314, i32 0, i32 0
  %n1316 = bitcast %union.Value.348* %value_1315 to double*
  %735 = load double* %n1316, align 8
  store double %735, double* %limit, align 8
  %736 = load double* %step, align 8
  %cmp1317 = fcmp olt double 0.000000e+00, %736
  br i1 %cmp1317, label %cond.true1319, label %cond.false1322

cond.true1319:                                    ; preds = %sw.bb1307
  %737 = load double* %idx, align 8
  %738 = load double* %limit, align 8
  %cmp1320 = fcmp ole double %737, %738
  br i1 %cmp1320, label %if.then1325, label %if.end1343

cond.false1322:                                   ; preds = %sw.bb1307
  %739 = load double* %limit, align 8
  %740 = load double* %idx, align 8
  %cmp1323 = fcmp ole double %739, %740
  br i1 %cmp1323, label %if.then1325, label %if.end1343

if.then1325:                                      ; preds = %cond.false1322, %cond.true1319
  %741 = load i32* %i, align 4
  %shr1326 = lshr i32 %741, 14
  %and1327 = and i32 %shr1326, 262143
  %sub1328 = sub nsw i32 %and1327, 131071
  %742 = load %struct.CallInfo.361** %ci, align 8
  %u1329 = getelementptr inbounds %struct.CallInfo.361* %742, i32 0, i32 7
  %l1330 = bitcast %union.anon.360* %u1329 to %struct.anon.482*
  %savedpc1331 = getelementptr inbounds %struct.anon.482* %l1330, i32 0, i32 1
  %743 = load i32** %savedpc1331, align 8
  %idx.ext1332 = sext i32 %sub1328 to i64
  %add.ptr1333 = getelementptr inbounds i32* %743, i64 %idx.ext1332
  store i32* %add.ptr1333, i32** %savedpc1331, align 8
  %744 = load %struct.lua_TValue.349** %ra, align 8
  store %struct.lua_TValue.349* %744, %struct.lua_TValue.349** %io1334, align 8
  %745 = load double* %idx, align 8
  %746 = load %struct.lua_TValue.349** %io1334, align 8
  %value_1335 = getelementptr inbounds %struct.lua_TValue.349* %746, i32 0, i32 0
  %n1336 = bitcast %union.Value.348* %value_1335 to double*
  store double %745, double* %n1336, align 8
  %747 = load %struct.lua_TValue.349** %io1334, align 8
  %tt_1337 = getelementptr inbounds %struct.lua_TValue.349* %747, i32 0, i32 1
  store i32 3, i32* %tt_1337, align 4
  %748 = load %struct.lua_TValue.349** %ra, align 8
  %add.ptr1339 = getelementptr inbounds %struct.lua_TValue.349* %748, i64 3
  store %struct.lua_TValue.349* %add.ptr1339, %struct.lua_TValue.349** %io1338, align 8
  %749 = load double* %idx, align 8
  %750 = load %struct.lua_TValue.349** %io1338, align 8
  %value_1340 = getelementptr inbounds %struct.lua_TValue.349* %750, i32 0, i32 0
  %n1341 = bitcast %union.Value.348* %value_1340 to double*
  store double %749, double* %n1341, align 8
  %751 = load %struct.lua_TValue.349** %io1338, align 8
  %tt_1342 = getelementptr inbounds %struct.lua_TValue.349* %751, i32 0, i32 1
  store i32 3, i32* %tt_1342, align 4
  br label %if.end1343

if.end1343:                                       ; preds = %if.then1325, %cond.false1322, %cond.true1319
  br label %sw.epilog

sw.bb1344:                                        ; preds = %if.end
  %752 = load %struct.lua_TValue.349** %ra, align 8
  store %struct.lua_TValue.349* %752, %struct.lua_TValue.349** %init, align 8
  %753 = load %struct.lua_TValue.349** %ra, align 8
  %add.ptr1345 = getelementptr inbounds %struct.lua_TValue.349* %753, i64 1
  store %struct.lua_TValue.349* %add.ptr1345, %struct.lua_TValue.349** %plimit, align 8
  %754 = load %struct.lua_TValue.349** %ra, align 8
  %add.ptr1346 = getelementptr inbounds %struct.lua_TValue.349* %754, i64 2
  store %struct.lua_TValue.349* %add.ptr1346, %struct.lua_TValue.349** %pstep, align 8
  %755 = load %struct.lua_TValue.349** %init, align 8
  %tt_1347 = getelementptr inbounds %struct.lua_TValue.349* %755, i32 0, i32 1
  %756 = load i32* %tt_1347, align 4
  %cmp1348 = icmp eq i32 %756, 3
  br i1 %cmp1348, label %if.else1355, label %lor.lhs.false1350

lor.lhs.false1350:                                ; preds = %sw.bb1344
  %757 = load %struct.lua_TValue.349** %init, align 8
  %758 = load %struct.lua_TValue.349** %ra, align 8
  %call1351 = call %struct.lua_TValue.349* @luaV_tonumber(%struct.lua_TValue.349* %757, %struct.lua_TValue.349* %758)
  store %struct.lua_TValue.349* %call1351, %struct.lua_TValue.349** %init, align 8
  %cmp1352 = icmp ne %struct.lua_TValue.349* %call1351, null
  br i1 %cmp1352, label %if.else1355, label %if.then1354

if.then1354:                                      ; preds = %lor.lhs.false1350
  %759 = load %struct.lua_State.364** %L.addr, align 8
  call void (%struct.lua_State.364*, i8*, ...)* bitcast (void (%struct.lua_State*, i8*, ...)* @luaG_runerror to void (%struct.lua_State.364*, i8*, ...)*)(%struct.lua_State.364* %759, i8* getelementptr inbounds ([37 x i8]* @.str6832, i32 0, i32 0)) #9
  unreachable

if.else1355:                                      ; preds = %lor.lhs.false1350, %sw.bb1344
  %760 = load %struct.lua_TValue.349** %plimit, align 8
  %tt_1356 = getelementptr inbounds %struct.lua_TValue.349* %760, i32 0, i32 1
  %761 = load i32* %tt_1356, align 4
  %cmp1357 = icmp eq i32 %761, 3
  br i1 %cmp1357, label %if.else1365, label %lor.lhs.false1359

lor.lhs.false1359:                                ; preds = %if.else1355
  %762 = load %struct.lua_TValue.349** %plimit, align 8
  %763 = load %struct.lua_TValue.349** %ra, align 8
  %add.ptr1360 = getelementptr inbounds %struct.lua_TValue.349* %763, i64 1
  %call1361 = call %struct.lua_TValue.349* @luaV_tonumber(%struct.lua_TValue.349* %762, %struct.lua_TValue.349* %add.ptr1360)
  store %struct.lua_TValue.349* %call1361, %struct.lua_TValue.349** %plimit, align 8
  %cmp1362 = icmp ne %struct.lua_TValue.349* %call1361, null
  br i1 %cmp1362, label %if.else1365, label %if.then1364

if.then1364:                                      ; preds = %lor.lhs.false1359
  %764 = load %struct.lua_State.364** %L.addr, align 8
  call void (%struct.lua_State.364*, i8*, ...)* bitcast (void (%struct.lua_State*, i8*, ...)* @luaG_runerror to void (%struct.lua_State.364*, i8*, ...)*)(%struct.lua_State.364* %764, i8* getelementptr inbounds ([29 x i8]* @.str7833, i32 0, i32 0)) #9
  unreachable

if.else1365:                                      ; preds = %lor.lhs.false1359, %if.else1355
  %765 = load %struct.lua_TValue.349** %pstep, align 8
  %tt_1366 = getelementptr inbounds %struct.lua_TValue.349* %765, i32 0, i32 1
  %766 = load i32* %tt_1366, align 4
  %cmp1367 = icmp eq i32 %766, 3
  br i1 %cmp1367, label %if.end1375, label %lor.lhs.false1369

lor.lhs.false1369:                                ; preds = %if.else1365
  %767 = load %struct.lua_TValue.349** %pstep, align 8
  %768 = load %struct.lua_TValue.349** %ra, align 8
  %add.ptr1370 = getelementptr inbounds %struct.lua_TValue.349* %768, i64 2
  %call1371 = call %struct.lua_TValue.349* @luaV_tonumber(%struct.lua_TValue.349* %767, %struct.lua_TValue.349* %add.ptr1370)
  store %struct.lua_TValue.349* %call1371, %struct.lua_TValue.349** %pstep, align 8
  %cmp1372 = icmp ne %struct.lua_TValue.349* %call1371, null
  br i1 %cmp1372, label %if.end1375, label %if.then1374

if.then1374:                                      ; preds = %lor.lhs.false1369
  %769 = load %struct.lua_State.364** %L.addr, align 8
  call void (%struct.lua_State.364*, i8*, ...)* bitcast (void (%struct.lua_State*, i8*, ...)* @luaG_runerror to void (%struct.lua_State.364*, i8*, ...)*)(%struct.lua_State.364* %769, i8* getelementptr inbounds ([28 x i8]* @.str8834, i32 0, i32 0)) #9
  unreachable

if.end1375:                                       ; preds = %lor.lhs.false1369, %if.else1365
  br label %if.end1376

if.end1376:                                       ; preds = %if.end1375
  br label %if.end1377

if.end1377:                                       ; preds = %if.end1376
  %770 = load %struct.lua_TValue.349** %ra, align 8
  store %struct.lua_TValue.349* %770, %struct.lua_TValue.349** %io1378, align 8
  %771 = load %struct.lua_TValue.349** %ra, align 8
  %value_1379 = getelementptr inbounds %struct.lua_TValue.349* %771, i32 0, i32 0
  %n1380 = bitcast %union.Value.348* %value_1379 to double*
  %772 = load double* %n1380, align 8
  %773 = load %struct.lua_TValue.349** %pstep, align 8
  %value_1381 = getelementptr inbounds %struct.lua_TValue.349* %773, i32 0, i32 0
  %n1382 = bitcast %union.Value.348* %value_1381 to double*
  %774 = load double* %n1382, align 8
  %sub1383 = fsub double %772, %774
  %775 = load %struct.lua_TValue.349** %io1378, align 8
  %value_1384 = getelementptr inbounds %struct.lua_TValue.349* %775, i32 0, i32 0
  %n1385 = bitcast %union.Value.348* %value_1384 to double*
  store double %sub1383, double* %n1385, align 8
  %776 = load %struct.lua_TValue.349** %io1378, align 8
  %tt_1386 = getelementptr inbounds %struct.lua_TValue.349* %776, i32 0, i32 1
  store i32 3, i32* %tt_1386, align 4
  %777 = load i32* %i, align 4
  %shr1387 = lshr i32 %777, 14
  %and1388 = and i32 %shr1387, 262143
  %sub1389 = sub nsw i32 %and1388, 131071
  %778 = load %struct.CallInfo.361** %ci, align 8
  %u1390 = getelementptr inbounds %struct.CallInfo.361* %778, i32 0, i32 7
  %l1391 = bitcast %union.anon.360* %u1390 to %struct.anon.482*
  %savedpc1392 = getelementptr inbounds %struct.anon.482* %l1391, i32 0, i32 1
  %779 = load i32** %savedpc1392, align 8
  %idx.ext1393 = sext i32 %sub1389 to i64
  %add.ptr1394 = getelementptr inbounds i32* %779, i64 %idx.ext1393
  store i32* %add.ptr1394, i32** %savedpc1392, align 8
  br label %sw.epilog

sw.bb1395:                                        ; preds = %if.end
  %780 = load %struct.lua_TValue.349** %ra, align 8
  %add.ptr1396 = getelementptr inbounds %struct.lua_TValue.349* %780, i64 3
  store %struct.lua_TValue.349* %add.ptr1396, %struct.lua_TValue.349** %cb, align 8
  %781 = load %struct.lua_TValue.349** %ra, align 8
  %add.ptr1398 = getelementptr inbounds %struct.lua_TValue.349* %781, i64 2
  store %struct.lua_TValue.349* %add.ptr1398, %struct.lua_TValue.349** %io21397, align 8
  %782 = load %struct.lua_TValue.349** %cb, align 8
  %add.ptr1400 = getelementptr inbounds %struct.lua_TValue.349* %782, i64 2
  store %struct.lua_TValue.349* %add.ptr1400, %struct.lua_TValue.349** %io11399, align 8
  %783 = load %struct.lua_TValue.349** %io11399, align 8
  %value_1401 = getelementptr inbounds %struct.lua_TValue.349* %783, i32 0, i32 0
  %784 = load %struct.lua_TValue.349** %io21397, align 8
  %value_1402 = getelementptr inbounds %struct.lua_TValue.349* %784, i32 0, i32 0
  %785 = bitcast %union.Value.348* %value_1401 to i8*
  %786 = bitcast %union.Value.348* %value_1402 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %785, i8* %786, i64 8, i32 8, i1 false)
  %787 = load %struct.lua_TValue.349** %io21397, align 8
  %tt_1403 = getelementptr inbounds %struct.lua_TValue.349* %787, i32 0, i32 1
  %788 = load i32* %tt_1403, align 4
  %789 = load %struct.lua_TValue.349** %io11399, align 8
  %tt_1404 = getelementptr inbounds %struct.lua_TValue.349* %789, i32 0, i32 1
  store i32 %788, i32* %tt_1404, align 4
  %790 = load %struct.lua_TValue.349** %ra, align 8
  %add.ptr1406 = getelementptr inbounds %struct.lua_TValue.349* %790, i64 1
  store %struct.lua_TValue.349* %add.ptr1406, %struct.lua_TValue.349** %io21405, align 8
  %791 = load %struct.lua_TValue.349** %cb, align 8
  %add.ptr1408 = getelementptr inbounds %struct.lua_TValue.349* %791, i64 1
  store %struct.lua_TValue.349* %add.ptr1408, %struct.lua_TValue.349** %io11407, align 8
  %792 = load %struct.lua_TValue.349** %io11407, align 8
  %value_1409 = getelementptr inbounds %struct.lua_TValue.349* %792, i32 0, i32 0
  %793 = load %struct.lua_TValue.349** %io21405, align 8
  %value_1410 = getelementptr inbounds %struct.lua_TValue.349* %793, i32 0, i32 0
  %794 = bitcast %union.Value.348* %value_1409 to i8*
  %795 = bitcast %union.Value.348* %value_1410 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %794, i8* %795, i64 8, i32 8, i1 false)
  %796 = load %struct.lua_TValue.349** %io21405, align 8
  %tt_1411 = getelementptr inbounds %struct.lua_TValue.349* %796, i32 0, i32 1
  %797 = load i32* %tt_1411, align 4
  %798 = load %struct.lua_TValue.349** %io11407, align 8
  %tt_1412 = getelementptr inbounds %struct.lua_TValue.349* %798, i32 0, i32 1
  store i32 %797, i32* %tt_1412, align 4
  %799 = load %struct.lua_TValue.349** %ra, align 8
  store %struct.lua_TValue.349* %799, %struct.lua_TValue.349** %io21413, align 8
  %800 = load %struct.lua_TValue.349** %cb, align 8
  store %struct.lua_TValue.349* %800, %struct.lua_TValue.349** %io11414, align 8
  %801 = load %struct.lua_TValue.349** %io11414, align 8
  %value_1415 = getelementptr inbounds %struct.lua_TValue.349* %801, i32 0, i32 0
  %802 = load %struct.lua_TValue.349** %io21413, align 8
  %value_1416 = getelementptr inbounds %struct.lua_TValue.349* %802, i32 0, i32 0
  %803 = bitcast %union.Value.348* %value_1415 to i8*
  %804 = bitcast %union.Value.348* %value_1416 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %803, i8* %804, i64 8, i32 8, i1 false)
  %805 = load %struct.lua_TValue.349** %io21413, align 8
  %tt_1417 = getelementptr inbounds %struct.lua_TValue.349* %805, i32 0, i32 1
  %806 = load i32* %tt_1417, align 4
  %807 = load %struct.lua_TValue.349** %io11414, align 8
  %tt_1418 = getelementptr inbounds %struct.lua_TValue.349* %807, i32 0, i32 1
  store i32 %806, i32* %tt_1418, align 4
  %808 = load %struct.lua_TValue.349** %cb, align 8
  %add.ptr1419 = getelementptr inbounds %struct.lua_TValue.349* %808, i64 3
  %809 = load %struct.lua_State.364** %L.addr, align 8
  %top1420 = getelementptr inbounds %struct.lua_State.364* %809, i32 0, i32 4
  store %struct.lua_TValue.349* %add.ptr1419, %struct.lua_TValue.349** %top1420, align 8
  %810 = load %struct.lua_State.364** %L.addr, align 8
  %811 = load %struct.lua_TValue.349** %cb, align 8
  %812 = load i32* %i, align 4
  %shr1421 = lshr i32 %812, 14
  %and1422 = and i32 %shr1421, 511
  call void bitcast (void (%struct.lua_State*, %struct.lua_TValue*, i32, i32)* @luaD_call to void (%struct.lua_State.364*, %struct.lua_TValue.349*, i32, i32)*)(%struct.lua_State.364* %810, %struct.lua_TValue.349* %811, i32 %and1422, i32 1)
  %813 = load %struct.CallInfo.361** %ci, align 8
  %u1423 = getelementptr inbounds %struct.CallInfo.361* %813, i32 0, i32 7
  %l1424 = bitcast %union.anon.360* %u1423 to %struct.anon.482*
  %base1425 = getelementptr inbounds %struct.anon.482* %l1424, i32 0, i32 0
  %814 = load %struct.lua_TValue.349** %base1425, align 8
  store %struct.lua_TValue.349* %814, %struct.lua_TValue.349** %base, align 8
  %815 = load %struct.CallInfo.361** %ci, align 8
  %top1426 = getelementptr inbounds %struct.CallInfo.361* %815, i32 0, i32 1
  %816 = load %struct.lua_TValue.349** %top1426, align 8
  %817 = load %struct.lua_State.364** %L.addr, align 8
  %top1427 = getelementptr inbounds %struct.lua_State.364* %817, i32 0, i32 4
  store %struct.lua_TValue.349* %816, %struct.lua_TValue.349** %top1427, align 8
  %818 = load %struct.CallInfo.361** %ci, align 8
  %u1428 = getelementptr inbounds %struct.CallInfo.361* %818, i32 0, i32 7
  %l1429 = bitcast %union.anon.360* %u1428 to %struct.anon.482*
  %savedpc1430 = getelementptr inbounds %struct.anon.482* %l1429, i32 0, i32 1
  %819 = load i32** %savedpc1430, align 8
  %incdec.ptr1431 = getelementptr inbounds i32* %819, i32 1
  store i32* %incdec.ptr1431, i32** %savedpc1430, align 8
  %820 = load i32* %819, align 4
  store i32 %820, i32* %i, align 4
  %821 = load %struct.lua_TValue.349** %base, align 8
  %822 = load i32* %i, align 4
  %shr1432 = lshr i32 %822, 6
  %and1433 = and i32 %shr1432, 255
  %idx.ext1434 = sext i32 %and1433 to i64
  %add.ptr1435 = getelementptr inbounds %struct.lua_TValue.349* %821, i64 %idx.ext1434
  store %struct.lua_TValue.349* %add.ptr1435, %struct.lua_TValue.349** %ra, align 8
  br label %l_tforloop

sw.bb1436:                                        ; preds = %if.end
  br label %l_tforloop

l_tforloop:                                       ; preds = %sw.bb1436, %sw.bb1395
  %823 = load %struct.lua_TValue.349** %ra, align 8
  %add.ptr1437 = getelementptr inbounds %struct.lua_TValue.349* %823, i64 1
  %tt_1438 = getelementptr inbounds %struct.lua_TValue.349* %add.ptr1437, i32 0, i32 1
  %824 = load i32* %tt_1438, align 4
  %cmp1439 = icmp eq i32 %824, 0
  br i1 %cmp1439, label %if.end1457, label %if.then1441

if.then1441:                                      ; preds = %l_tforloop
  %825 = load %struct.lua_TValue.349** %ra, align 8
  %add.ptr1443 = getelementptr inbounds %struct.lua_TValue.349* %825, i64 1
  store %struct.lua_TValue.349* %add.ptr1443, %struct.lua_TValue.349** %io21442, align 8
  %826 = load %struct.lua_TValue.349** %ra, align 8
  store %struct.lua_TValue.349* %826, %struct.lua_TValue.349** %io11444, align 8
  %827 = load %struct.lua_TValue.349** %io11444, align 8
  %value_1445 = getelementptr inbounds %struct.lua_TValue.349* %827, i32 0, i32 0
  %828 = load %struct.lua_TValue.349** %io21442, align 8
  %value_1446 = getelementptr inbounds %struct.lua_TValue.349* %828, i32 0, i32 0
  %829 = bitcast %union.Value.348* %value_1445 to i8*
  %830 = bitcast %union.Value.348* %value_1446 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %829, i8* %830, i64 8, i32 8, i1 false)
  %831 = load %struct.lua_TValue.349** %io21442, align 8
  %tt_1447 = getelementptr inbounds %struct.lua_TValue.349* %831, i32 0, i32 1
  %832 = load i32* %tt_1447, align 4
  %833 = load %struct.lua_TValue.349** %io11444, align 8
  %tt_1448 = getelementptr inbounds %struct.lua_TValue.349* %833, i32 0, i32 1
  store i32 %832, i32* %tt_1448, align 4
  %834 = load i32* %i, align 4
  %shr1449 = lshr i32 %834, 14
  %and1450 = and i32 %shr1449, 262143
  %sub1451 = sub nsw i32 %and1450, 131071
  %835 = load %struct.CallInfo.361** %ci, align 8
  %u1452 = getelementptr inbounds %struct.CallInfo.361* %835, i32 0, i32 7
  %l1453 = bitcast %union.anon.360* %u1452 to %struct.anon.482*
  %savedpc1454 = getelementptr inbounds %struct.anon.482* %l1453, i32 0, i32 1
  %836 = load i32** %savedpc1454, align 8
  %idx.ext1455 = sext i32 %sub1451 to i64
  %add.ptr1456 = getelementptr inbounds i32* %836, i64 %idx.ext1455
  store i32* %add.ptr1456, i32** %savedpc1454, align 8
  br label %if.end1457

if.end1457:                                       ; preds = %if.then1441, %l_tforloop
  br label %sw.epilog

sw.bb1458:                                        ; preds = %if.end
  %837 = load i32* %i, align 4
  %shr1460 = lshr i32 %837, 23
  %and1461 = and i32 %shr1460, 511
  store i32 %and1461, i32* %n1459, align 4
  %838 = load i32* %i, align 4
  %shr1463 = lshr i32 %838, 14
  %and1464 = and i32 %shr1463, 511
  store i32 %and1464, i32* %c1462, align 4
  %839 = load i32* %n1459, align 4
  %cmp1465 = icmp eq i32 %839, 0
  br i1 %cmp1465, label %if.then1467, label %if.end1475

if.then1467:                                      ; preds = %sw.bb1458
  %840 = load %struct.lua_State.364** %L.addr, align 8
  %top1468 = getelementptr inbounds %struct.lua_State.364* %840, i32 0, i32 4
  %841 = load %struct.lua_TValue.349** %top1468, align 8
  %842 = load %struct.lua_TValue.349** %ra, align 8
  %sub.ptr.lhs.cast1469 = ptrtoint %struct.lua_TValue.349* %841 to i64
  %sub.ptr.rhs.cast1470 = ptrtoint %struct.lua_TValue.349* %842 to i64
  %sub.ptr.sub1471 = sub i64 %sub.ptr.lhs.cast1469, %sub.ptr.rhs.cast1470
  %sub.ptr.div1472 = sdiv exact i64 %sub.ptr.sub1471, 16
  %conv1473 = trunc i64 %sub.ptr.div1472 to i32
  %sub1474 = sub nsw i32 %conv1473, 1
  store i32 %sub1474, i32* %n1459, align 4
  br label %if.end1475

if.end1475:                                       ; preds = %if.then1467, %sw.bb1458
  %843 = load i32* %c1462, align 4
  %cmp1476 = icmp eq i32 %843, 0
  br i1 %cmp1476, label %if.then1478, label %if.end1485

if.then1478:                                      ; preds = %if.end1475
  %844 = load %struct.CallInfo.361** %ci, align 8
  %u1479 = getelementptr inbounds %struct.CallInfo.361* %844, i32 0, i32 7
  %l1480 = bitcast %union.anon.360* %u1479 to %struct.anon.482*
  %savedpc1481 = getelementptr inbounds %struct.anon.482* %l1480, i32 0, i32 1
  %845 = load i32** %savedpc1481, align 8
  %incdec.ptr1482 = getelementptr inbounds i32* %845, i32 1
  store i32* %incdec.ptr1482, i32** %savedpc1481, align 8
  %846 = load i32* %845, align 4
  %shr1483 = lshr i32 %846, 6
  %and1484 = and i32 %shr1483, 67108863
  store i32 %and1484, i32* %c1462, align 4
  br label %if.end1485

if.end1485:                                       ; preds = %if.then1478, %if.end1475
  %847 = load %struct.lua_TValue.349** %ra, align 8
  %value_1486 = getelementptr inbounds %struct.lua_TValue.349* %847, i32 0, i32 0
  %gc1487 = bitcast %union.Value.348* %value_1486 to %union.GCObject.365**
  %848 = load %union.GCObject.365** %gc1487, align 8
  %h1488 = bitcast %union.GCObject.365* %848 to %struct.Table.357*
  store %struct.Table.357* %h1488, %struct.Table.357** %h, align 8
  %849 = load i32* %c1462, align 4
  %sub1489 = sub nsw i32 %849, 1
  %mul1490 = mul nsw i32 %sub1489, 50
  %850 = load i32* %n1459, align 4
  %add1491 = add nsw i32 %mul1490, %850
  store i32 %add1491, i32* %last, align 4
  %851 = load i32* %last, align 4
  %852 = load %struct.Table.357** %h, align 8
  %sizearray = getelementptr inbounds %struct.Table.357* %852, i32 0, i32 10
  %853 = load i32* %sizearray, align 4
  %cmp1492 = icmp sgt i32 %851, %853
  br i1 %cmp1492, label %if.then1494, label %if.end1495

if.then1494:                                      ; preds = %if.end1485
  %854 = load %struct.lua_State.364** %L.addr, align 8
  %855 = load %struct.Table.357** %h, align 8
  %856 = load i32* %last, align 4
  call void bitcast (void (%struct.lua_State*, %struct.Table*, i32)* @luaH_resizearray to void (%struct.lua_State.364*, %struct.Table.357*, i32)*)(%struct.lua_State.364* %854, %struct.Table.357* %855, i32 %856)
  br label %if.end1495

if.end1495:                                       ; preds = %if.then1494, %if.end1485
  br label %for.cond1496

for.cond1496:                                     ; preds = %for.inc1522, %if.end1495
  %857 = load i32* %n1459, align 4
  %cmp1497 = icmp sgt i32 %857, 0
  br i1 %cmp1497, label %for.body1499, label %for.end1524

for.body1499:                                     ; preds = %for.cond1496
  %858 = load %struct.lua_TValue.349** %ra, align 8
  %859 = load i32* %n1459, align 4
  %idx.ext1500 = sext i32 %859 to i64
  %add.ptr1501 = getelementptr inbounds %struct.lua_TValue.349* %858, i64 %idx.ext1500
  store %struct.lua_TValue.349* %add.ptr1501, %struct.lua_TValue.349** %val, align 8
  %860 = load %struct.lua_State.364** %L.addr, align 8
  %861 = load %struct.Table.357** %h, align 8
  %862 = load i32* %last, align 4
  %dec1502 = add nsw i32 %862, -1
  store i32 %dec1502, i32* %last, align 4
  %863 = load %struct.lua_TValue.349** %val, align 8
  call void bitcast (void (%struct.lua_State*, %struct.Table*, i32, %struct.lua_TValue*)* @luaH_setint to void (%struct.lua_State.364*, %struct.Table.357*, i32, %struct.lua_TValue.349*)*)(%struct.lua_State.364* %860, %struct.Table.357* %861, i32 %862, %struct.lua_TValue.349* %863)
  %864 = load %struct.lua_TValue.349** %val, align 8
  %tt_1503 = getelementptr inbounds %struct.lua_TValue.349* %864, i32 0, i32 1
  %865 = load i32* %tt_1503, align 4
  %and1504 = and i32 %865, 64
  %tobool1505 = icmp ne i32 %and1504, 0
  br i1 %tobool1505, label %land.lhs.true1506, label %if.end1521

land.lhs.true1506:                                ; preds = %for.body1499
  %866 = load %struct.lua_TValue.349** %val, align 8
  %value_1507 = getelementptr inbounds %struct.lua_TValue.349* %866, i32 0, i32 0
  %gc1508 = bitcast %union.Value.348* %value_1507 to %union.GCObject.365**
  %867 = load %union.GCObject.365** %gc1508, align 8
  %gch1509 = bitcast %union.GCObject.365* %867 to %struct.GCheader.479*
  %marked1510 = getelementptr inbounds %struct.GCheader.479* %gch1509, i32 0, i32 2
  %868 = load i8* %marked1510, align 1
  %conv1511 = zext i8 %868 to i32
  %and1512 = and i32 %conv1511, 3
  %tobool1513 = icmp ne i32 %and1512, 0
  br i1 %tobool1513, label %land.lhs.true1514, label %if.end1521

land.lhs.true1514:                                ; preds = %land.lhs.true1506
  %869 = load %struct.Table.357** %h, align 8
  %870 = bitcast %struct.Table.357* %869 to %union.GCObject.365*
  %gch1515 = bitcast %union.GCObject.365* %870 to %struct.GCheader.479*
  %marked1516 = getelementptr inbounds %struct.GCheader.479* %gch1515, i32 0, i32 2
  %871 = load i8* %marked1516, align 1
  %conv1517 = zext i8 %871 to i32
  %and1518 = and i32 %conv1517, 4
  %tobool1519 = icmp ne i32 %and1518, 0
  br i1 %tobool1519, label %if.then1520, label %if.end1521

if.then1520:                                      ; preds = %land.lhs.true1514
  %872 = load %struct.lua_State.364** %L.addr, align 8
  %873 = load %struct.Table.357** %h, align 8
  %874 = bitcast %struct.Table.357* %873 to %union.GCObject.365*
  call void bitcast (void (%struct.lua_State*, %union.GCObject*)* @luaC_barrierback_ to void (%struct.lua_State.364*, %union.GCObject.365*)*)(%struct.lua_State.364* %872, %union.GCObject.365* %874)
  br label %if.end1521

if.end1521:                                       ; preds = %if.then1520, %land.lhs.true1514, %land.lhs.true1506, %for.body1499
  br label %for.inc1522

for.inc1522:                                      ; preds = %if.end1521
  %875 = load i32* %n1459, align 4
  %dec1523 = add nsw i32 %875, -1
  store i32 %dec1523, i32* %n1459, align 4
  br label %for.cond1496

for.end1524:                                      ; preds = %for.cond1496
  %876 = load %struct.CallInfo.361** %ci, align 8
  %top1525 = getelementptr inbounds %struct.CallInfo.361* %876, i32 0, i32 1
  %877 = load %struct.lua_TValue.349** %top1525, align 8
  %878 = load %struct.lua_State.364** %L.addr, align 8
  %top1526 = getelementptr inbounds %struct.lua_State.364* %878, i32 0, i32 4
  store %struct.lua_TValue.349* %877, %struct.lua_TValue.349** %top1526, align 8
  br label %sw.epilog

sw.bb1527:                                        ; preds = %if.end
  %879 = load i32* %i, align 4
  %shr1529 = lshr i32 %879, 14
  %and1530 = and i32 %shr1529, 262143
  %idxprom1531 = sext i32 %and1530 to i64
  %880 = load %struct.LClosure.483** %cl, align 8
  %p1532 = getelementptr inbounds %struct.LClosure.483* %880, i32 0, i32 5
  %881 = load %struct.Proto.478** %p1532, align 8
  %p1533 = getelementptr inbounds %struct.Proto.478* %881, i32 0, i32 5
  %882 = load %struct.Proto.478*** %p1533, align 8
  %arrayidx1534 = getelementptr inbounds %struct.Proto.478** %882, i64 %idxprom1531
  %883 = load %struct.Proto.478** %arrayidx1534, align 8
  store %struct.Proto.478* %883, %struct.Proto.478** %p1528, align 8
  %884 = load %struct.Proto.478** %p1528, align 8
  %885 = load %struct.LClosure.483** %cl, align 8
  %upvals1535 = getelementptr inbounds %struct.LClosure.483* %885, i32 0, i32 6
  %arraydecay = getelementptr inbounds [1 x %struct.UpVal.352*]* %upvals1535, i32 0, i32 0
  %886 = load %struct.lua_TValue.349** %base, align 8
  %call1536 = call %union.Closure.475* @getcached(%struct.Proto.478* %884, %struct.UpVal.352** %arraydecay, %struct.lua_TValue.349* %886)
  store %union.Closure.475* %call1536, %union.Closure.475** %ncl, align 8
  %887 = load %union.Closure.475** %ncl, align 8
  %cmp1537 = icmp eq %union.Closure.475* %887, null
  br i1 %cmp1537, label %if.then1539, label %if.else1542

if.then1539:                                      ; preds = %sw.bb1527
  %888 = load %struct.lua_State.364** %L.addr, align 8
  %889 = load %struct.Proto.478** %p1528, align 8
  %890 = load %struct.LClosure.483** %cl, align 8
  %upvals1540 = getelementptr inbounds %struct.LClosure.483* %890, i32 0, i32 6
  %arraydecay1541 = getelementptr inbounds [1 x %struct.UpVal.352*]* %upvals1540, i32 0, i32 0
  %891 = load %struct.lua_TValue.349** %base, align 8
  %892 = load %struct.lua_TValue.349** %ra, align 8
  call void @pushclosure(%struct.lua_State.364* %888, %struct.Proto.478* %889, %struct.UpVal.352** %arraydecay1541, %struct.lua_TValue.349* %891, %struct.lua_TValue.349* %892)
  br label %if.end1547

if.else1542:                                      ; preds = %sw.bb1527
  %893 = load %struct.lua_TValue.349** %ra, align 8
  store %struct.lua_TValue.349* %893, %struct.lua_TValue.349** %io1543, align 8
  %894 = load %union.Closure.475** %ncl, align 8
  %895 = bitcast %union.Closure.475* %894 to %union.GCObject.365*
  %896 = load %struct.lua_TValue.349** %io1543, align 8
  %value_1544 = getelementptr inbounds %struct.lua_TValue.349* %896, i32 0, i32 0
  %gc1545 = bitcast %union.Value.348* %value_1544 to %union.GCObject.365**
  store %union.GCObject.365* %895, %union.GCObject.365** %gc1545, align 8
  %897 = load %struct.lua_TValue.349** %io1543, align 8
  %tt_1546 = getelementptr inbounds %struct.lua_TValue.349* %897, i32 0, i32 1
  store i32 70, i32* %tt_1546, align 4
  br label %if.end1547

if.end1547:                                       ; preds = %if.else1542, %if.then1539
  %898 = load %struct.lua_State.364** %L.addr, align 8
  %l_G1548 = getelementptr inbounds %struct.lua_State.364* %898, i32 0, i32 5
  %899 = load %struct.global_State.358** %l_G1548, align 8
  %GCdebt1549 = getelementptr inbounds %struct.global_State.358* %899, i32 0, i32 3
  %900 = load i64* %GCdebt1549, align 8
  %cmp1550 = icmp sgt i64 %900, 0
  br i1 %cmp1550, label %if.then1552, label %if.end1557

if.then1552:                                      ; preds = %if.end1547
  %901 = load %struct.lua_TValue.349** %ra, align 8
  %add.ptr1553 = getelementptr inbounds %struct.lua_TValue.349* %901, i64 1
  %902 = load %struct.lua_State.364** %L.addr, align 8
  %top1554 = getelementptr inbounds %struct.lua_State.364* %902, i32 0, i32 4
  store %struct.lua_TValue.349* %add.ptr1553, %struct.lua_TValue.349** %top1554, align 8
  %903 = load %struct.lua_State.364** %L.addr, align 8
  call void bitcast (void (%struct.lua_State*)* @luaC_step to void (%struct.lua_State.364*)*)(%struct.lua_State.364* %903)
  %904 = load %struct.CallInfo.361** %ci, align 8
  %top1555 = getelementptr inbounds %struct.CallInfo.361* %904, i32 0, i32 1
  %905 = load %struct.lua_TValue.349** %top1555, align 8
  %906 = load %struct.lua_State.364** %L.addr, align 8
  %top1556 = getelementptr inbounds %struct.lua_State.364* %906, i32 0, i32 4
  store %struct.lua_TValue.349* %905, %struct.lua_TValue.349** %top1556, align 8
  br label %if.end1557

if.end1557:                                       ; preds = %if.then1552, %if.end1547
  %907 = load %struct.CallInfo.361** %ci, align 8
  %u1558 = getelementptr inbounds %struct.CallInfo.361* %907, i32 0, i32 7
  %l1559 = bitcast %union.anon.360* %u1558 to %struct.anon.482*
  %base1560 = getelementptr inbounds %struct.anon.482* %l1559, i32 0, i32 0
  %908 = load %struct.lua_TValue.349** %base1560, align 8
  store %struct.lua_TValue.349* %908, %struct.lua_TValue.349** %base, align 8
  br label %sw.epilog

sw.bb1561:                                        ; preds = %if.end
  %909 = load i32* %i, align 4
  %shr1563 = lshr i32 %909, 23
  %and1564 = and i32 %shr1563, 511
  %sub1565 = sub nsw i32 %and1564, 1
  store i32 %sub1565, i32* %b1562, align 4
  %910 = load %struct.lua_TValue.349** %base, align 8
  %911 = load %struct.CallInfo.361** %ci, align 8
  %func1567 = getelementptr inbounds %struct.CallInfo.361* %911, i32 0, i32 0
  %912 = load %struct.lua_TValue.349** %func1567, align 8
  %sub.ptr.lhs.cast1568 = ptrtoint %struct.lua_TValue.349* %910 to i64
  %sub.ptr.rhs.cast1569 = ptrtoint %struct.lua_TValue.349* %912 to i64
  %sub.ptr.sub1570 = sub i64 %sub.ptr.lhs.cast1568, %sub.ptr.rhs.cast1569
  %sub.ptr.div1571 = sdiv exact i64 %sub.ptr.sub1570, 16
  %conv1572 = trunc i64 %sub.ptr.div1571 to i32
  %913 = load %struct.LClosure.483** %cl, align 8
  %p1573 = getelementptr inbounds %struct.LClosure.483* %913, i32 0, i32 5
  %914 = load %struct.Proto.478** %p1573, align 8
  %numparams1574 = getelementptr inbounds %struct.Proto.478* %914, i32 0, i32 20
  %915 = load i8* %numparams1574, align 1
  %conv1575 = zext i8 %915 to i32
  %sub1576 = sub nsw i32 %conv1572, %conv1575
  %sub1577 = sub nsw i32 %sub1576, 1
  store i32 %sub1577, i32* %n1566, align 4
  %916 = load i32* %b1562, align 4
  %cmp1578 = icmp slt i32 %916, 0
  br i1 %cmp1578, label %if.then1580, label %if.end1602

if.then1580:                                      ; preds = %sw.bb1561
  %917 = load i32* %n1566, align 4
  store i32 %917, i32* %b1562, align 4
  %918 = load %struct.lua_State.364** %L.addr, align 8
  %stack_last = getelementptr inbounds %struct.lua_State.364* %918, i32 0, i32 8
  %919 = load %struct.lua_TValue.349** %stack_last, align 8
  %920 = load %struct.lua_State.364** %L.addr, align 8
  %top1581 = getelementptr inbounds %struct.lua_State.364* %920, i32 0, i32 4
  %921 = load %struct.lua_TValue.349** %top1581, align 8
  %sub.ptr.lhs.cast1582 = ptrtoint %struct.lua_TValue.349* %919 to i64
  %sub.ptr.rhs.cast1583 = ptrtoint %struct.lua_TValue.349* %921 to i64
  %sub.ptr.sub1584 = sub i64 %sub.ptr.lhs.cast1582, %sub.ptr.rhs.cast1583
  %sub.ptr.div1585 = sdiv exact i64 %sub.ptr.sub1584, 16
  %922 = load i32* %n1566, align 4
  %conv1586 = sext i32 %922 to i64
  %cmp1587 = icmp sle i64 %sub.ptr.div1585, %conv1586
  br i1 %cmp1587, label %if.then1589, label %if.else1590

if.then1589:                                      ; preds = %if.then1580
  %923 = load %struct.lua_State.364** %L.addr, align 8
  %924 = load i32* %n1566, align 4
  call void bitcast (void (%struct.lua_State*, i32)* @luaD_growstack to void (%struct.lua_State.364*, i32)*)(%struct.lua_State.364* %923, i32 %924)
  br label %if.end1591

if.else1590:                                      ; preds = %if.then1580
  br label %if.end1591

if.end1591:                                       ; preds = %if.else1590, %if.then1589
  %925 = load %struct.CallInfo.361** %ci, align 8
  %u1592 = getelementptr inbounds %struct.CallInfo.361* %925, i32 0, i32 7
  %l1593 = bitcast %union.anon.360* %u1592 to %struct.anon.482*
  %base1594 = getelementptr inbounds %struct.anon.482* %l1593, i32 0, i32 0
  %926 = load %struct.lua_TValue.349** %base1594, align 8
  store %struct.lua_TValue.349* %926, %struct.lua_TValue.349** %base, align 8
  %927 = load %struct.lua_TValue.349** %base, align 8
  %928 = load i32* %i, align 4
  %shr1595 = lshr i32 %928, 6
  %and1596 = and i32 %shr1595, 255
  %idx.ext1597 = sext i32 %and1596 to i64
  %add.ptr1598 = getelementptr inbounds %struct.lua_TValue.349* %927, i64 %idx.ext1597
  store %struct.lua_TValue.349* %add.ptr1598, %struct.lua_TValue.349** %ra, align 8
  %929 = load %struct.lua_TValue.349** %ra, align 8
  %930 = load i32* %n1566, align 4
  %idx.ext1599 = sext i32 %930 to i64
  %add.ptr1600 = getelementptr inbounds %struct.lua_TValue.349* %929, i64 %idx.ext1599
  %931 = load %struct.lua_State.364** %L.addr, align 8
  %top1601 = getelementptr inbounds %struct.lua_State.364* %931, i32 0, i32 4
  store %struct.lua_TValue.349* %add.ptr1600, %struct.lua_TValue.349** %top1601, align 8
  br label %if.end1602

if.end1602:                                       ; preds = %if.end1591, %sw.bb1561
  store i32 0, i32* %j, align 4
  br label %for.cond1603

for.cond1603:                                     ; preds = %for.inc1627, %if.end1602
  %932 = load i32* %j, align 4
  %933 = load i32* %b1562, align 4
  %cmp1604 = icmp slt i32 %932, %933
  br i1 %cmp1604, label %for.body1606, label %for.end1629

for.body1606:                                     ; preds = %for.cond1603
  %934 = load i32* %j, align 4
  %935 = load i32* %n1566, align 4
  %cmp1607 = icmp slt i32 %934, %935
  br i1 %cmp1607, label %if.then1609, label %if.else1622

if.then1609:                                      ; preds = %for.body1606
  %936 = load %struct.lua_TValue.349** %base, align 8
  %937 = load i32* %n1566, align 4
  %idx.ext1611 = sext i32 %937 to i64
  %idx.neg = sub i64 0, %idx.ext1611
  %add.ptr1612 = getelementptr inbounds %struct.lua_TValue.349* %936, i64 %idx.neg
  %938 = load i32* %j, align 4
  %idx.ext1613 = sext i32 %938 to i64
  %add.ptr1614 = getelementptr inbounds %struct.lua_TValue.349* %add.ptr1612, i64 %idx.ext1613
  store %struct.lua_TValue.349* %add.ptr1614, %struct.lua_TValue.349** %io21610, align 8
  %939 = load %struct.lua_TValue.349** %ra, align 8
  %940 = load i32* %j, align 4
  %idx.ext1616 = sext i32 %940 to i64
  %add.ptr1617 = getelementptr inbounds %struct.lua_TValue.349* %939, i64 %idx.ext1616
  store %struct.lua_TValue.349* %add.ptr1617, %struct.lua_TValue.349** %io11615, align 8
  %941 = load %struct.lua_TValue.349** %io11615, align 8
  %value_1618 = getelementptr inbounds %struct.lua_TValue.349* %941, i32 0, i32 0
  %942 = load %struct.lua_TValue.349** %io21610, align 8
  %value_1619 = getelementptr inbounds %struct.lua_TValue.349* %942, i32 0, i32 0
  %943 = bitcast %union.Value.348* %value_1618 to i8*
  %944 = bitcast %union.Value.348* %value_1619 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %943, i8* %944, i64 8, i32 8, i1 false)
  %945 = load %struct.lua_TValue.349** %io21610, align 8
  %tt_1620 = getelementptr inbounds %struct.lua_TValue.349* %945, i32 0, i32 1
  %946 = load i32* %tt_1620, align 4
  %947 = load %struct.lua_TValue.349** %io11615, align 8
  %tt_1621 = getelementptr inbounds %struct.lua_TValue.349* %947, i32 0, i32 1
  store i32 %946, i32* %tt_1621, align 4
  br label %if.end1626

if.else1622:                                      ; preds = %for.body1606
  %948 = load %struct.lua_TValue.349** %ra, align 8
  %949 = load i32* %j, align 4
  %idx.ext1623 = sext i32 %949 to i64
  %add.ptr1624 = getelementptr inbounds %struct.lua_TValue.349* %948, i64 %idx.ext1623
  %tt_1625 = getelementptr inbounds %struct.lua_TValue.349* %add.ptr1624, i32 0, i32 1
  store i32 0, i32* %tt_1625, align 4
  br label %if.end1626

if.end1626:                                       ; preds = %if.else1622, %if.then1609
  br label %for.inc1627

for.inc1627:                                      ; preds = %if.end1626
  %950 = load i32* %j, align 4
  %inc1628 = add nsw i32 %950, 1
  store i32 %inc1628, i32* %j, align 4
  br label %for.cond1603

for.end1629:                                      ; preds = %for.cond1603
  br label %sw.epilog

sw.bb1630:                                        ; preds = %if.end
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb1630, %for.end1629, %if.end1557, %for.end1524, %if.end1457, %if.end1377, %if.end1343, %if.end1275, %if.end1193, %if.end1162, %if.end1089, %if.end1024, %if.end949, %if.end874, %if.end784, %if.end765, %sw.bb713, %lor.end, %if.end692, %if.end669, %if.end608, %if.end544, %if.end484, %if.end424, %if.end364, %cond.end305, %if.end273, %cond.end243, %if.end209, %cond.end173, %cond.end129, %cond.end, %sw.bb75, %do.end, %if.end66, %sw.bb37, %sw.bb26, %sw.bb, %if.end
  br label %for.cond
}

; Function Attrs: nounwind readonly
declare i32 @strcoll(i8*, i8*) #2

; Function Attrs: nounwind uwtable
define internal void @callTM(%struct.lua_State.364* %L, %struct.lua_TValue.349* %f, %struct.lua_TValue.349* %p1, %struct.lua_TValue.349* %p2, %struct.lua_TValue.349* %p3, i32 %hasres) #0 {
entry:
  %L.addr = alloca %struct.lua_State.364*, align 8
  %f.addr = alloca %struct.lua_TValue.349*, align 8
  %p1.addr = alloca %struct.lua_TValue.349*, align 8
  %p2.addr = alloca %struct.lua_TValue.349*, align 8
  %p3.addr = alloca %struct.lua_TValue.349*, align 8
  %hasres.addr = alloca i32, align 4
  %result = alloca i64, align 8
  %io2 = alloca %struct.lua_TValue.349*, align 8
  %io1 = alloca %struct.lua_TValue.349*, align 8
  %io23 = alloca %struct.lua_TValue.349*, align 8
  %io14 = alloca %struct.lua_TValue.349*, align 8
  %io211 = alloca %struct.lua_TValue.349*, align 8
  %io112 = alloca %struct.lua_TValue.349*, align 8
  %io219 = alloca %struct.lua_TValue.349*, align 8
  %io120 = alloca %struct.lua_TValue.349*, align 8
  %io232 = alloca %struct.lua_TValue.349*, align 8
  %io135 = alloca %struct.lua_TValue.349*, align 8
  store %struct.lua_State.364* %L, %struct.lua_State.364** %L.addr, align 8
  store %struct.lua_TValue.349* %f, %struct.lua_TValue.349** %f.addr, align 8
  store %struct.lua_TValue.349* %p1, %struct.lua_TValue.349** %p1.addr, align 8
  store %struct.lua_TValue.349* %p2, %struct.lua_TValue.349** %p2.addr, align 8
  store %struct.lua_TValue.349* %p3, %struct.lua_TValue.349** %p3.addr, align 8
  store i32 %hasres, i32* %hasres.addr, align 4
  %0 = load %struct.lua_TValue.349** %p3.addr, align 8
  %1 = bitcast %struct.lua_TValue.349* %0 to i8*
  %2 = load %struct.lua_State.364** %L.addr, align 8
  %stack = getelementptr inbounds %struct.lua_State.364* %2, i32 0, i32 9
  %3 = load %struct.lua_TValue.349** %stack, align 8
  %4 = bitcast %struct.lua_TValue.349* %3 to i8*
  %sub.ptr.lhs.cast = ptrtoint i8* %1 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %4 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, i64* %result, align 8
  %5 = load %struct.lua_TValue.349** %f.addr, align 8
  store %struct.lua_TValue.349* %5, %struct.lua_TValue.349** %io2, align 8
  %6 = load %struct.lua_State.364** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State.364* %6, i32 0, i32 4
  %7 = load %struct.lua_TValue.349** %top, align 8
  %incdec.ptr = getelementptr inbounds %struct.lua_TValue.349* %7, i32 1
  store %struct.lua_TValue.349* %incdec.ptr, %struct.lua_TValue.349** %top, align 8
  store %struct.lua_TValue.349* %7, %struct.lua_TValue.349** %io1, align 8
  %8 = load %struct.lua_TValue.349** %io1, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue.349* %8, i32 0, i32 0
  %9 = load %struct.lua_TValue.349** %io2, align 8
  %value_1 = getelementptr inbounds %struct.lua_TValue.349* %9, i32 0, i32 0
  %10 = bitcast %union.Value.348* %value_ to i8*
  %11 = bitcast %union.Value.348* %value_1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %10, i8* %11, i64 8, i32 8, i1 false)
  %12 = load %struct.lua_TValue.349** %io2, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue.349* %12, i32 0, i32 1
  %13 = load i32* %tt_, align 4
  %14 = load %struct.lua_TValue.349** %io1, align 8
  %tt_2 = getelementptr inbounds %struct.lua_TValue.349* %14, i32 0, i32 1
  store i32 %13, i32* %tt_2, align 4
  %15 = load %struct.lua_TValue.349** %p1.addr, align 8
  store %struct.lua_TValue.349* %15, %struct.lua_TValue.349** %io23, align 8
  %16 = load %struct.lua_State.364** %L.addr, align 8
  %top5 = getelementptr inbounds %struct.lua_State.364* %16, i32 0, i32 4
  %17 = load %struct.lua_TValue.349** %top5, align 8
  %incdec.ptr6 = getelementptr inbounds %struct.lua_TValue.349* %17, i32 1
  store %struct.lua_TValue.349* %incdec.ptr6, %struct.lua_TValue.349** %top5, align 8
  store %struct.lua_TValue.349* %17, %struct.lua_TValue.349** %io14, align 8
  %18 = load %struct.lua_TValue.349** %io14, align 8
  %value_7 = getelementptr inbounds %struct.lua_TValue.349* %18, i32 0, i32 0
  %19 = load %struct.lua_TValue.349** %io23, align 8
  %value_8 = getelementptr inbounds %struct.lua_TValue.349* %19, i32 0, i32 0
  %20 = bitcast %union.Value.348* %value_7 to i8*
  %21 = bitcast %union.Value.348* %value_8 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %20, i8* %21, i64 8, i32 8, i1 false)
  %22 = load %struct.lua_TValue.349** %io23, align 8
  %tt_9 = getelementptr inbounds %struct.lua_TValue.349* %22, i32 0, i32 1
  %23 = load i32* %tt_9, align 4
  %24 = load %struct.lua_TValue.349** %io14, align 8
  %tt_10 = getelementptr inbounds %struct.lua_TValue.349* %24, i32 0, i32 1
  store i32 %23, i32* %tt_10, align 4
  %25 = load %struct.lua_TValue.349** %p2.addr, align 8
  store %struct.lua_TValue.349* %25, %struct.lua_TValue.349** %io211, align 8
  %26 = load %struct.lua_State.364** %L.addr, align 8
  %top13 = getelementptr inbounds %struct.lua_State.364* %26, i32 0, i32 4
  %27 = load %struct.lua_TValue.349** %top13, align 8
  %incdec.ptr14 = getelementptr inbounds %struct.lua_TValue.349* %27, i32 1
  store %struct.lua_TValue.349* %incdec.ptr14, %struct.lua_TValue.349** %top13, align 8
  store %struct.lua_TValue.349* %27, %struct.lua_TValue.349** %io112, align 8
  %28 = load %struct.lua_TValue.349** %io112, align 8
  %value_15 = getelementptr inbounds %struct.lua_TValue.349* %28, i32 0, i32 0
  %29 = load %struct.lua_TValue.349** %io211, align 8
  %value_16 = getelementptr inbounds %struct.lua_TValue.349* %29, i32 0, i32 0
  %30 = bitcast %union.Value.348* %value_15 to i8*
  %31 = bitcast %union.Value.348* %value_16 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %30, i8* %31, i64 8, i32 8, i1 false)
  %32 = load %struct.lua_TValue.349** %io211, align 8
  %tt_17 = getelementptr inbounds %struct.lua_TValue.349* %32, i32 0, i32 1
  %33 = load i32* %tt_17, align 4
  %34 = load %struct.lua_TValue.349** %io112, align 8
  %tt_18 = getelementptr inbounds %struct.lua_TValue.349* %34, i32 0, i32 1
  store i32 %33, i32* %tt_18, align 4
  %35 = load i32* %hasres.addr, align 4
  %tobool = icmp ne i32 %35, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %36 = load %struct.lua_TValue.349** %p3.addr, align 8
  store %struct.lua_TValue.349* %36, %struct.lua_TValue.349** %io219, align 8
  %37 = load %struct.lua_State.364** %L.addr, align 8
  %top21 = getelementptr inbounds %struct.lua_State.364* %37, i32 0, i32 4
  %38 = load %struct.lua_TValue.349** %top21, align 8
  %incdec.ptr22 = getelementptr inbounds %struct.lua_TValue.349* %38, i32 1
  store %struct.lua_TValue.349* %incdec.ptr22, %struct.lua_TValue.349** %top21, align 8
  store %struct.lua_TValue.349* %38, %struct.lua_TValue.349** %io120, align 8
  %39 = load %struct.lua_TValue.349** %io120, align 8
  %value_23 = getelementptr inbounds %struct.lua_TValue.349* %39, i32 0, i32 0
  %40 = load %struct.lua_TValue.349** %io219, align 8
  %value_24 = getelementptr inbounds %struct.lua_TValue.349* %40, i32 0, i32 0
  %41 = bitcast %union.Value.348* %value_23 to i8*
  %42 = bitcast %union.Value.348* %value_24 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %41, i8* %42, i64 8, i32 8, i1 false)
  %43 = load %struct.lua_TValue.349** %io219, align 8
  %tt_25 = getelementptr inbounds %struct.lua_TValue.349* %43, i32 0, i32 1
  %44 = load i32* %tt_25, align 4
  %45 = load %struct.lua_TValue.349** %io120, align 8
  %tt_26 = getelementptr inbounds %struct.lua_TValue.349* %45, i32 0, i32 1
  store i32 %44, i32* %tt_26, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %46 = load %struct.lua_State.364** %L.addr, align 8
  %47 = load %struct.lua_State.364** %L.addr, align 8
  %top27 = getelementptr inbounds %struct.lua_State.364* %47, i32 0, i32 4
  %48 = load %struct.lua_TValue.349** %top27, align 8
  %49 = load i32* %hasres.addr, align 4
  %sub = sub nsw i32 4, %49
  %idx.ext = sext i32 %sub to i64
  %idx.neg = sub i64 0, %idx.ext
  %add.ptr = getelementptr inbounds %struct.lua_TValue.349* %48, i64 %idx.neg
  %50 = load i32* %hasres.addr, align 4
  %51 = load %struct.lua_State.364** %L.addr, align 8
  %ci = getelementptr inbounds %struct.lua_State.364* %51, i32 0, i32 6
  %52 = load %struct.CallInfo.361** %ci, align 8
  %callstatus = getelementptr inbounds %struct.CallInfo.361* %52, i32 0, i32 5
  %53 = load i8* %callstatus, align 1
  %conv = zext i8 %53 to i32
  %and = and i32 %conv, 1
  call void bitcast (void (%struct.lua_State*, %struct.lua_TValue*, i32, i32)* @luaD_call to void (%struct.lua_State.364*, %struct.lua_TValue.349*, i32, i32)*)(%struct.lua_State.364* %46, %struct.lua_TValue.349* %add.ptr, i32 %50, i32 %and)
  %54 = load i32* %hasres.addr, align 4
  %tobool28 = icmp ne i32 %54, 0
  br i1 %tobool28, label %if.then29, label %if.end40

if.then29:                                        ; preds = %if.end
  %55 = load %struct.lua_State.364** %L.addr, align 8
  %stack30 = getelementptr inbounds %struct.lua_State.364* %55, i32 0, i32 9
  %56 = load %struct.lua_TValue.349** %stack30, align 8
  %57 = bitcast %struct.lua_TValue.349* %56 to i8*
  %58 = load i64* %result, align 8
  %add.ptr31 = getelementptr inbounds i8* %57, i64 %58
  %59 = bitcast i8* %add.ptr31 to %struct.lua_TValue.349*
  store %struct.lua_TValue.349* %59, %struct.lua_TValue.349** %p3.addr, align 8
  %60 = load %struct.lua_State.364** %L.addr, align 8
  %top33 = getelementptr inbounds %struct.lua_State.364* %60, i32 0, i32 4
  %61 = load %struct.lua_TValue.349** %top33, align 8
  %incdec.ptr34 = getelementptr inbounds %struct.lua_TValue.349* %61, i32 -1
  store %struct.lua_TValue.349* %incdec.ptr34, %struct.lua_TValue.349** %top33, align 8
  store %struct.lua_TValue.349* %incdec.ptr34, %struct.lua_TValue.349** %io232, align 8
  %62 = load %struct.lua_TValue.349** %p3.addr, align 8
  store %struct.lua_TValue.349* %62, %struct.lua_TValue.349** %io135, align 8
  %63 = load %struct.lua_TValue.349** %io135, align 8
  %value_36 = getelementptr inbounds %struct.lua_TValue.349* %63, i32 0, i32 0
  %64 = load %struct.lua_TValue.349** %io232, align 8
  %value_37 = getelementptr inbounds %struct.lua_TValue.349* %64, i32 0, i32 0
  %65 = bitcast %union.Value.348* %value_36 to i8*
  %66 = bitcast %union.Value.348* %value_37 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %65, i8* %66, i64 8, i32 8, i1 false)
  %67 = load %struct.lua_TValue.349** %io232, align 8
  %tt_38 = getelementptr inbounds %struct.lua_TValue.349* %67, i32 0, i32 1
  %68 = load i32* %tt_38, align 4
  %69 = load %struct.lua_TValue.349** %io135, align 8
  %tt_39 = getelementptr inbounds %struct.lua_TValue.349* %69, i32 0, i32 1
  store i32 %68, i32* %tt_39, align 4
  br label %if.end40

if.end40:                                         ; preds = %if.then29, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @l_strcmp(%union.TString.367* %ls, %union.TString.367* %rs) #0 {
entry:
  %retval = alloca i32, align 4
  %ls.addr = alloca %union.TString.367*, align 8
  %rs.addr = alloca %union.TString.367*, align 8
  %l = alloca i8*, align 8
  %ll = alloca i64, align 8
  %r = alloca i8*, align 8
  %lr = alloca i64, align 8
  %temp = alloca i32, align 4
  %len4 = alloca i64, align 8
  store %union.TString.367* %ls, %union.TString.367** %ls.addr, align 8
  store %union.TString.367* %rs, %union.TString.367** %rs.addr, align 8
  %0 = load %union.TString.367** %ls.addr, align 8
  %add.ptr = getelementptr inbounds %union.TString.367* %0, i64 1
  %1 = bitcast %union.TString.367* %add.ptr to i8*
  store i8* %1, i8** %l, align 8
  %2 = load %union.TString.367** %ls.addr, align 8
  %tsv = bitcast %union.TString.367* %2 to %struct.anon.366*
  %len = getelementptr inbounds %struct.anon.366* %tsv, i32 0, i32 5
  %3 = load i64* %len, align 8
  store i64 %3, i64* %ll, align 8
  %4 = load %union.TString.367** %rs.addr, align 8
  %add.ptr1 = getelementptr inbounds %union.TString.367* %4, i64 1
  %5 = bitcast %union.TString.367* %add.ptr1 to i8*
  store i8* %5, i8** %r, align 8
  %6 = load %union.TString.367** %rs.addr, align 8
  %tsv2 = bitcast %union.TString.367* %6 to %struct.anon.366*
  %len3 = getelementptr inbounds %struct.anon.366* %tsv2, i32 0, i32 5
  %7 = load i64* %len3, align 8
  store i64 %7, i64* %lr, align 8
  br label %for.cond

for.cond:                                         ; preds = %if.end16, %entry
  %8 = load i8** %l, align 8
  %9 = load i8** %r, align 8
  %call = call i32 @strcoll(i8* %8, i8* %9) #10
  store i32 %call, i32* %temp, align 4
  %10 = load i32* %temp, align 4
  %cmp = icmp ne i32 %10, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %for.cond
  %11 = load i32* %temp, align 4
  store i32 %11, i32* %retval
  br label %return

if.else:                                          ; preds = %for.cond
  %12 = load i8** %l, align 8
  %call5 = call i64 @strlen(i8* %12) #10
  store i64 %call5, i64* %len4, align 8
  %13 = load i64* %len4, align 8
  %14 = load i64* %lr, align 8
  %cmp6 = icmp eq i64 %13, %14
  br i1 %cmp6, label %if.then7, label %if.else9

if.then7:                                         ; preds = %if.else
  %15 = load i64* %len4, align 8
  %16 = load i64* %ll, align 8
  %cmp8 = icmp eq i64 %15, %16
  %cond = select i1 %cmp8, i32 0, i32 1
  store i32 %cond, i32* %retval
  br label %return

if.else9:                                         ; preds = %if.else
  %17 = load i64* %len4, align 8
  %18 = load i64* %ll, align 8
  %cmp10 = icmp eq i64 %17, %18
  br i1 %cmp10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.else9
  store i32 -1, i32* %retval
  br label %return

if.end:                                           ; preds = %if.else9
  br label %if.end12

if.end12:                                         ; preds = %if.end
  %19 = load i64* %len4, align 8
  %inc = add i64 %19, 1
  store i64 %inc, i64* %len4, align 8
  %20 = load i64* %len4, align 8
  %21 = load i8** %l, align 8
  %add.ptr13 = getelementptr inbounds i8* %21, i64 %20
  store i8* %add.ptr13, i8** %l, align 8
  %22 = load i64* %len4, align 8
  %23 = load i64* %ll, align 8
  %sub = sub i64 %23, %22
  store i64 %sub, i64* %ll, align 8
  %24 = load i64* %len4, align 8
  %25 = load i8** %r, align 8
  %add.ptr14 = getelementptr inbounds i8* %25, i64 %24
  store i8* %add.ptr14, i8** %r, align 8
  %26 = load i64* %len4, align 8
  %27 = load i64* %lr, align 8
  %sub15 = sub i64 %27, %26
  store i64 %sub15, i64* %lr, align 8
  br label %if.end16

if.end16:                                         ; preds = %if.end12
  br label %for.cond

return:                                           ; preds = %if.then11, %if.then7, %if.then
  %28 = load i32* %retval
  ret i32 %28
}

; Function Attrs: nounwind uwtable
define internal i32 @call_orderTM(%struct.lua_State.364* %L, %struct.lua_TValue.349* %p1, %struct.lua_TValue.349* %p2, i32 %event) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State.364*, align 8
  %p1.addr = alloca %struct.lua_TValue.349*, align 8
  %p2.addr = alloca %struct.lua_TValue.349*, align 8
  %event.addr = alloca i32, align 4
  store %struct.lua_State.364* %L, %struct.lua_State.364** %L.addr, align 8
  store %struct.lua_TValue.349* %p1, %struct.lua_TValue.349** %p1.addr, align 8
  store %struct.lua_TValue.349* %p2, %struct.lua_TValue.349** %p2.addr, align 8
  store i32 %event, i32* %event.addr, align 4
  %0 = load %struct.lua_State.364** %L.addr, align 8
  %1 = load %struct.lua_TValue.349** %p1.addr, align 8
  %2 = load %struct.lua_TValue.349** %p2.addr, align 8
  %3 = load %struct.lua_State.364** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State.364* %3, i32 0, i32 4
  %4 = load %struct.lua_TValue.349** %top, align 8
  %5 = load i32* %event.addr, align 4
  %call = call i32 @call_binTM(%struct.lua_State.364* %0, %struct.lua_TValue.349* %1, %struct.lua_TValue.349* %2, %struct.lua_TValue.349* %4, i32 %5)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  store i32 -1, i32* %retval
  br label %return

if.else:                                          ; preds = %entry
  %6 = load %struct.lua_State.364** %L.addr, align 8
  %top1 = getelementptr inbounds %struct.lua_State.364* %6, i32 0, i32 4
  %7 = load %struct.lua_TValue.349** %top1, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue.349* %7, i32 0, i32 1
  %8 = load i32* %tt_, align 4
  %cmp = icmp eq i32 %8, 0
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.else
  %9 = load %struct.lua_State.364** %L.addr, align 8
  %top2 = getelementptr inbounds %struct.lua_State.364* %9, i32 0, i32 4
  %10 = load %struct.lua_TValue.349** %top2, align 8
  %tt_3 = getelementptr inbounds %struct.lua_TValue.349* %10, i32 0, i32 1
  %11 = load i32* %tt_3, align 4
  %cmp4 = icmp eq i32 %11, 1
  br i1 %cmp4, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %lor.rhs
  %12 = load %struct.lua_State.364** %L.addr, align 8
  %top5 = getelementptr inbounds %struct.lua_State.364* %12, i32 0, i32 4
  %13 = load %struct.lua_TValue.349** %top5, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue.349* %13, i32 0, i32 0
  %b = bitcast %union.Value.348* %value_ to i32*
  %14 = load i32* %b, align 4
  %cmp6 = icmp eq i32 %14, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %lor.rhs
  %15 = phi i1 [ false, %lor.rhs ], [ %cmp6, %land.rhs ]
  br label %lor.end

lor.end:                                          ; preds = %land.end, %if.else
  %16 = phi i1 [ true, %if.else ], [ %15, %land.end ]
  %lnot = xor i1 %16, true
  %lnot.ext = zext i1 %lnot to i32
  store i32 %lnot.ext, i32* %retval
  br label %return

return:                                           ; preds = %lor.end, %if.then
  %17 = load i32* %retval
  ret i32 %17
}

; Function Attrs: nounwind uwtable
define internal %struct.lua_TValue.349* @get_equalTM(%struct.lua_State.364* %L, %struct.Table.357* %mt1, %struct.Table.357* %mt2, i32 %event) #0 {
entry:
  %retval = alloca %struct.lua_TValue.349*, align 8
  %L.addr = alloca %struct.lua_State.364*, align 8
  %mt1.addr = alloca %struct.Table.357*, align 8
  %mt2.addr = alloca %struct.Table.357*, align 8
  %event.addr = alloca i32, align 4
  %tm1 = alloca %struct.lua_TValue.349*, align 8
  %tm2 = alloca %struct.lua_TValue.349*, align 8
  store %struct.lua_State.364* %L, %struct.lua_State.364** %L.addr, align 8
  store %struct.Table.357* %mt1, %struct.Table.357** %mt1.addr, align 8
  store %struct.Table.357* %mt2, %struct.Table.357** %mt2.addr, align 8
  store i32 %event, i32* %event.addr, align 4
  %0 = load %struct.Table.357** %mt1.addr, align 8
  %cmp = icmp eq %struct.Table.357* %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end3

cond.false:                                       ; preds = %entry
  %1 = load %struct.Table.357** %mt1.addr, align 8
  %flags = getelementptr inbounds %struct.Table.357* %1, i32 0, i32 3
  %2 = load i8* %flags, align 1
  %conv = zext i8 %2 to i32
  %3 = load i32* %event.addr, align 4
  %shl = shl i32 1, %3
  %and = and i32 %conv, %shl
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true1, label %cond.false2

cond.true1:                                       ; preds = %cond.false
  br label %cond.end

cond.false2:                                      ; preds = %cond.false
  %4 = load %struct.Table.357** %mt1.addr, align 8
  %5 = load i32* %event.addr, align 4
  %6 = load i32* %event.addr, align 4
  %idxprom = zext i32 %6 to i64
  %7 = load %struct.lua_State.364** %L.addr, align 8
  %l_G = getelementptr inbounds %struct.lua_State.364* %7, i32 0, i32 5
  %8 = load %struct.global_State.358** %l_G, align 8
  %tmname = getelementptr inbounds %struct.global_State.358* %8, i32 0, i32 33
  %arrayidx = getelementptr inbounds [17 x %union.TString.367*]* %tmname, i32 0, i64 %idxprom
  %9 = load %union.TString.367** %arrayidx, align 8
  %call = call %struct.lua_TValue.349* bitcast (%struct.lua_TValue* (%struct.Table*, i32, %union.TString*)* @luaT_gettm to %struct.lua_TValue.349* (%struct.Table.357*, i32, %union.TString.367*)*)(%struct.Table.357* %4, i32 %5, %union.TString.367* %9)
  br label %cond.end

cond.end:                                         ; preds = %cond.false2, %cond.true1
  %cond = phi %struct.lua_TValue.349* [ null, %cond.true1 ], [ %call, %cond.false2 ]
  br label %cond.end3

cond.end3:                                        ; preds = %cond.end, %cond.true
  %cond4 = phi %struct.lua_TValue.349* [ null, %cond.true ], [ %cond, %cond.end ]
  store %struct.lua_TValue.349* %cond4, %struct.lua_TValue.349** %tm1, align 8
  %10 = load %struct.lua_TValue.349** %tm1, align 8
  %cmp5 = icmp eq %struct.lua_TValue.349* %10, null
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end3
  store %struct.lua_TValue.349* null, %struct.lua_TValue.349** %retval
  br label %return

if.end:                                           ; preds = %cond.end3
  %11 = load %struct.Table.357** %mt1.addr, align 8
  %12 = load %struct.Table.357** %mt2.addr, align 8
  %cmp7 = icmp eq %struct.Table.357* %11, %12
  br i1 %cmp7, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end
  %13 = load %struct.lua_TValue.349** %tm1, align 8
  store %struct.lua_TValue.349* %13, %struct.lua_TValue.349** %retval
  br label %return

if.end10:                                         ; preds = %if.end
  %14 = load %struct.Table.357** %mt2.addr, align 8
  %cmp11 = icmp eq %struct.Table.357* %14, null
  br i1 %cmp11, label %cond.true13, label %cond.false14

cond.true13:                                      ; preds = %if.end10
  br label %cond.end29

cond.false14:                                     ; preds = %if.end10
  %15 = load %struct.Table.357** %mt2.addr, align 8
  %flags15 = getelementptr inbounds %struct.Table.357* %15, i32 0, i32 3
  %16 = load i8* %flags15, align 1
  %conv16 = zext i8 %16 to i32
  %17 = load i32* %event.addr, align 4
  %shl17 = shl i32 1, %17
  %and18 = and i32 %conv16, %shl17
  %tobool19 = icmp ne i32 %and18, 0
  br i1 %tobool19, label %cond.true20, label %cond.false21

cond.true20:                                      ; preds = %cond.false14
  br label %cond.end27

cond.false21:                                     ; preds = %cond.false14
  %18 = load %struct.Table.357** %mt2.addr, align 8
  %19 = load i32* %event.addr, align 4
  %20 = load i32* %event.addr, align 4
  %idxprom22 = zext i32 %20 to i64
  %21 = load %struct.lua_State.364** %L.addr, align 8
  %l_G23 = getelementptr inbounds %struct.lua_State.364* %21, i32 0, i32 5
  %22 = load %struct.global_State.358** %l_G23, align 8
  %tmname24 = getelementptr inbounds %struct.global_State.358* %22, i32 0, i32 33
  %arrayidx25 = getelementptr inbounds [17 x %union.TString.367*]* %tmname24, i32 0, i64 %idxprom22
  %23 = load %union.TString.367** %arrayidx25, align 8
  %call26 = call %struct.lua_TValue.349* bitcast (%struct.lua_TValue* (%struct.Table*, i32, %union.TString*)* @luaT_gettm to %struct.lua_TValue.349* (%struct.Table.357*, i32, %union.TString.367*)*)(%struct.Table.357* %18, i32 %19, %union.TString.367* %23)
  br label %cond.end27

cond.end27:                                       ; preds = %cond.false21, %cond.true20
  %cond28 = phi %struct.lua_TValue.349* [ null, %cond.true20 ], [ %call26, %cond.false21 ]
  br label %cond.end29

cond.end29:                                       ; preds = %cond.end27, %cond.true13
  %cond30 = phi %struct.lua_TValue.349* [ null, %cond.true13 ], [ %cond28, %cond.end27 ]
  store %struct.lua_TValue.349* %cond30, %struct.lua_TValue.349** %tm2, align 8
  %24 = load %struct.lua_TValue.349** %tm2, align 8
  %cmp31 = icmp eq %struct.lua_TValue.349* %24, null
  br i1 %cmp31, label %if.then33, label %if.end34

if.then33:                                        ; preds = %cond.end29
  store %struct.lua_TValue.349* null, %struct.lua_TValue.349** %retval
  br label %return

if.end34:                                         ; preds = %cond.end29
  %25 = load %struct.lua_TValue.349** %tm1, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue.349* %25, i32 0, i32 1
  %26 = load i32* %tt_, align 4
  %27 = load %struct.lua_TValue.349** %tm2, align 8
  %tt_35 = getelementptr inbounds %struct.lua_TValue.349* %27, i32 0, i32 1
  %28 = load i32* %tt_35, align 4
  %cmp36 = icmp eq i32 %26, %28
  br i1 %cmp36, label %land.lhs.true, label %if.end41

land.lhs.true:                                    ; preds = %if.end34
  %29 = load %struct.lua_TValue.349** %tm1, align 8
  %30 = load %struct.lua_TValue.349** %tm2, align 8
  %call38 = call i32 @luaV_equalobj_(%struct.lua_State.364* null, %struct.lua_TValue.349* %29, %struct.lua_TValue.349* %30)
  %tobool39 = icmp ne i32 %call38, 0
  br i1 %tobool39, label %if.then40, label %if.end41

if.then40:                                        ; preds = %land.lhs.true
  %31 = load %struct.lua_TValue.349** %tm1, align 8
  store %struct.lua_TValue.349* %31, %struct.lua_TValue.349** %retval
  br label %return

if.end41:                                         ; preds = %land.lhs.true, %if.end34
  store %struct.lua_TValue.349* null, %struct.lua_TValue.349** %retval
  br label %return

return:                                           ; preds = %if.end41, %if.then40, %if.then33, %if.then9, %if.then
  %32 = load %struct.lua_TValue.349** %retval
  ret %struct.lua_TValue.349* %32
}

; Function Attrs: nounwind uwtable
define internal i32 @call_binTM(%struct.lua_State.364* %L, %struct.lua_TValue.349* %p1, %struct.lua_TValue.349* %p2, %struct.lua_TValue.349* %res, i32 %event) #0 {
entry:
  %retval = alloca i32, align 4
  %L.addr = alloca %struct.lua_State.364*, align 8
  %p1.addr = alloca %struct.lua_TValue.349*, align 8
  %p2.addr = alloca %struct.lua_TValue.349*, align 8
  %res.addr = alloca %struct.lua_TValue.349*, align 8
  %event.addr = alloca i32, align 4
  %tm = alloca %struct.lua_TValue.349*, align 8
  store %struct.lua_State.364* %L, %struct.lua_State.364** %L.addr, align 8
  store %struct.lua_TValue.349* %p1, %struct.lua_TValue.349** %p1.addr, align 8
  store %struct.lua_TValue.349* %p2, %struct.lua_TValue.349** %p2.addr, align 8
  store %struct.lua_TValue.349* %res, %struct.lua_TValue.349** %res.addr, align 8
  store i32 %event, i32* %event.addr, align 4
  %0 = load %struct.lua_State.364** %L.addr, align 8
  %1 = load %struct.lua_TValue.349** %p1.addr, align 8
  %2 = load i32* %event.addr, align 4
  %call = call %struct.lua_TValue.349* bitcast (%struct.lua_TValue* (%struct.lua_State*, %struct.lua_TValue*, i32)* @luaT_gettmbyobj to %struct.lua_TValue.349* (%struct.lua_State.364*, %struct.lua_TValue.349*, i32)*)(%struct.lua_State.364* %0, %struct.lua_TValue.349* %1, i32 %2)
  store %struct.lua_TValue.349* %call, %struct.lua_TValue.349** %tm, align 8
  %3 = load %struct.lua_TValue.349** %tm, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue.349* %3, i32 0, i32 1
  %4 = load i32* %tt_, align 4
  %cmp = icmp eq i32 %4, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load %struct.lua_State.364** %L.addr, align 8
  %6 = load %struct.lua_TValue.349** %p2.addr, align 8
  %7 = load i32* %event.addr, align 4
  %call1 = call %struct.lua_TValue.349* bitcast (%struct.lua_TValue* (%struct.lua_State*, %struct.lua_TValue*, i32)* @luaT_gettmbyobj to %struct.lua_TValue.349* (%struct.lua_State.364*, %struct.lua_TValue.349*, i32)*)(%struct.lua_State.364* %5, %struct.lua_TValue.349* %6, i32 %7)
  store %struct.lua_TValue.349* %call1, %struct.lua_TValue.349** %tm, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %8 = load %struct.lua_TValue.349** %tm, align 8
  %tt_2 = getelementptr inbounds %struct.lua_TValue.349* %8, i32 0, i32 1
  %9 = load i32* %tt_2, align 4
  %cmp3 = icmp eq i32 %9, 0
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  store i32 0, i32* %retval
  br label %return

if.end5:                                          ; preds = %if.end
  %10 = load %struct.lua_State.364** %L.addr, align 8
  %11 = load %struct.lua_TValue.349** %tm, align 8
  %12 = load %struct.lua_TValue.349** %p1.addr, align 8
  %13 = load %struct.lua_TValue.349** %p2.addr, align 8
  %14 = load %struct.lua_TValue.349** %res.addr, align 8
  call void @callTM(%struct.lua_State.364* %10, %struct.lua_TValue.349* %11, %struct.lua_TValue.349* %12, %struct.lua_TValue.349* %13, %struct.lua_TValue.349* %14, i32 1)
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %if.end5, %if.then4
  %15 = load i32* %retval
  ret i32 %15
}

; Function Attrs: nounwind uwtable
define internal void @traceexec(%struct.lua_State.364* %L) #0 {
entry:
  %L.addr = alloca %struct.lua_State.364*, align 8
  %ci = alloca %struct.CallInfo.361*, align 8
  %mask = alloca i8, align 1
  %counthook = alloca i32, align 4
  %p = alloca %struct.Proto.478*, align 8
  %npc = alloca i32, align 4
  %newline = alloca i32, align 4
  store %struct.lua_State.364* %L, %struct.lua_State.364** %L.addr, align 8
  %0 = load %struct.lua_State.364** %L.addr, align 8
  %ci1 = getelementptr inbounds %struct.lua_State.364* %0, i32 0, i32 6
  %1 = load %struct.CallInfo.361** %ci1, align 8
  store %struct.CallInfo.361* %1, %struct.CallInfo.361** %ci, align 8
  %2 = load %struct.lua_State.364** %L.addr, align 8
  %hookmask = getelementptr inbounds %struct.lua_State.364* %2, i32 0, i32 13
  %3 = load i8* %hookmask, align 1
  store i8 %3, i8* %mask, align 1
  %4 = load i8* %mask, align 1
  %conv = zext i8 %4 to i32
  %and = and i32 %conv, 8
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %5 = load %struct.lua_State.364** %L.addr, align 8
  %hookcount = getelementptr inbounds %struct.lua_State.364* %5, i32 0, i32 16
  %6 = load i32* %hookcount, align 4
  %cmp = icmp eq i32 %6, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %7 = phi i1 [ false, %entry ], [ %cmp, %land.rhs ]
  %land.ext = zext i1 %7 to i32
  store i32 %land.ext, i32* %counthook, align 4
  %8 = load i32* %counthook, align 4
  %tobool3 = icmp ne i32 %8, 0
  br i1 %tobool3, label %if.then, label %if.end

if.then:                                          ; preds = %land.end
  %9 = load %struct.lua_State.364** %L.addr, align 8
  %basehookcount = getelementptr inbounds %struct.lua_State.364* %9, i32 0, i32 15
  %10 = load i32* %basehookcount, align 4
  %11 = load %struct.lua_State.364** %L.addr, align 8
  %hookcount4 = getelementptr inbounds %struct.lua_State.364* %11, i32 0, i32 16
  store i32 %10, i32* %hookcount4, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %land.end
  %12 = load %struct.CallInfo.361** %ci, align 8
  %callstatus = getelementptr inbounds %struct.CallInfo.361* %12, i32 0, i32 5
  %13 = load i8* %callstatus, align 1
  %conv5 = zext i8 %13 to i32
  %and6 = and i32 %conv5, 128
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %if.then8, label %if.end13

if.then8:                                         ; preds = %if.end
  %14 = load %struct.CallInfo.361** %ci, align 8
  %callstatus9 = getelementptr inbounds %struct.CallInfo.361* %14, i32 0, i32 5
  %15 = load i8* %callstatus9, align 1
  %conv10 = zext i8 %15 to i32
  %and11 = and i32 %conv10, -129
  %conv12 = trunc i32 %and11 to i8
  store i8 %conv12, i8* %callstatus9, align 1
  br label %if.end75

if.end13:                                         ; preds = %if.end
  %16 = load i32* %counthook, align 4
  %tobool14 = icmp ne i32 %16, 0
  br i1 %tobool14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.end13
  %17 = load %struct.lua_State.364** %L.addr, align 8
  call void bitcast (void (%struct.lua_State*, i32, i32)* @luaD_hook to void (%struct.lua_State.364*, i32, i32)*)(%struct.lua_State.364* %17, i32 3, i32 -1)
  br label %if.end16

if.end16:                                         ; preds = %if.then15, %if.end13
  %18 = load i8* %mask, align 1
  %conv17 = zext i8 %18 to i32
  %and18 = and i32 %conv17, 4
  %tobool19 = icmp ne i32 %and18, 0
  br i1 %tobool19, label %if.then20, label %if.end55

if.then20:                                        ; preds = %if.end16
  %19 = load %struct.CallInfo.361** %ci, align 8
  %func = getelementptr inbounds %struct.CallInfo.361* %19, i32 0, i32 0
  %20 = load %struct.lua_TValue.349** %func, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue.349* %20, i32 0, i32 0
  %gc = bitcast %union.Value.348* %value_ to %union.GCObject.365**
  %21 = load %union.GCObject.365** %gc, align 8
  %cl = bitcast %union.GCObject.365* %21 to %union.Closure.475*
  %l = bitcast %union.Closure.475* %cl to %struct.LClosure.483*
  %p21 = getelementptr inbounds %struct.LClosure.483* %l, i32 0, i32 5
  %22 = load %struct.Proto.478** %p21, align 8
  store %struct.Proto.478* %22, %struct.Proto.478** %p, align 8
  %23 = load %struct.CallInfo.361** %ci, align 8
  %u = getelementptr inbounds %struct.CallInfo.361* %23, i32 0, i32 7
  %l22 = bitcast %union.anon.360* %u to %struct.anon.482*
  %savedpc = getelementptr inbounds %struct.anon.482* %l22, i32 0, i32 1
  %24 = load i32** %savedpc, align 8
  %25 = load %struct.Proto.478** %p, align 8
  %code = getelementptr inbounds %struct.Proto.478* %25, i32 0, i32 4
  %26 = load i32** %code, align 8
  %sub.ptr.lhs.cast = ptrtoint i32* %24 to i64
  %sub.ptr.rhs.cast = ptrtoint i32* %26 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 4
  %conv23 = trunc i64 %sub.ptr.div to i32
  %sub = sub nsw i32 %conv23, 1
  store i32 %sub, i32* %npc, align 4
  %27 = load %struct.Proto.478** %p, align 8
  %lineinfo = getelementptr inbounds %struct.Proto.478* %27, i32 0, i32 6
  %28 = load i32** %lineinfo, align 8
  %tobool24 = icmp ne i32* %28, null
  br i1 %tobool24, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then20
  %29 = load i32* %npc, align 4
  %idxprom = sext i32 %29 to i64
  %30 = load %struct.Proto.478** %p, align 8
  %lineinfo25 = getelementptr inbounds %struct.Proto.478* %30, i32 0, i32 6
  %31 = load i32** %lineinfo25, align 8
  %arrayidx = getelementptr inbounds i32* %31, i64 %idxprom
  %32 = load i32* %arrayidx, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.then20
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %32, %cond.true ], [ 0, %cond.false ]
  store i32 %cond, i32* %newline, align 4
  %33 = load i32* %npc, align 4
  %cmp26 = icmp eq i32 %33, 0
  br i1 %cmp26, label %if.then53, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end
  %34 = load %struct.CallInfo.361** %ci, align 8
  %u28 = getelementptr inbounds %struct.CallInfo.361* %34, i32 0, i32 7
  %l29 = bitcast %union.anon.360* %u28 to %struct.anon.482*
  %savedpc30 = getelementptr inbounds %struct.anon.482* %l29, i32 0, i32 1
  %35 = load i32** %savedpc30, align 8
  %36 = load %struct.lua_State.364** %L.addr, align 8
  %oldpc = getelementptr inbounds %struct.lua_State.364* %36, i32 0, i32 7
  %37 = load i32** %oldpc, align 8
  %cmp31 = icmp ule i32* %35, %37
  br i1 %cmp31, label %if.then53, label %lor.lhs.false33

lor.lhs.false33:                                  ; preds = %lor.lhs.false
  %38 = load i32* %newline, align 4
  %39 = load %struct.Proto.478** %p, align 8
  %lineinfo34 = getelementptr inbounds %struct.Proto.478* %39, i32 0, i32 6
  %40 = load i32** %lineinfo34, align 8
  %tobool35 = icmp ne i32* %40, null
  br i1 %tobool35, label %cond.true36, label %cond.false48

cond.true36:                                      ; preds = %lor.lhs.false33
  %41 = load %struct.lua_State.364** %L.addr, align 8
  %oldpc37 = getelementptr inbounds %struct.lua_State.364* %41, i32 0, i32 7
  %42 = load i32** %oldpc37, align 8
  %43 = load %struct.Proto.478** %p, align 8
  %code38 = getelementptr inbounds %struct.Proto.478* %43, i32 0, i32 4
  %44 = load i32** %code38, align 8
  %sub.ptr.lhs.cast39 = ptrtoint i32* %42 to i64
  %sub.ptr.rhs.cast40 = ptrtoint i32* %44 to i64
  %sub.ptr.sub41 = sub i64 %sub.ptr.lhs.cast39, %sub.ptr.rhs.cast40
  %sub.ptr.div42 = sdiv exact i64 %sub.ptr.sub41, 4
  %conv43 = trunc i64 %sub.ptr.div42 to i32
  %sub44 = sub nsw i32 %conv43, 1
  %idxprom45 = sext i32 %sub44 to i64
  %45 = load %struct.Proto.478** %p, align 8
  %lineinfo46 = getelementptr inbounds %struct.Proto.478* %45, i32 0, i32 6
  %46 = load i32** %lineinfo46, align 8
  %arrayidx47 = getelementptr inbounds i32* %46, i64 %idxprom45
  %47 = load i32* %arrayidx47, align 4
  br label %cond.end49

cond.false48:                                     ; preds = %lor.lhs.false33
  br label %cond.end49

cond.end49:                                       ; preds = %cond.false48, %cond.true36
  %cond50 = phi i32 [ %47, %cond.true36 ], [ 0, %cond.false48 ]
  %cmp51 = icmp ne i32 %38, %cond50
  br i1 %cmp51, label %if.then53, label %if.end54

if.then53:                                        ; preds = %cond.end49, %lor.lhs.false, %cond.end
  %48 = load %struct.lua_State.364** %L.addr, align 8
  %49 = load i32* %newline, align 4
  call void bitcast (void (%struct.lua_State*, i32, i32)* @luaD_hook to void (%struct.lua_State.364*, i32, i32)*)(%struct.lua_State.364* %48, i32 2, i32 %49)
  br label %if.end54

if.end54:                                         ; preds = %if.then53, %cond.end49
  br label %if.end55

if.end55:                                         ; preds = %if.end54, %if.end16
  %50 = load %struct.CallInfo.361** %ci, align 8
  %u56 = getelementptr inbounds %struct.CallInfo.361* %50, i32 0, i32 7
  %l57 = bitcast %union.anon.360* %u56 to %struct.anon.482*
  %savedpc58 = getelementptr inbounds %struct.anon.482* %l57, i32 0, i32 1
  %51 = load i32** %savedpc58, align 8
  %52 = load %struct.lua_State.364** %L.addr, align 8
  %oldpc59 = getelementptr inbounds %struct.lua_State.364* %52, i32 0, i32 7
  store i32* %51, i32** %oldpc59, align 8
  %53 = load %struct.lua_State.364** %L.addr, align 8
  %status = getelementptr inbounds %struct.lua_State.364* %53, i32 0, i32 3
  %54 = load i8* %status, align 1
  %conv60 = zext i8 %54 to i32
  %cmp61 = icmp eq i32 %conv60, 1
  br i1 %cmp61, label %if.then63, label %if.end75

if.then63:                                        ; preds = %if.end55
  %55 = load i32* %counthook, align 4
  %tobool64 = icmp ne i32 %55, 0
  br i1 %tobool64, label %if.then65, label %if.end67

if.then65:                                        ; preds = %if.then63
  %56 = load %struct.lua_State.364** %L.addr, align 8
  %hookcount66 = getelementptr inbounds %struct.lua_State.364* %56, i32 0, i32 16
  store i32 1, i32* %hookcount66, align 4
  br label %if.end67

if.end67:                                         ; preds = %if.then65, %if.then63
  %57 = load %struct.CallInfo.361** %ci, align 8
  %u68 = getelementptr inbounds %struct.CallInfo.361* %57, i32 0, i32 7
  %l69 = bitcast %union.anon.360* %u68 to %struct.anon.482*
  %savedpc70 = getelementptr inbounds %struct.anon.482* %l69, i32 0, i32 1
  %58 = load i32** %savedpc70, align 8
  %incdec.ptr = getelementptr inbounds i32* %58, i32 -1
  store i32* %incdec.ptr, i32** %savedpc70, align 8
  %59 = load %struct.CallInfo.361** %ci, align 8
  %callstatus71 = getelementptr inbounds %struct.CallInfo.361* %59, i32 0, i32 5
  %60 = load i8* %callstatus71, align 1
  %conv72 = zext i8 %60 to i32
  %or = or i32 %conv72, 128
  %conv73 = trunc i32 %or to i8
  store i8 %conv73, i8* %callstatus71, align 1
  %61 = load %struct.lua_State.364** %L.addr, align 8
  %top = getelementptr inbounds %struct.lua_State.364* %61, i32 0, i32 4
  %62 = load %struct.lua_TValue.349** %top, align 8
  %add.ptr = getelementptr inbounds %struct.lua_TValue.349* %62, i64 -1
  %63 = load %struct.CallInfo.361** %ci, align 8
  %func74 = getelementptr inbounds %struct.CallInfo.361* %63, i32 0, i32 0
  store %struct.lua_TValue.349* %add.ptr, %struct.lua_TValue.349** %func74, align 8
  %64 = load %struct.lua_State.364** %L.addr, align 8
  call void bitcast (void (%struct.lua_State*, i32)* @luaD_throw to void (%struct.lua_State.364*, i32)*)(%struct.lua_State.364* %64, i32 1) #9
  unreachable

if.end75:                                         ; preds = %if.end55, %if.then8
  ret void
}

; Function Attrs: nounwind uwtable
define internal %union.Closure.475* @getcached(%struct.Proto.478* %p, %struct.UpVal.352** %encup, %struct.lua_TValue.349* %base) #0 {
entry:
  %retval = alloca %union.Closure.475*, align 8
  %p.addr = alloca %struct.Proto.478*, align 8
  %encup.addr = alloca %struct.UpVal.352**, align 8
  %base.addr = alloca %struct.lua_TValue.349*, align 8
  %c = alloca %union.Closure.475*, align 8
  %nup = alloca i32, align 4
  %uv = alloca %struct.Upvaldesc.477*, align 8
  %i = alloca i32, align 4
  %v = alloca %struct.lua_TValue.349*, align 8
  store %struct.Proto.478* %p, %struct.Proto.478** %p.addr, align 8
  store %struct.UpVal.352** %encup, %struct.UpVal.352*** %encup.addr, align 8
  store %struct.lua_TValue.349* %base, %struct.lua_TValue.349** %base.addr, align 8
  %0 = load %struct.Proto.478** %p.addr, align 8
  %cache = getelementptr inbounds %struct.Proto.478* %0, i32 0, i32 9
  %1 = load %union.Closure.475** %cache, align 8
  store %union.Closure.475* %1, %union.Closure.475** %c, align 8
  %2 = load %union.Closure.475** %c, align 8
  %cmp = icmp ne %union.Closure.475* %2, null
  br i1 %cmp, label %if.then, label %if.end17

if.then:                                          ; preds = %entry
  %3 = load %struct.Proto.478** %p.addr, align 8
  %sizeupvalues = getelementptr inbounds %struct.Proto.478* %3, i32 0, i32 11
  %4 = load i32* %sizeupvalues, align 4
  store i32 %4, i32* %nup, align 4
  %5 = load %struct.Proto.478** %p.addr, align 8
  %upvalues = getelementptr inbounds %struct.Proto.478* %5, i32 0, i32 8
  %6 = load %struct.Upvaldesc.477** %upvalues, align 8
  store %struct.Upvaldesc.477* %6, %struct.Upvaldesc.477** %uv, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %7 = load i32* %i, align 4
  %8 = load i32* %nup, align 4
  %cmp1 = icmp slt i32 %7, %8
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load i32* %i, align 4
  %idxprom = sext i32 %9 to i64
  %10 = load %struct.Upvaldesc.477** %uv, align 8
  %arrayidx = getelementptr inbounds %struct.Upvaldesc.477* %10, i64 %idxprom
  %instack = getelementptr inbounds %struct.Upvaldesc.477* %arrayidx, i32 0, i32 1
  %11 = load i8* %instack, align 1
  %conv = zext i8 %11 to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  %12 = load %struct.lua_TValue.349** %base.addr, align 8
  %13 = load i32* %i, align 4
  %idxprom2 = sext i32 %13 to i64
  %14 = load %struct.Upvaldesc.477** %uv, align 8
  %arrayidx3 = getelementptr inbounds %struct.Upvaldesc.477* %14, i64 %idxprom2
  %idx = getelementptr inbounds %struct.Upvaldesc.477* %arrayidx3, i32 0, i32 2
  %15 = load i8* %idx, align 1
  %conv4 = zext i8 %15 to i32
  %idx.ext = sext i32 %conv4 to i64
  %add.ptr = getelementptr inbounds %struct.lua_TValue.349* %12, i64 %idx.ext
  br label %cond.end

cond.false:                                       ; preds = %for.body
  %16 = load i32* %i, align 4
  %idxprom5 = sext i32 %16 to i64
  %17 = load %struct.Upvaldesc.477** %uv, align 8
  %arrayidx6 = getelementptr inbounds %struct.Upvaldesc.477* %17, i64 %idxprom5
  %idx7 = getelementptr inbounds %struct.Upvaldesc.477* %arrayidx6, i32 0, i32 2
  %18 = load i8* %idx7, align 1
  %idxprom8 = zext i8 %18 to i64
  %19 = load %struct.UpVal.352*** %encup.addr, align 8
  %arrayidx9 = getelementptr inbounds %struct.UpVal.352** %19, i64 %idxprom8
  %20 = load %struct.UpVal.352** %arrayidx9, align 8
  %v10 = getelementptr inbounds %struct.UpVal.352* %20, i32 0, i32 3
  %21 = load %struct.lua_TValue.349** %v10, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.lua_TValue.349* [ %add.ptr, %cond.true ], [ %21, %cond.false ]
  store %struct.lua_TValue.349* %cond, %struct.lua_TValue.349** %v, align 8
  %22 = load i32* %i, align 4
  %idxprom11 = sext i32 %22 to i64
  %23 = load %union.Closure.475** %c, align 8
  %l = bitcast %union.Closure.475* %23 to %struct.LClosure.483*
  %upvals = getelementptr inbounds %struct.LClosure.483* %l, i32 0, i32 6
  %arrayidx12 = getelementptr inbounds [1 x %struct.UpVal.352*]* %upvals, i32 0, i64 %idxprom11
  %24 = load %struct.UpVal.352** %arrayidx12, align 8
  %v13 = getelementptr inbounds %struct.UpVal.352* %24, i32 0, i32 3
  %25 = load %struct.lua_TValue.349** %v13, align 8
  %26 = load %struct.lua_TValue.349** %v, align 8
  %cmp14 = icmp ne %struct.lua_TValue.349* %25, %26
  br i1 %cmp14, label %if.then16, label %if.end

if.then16:                                        ; preds = %cond.end
  store %union.Closure.475* null, %union.Closure.475** %retval
  br label %return

if.end:                                           ; preds = %cond.end
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %27 = load i32* %i, align 4
  %inc = add nsw i32 %27, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end17

if.end17:                                         ; preds = %for.end, %entry
  %28 = load %union.Closure.475** %c, align 8
  store %union.Closure.475* %28, %union.Closure.475** %retval
  br label %return

return:                                           ; preds = %if.end17, %if.then16
  %29 = load %union.Closure.475** %retval
  ret %union.Closure.475* %29
}

; Function Attrs: nounwind uwtable
define internal void @pushclosure(%struct.lua_State.364* %L, %struct.Proto.478* %p, %struct.UpVal.352** %encup, %struct.lua_TValue.349* %base, %struct.lua_TValue.349* %ra) #0 {
entry:
  %L.addr = alloca %struct.lua_State.364*, align 8
  %p.addr = alloca %struct.Proto.478*, align 8
  %encup.addr = alloca %struct.UpVal.352**, align 8
  %base.addr = alloca %struct.lua_TValue.349*, align 8
  %ra.addr = alloca %struct.lua_TValue.349*, align 8
  %nup = alloca i32, align 4
  %uv = alloca %struct.Upvaldesc.477*, align 8
  %i = alloca i32, align 4
  %ncl = alloca %union.Closure.475*, align 8
  %io = alloca %struct.lua_TValue.349*, align 8
  store %struct.lua_State.364* %L, %struct.lua_State.364** %L.addr, align 8
  store %struct.Proto.478* %p, %struct.Proto.478** %p.addr, align 8
  store %struct.UpVal.352** %encup, %struct.UpVal.352*** %encup.addr, align 8
  store %struct.lua_TValue.349* %base, %struct.lua_TValue.349** %base.addr, align 8
  store %struct.lua_TValue.349* %ra, %struct.lua_TValue.349** %ra.addr, align 8
  %0 = load %struct.Proto.478** %p.addr, align 8
  %sizeupvalues = getelementptr inbounds %struct.Proto.478* %0, i32 0, i32 11
  %1 = load i32* %sizeupvalues, align 4
  store i32 %1, i32* %nup, align 4
  %2 = load %struct.Proto.478** %p.addr, align 8
  %upvalues = getelementptr inbounds %struct.Proto.478* %2, i32 0, i32 8
  %3 = load %struct.Upvaldesc.477** %upvalues, align 8
  store %struct.Upvaldesc.477* %3, %struct.Upvaldesc.477** %uv, align 8
  %4 = load %struct.lua_State.364** %L.addr, align 8
  %5 = load i32* %nup, align 4
  %call = call %union.Closure.475* bitcast (%union.Closure.157* (%struct.lua_State.154*, i32)* @luaF_newLclosure to %union.Closure.475* (%struct.lua_State.364*, i32)*)(%struct.lua_State.364* %4, i32 %5)
  store %union.Closure.475* %call, %union.Closure.475** %ncl, align 8
  %6 = load %struct.Proto.478** %p.addr, align 8
  %7 = load %union.Closure.475** %ncl, align 8
  %l = bitcast %union.Closure.475* %7 to %struct.LClosure.483*
  %p1 = getelementptr inbounds %struct.LClosure.483* %l, i32 0, i32 5
  store %struct.Proto.478* %6, %struct.Proto.478** %p1, align 8
  %8 = load %struct.lua_TValue.349** %ra.addr, align 8
  store %struct.lua_TValue.349* %8, %struct.lua_TValue.349** %io, align 8
  %9 = load %union.Closure.475** %ncl, align 8
  %10 = bitcast %union.Closure.475* %9 to %union.GCObject.365*
  %11 = load %struct.lua_TValue.349** %io, align 8
  %value_ = getelementptr inbounds %struct.lua_TValue.349* %11, i32 0, i32 0
  %gc = bitcast %union.Value.348* %value_ to %union.GCObject.365**
  store %union.GCObject.365* %10, %union.GCObject.365** %gc, align 8
  %12 = load %struct.lua_TValue.349** %io, align 8
  %tt_ = getelementptr inbounds %struct.lua_TValue.349* %12, i32 0, i32 1
  store i32 70, i32* %tt_, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %13 = load i32* %i, align 4
  %14 = load i32* %nup, align 4
  %cmp = icmp slt i32 %13, %14
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %15 = load i32* %i, align 4
  %idxprom = sext i32 %15 to i64
  %16 = load %struct.Upvaldesc.477** %uv, align 8
  %arrayidx = getelementptr inbounds %struct.Upvaldesc.477* %16, i64 %idxprom
  %instack = getelementptr inbounds %struct.Upvaldesc.477* %arrayidx, i32 0, i32 1
  %17 = load i8* %instack, align 1
  %tobool = icmp ne i8 %17, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %18 = load %struct.lua_State.364** %L.addr, align 8
  %19 = load %struct.lua_TValue.349** %base.addr, align 8
  %20 = load i32* %i, align 4
  %idxprom2 = sext i32 %20 to i64
  %21 = load %struct.Upvaldesc.477** %uv, align 8
  %arrayidx3 = getelementptr inbounds %struct.Upvaldesc.477* %21, i64 %idxprom2
  %idx = getelementptr inbounds %struct.Upvaldesc.477* %arrayidx3, i32 0, i32 2
  %22 = load i8* %idx, align 1
  %conv = zext i8 %22 to i32
  %idx.ext = sext i32 %conv to i64
  %add.ptr = getelementptr inbounds %struct.lua_TValue.349* %19, i64 %idx.ext
  %call4 = call %struct.UpVal.352* bitcast (%struct.UpVal.140* (%struct.lua_State.154*, %struct.lua_TValue.137*)* @luaF_findupval to %struct.UpVal.352* (%struct.lua_State.364*, %struct.lua_TValue.349*)*)(%struct.lua_State.364* %18, %struct.lua_TValue.349* %add.ptr)
  %23 = load i32* %i, align 4
  %idxprom5 = sext i32 %23 to i64
  %24 = load %union.Closure.475** %ncl, align 8
  %l6 = bitcast %union.Closure.475* %24 to %struct.LClosure.483*
  %upvals = getelementptr inbounds %struct.LClosure.483* %l6, i32 0, i32 6
  %arrayidx7 = getelementptr inbounds [1 x %struct.UpVal.352*]* %upvals, i32 0, i64 %idxprom5
  store %struct.UpVal.352* %call4, %struct.UpVal.352** %arrayidx7, align 8
  br label %if.end

if.else:                                          ; preds = %for.body
  %25 = load i32* %i, align 4
  %idxprom8 = sext i32 %25 to i64
  %26 = load %struct.Upvaldesc.477** %uv, align 8
  %arrayidx9 = getelementptr inbounds %struct.Upvaldesc.477* %26, i64 %idxprom8
  %idx10 = getelementptr inbounds %struct.Upvaldesc.477* %arrayidx9, i32 0, i32 2
  %27 = load i8* %idx10, align 1
  %idxprom11 = zext i8 %27 to i64
  %28 = load %struct.UpVal.352*** %encup.addr, align 8
  %arrayidx12 = getelementptr inbounds %struct.UpVal.352** %28, i64 %idxprom11
  %29 = load %struct.UpVal.352** %arrayidx12, align 8
  %30 = load i32* %i, align 4
  %idxprom13 = sext i32 %30 to i64
  %31 = load %union.Closure.475** %ncl, align 8
  %l14 = bitcast %union.Closure.475* %31 to %struct.LClosure.483*
  %upvals15 = getelementptr inbounds %struct.LClosure.483* %l14, i32 0, i32 6
  %arrayidx16 = getelementptr inbounds [1 x %struct.UpVal.352*]* %upvals15, i32 0, i64 %idxprom13
  store %struct.UpVal.352* %29, %struct.UpVal.352** %arrayidx16, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %32 = load i32* %i, align 4
  %inc = add nsw i32 %32, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %33 = load %struct.Proto.478** %p.addr, align 8
  %34 = bitcast %struct.Proto.478* %33 to %union.GCObject.365*
  %gch = bitcast %union.GCObject.365* %34 to %struct.GCheader.479*
  %marked = getelementptr inbounds %struct.GCheader.479* %gch, i32 0, i32 2
  %35 = load i8* %marked, align 1
  %conv17 = zext i8 %35 to i32
  %and = and i32 %conv17, 4
  %tobool18 = icmp ne i32 %and, 0
  br i1 %tobool18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %for.end
  %36 = load %struct.lua_State.364** %L.addr, align 8
  %37 = load %struct.Proto.478** %p.addr, align 8
  %38 = load %union.Closure.475** %ncl, align 8
  call void bitcast (void (%struct.lua_State*, %struct.Proto*, %union.Closure*)* @luaC_barrierproto_ to void (%struct.lua_State.364*, %struct.Proto.478*, %union.Closure.475*)*)(%struct.lua_State.364* %36, %struct.Proto.478* %37, %union.Closure.475* %38)
  br label %if.end20

if.end20:                                         ; preds = %if.then19, %for.end
  %39 = load %union.Closure.475** %ncl, align 8
  %40 = load %struct.Proto.478** %p.addr, align 8
  %cache = getelementptr inbounds %struct.Proto.478* %40, i32 0, i32 9
  store %union.Closure.475* %39, %union.Closure.475** %cache, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define hidden i32 @luaZ_fill(%struct.Zio* %z) #0 {
entry:
  %retval = alloca i32, align 4
  %z.addr = alloca %struct.Zio*, align 8
  %size = alloca i64, align 8
  %L = alloca %struct.lua_State*, align 8
  %buff = alloca i8*, align 8
  store %struct.Zio* %z, %struct.Zio** %z.addr, align 8
  %0 = load %struct.Zio** %z.addr, align 8
  %L1 = getelementptr inbounds %struct.Zio* %0, i32 0, i32 4
  %1 = load %struct.lua_State** %L1, align 8
  store %struct.lua_State* %1, %struct.lua_State** %L, align 8
  %2 = load %struct.Zio** %z.addr, align 8
  %reader = getelementptr inbounds %struct.Zio* %2, i32 0, i32 2
  %3 = load i8* (%struct.lua_State*, i8*, i64*)** %reader, align 8
  %4 = load %struct.lua_State** %L, align 8
  %5 = load %struct.Zio** %z.addr, align 8
  %data = getelementptr inbounds %struct.Zio* %5, i32 0, i32 3
  %6 = load i8** %data, align 8
  %call = call i8* %3(%struct.lua_State* %4, i8* %6, i64* %size)
  store i8* %call, i8** %buff, align 8
  %7 = load i8** %buff, align 8
  %cmp = icmp eq i8* %7, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %8 = load i64* %size, align 8
  %cmp2 = icmp eq i64 %8, 0
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 -1, i32* %retval
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %9 = load i64* %size, align 8
  %sub = sub i64 %9, 1
  %10 = load %struct.Zio** %z.addr, align 8
  %n = getelementptr inbounds %struct.Zio* %10, i32 0, i32 0
  store i64 %sub, i64* %n, align 8
  %11 = load i8** %buff, align 8
  %12 = load %struct.Zio** %z.addr, align 8
  %p = getelementptr inbounds %struct.Zio* %12, i32 0, i32 1
  store i8* %11, i8** %p, align 8
  %13 = load %struct.Zio** %z.addr, align 8
  %p3 = getelementptr inbounds %struct.Zio* %13, i32 0, i32 1
  %14 = load i8** %p3, align 8
  %incdec.ptr = getelementptr inbounds i8* %14, i32 1
  store i8* %incdec.ptr, i8** %p3, align 8
  %15 = load i8* %14, align 1
  %conv = zext i8 %15 to i32
  store i32 %conv, i32* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %16 = load i32* %retval
  ret i32 %16
}

; Function Attrs: nounwind uwtable
define hidden void @luaZ_init(%struct.lua_State* %L, %struct.Zio* %z, i8* (%struct.lua_State*, i8*, i64*)* %reader, i8* %data) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %z.addr = alloca %struct.Zio*, align 8
  %reader.addr = alloca i8* (%struct.lua_State*, i8*, i64*)*, align 8
  %data.addr = alloca i8*, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.Zio* %z, %struct.Zio** %z.addr, align 8
  store i8* (%struct.lua_State*, i8*, i64*)* %reader, i8* (%struct.lua_State*, i8*, i64*)** %reader.addr, align 8
  store i8* %data, i8** %data.addr, align 8
  %0 = load %struct.lua_State** %L.addr, align 8
  %1 = load %struct.Zio** %z.addr, align 8
  %L1 = getelementptr inbounds %struct.Zio* %1, i32 0, i32 4
  store %struct.lua_State* %0, %struct.lua_State** %L1, align 8
  %2 = load i8* (%struct.lua_State*, i8*, i64*)** %reader.addr, align 8
  %3 = load %struct.Zio** %z.addr, align 8
  %reader2 = getelementptr inbounds %struct.Zio* %3, i32 0, i32 2
  store i8* (%struct.lua_State*, i8*, i64*)* %2, i8* (%struct.lua_State*, i8*, i64*)** %reader2, align 8
  %4 = load i8** %data.addr, align 8
  %5 = load %struct.Zio** %z.addr, align 8
  %data3 = getelementptr inbounds %struct.Zio* %5, i32 0, i32 3
  store i8* %4, i8** %data3, align 8
  %6 = load %struct.Zio** %z.addr, align 8
  %n = getelementptr inbounds %struct.Zio* %6, i32 0, i32 0
  store i64 0, i64* %n, align 8
  %7 = load %struct.Zio** %z.addr, align 8
  %p = getelementptr inbounds %struct.Zio* %7, i32 0, i32 1
  store i8* null, i8** %p, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define hidden i64 @luaZ_read(%struct.Zio* %z, i8* %b, i64 %n) #0 {
entry:
  %retval = alloca i64, align 8
  %z.addr = alloca %struct.Zio*, align 8
  %b.addr = alloca i8*, align 8
  %n.addr = alloca i64, align 8
  %m = alloca i64, align 8
  store %struct.Zio* %z, %struct.Zio** %z.addr, align 8
  store i8* %b, i8** %b.addr, align 8
  store i64 %n, i64* %n.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %cond.end, %entry
  %0 = load i64* %n.addr, align 8
  %tobool = icmp ne i64 %0, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load %struct.Zio** %z.addr, align 8
  %n1 = getelementptr inbounds %struct.Zio* %1, i32 0, i32 0
  %2 = load i64* %n1, align 8
  %cmp = icmp eq i64 %2, 0
  br i1 %cmp, label %if.then, label %if.end5

if.then:                                          ; preds = %while.body
  %3 = load %struct.Zio** %z.addr, align 8
  %call = call i32 @luaZ_fill(%struct.Zio* %3)
  %cmp2 = icmp eq i32 %call, -1
  br i1 %cmp2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.then
  %4 = load i64* %n.addr, align 8
  store i64 %4, i64* %retval
  br label %return

if.else:                                          ; preds = %if.then
  %5 = load %struct.Zio** %z.addr, align 8
  %n4 = getelementptr inbounds %struct.Zio* %5, i32 0, i32 0
  %6 = load i64* %n4, align 8
  %inc = add i64 %6, 1
  store i64 %inc, i64* %n4, align 8
  %7 = load %struct.Zio** %z.addr, align 8
  %p = getelementptr inbounds %struct.Zio* %7, i32 0, i32 1
  %8 = load i8** %p, align 8
  %incdec.ptr = getelementptr inbounds i8* %8, i32 -1
  store i8* %incdec.ptr, i8** %p, align 8
  br label %if.end

if.end:                                           ; preds = %if.else
  br label %if.end5

if.end5:                                          ; preds = %if.end, %while.body
  %9 = load i64* %n.addr, align 8
  %10 = load %struct.Zio** %z.addr, align 8
  %n6 = getelementptr inbounds %struct.Zio* %10, i32 0, i32 0
  %11 = load i64* %n6, align 8
  %cmp7 = icmp ule i64 %9, %11
  br i1 %cmp7, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end5
  %12 = load i64* %n.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end5
  %13 = load %struct.Zio** %z.addr, align 8
  %n8 = getelementptr inbounds %struct.Zio* %13, i32 0, i32 0
  %14 = load i64* %n8, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %12, %cond.true ], [ %14, %cond.false ]
  store i64 %cond, i64* %m, align 8
  %15 = load i8** %b.addr, align 8
  %16 = load %struct.Zio** %z.addr, align 8
  %p9 = getelementptr inbounds %struct.Zio* %16, i32 0, i32 1
  %17 = load i8** %p9, align 8
  %18 = load i64* %m, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %15, i8* %17, i64 %18, i32 1, i1 false)
  %19 = load i64* %m, align 8
  %20 = load %struct.Zio** %z.addr, align 8
  %n10 = getelementptr inbounds %struct.Zio* %20, i32 0, i32 0
  %21 = load i64* %n10, align 8
  %sub = sub i64 %21, %19
  store i64 %sub, i64* %n10, align 8
  %22 = load i64* %m, align 8
  %23 = load %struct.Zio** %z.addr, align 8
  %p11 = getelementptr inbounds %struct.Zio* %23, i32 0, i32 1
  %24 = load i8** %p11, align 8
  %add.ptr = getelementptr inbounds i8* %24, i64 %22
  store i8* %add.ptr, i8** %p11, align 8
  %25 = load i8** %b.addr, align 8
  %26 = load i64* %m, align 8
  %add.ptr12 = getelementptr inbounds i8* %25, i64 %26
  store i8* %add.ptr12, i8** %b.addr, align 8
  %27 = load i64* %m, align 8
  %28 = load i64* %n.addr, align 8
  %sub13 = sub i64 %28, %27
  store i64 %sub13, i64* %n.addr, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  store i64 0, i64* %retval
  br label %return

return:                                           ; preds = %while.end, %if.then3
  %29 = load i64* %retval
  ret i64 %29
}

; Function Attrs: nounwind uwtable
define hidden i8* @luaZ_openspace(%struct.lua_State* %L, %struct.Mbuffer* %buff, i64 %n) #0 {
entry:
  %L.addr = alloca %struct.lua_State*, align 8
  %buff.addr = alloca %struct.Mbuffer*, align 8
  %n.addr = alloca i64, align 8
  store %struct.lua_State* %L, %struct.lua_State** %L.addr, align 8
  store %struct.Mbuffer* %buff, %struct.Mbuffer** %buff.addr, align 8
  store i64 %n, i64* %n.addr, align 8
  %0 = load i64* %n.addr, align 8
  %1 = load %struct.Mbuffer** %buff.addr, align 8
  %buffsize = getelementptr inbounds %struct.Mbuffer* %1, i32 0, i32 2
  %2 = load i64* %buffsize, align 8
  %cmp = icmp ugt i64 %0, %2
  br i1 %cmp, label %if.then, label %if.end8

if.then:                                          ; preds = %entry
  %3 = load i64* %n.addr, align 8
  %cmp1 = icmp ult i64 %3, 32
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  store i64 32, i64* %n.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then2, %if.then
  %4 = load i64* %n.addr, align 8
  %add = add i64 %4, 1
  %cmp3 = icmp ugt i64 %add, -3
  br i1 %cmp3, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %5 = load %struct.lua_State** %L.addr, align 8
  call void @luaM_toobig(%struct.lua_State* %5) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.false:                                       ; preds = %if.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %6
  %cond = phi i32 [ 0, %6 ], [ 0, %cond.false ]
  %7 = load %struct.lua_State** %L.addr, align 8
  %8 = load %struct.Mbuffer** %buff.addr, align 8
  %buffer = getelementptr inbounds %struct.Mbuffer* %8, i32 0, i32 0
  %9 = load i8** %buffer, align 8
  %10 = load %struct.Mbuffer** %buff.addr, align 8
  %buffsize4 = getelementptr inbounds %struct.Mbuffer* %10, i32 0, i32 2
  %11 = load i64* %buffsize4, align 8
  %mul = mul i64 %11, 1
  %12 = load i64* %n.addr, align 8
  %mul5 = mul i64 %12, 1
  %call = call i8* @luaM_realloc_(%struct.lua_State* %7, i8* %9, i64 %mul, i64 %mul5)
  %13 = load %struct.Mbuffer** %buff.addr, align 8
  %buffer6 = getelementptr inbounds %struct.Mbuffer* %13, i32 0, i32 0
  store i8* %call, i8** %buffer6, align 8
  %14 = load i64* %n.addr, align 8
  %15 = load %struct.Mbuffer** %buff.addr, align 8
  %buffsize7 = getelementptr inbounds %struct.Mbuffer* %15, i32 0, i32 2
  store i64 %14, i64* %buffsize7, align 8
  br label %if.end8

if.end8:                                          ; preds = %cond.end, %entry
  %16 = load %struct.Mbuffer** %buff.addr, align 8
  %buffer9 = getelementptr inbounds %struct.Mbuffer* %16, i32 0, i32 0
  %17 = load i8** %buffer9, align 8
  ret i8* %17
}

; Function Attrs: nounwind
declare void @llvm.lifetime.start(i64, i8* nocapture) #1

; Function Attrs: nounwind
declare void @llvm.lifetime.end(i64, i8* nocapture) #1

attributes #0 = { nounwind uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind }
attributes #2 = { nounwind readonly "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind readnone "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { noreturn nounwind uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #7 = { noreturn nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #8 = { nounwind returns_twice "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #9 = { noreturn }
attributes #10 = { nounwind readonly }
attributes #11 = { nounwind readnone }
attributes #12 = { noreturn nounwind }
attributes #13 = { nounwind returns_twice }

!llvm.ident = !{!0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0}

!0 = metadata !{metadata !"clang version 3.5 (trunk 195908)"}
