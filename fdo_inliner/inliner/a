#include "llvm/Pass.h"
#include "llvm/Analysis/CallGraph.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/IntrinsicInst.h"
#include "llvm/IR/Module.h"
#include "llvm/Analysis/LoopInfo.h"
#include "llvm/Support/CallSite.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/raw_ostream.h"
using namespace llvm;

namespace {

    class loopdetector : public ModulePass {
    public:
  	static char ID;
	loopdetector(ID):ModulePass(ID){};
	virtual bool runOnModule(Module &M);
	virtual void getAnalysisUsage(AnalysisUsage &AU) const{ 
	        AU.addRequired<LoopInfo>();
	}
    }; 

 
    bool loopdetector::runOnModule(Module &M) {

  	CallGraph::initialize(M);
    	ExternalCallingNode = getOrInsertFunction(0);
    	CallsExternalNode = new CallGraphNode(0);
    	Root = 0;
	//populating CallGraph
    	for (Module::iterator I = M.begin(), E = M.end(); I != E; ++I){
		++fnctr;
		int bb_local=(int)I->size();
		//errs()<<"\nFunction: "<<I->getName()<<" Blocks: "<<bb_local;
      		traverseFunction(I);
		if (bb_local){
			if (maxbb < bb_local)
				maxbb=bb_local;
			if (minbb == -1 ||  minbb > bb_local)
				minbb=bb_local;
			totalbb += bb_local;
		}
		else
			++extctr;
		//errs()<<"\n"<<I->getName()<<" : is_ext: "<<is_ext<<" Basic blocks: "<<bb_local;
 	}
	avgbb=(double)totalbb/(fnctr-extctr);
	avgcfg=(double)totalcfg/(fnctr-extctr);
	avgloop=(double)totalloop/(fnctr-extctr);
	avgloopbb=(double)totalloopbb/(fnctr-extctr);
	avgdom=(double)domctr/totalbb;
	 
    	if (Root == 0) 
		Root = ExternalCallingNode;
   
    	print_solution();
   	return false;
    }

    
    void loopdetector::traverseFunction(Function *F) {

    	CallGraphNode *Node = getOrInsertFunction(F);
	
	is_ext=false;

    	if (!F->hasLocalLinkage()) {
    		ExternalCallingNode->addCalledFunction(CallSite(), Node);
    	  	if (F->getName() == "main") {
    	  		if (Root)    
    				Root = ExternalCallingNode;
            	  	else
          			Root = Node;        
      		}
    	}

    	if (F->hasAddressTaken()){
    		ExternalCallingNode->addCalledFunction(CallSite(), Node);
	}

    	if (F->isDeclaration() && !F->isIntrinsic()){
      		Node->addCalledFunction(CallSite(), CallsExternalNode);
		is_ext=true;
	}

	int cfgedge_local=0;
 
   	for (Function::iterator BB = F->begin(), BBE = F->end(); BB != BBE; ++BB){
   	
		//calculating edge counts of CallGraph

      		for (BasicBlock::iterator II = BB->begin(), IE = BB->end() ; II!= IE ; ++II){
        		CallSite CS(cast<Value>(II));
        		if (CS) {
				++ectr;
          			Function *Callee = CS.getCalledFunction();
          			if (!Callee)
            				Node->addCalledFunction(CS, CallsExternalNode);
          			else if (!Callee->isIntrinsic())
            				Node->addCalledFunction(CS, getOrInsertFunction(Callee));
        		}
      		}

		//calculating number of CFG edges.

		TerminatorInst *term=BB->getTerminator();
		cfgedge_local+=term->getNumSuccessors();
	}

	//loop detection and dominance relations

	int loop_local=0;
	int loopbb_local=0;

	if(F->size()!=0){
		DominatorTree &DT = getAnalysis<DominatorTree>(*F) ;
		LoopInfo &LI = getAnalysis<LoopInfo>(*F) ;
  
 		for (Function::iterator BB = F->begin(), BBE = F->end(); BB != BBE; ++BB){

			//back edge counting 

			TerminatorInst *term=BB->getTerminator();
			for(unsigned int i= 0 ; i < term->getNumSuccessors() ; ++i) {
				BasicBlock *succBB = term->getSuccessor(i);
				if(succBB && DT.dominates(succBB,BB)) 
					++loop_local; 
			}

			//loop block counting

			if (LI.getLoopFor(BB))
				++loopbb_local;	

			//dominance relation count

			for (Function::iterator BB2 = F->begin(), BBE2 = F->end(); BB2 != BBE2; ++BB2){
				if (DT.dominates(BB,BB2))
					domctr++;				
      			}
		}	
	}

	if (!is_ext){
		if (maxcfg < cfgedge_local)
			maxcfg=cfgedge_local;
		if (mincfg == -1 ||  mincfg > cfgedge_local)
			mincfg=cfgedge_local;
		totalcfg += cfgedge_local;

		if (maxloop < loop_local)
			maxloop=loop_local;
		if (minloop == -1 ||  minloop > loop_local)
			minloop=loop_local;
		totalloop += loop_local;

		if (maxloopbb < loopbb_local)
			maxloopbb=loopbb_local;
		if (minloopbb == -1 ||  minloopbb > loopbb_local)
			minloopbb=loopbb_local;
		totalloopbb += loopbb_local;
	}

	//detecting unreachable code;

	if(cfgedge_local==0)
		return;
 
  	SmallPtrSet<BasicBlock*, 16>reachset;
	for (df_ext_iterator<Function*, SmallPtrSet<BasicBlock*, 16> > I = df_ext_begin(F,reachset), E = df_ext_end(F, reachset); I != E; ++I);

	std::vector<BasicBlock*> unreachable_bbs;
	int unreachable_removed=0;

	for (Function::iterator I = F->begin(), E = F->end(); I != E; ++I){
		if (!reachset.count(I)) {
			BasicBlock *BB = I;
			unreachable_bbs.push_back(BB);
			while (PHINode *phinode = dyn_cast<PHINode>(BB->begin())) {
				phinode->replaceAllUsesWith(Constant::getNullValue(phinode->getType()));
			        BB->getInstList().pop_front();
			}
			for (succ_iterator SI = succ_begin(BB), E = succ_end(BB); SI != E; ++SI)
			        (*SI)->removePredecessor(BB);
		        BB->dropAllReferences();
		        
		}
	}

		// Removing Blocks 

	for (unsigned i = 0, e = unreachable_bbs.size(); i != e; ++i) {
		unreachable_bbs[i]->eraseFromParent();
		++unreachable_removed;
	}	
	total_unreachable_removed += unreachable_removed;
	if(unreachable_removed == 1 )	
		errs()<<"\n1 block was found unreachable and removed from the function "<<F->getName() ;
	else if(unreachable_removed != 0)	
		errs()<<"\n"<<unreachable_removed<<" blocks were found unreachable and removed from the function "<<F->getName() ;

   }



    void loopdetector::destroy() {
	if (CallsExternalNode) {
      		CallsExternalNode->allReferencesDropped();
      		delete CallsExternalNode;
      		CallsExternalNode = 0;
    	}
	CallGraph::destroy();
    }

   void loopdetector::print_solution() {
	errs()<<"\n\nTotal number of Functions in the application : "<<(fnctr-extctr)<<"\n";
	errs()<<"Total number of Edge of the static CallGraph : "<<ectr<<"\n\n";
	errs()<<"Maximum number of Basic Blocks : "<<maxbb<<"\n";
	errs()<<"Minimum number of Basic Blocks : "<<minbb<<"\n";
	errs()<<"Average number of Basic Blocks : "<<avgbb<<"\n\n";
	errs()<<"Maximum number of CFG Edges : "<<maxcfg<<"\n";
	errs()<<"Minimum number of CFG Edges : " <<mincfg<<"\n";
	errs()<<"Average number of CFG Edges : " <<avgcfg<<"\n\n";
	errs()<<"Maximum number of loops (back edges) : "<<maxloop<<"\n";
	errs()<<"Minimum number of loops (back edges) : "<<minloop<<"\n";
	errs()<<"Average number of loops (back edges) : "<<avgloop<<"\n\n";
	errs()<<"Maximum number of loop basic blocks : "<<maxloopbb<<"\n";
	errs()<<"Minimum number of loop basic blocks : "<<minloopbb<<"\n";
	errs()<<"Average number of loop basic blocks : "<<avgloopbb<<"\n\n";
	errs()<<"Average number of dominators for a basic block across all functions: "<<avgdom<<"\n\n";
	errs()<<"Average number of basic blocks dominated by a given basic block, across all functions: "<<avgdom<<"\n\n"; 
	if(total_unreachable_removed == 0 )	
		errs()<<"No unreachable block was found.\n\n";
	if(total_unreachable_removed == 1 )	
		errs()<<total_unreachable_removed<<" unreachable block was found and removed.\n\n";
	else if(total_unreachable_removed != 0)	
		errs()<<total_unreachable_removed<<" unreachable blocks were found and removed.\n\n";
   }

}

char loopdetector::ID= 0;
static RegisterPass<loopdetector> Y("cgp","Assignment 1" ,false,false);
